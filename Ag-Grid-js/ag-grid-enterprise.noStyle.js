(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["agGrid"] = factory();
	else
		root["agGrid"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5372:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.advancedFilterCSS = void 0;
exports.advancedFilterCSS = `.ag-advanced-filter-header{align-items:center;background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);display:flex;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);position:relative}.ag-advanced-filter{align-items:center;display:flex;width:100%}.ag-advanced-filter-apply-button,.ag-advanced-filter-builder-button{line-height:normal;white-space:nowrap}:where(.ag-ltr) .ag-advanced-filter-apply-button,:where(.ag-ltr) .ag-advanced-filter-builder-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-advanced-filter-apply-button,:where(.ag-rtl) .ag-advanced-filter-builder-button{margin-right:calc(var(--ag-spacing)*2)}.ag-advanced-filter-builder-button{align-items:center;background-color:unset;border:0;display:flex;font-size:var(--ag-font-size);font-weight:600;padding:var(--ag-spacing);&:where(:not(:disabled)){cursor:pointer;&:hover{background-color:var(--ag-row-hover-color)}}}:where(.ag-ltr) .ag-advanced-filter-builder-button-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-advanced-filter-builder-button-label{margin-right:var(--ag-spacing)}.ag-advanced-filter-builder{display:flex;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-advanced-filter-builder-list{flex:1;overflow:auto}.ag-advanced-filter-builder-button-panel{border-top:var(--ag-advanced-filter-builder-button-bar-border);display:flex;justify-content:flex-end;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-advanced-filter-builder-apply-button,:where(.ag-ltr) .ag-advanced-filter-builder-cancel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-advanced-filter-builder-apply-button,:where(.ag-rtl) .ag-advanced-filter-builder-cancel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-advanced-filter-builder-item-wrapper{align-items:center;display:flex;flex:1 1 auto;justify-content:space-between;overflow:hidden}:where(.ag-ltr) .ag-advanced-filter-builder-item-wrapper{padding-left:calc(var(--ag-icon-size)/2);padding-right:var(--ag-icon-size)}:where(.ag-rtl) .ag-advanced-filter-builder-item-wrapper{padding-left:var(--ag-icon-size);padding-right:calc(var(--ag-icon-size)/2)}:where(.ag-virtual-list-viewport .ag-advanced-filter-builder-item-wrapper) .ag-tab-guard{position:absolute}.ag-advanced-filter-builder-item-tree-lines>*{width:var(--ag-advanced-filter-builder-indent-size)}.ag-advanced-filter-builder-item-tree-line-root{width:var(--ag-icon-size);&:before{height:50%;top:50%}}.ag-advanced-filter-builder-item-tree-line-horizontal,.ag-advanced-filter-builder-item-tree-line-vertical,.ag-advanced-filter-builder-item-tree-line-vertical-bottom,.ag-advanced-filter-builder-item-tree-line-vertical-top{align-items:center;display:flex;height:100%;position:relative;&:after,&:before{content:"";height:100%;position:absolute}}.ag-advanced-filter-builder-item-tree-line-horizontal:after{border-bottom:1px solid var(--ag-border-color);height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size))}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-horizontal:after{left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-horizontal:after{right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical:before{top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-top:before{height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{height:calc(50% - var(--ag-icon-size)*1.5/2);top:calc(50% + var(--ag-icon-size)*1.5/2);width:calc(var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-condition{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing)}.ag-advanced-filter-builder-item,.ag-advanced-filter-builder-item-buttons,.ag-advanced-filter-builder-item-condition,.ag-advanced-filter-builder-item-tree-lines,.ag-advanced-filter-builder-pill,.ag-advanced-filter-builder-pill-wrapper{align-items:center;display:flex;height:100%}.ag-advanced-filter-builder-pill-wrapper{margin:0 var(--ag-spacing)}.ag-advanced-filter-builder-pill{border-radius:var(--ag-border-radius);min-height:calc(100% - var(--ag-spacing)*3);min-width:calc(var(--ag-spacing)*2);padding:var(--ag-spacing) calc(var(--ag-spacing)*2);position:relative}:where(.ag-advanced-filter-builder-pill){.ag-advanced-filter-builder-value-number{font-family:monospace;font-weight:700}.ag-advanced-filter-builder-value-empty{color:var(--ag-subtle-text-color)}}:where(.ag-ltr) :where(.ag-advanced-filter-builder-pill){.ag-picker-field-display{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-advanced-filter-builder-pill){.ag-picker-field-display{margin-left:var(--ag-spacing)}}.ag-advanced-filter-builder-pill-display{font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-advanced-filter-builder-join-pill{background-color:var(--ag-advanced-filter-builder-join-pill-color);cursor:pointer}.ag-advanced-filter-builder-column-pill{background-color:var(--ag-advanced-filter-builder-column-pill-color);cursor:pointer}.ag-advanced-filter-builder-option-pill{background-color:var(--ag-advanced-filter-builder-option-pill-color);cursor:pointer}.ag-advanced-filter-builder-value-pill{background-color:var(--ag-advanced-filter-builder-value-pill-color);cursor:text;max-width:140px;:where(.ag-advanced-filter-builder-pill-display){display:block}}.ag-advanced-filter-builder-item-buttons>*{margin:0 calc(var(--ag-spacing)*.5)}.ag-advanced-filter-builder-item-button{color:var(--ag-subtle-text-color);cursor:pointer;position:relative}.ag-advanced-filter-builder-item-button,.ag-advanced-filter-builder-pill{&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-advanced-filter-builder-item-button-disabled{cursor:default;opacity:.5}.ag-advanced-filter-builder-virtual-list-container{top:var(--ag-spacing)}.ag-advanced-filter-builder-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:hover{background-color:var(--ag-row-hover-color);:where(.ag-advanced-filter-builder-item-button){opacity:1}}}.ag-advanced-filter-builder-invalid{color:var(--ag-invalid-color);cursor:default;margin:0 var(--ag-spacing)}:where(.ag-advanced-filter-builder-validation) .ag-advanced-filter-builder-invalid,:where(.ag-advanced-filter-builder-virtual-list-item-highlight) .ag-advanced-filter-builder-item-button:focus-visible{opacity:1}`;


/***/ }),

/***/ 6138:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hideAdvancedFilterBuilder = exports.showAdvancedFilterBuilder = exports.setAdvancedFilterModel = exports.getAdvancedFilterModel = void 0;
function getAdvancedFilterModel(beans) {
    return beans.filterManager?.getAdvFilterModel() ?? null;
}
exports.getAdvancedFilterModel = getAdvancedFilterModel;
function setAdvancedFilterModel(beans, advancedFilterModel) {
    beans.filterManager?.setAdvFilterModel(advancedFilterModel);
}
exports.setAdvancedFilterModel = setAdvancedFilterModel;
function showAdvancedFilterBuilder(beans) {
    beans.filterManager?.toggleAdvFilterBuilder(true, 'api');
}
exports.showAdvancedFilterBuilder = showAdvancedFilterBuilder;
function hideAdvancedFilterBuilder(beans) {
    beans.filterManager?.toggleAdvFilterBuilder(false, 'api');
}
exports.hideAdvancedFilterBuilder = hideAdvancedFilterBuilder;


/***/ }),

/***/ 2583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agAutocomplete_1 = __webpack_require__(2611);
class AdvancedFilterComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.advancedFilter = beans.advancedFilter;
        this.filterManager = beans.filterManager;
        this.registry = beans.registry;
    }
    constructor() {
        super(
        /* html */ `
            <div class="ag-advanced-filter" role="presentation" tabindex="-1">
                <ag-autocomplete data-ref="eAutocomplete"></ag-autocomplete>
                <button class="ag-button ag-standard-button ag-advanced-filter-apply-button" data-ref="eApplyFilterButton"></button>
                <button class="ag-button ag-advanced-filter-builder-button" data-ref="eBuilderFilterButton">
                    <span data-ref="eBuilderFilterButtonIcon" aria-hidden="true"></span>
                    <span class="ag-advanced-filter-builder-button-label" data-ref="eBuilderFilterButtonLabel"></span>
                </button>
            </div>`, [agAutocomplete_1.AgAutocompleteSelector]);
        this.eAutocomplete = ag_grid_community_1.RefPlaceholder;
        this.eApplyFilterButton = ag_grid_community_1.RefPlaceholder;
        this.eBuilderFilterButton = ag_grid_community_1.RefPlaceholder;
        this.eBuilderFilterButtonIcon = ag_grid_community_1.RefPlaceholder;
        this.eBuilderFilterButtonLabel = ag_grid_community_1.RefPlaceholder;
        this.expressionParser = null;
        this.isApplyDisabled = true;
        this.builderOpen = false;
    }
    postConstruct() {
        this.tooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getTooltipShowDelayOverride: () => 1000,
            getLocation: () => 'advancedFilter',
        }));
        this.eAutocomplete
            .setListGenerator((_value, position) => this.generateAutocompleteListParams(position))
            .setValidator(() => this.validateValue())
            .setForceLastSelection((lastSelection, searchString) => this.forceLastSelection(lastSelection, searchString))
            .setInputAriaLabel(this.advFilterExpSvc.translate('ariaAdvancedFilterInput'))
            .setListAriaLabel(this.advFilterExpSvc.translate('ariaLabelAdvancedFilterAutocomplete'));
        this.refresh();
        this.addManagedListeners(this.eAutocomplete, {
            eventValueChanged: ({ value }) => this.onValueChanged(value),
            eventValueConfirmed: ({ isValid }) => this.onValueConfirmed(isValid),
            eventOptionSelected: ({ position, updateEntry, autocompleteType }) => this.onOptionSelected(position, updateEntry, autocompleteType),
            eventValidChanged: ({ isValid, validationMessage }) => this.onValidChanged(isValid, validationMessage),
        });
        this.setupApplyButton();
        this.setupBuilderButton();
    }
    refresh() {
        const expression = this.advancedFilter.getExpressionDisplayValue();
        this.eAutocomplete.setValue({
            value: expression ?? '',
            position: expression?.length,
            updateListOnlyIfOpen: true,
        });
    }
    setInputDisabled(disabled) {
        this.eAutocomplete.setInputDisabled(disabled);
        (0, ag_grid_community_1._setDisabled)(this.eApplyFilterButton, disabled || this.isApplyDisabled);
    }
    setupApplyButton() {
        this.eApplyFilterButton.innerText = this.advFilterExpSvc.translate('advancedFilterApply');
        this.activateTabIndex([this.eApplyFilterButton]);
        this.addManagedElementListeners(this.eApplyFilterButton, {
            click: () => this.onValueConfirmed(this.eAutocomplete.isValid()),
        });
        (0, ag_grid_community_1._setDisabled)(this.eApplyFilterButton, this.isApplyDisabled);
    }
    setupBuilderButton() {
        this.eBuilderFilterButtonIcon.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilder', this.beans));
        this.eBuilderFilterButtonLabel.innerText = this.advFilterExpSvc.translate('advancedFilterBuilder');
        this.activateTabIndex([this.eBuilderFilterButton]);
        this.addManagedElementListeners(this.eBuilderFilterButton, { click: () => this.openBuilder() });
        this.addManagedListeners(this.advancedFilter.getCtrl(), {
            advancedFilterBuilderClosed: () => this.closeBuilder(),
        });
    }
    onValueChanged(value) {
        value = (0, ag_grid_community_1._makeNull)(value);
        this.advancedFilter.setExpressionDisplayValue(value);
        this.expressionParser = this.advancedFilter.createExpressionParser(value);
        const updatedExpression = this.expressionParser?.parseExpression();
        if (updatedExpression && updatedExpression !== value) {
            this.eAutocomplete.setValue({ value: updatedExpression, silent: true, restoreFocus: true });
        }
    }
    onValueConfirmed(isValid) {
        if (!isValid || this.isApplyDisabled) {
            return;
        }
        (0, ag_grid_community_1._setDisabled)(this.eApplyFilterButton, true);
        this.advancedFilter.applyExpression();
        this.filterManager?.onFilterChanged({ source: 'advancedFilter' });
    }
    onOptionSelected(position, updateEntry, type) {
        const { updatedValue, updatedPosition, hideAutocomplete } = this.updateExpression(position, updateEntry, type);
        this.eAutocomplete.setValue({
            value: updatedValue,
            position: updatedPosition,
            updateListOnlyIfOpen: hideAutocomplete,
            restoreFocus: true,
        });
    }
    validateValue() {
        return this.expressionParser?.isValid() ? null : this.expressionParser?.getValidationMessage() ?? null;
    }
    onValidChanged(isValid, validationMessage) {
        this.isApplyDisabled = !isValid || this.advancedFilter.isCurrentExpressionApplied();
        (0, ag_grid_community_1._setDisabled)(this.eApplyFilterButton, this.isApplyDisabled);
        this.tooltipFeature?.setTooltipAndRefresh(validationMessage);
    }
    generateAutocompleteListParams(position) {
        return this.expressionParser
            ? this.expressionParser.getAutocompleteListParams(position)
            : this.advFilterExpSvc.getDefaultAutocompleteListParams('');
    }
    updateExpression(position, updateEntry, type) {
        this.advFilterExpSvc.updateAutocompleteCache(updateEntry, type);
        return (this.expressionParser?.updateExpression(position, updateEntry, type) ??
            this.advancedFilter.getDefaultExpression(updateEntry));
    }
    forceLastSelection({ key, displayValue }, searchString) {
        return !!searchString.toLocaleLowerCase().match(`^${(displayValue ?? key).toLocaleLowerCase()}\\s*$`);
    }
    openBuilder() {
        if (this.builderOpen) {
            return;
        }
        this.builderOpen = true;
        (0, ag_grid_community_1._setDisabled)(this.eBuilderFilterButton, true);
        this.advancedFilter.getCtrl().toggleFilterBuilder({ source: 'ui', eventSource: this.eBuilderFilterButton });
    }
    closeBuilder() {
        if (!this.builderOpen) {
            return;
        }
        this.builderOpen = false;
        (0, ag_grid_community_1._setDisabled)(this.eBuilderFilterButton, false);
        this.eBuilderFilterButton.focus();
    }
}
exports.AdvancedFilterComp = AdvancedFilterComp;


/***/ }),

/***/ 5865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterCtrl = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agDialog_1 = __webpack_require__(8775);
const advancedFilterComp_1 = __webpack_require__(2583);
const advancedFilterHeaderComp_1 = __webpack_require__(4858);
const advancedFilterBuilderComp_1 = __webpack_require__(8986);
class AdvancedFilterCtrl extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.ctrlsSvc = beans.ctrlsSvc;
        this.popupSvc = beans.popupSvc;
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.environment = beans.environment;
    }
    constructor(enabled) {
        super();
        this.enabled = enabled;
    }
    postConstruct() {
        this.hasAdvancedFilterParent = !!this.gos.get('advancedFilterParent');
        this.ctrlsSvc.whenReady(this, () => this.setAdvancedFilterComp());
        this.addManagedEventListeners({
            advancedFilterEnabledChanged: ({ enabled }) => this.onEnabledChanged(enabled),
        });
        this.addManagedPropertyListener('advancedFilterParent', () => this.updateComps());
        this.addDestroyFunc(() => {
            this.destroyAdvancedFilterComp();
            this.destroyBean(this.eBuilderComp);
            if (this.eBuilderDialog && this.eBuilderDialog.isAlive()) {
                this.destroyBean(this.eBuilderDialog);
            }
        });
    }
    setupHeaderComp(eCompToInsertBefore) {
        if (this.eHeaderComp) {
            this.eHeaderComp?.getGui().remove();
            this.destroyBean(this.eHeaderComp);
        }
        this.eHeaderComp = this.createManagedBean(new advancedFilterHeaderComp_1.AdvancedFilterHeaderComp(this.enabled && !this.hasAdvancedFilterParent));
        eCompToInsertBefore.insertAdjacentElement('beforebegin', this.eHeaderComp.getGui());
    }
    focusHeaderComp() {
        if (this.eHeaderComp) {
            this.eHeaderComp.getFocusableElement().focus();
            return true;
        }
        return false;
    }
    refreshComp() {
        this.eFilterComp?.refresh();
        this.eHeaderComp?.refresh();
    }
    refreshBuilderComp() {
        this.eBuilderComp?.refresh();
    }
    getHeaderHeight() {
        return this.eHeaderComp?.getHeight() ?? 0;
    }
    setInputDisabled(disabled) {
        this.eFilterComp?.setInputDisabled(disabled);
        this.eHeaderComp?.setInputDisabled(disabled);
    }
    toggleFilterBuilder(params) {
        const { source, force, eventSource } = params;
        if ((force && this.eBuilderDialog) || (force === false && !this.eBuilderDialog)) {
            // state requested is already active
            return;
        }
        if (this.eBuilderDialog) {
            this.builderDestroySource = source;
            this.destroyBean(this.eBuilderDialog);
            return;
        }
        this.setInputDisabled(true);
        const { width, height, minWidth } = this.getBuilderDialogSize();
        this.eBuilderComp = this.createBean(new advancedFilterBuilderComp_1.AdvancedFilterBuilderComp());
        this.eBuilderDialog = this.createBean(new agDialog_1.AgDialog({
            title: this.advFilterExpSvc.translate('advancedFilterBuilderTitle'),
            component: this.eBuilderComp,
            width,
            height,
            resizable: true,
            movable: true,
            maximizable: true,
            centered: true,
            closable: true,
            minWidth,
            afterGuiAttached: () => this.eBuilderComp?.afterGuiAttached(),
            postProcessPopupParams: {
                type: 'advancedFilterBuilder',
                eventSource,
            },
        }));
        this.dispatchFilterBuilderVisibleChangedEvent(source, true);
        this.eBuilderDialog.addEventListener('destroyed', () => {
            this.destroyBean(this.eBuilderComp);
            this.eBuilderComp = undefined;
            this.eBuilderDialog = undefined;
            this.setInputDisabled(false);
            this.dispatchLocalEvent({
                type: 'advancedFilterBuilderClosed',
            });
            this.dispatchFilterBuilderVisibleChangedEvent(this.builderDestroySource ?? 'ui', false);
            this.builderDestroySource = undefined;
        });
    }
    dispatchFilterBuilderVisibleChangedEvent(source, visible) {
        this.eventSvc.dispatchEvent({
            type: 'advancedFilterBuilderVisibleChanged',
            source,
            visible,
        });
    }
    getBuilderDialogSize() {
        const minWidth = this.gos.get('advancedFilterBuilderParams')?.minWidth ?? 500;
        const popupParent = this.popupSvc.getPopupParent();
        const maxWidth = Math.round((0, ag_grid_community_1._getAbsoluteWidth)(popupParent)) - 2; // assume 1 pixel border
        const maxHeight = Math.round((0, ag_grid_community_1._getAbsoluteHeight)(popupParent) * 0.75) - 2;
        const width = Math.min(Math.max(600, minWidth), maxWidth);
        const height = Math.min(600, maxHeight);
        return { width, height, minWidth };
    }
    onEnabledChanged(enabled) {
        this.enabled = enabled;
        this.updateComps();
    }
    updateComps() {
        this.setAdvancedFilterComp();
        this.setHeaderCompEnabled();
        this.eventSvc.dispatchEvent({
            type: 'headerHeightChanged',
        });
    }
    setAdvancedFilterComp() {
        this.destroyAdvancedFilterComp();
        if (!this.enabled) {
            return;
        }
        const advancedFilterParent = this.gos.get('advancedFilterParent');
        this.hasAdvancedFilterParent = !!advancedFilterParent;
        if (advancedFilterParent) {
            // unmanaged as can be recreated
            const eAdvancedFilterComp = this.createBean(new advancedFilterComp_1.AdvancedFilterComp());
            const eAdvancedFilterCompGui = eAdvancedFilterComp.getGui();
            this.environment.applyThemeClasses(eAdvancedFilterCompGui);
            eAdvancedFilterCompGui.classList.add(this.gos.get('enableRtl') ? 'ag-rtl' : 'ag-ltr');
            advancedFilterParent.appendChild(eAdvancedFilterCompGui);
            this.eFilterComp = eAdvancedFilterComp;
        }
    }
    setHeaderCompEnabled() {
        this.eHeaderComp?.setEnabled(this.enabled && !this.hasAdvancedFilterParent);
    }
    destroyAdvancedFilterComp() {
        if (this.eFilterComp) {
            (0, ag_grid_community_1._removeFromParent)(this.eFilterComp.getGui());
            this.destroyBean(this.eFilterComp);
        }
    }
}
exports.AdvancedFilterCtrl = AdvancedFilterCtrl;


/***/ }),

/***/ 1723:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterExpressionService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const advancedFilterLocaleText_1 = __webpack_require__(8397);
const colFilterExpressionParser_1 = __webpack_require__(9023);
const filterExpressionOperators_1 = __webpack_require__(9459);
class AdvancedFilterExpressionService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'advFilterExpSvc';
        this.columnNameToIdMap = {};
        this.columnAutocompleteEntries = null;
        this.expressionEvaluatorParams = {};
    }
    wireBeans(beans) {
        this.valueSvc = beans.valueSvc;
        this.colModel = beans.colModel;
        this.colNames = beans.colNames;
        this.dataTypeSvc = beans.dataTypeSvc;
    }
    postConstruct() {
        this.expressionJoinOperators = this.generateExpressionJoinOperators();
        this.expressionOperators = this.generateExpressionOperators();
    }
    parseJoinOperator(model) {
        const { type } = model;
        return this.expressionJoinOperators[type] ?? type;
    }
    getColumnDisplayValue(model) {
        const { colId } = model;
        const columnEntries = this.getColumnAutocompleteEntries();
        const columnEntry = columnEntries.find(({ key }) => key === colId);
        let columnName;
        if (columnEntry) {
            columnName = columnEntry.displayValue;
            this.columnNameToIdMap[columnName.toLocaleUpperCase()] = { colId, columnName };
        }
        else {
            columnName = colId;
        }
        return columnName;
    }
    getOperatorDisplayValue(model) {
        return this.getExpressionOperator(model.filterType, model.type)?.displayValue ?? model.type;
    }
    getOperandModelValue(operand, baseCellDataType, column) {
        switch (baseCellDataType) {
            case 'number':
                return (0, ag_grid_community_1._exists)(operand) ? Number(operand) : null;
            case 'date':
                return (0, ag_grid_community_1._serialiseDate)(this.valueSvc.parseValue(column, null, operand, undefined), false);
            case 'dateString': {
                // displayed string format may be different from data string format, so parse before converting to date
                const parsedDateString = this.valueSvc.parseValue(column, null, operand, undefined);
                return this.dataTypeSvc
                    ? (0, ag_grid_community_1._serialiseDate)(this.dataTypeSvc.getDateParserFunction(column)(parsedDateString) ?? null, false)
                    : parsedDateString;
            }
        }
        return operand;
    }
    getOperandDisplayValue(model, skipFormatting) {
        const { colId, filter } = model;
        const column = this.colModel.getColDefCol(colId);
        let operand = '';
        if (filter != null) {
            let operand1;
            switch (model.filterType) {
                case 'number':
                    operand1 = (0, ag_grid_community_1._toStringOrNull)(filter) ?? '';
                    break;
                case 'date': {
                    const dateValue = (0, ag_grid_community_1._parseDateTimeFromString)(filter);
                    operand1 = column ? this.valueSvc.formatValue(column, null, dateValue) : null;
                    break;
                }
                case 'dateString': {
                    let dateStringStringValue;
                    if (this.dataTypeSvc) {
                        // need to convert from ISO date string to Date to data string format to formatted string format
                        const dateStringDateValue = (0, ag_grid_community_1._parseDateTimeFromString)(filter);
                        dateStringStringValue = column
                            ? this.dataTypeSvc?.getDateFormatterFunction(column)(dateStringDateValue ?? undefined)
                            : null;
                    }
                    else {
                        dateStringStringValue = filter;
                    }
                    operand1 = column ? this.valueSvc.formatValue(column, null, dateStringStringValue) : null;
                    break;
                }
            }
            if (model.filterType !== 'number') {
                operand1 = operand1 ?? (0, ag_grid_community_1._toStringOrNull)(filter) ?? '';
                if (!skipFormatting) {
                    operand1 = `"${operand1}"`;
                }
            }
            operand = skipFormatting ? operand1 : ` ${operand1}`;
        }
        return operand;
    }
    parseColumnFilterModel(model) {
        const columnName = this.getColumnDisplayValue(model) ?? '';
        const operator = this.getOperatorDisplayValue(model) ?? '';
        const operands = this.getOperandDisplayValue(model);
        return `[${columnName}] ${operator}${operands}`;
    }
    updateAutocompleteCache(updateEntry, type) {
        if (type === 'column') {
            const { key: colId, displayValue } = updateEntry;
            this.columnNameToIdMap[updateEntry.displayValue.toLocaleUpperCase()] = {
                colId,
                columnName: displayValue,
            };
        }
    }
    translate(key, variableValues) {
        let defaultValue = advancedFilterLocaleText_1.ADVANCED_FILTER_LOCALE_TEXT[key];
        if (typeof defaultValue === 'function') {
            defaultValue = defaultValue(variableValues);
        }
        return this.getLocaleTextFunc()(key, defaultValue, variableValues);
    }
    generateAutocompleteListParams(entries, type, searchString) {
        return {
            enabled: true,
            type,
            searchString,
            entries,
        };
    }
    getColumnAutocompleteEntries() {
        if (this.columnAutocompleteEntries) {
            return this.columnAutocompleteEntries;
        }
        const columns = this.colModel.getColDefCols() ?? [];
        const entries = [];
        const includeHiddenColumns = this.gos.get('includeHiddenColumnsInAdvancedFilter');
        columns.forEach((column) => {
            if (column.getColDef().filter &&
                (includeHiddenColumns || column.isVisible() || column.isRowGroupActive())) {
                entries.push({
                    key: column.getColId(),
                    displayValue: this.colNames.getDisplayNameForColumn(column, 'advancedFilter'),
                });
            }
        });
        entries.sort((a, b) => {
            const aValue = a.displayValue ?? '';
            const bValue = b.displayValue ?? '';
            if (aValue < bValue) {
                return -1;
            }
            else if (bValue > aValue) {
                return 1;
            }
            return 0;
        });
        return entries;
    }
    getOperatorAutocompleteEntries(column, baseCellDataType) {
        const activeOperators = this.getActiveOperators(column);
        return this.getDataTypeExpressionOperator(baseCellDataType).getEntries(activeOperators);
    }
    getJoinOperatorAutocompleteEntries() {
        return Object.entries(this.expressionJoinOperators).map(([key, displayValue]) => ({ key, displayValue }));
    }
    getDefaultAutocompleteListParams(searchString) {
        return this.generateAutocompleteListParams(this.getColumnAutocompleteEntries(), 'column', searchString);
    }
    getDataTypeExpressionOperator(baseCellDataType) {
        return this.expressionOperators[baseCellDataType];
    }
    getExpressionOperator(baseCellDataType, operator) {
        return this.getDataTypeExpressionOperator(baseCellDataType)?.operators?.[operator];
    }
    getExpressionJoinOperators() {
        return this.expressionJoinOperators;
    }
    getColId(columnName) {
        const upperCaseColumnName = columnName.toLocaleUpperCase();
        const cachedColId = this.columnNameToIdMap[upperCaseColumnName];
        if (cachedColId) {
            return cachedColId;
        }
        const columnAutocompleteEntries = this.getColumnAutocompleteEntries();
        const colEntry = columnAutocompleteEntries.find(({ displayValue }) => displayValue.toLocaleUpperCase() === upperCaseColumnName);
        if (colEntry) {
            const { key: colId, displayValue } = colEntry;
            const colValue = { colId, columnName: displayValue };
            // cache for faster lookup
            this.columnNameToIdMap[upperCaseColumnName] = colValue;
            return colValue;
        }
        return null;
    }
    getExpressionEvaluatorParams(colId) {
        let params = this.expressionEvaluatorParams[colId];
        if (params) {
            return params;
        }
        const column = this.colModel.getColDefCol(colId);
        if (!column) {
            return { valueConverter: (v) => v };
        }
        const baseCellDataType = this.dataTypeSvc?.getBaseDataType(column);
        switch (baseCellDataType) {
            case 'dateString':
                params = {
                    valueConverter: this.dataTypeSvc?.getDateParserFunction(column) ?? ((v) => v),
                };
                break;
            case 'object':
                // If there's a filter value getter, assume the value is already a string. Otherwise we need to format it.
                if (column.getColDef().filterValueGetter) {
                    params = { valueConverter: (v) => v };
                }
                else {
                    params = {
                        valueConverter: (value, node) => this.valueSvc.formatValue(column, node, value) ??
                            (typeof value.toString === 'function' ? value.toString() : ''),
                    };
                }
                break;
            case 'text':
            case undefined:
                params = { valueConverter: (v) => (0, ag_grid_community_1._toStringOrNull)(v) };
                break;
            default:
                params = { valueConverter: (v) => v };
                break;
        }
        const { filterParams } = column.getColDef();
        if (filterParams) {
            ['caseSensitive', 'includeBlanksInEquals', 'includeBlanksInLessThan', 'includeBlanksInGreaterThan'].forEach((param) => {
                const paramValue = filterParams[param];
                if (paramValue) {
                    params[param] = paramValue;
                }
            });
        }
        this.expressionEvaluatorParams[colId] = params;
        return params;
    }
    getColumnDetails(colId) {
        const column = this.colModel.getColDefCol(colId) ?? undefined;
        const baseCellDataType = (column ? this.dataTypeSvc?.getBaseDataType(column) : undefined) ?? 'text';
        return { column, baseCellDataType };
    }
    generateExpressionOperators() {
        const translate = (key, variableValues) => this.translate(key, variableValues);
        return {
            text: new filterExpressionOperators_1.TextFilterExpressionOperators({ translate }),
            boolean: new filterExpressionOperators_1.BooleanFilterExpressionOperators({ translate }),
            object: new filterExpressionOperators_1.TextFilterExpressionOperators({ translate }),
            number: new filterExpressionOperators_1.ScalarFilterExpressionOperators({ translate, equals: (v, o) => v === o }),
            date: new filterExpressionOperators_1.ScalarFilterExpressionOperators({
                translate,
                equals: (v, o) => v.getTime() === o.getTime(),
            }),
            dateString: new filterExpressionOperators_1.ScalarFilterExpressionOperators({
                translate,
                equals: (v, o) => v.getTime() === o.getTime(),
            }),
        };
    }
    getColumnValue({ displayValue }) {
        return `${colFilterExpressionParser_1.COL_FILTER_EXPRESSION_START_CHAR}${displayValue}${colFilterExpressionParser_1.COL_FILTER_EXPRESSION_END_CHAR}`;
    }
    generateExpressionJoinOperators() {
        return {
            AND: this.translate('advancedFilterAnd'),
            OR: this.translate('advancedFilterOr'),
        };
    }
    getActiveOperators(column) {
        const filterOptions = column.getColDef().filterParams?.filterOptions;
        if (!filterOptions) {
            return undefined;
        }
        const isValid = filterOptions.every((filterOption) => typeof filterOption === 'string');
        return isValid ? filterOptions : undefined;
    }
    resetColumnCaches() {
        this.columnAutocompleteEntries = null;
        this.columnNameToIdMap = {};
        this.expressionEvaluatorParams = {};
    }
}
exports.AdvancedFilterExpressionService = AdvancedFilterExpressionService;


/***/ }),

/***/ 4858:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterHeaderComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const advancedFilterComp_1 = __webpack_require__(2583);
class AdvancedFilterHeaderComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.focusSvc = beans.focusSvc;
        this.ctrlsSvc = beans.ctrlsSvc;
    }
    constructor(enabled) {
        super(/* html */ `
            <div class="ag-advanced-filter-header" role="row">
            </div>`);
        this.enabled = enabled;
    }
    postConstruct() {
        this.setupAdvancedFilter(this.enabled);
        this.addDestroyFunc(() => this.destroyBean(this.eAdvancedFilter));
        const heightListener = () => {
            if (this.enabled) {
                this.setEnabledHeight();
            }
        };
        this.addManagedEventListeners({
            gridColumnsChanged: () => this.onGridColumnsChanged(),
            columnHeaderHeightChanged: heightListener,
            gridStylesChanged: heightListener,
        });
        this.addManagedPropertyListener('headerHeight', heightListener);
        this.addManagedPropertyListener('floatingFiltersHeight', heightListener);
        this.addGuiEventListener('keydown', (event) => this.onKeyDown(event));
        this.addGuiEventListener('focusout', (event) => {
            if (!this.getFocusableElement().contains(event.relatedTarget)) {
                this.focusSvc.clearAdvancedFilterColumn();
            }
        });
    }
    getFocusableElement() {
        return this.eAdvancedFilter?.getGui() ?? this.getGui();
    }
    setEnabled(enabled) {
        if (enabled === this.enabled) {
            return;
        }
        this.setupAdvancedFilter(enabled);
    }
    refresh() {
        this.eAdvancedFilter?.refresh();
    }
    getHeight() {
        return this.height;
    }
    setInputDisabled(disabled) {
        this.eAdvancedFilter?.setInputDisabled(disabled);
    }
    setupAdvancedFilter(enabled) {
        const eGui = this.getGui();
        if (enabled) {
            // unmanaged as can be recreated
            this.eAdvancedFilter = this.createBean(new advancedFilterComp_1.AdvancedFilterComp());
            const eAdvancedFilterGui = this.eAdvancedFilter.getGui();
            this.eAdvancedFilter.addCssClass('ag-advanced-filter-header-cell');
            this.setEnabledHeight();
            this.setAriaRowIndex();
            (0, ag_grid_community_1._setAriaRole)(eAdvancedFilterGui, 'gridcell');
            (0, ag_grid_community_1._setAriaColIndex)(eAdvancedFilterGui, 1);
            this.setAriaColumnCount(eAdvancedFilterGui);
            eGui.appendChild(eAdvancedFilterGui);
        }
        else {
            (0, ag_grid_community_1._clearElement)(eGui);
            this.destroyBean(this.eAdvancedFilter);
            this.height = 0;
        }
        (0, ag_grid_community_1._setDisplayed)(eGui, enabled);
        this.enabled = enabled;
    }
    setEnabledHeight() {
        const eGui = this.getGui();
        this.height = (0, ag_grid_community_1._getFloatingFiltersHeight)(this.beans);
        const height = `${this.height}px`;
        eGui.style.height = height;
        eGui.style.minHeight = height;
    }
    setAriaColumnCount(eAdvancedFilterGui) {
        (0, ag_grid_community_1._setAriaColSpan)(eAdvancedFilterGui, this.colModel.getCols().length);
    }
    setAriaRowIndex() {
        (0, ag_grid_community_1._setAriaRowIndex)(this.getGui(), this.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0);
    }
    onGridColumnsChanged() {
        if (!this.eAdvancedFilter) {
            return;
        }
        this.setAriaColumnCount(this.eAdvancedFilter.getGui());
        this.setAriaRowIndex();
    }
    onKeyDown(event) {
        switch (event.key) {
            case ag_grid_community_1.KeyCode.ENTER: {
                if (this.hasFocus()) {
                    if ((0, ag_grid_community_1._focusInto)(this.getFocusableElement())) {
                        event.preventDefault();
                    }
                }
                break;
            }
            case ag_grid_community_1.KeyCode.ESCAPE:
                if (!this.hasFocus()) {
                    this.getFocusableElement().focus();
                }
                break;
            case ag_grid_community_1.KeyCode.UP:
                this.navigateUpDown(true, event);
                break;
            case ag_grid_community_1.KeyCode.DOWN:
                this.navigateUpDown(false, event);
                break;
            case ag_grid_community_1.KeyCode.TAB:
                if (this.hasFocus()) {
                    this.navigateLeftRight(event);
                }
                else {
                    const nextFocusableEl = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, this.getFocusableElement(), null, event.shiftKey);
                    if (nextFocusableEl) {
                        event.preventDefault();
                        nextFocusableEl.focus();
                    }
                    else {
                        this.navigateLeftRight(event);
                    }
                }
                break;
        }
    }
    navigateUpDown(backwards, event) {
        if (this.hasFocus()) {
            if (this.focusSvc.focusNextFromAdvancedFilter(backwards)) {
                event.preventDefault();
            }
        }
    }
    navigateLeftRight(event) {
        if (event.shiftKey ? this.focusSvc.focusLastHeader() : this.focusSvc.focusNextFromAdvancedFilter(false, true)) {
            event.preventDefault();
        }
    }
    hasFocus() {
        return (0, ag_grid_community_1._getActiveDomElement)(this.beans) === this.getFocusableElement();
    }
}
exports.AdvancedFilterHeaderComp = AdvancedFilterHeaderComp;


/***/ }),

/***/ 8397:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ADVANCED_FILTER_LOCALE_TEXT = void 0;
exports.ADVANCED_FILTER_LOCALE_TEXT = {
    ariaAdvancedFilterBuilderItem: (variableValues) => `${variableValues[0]}. Level ${variableValues[1]}. Press ENTER to edit`,
    ariaAdvancedFilterBuilderItemValidation: (variableValues) => `${variableValues[0]}. Level ${variableValues[1]}. ${variableValues[2]} Press ENTER to edit`,
    ariaAdvancedFilterBuilderList: 'Advanced Filter Builder List',
    ariaAdvancedFilterBuilderFilterItem: 'Filter Condition',
    ariaAdvancedFilterBuilderGroupItem: 'Filter Group',
    ariaAdvancedFilterBuilderColumn: 'Column',
    ariaAdvancedFilterBuilderOption: 'Option',
    ariaAdvancedFilterBuilderValue: 'Value',
    ariaAdvancedFilterBuilderJoinOperator: 'Join Operator',
    ariaAdvancedFilterInput: 'Advanced Filter Input',
    ariaLabelAdvancedFilterAutocomplete: 'Advanced Filter Autocomplete',
    advancedFilterContains: 'contains',
    advancedFilterNotContains: 'does not contain',
    advancedFilterTextEquals: 'equals',
    advancedFilterTextNotEqual: 'does not equal',
    advancedFilterStartsWith: 'begins with',
    advancedFilterEndsWith: 'ends with',
    advancedFilterBlank: 'is blank',
    advancedFilterNotBlank: 'is not blank',
    advancedFilterEquals: '=',
    advancedFilterNotEqual: '!=',
    advancedFilterGreaterThan: '>',
    advancedFilterGreaterThanOrEqual: '>=',
    advancedFilterLessThan: '<',
    advancedFilterLessThanOrEqual: '<=',
    advancedFilterTrue: 'is true',
    advancedFilterFalse: 'is false',
    advancedFilterAnd: 'AND',
    advancedFilterOr: 'OR',
    advancedFilterApply: 'Apply',
    advancedFilterBuilder: 'Builder',
    advancedFilterValidationMissingColumn: 'Column is missing',
    advancedFilterValidationMissingOption: 'Option is missing',
    advancedFilterValidationMissingValue: 'Value is missing',
    advancedFilterValidationInvalidColumn: 'Column not found',
    advancedFilterValidationInvalidOption: 'Option not found',
    advancedFilterValidationMissingQuote: 'Value is missing an end quote',
    advancedFilterValidationNotANumber: 'Value is not a number',
    advancedFilterValidationInvalidDate: 'Value is not a valid date',
    advancedFilterValidationMissingCondition: 'Condition is missing',
    advancedFilterValidationJoinOperatorMismatch: 'Join operators within a condition must be the same',
    advancedFilterValidationInvalidJoinOperator: 'Join operator not found',
    advancedFilterValidationMissingEndBracket: 'Missing end bracket',
    advancedFilterValidationExtraEndBracket: 'Too many end brackets',
    advancedFilterValidationMessage: (variableValues) => `Expression has an error. ${variableValues[0]} - ${variableValues[1]}.`,
    advancedFilterValidationMessageAtEnd: (variableValues) => `Expression has an error. ${variableValues[0]} at end of expression.`,
    advancedFilterBuilderTitle: 'Advanced Filter',
    advancedFilterBuilderApply: 'Apply',
    advancedFilterBuilderCancel: 'Cancel',
    advancedFilterBuilderAddButtonTooltip: 'Add Filter or Group',
    advancedFilterBuilderRemoveButtonTooltip: 'Remove',
    advancedFilterBuilderMoveUpButtonTooltip: 'Move Up',
    advancedFilterBuilderMoveDownButtonTooltip: 'Move Down',
    advancedFilterBuilderAddJoin: 'Add Group',
    advancedFilterBuilderAddCondition: 'Add Filter',
    advancedFilterBuilderSelectColumn: 'Select a column',
    advancedFilterBuilderSelectOption: 'Select an option',
    advancedFilterBuilderEnterValue: 'Enter a value...',
    advancedFilterBuilderValidationAlreadyApplied: 'Current filter already applied.',
    advancedFilterBuilderValidationIncomplete: 'Not all conditions are complete.',
    advancedFilterBuilderValidationSelectColumn: 'Must select a column.',
    advancedFilterBuilderValidationSelectOption: 'Must select an option.',
    advancedFilterBuilderValidationEnterValue: 'Must enter a value.',
};


/***/ }),

/***/ 7976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const advanced_filter_css_GENERATED_1 = __webpack_require__(5372);
const advancedFilterApi_1 = __webpack_require__(6138);
const advancedFilterExpressionService_1 = __webpack_require__(1723);
const advancedFilterService_1 = __webpack_require__(3065);
/**
 * @feature Filtering -> Advanced Filter
 * @gridOption enableAdvanced Filter
 */
exports.AdvancedFilterModule = {
    moduleName: 'AdvancedFilter',
    version: version_1.VERSION,
    beans: [advancedFilterService_1.AdvancedFilterService, advancedFilterExpressionService_1.AdvancedFilterExpressionService],
    icons: {
        // Builder button in Advanced Filter
        advancedFilterBuilder: 'group',
        // drag handle used to pick up Advanced Filter Builder rows
        advancedFilterBuilderDrag: 'grip',
        // Advanced Filter Builder row validation error
        advancedFilterBuilderInvalid: 'not-allowed',
        // shown on Advanced Filter Builder rows to move them up
        advancedFilterBuilderMoveUp: 'up',
        // shown on Advanced Filter Builder rows to move them down
        advancedFilterBuilderMoveDown: 'down',
        // shown on Advanced Filter Builder rows to add new rows
        advancedFilterBuilderAdd: 'plus',
        // shown on Advanced Filter Builder rows to remove row
        advancedFilterBuilderRemove: 'minus',
        // shown on Advanced Filter Builder selection pills
        advancedFilterBuilderSelectOpen: 'small-down',
        // remove for rich select editor pills
        richSelectRemove: 'cancel',
    },
    apiFunctions: {
        getAdvancedFilterModel: advancedFilterApi_1.getAdvancedFilterModel,
        setAdvancedFilterModel: advancedFilterApi_1.setAdvancedFilterModel,
        showAdvancedFilterBuilder: advancedFilterApi_1.showAdvancedFilterBuilder,
        hideAdvancedFilterBuilder: advancedFilterApi_1.hideAdvancedFilterBuilder,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._FilterCoreModule, ag_grid_community_1._SharedDragAndDropModule, ag_grid_community_1._PopupModule, ag_grid_community_1._FilterValueModule],
    css: [advanced_filter_css_GENERATED_1.advancedFilterCSS],
};


/***/ }),

/***/ 3065:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const advancedFilterCtrl_1 = __webpack_require__(5865);
const filterExpressionParser_1 = __webpack_require__(4899);
class AdvancedFilterService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'advancedFilter';
        this.appliedExpression = null;
        /** The value displayed in the input, which may be invalid */
        this.expression = null;
        this.isValid = true;
    }
    wireBeans(beans) {
        this.valueSvc = beans.valueSvc;
        this.colModel = beans.colModel;
        this.dataTypeSvc = beans.dataTypeSvc;
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.filterValueSvc = beans.filterValueSvc;
    }
    postConstruct() {
        this.setEnabled(this.gos.get('enableAdvancedFilter'), true);
        this.ctrl = this.createManagedBean(new advancedFilterCtrl_1.AdvancedFilterCtrl(this.enabled));
        this.expressionProxy = {
            getValue: (colId, node) => {
                const column = this.colModel.getColDefCol(colId);
                return column ? this.filterValueSvc.getValue(column, node) : undefined;
            },
        };
        this.addManagedPropertyListener('enableAdvancedFilter', (event) => this.setEnabled(!!event.currentValue));
        this.addManagedEventListeners({
            newColumnsLoaded: (event) => this.onNewColumnsLoaded(event),
        });
        this.addManagedPropertyListener('includeHiddenColumnsInAdvancedFilter', () => this.updateValidity());
    }
    isEnabled() {
        return this.enabled;
    }
    isFilterPresent() {
        return !!this.expressionFunction;
    }
    doesFilterPass(node) {
        return this.expressionFunction(this.expressionProxy, node, this.expressionParams);
    }
    getModel() {
        const expressionParser = this.createExpressionParser(this.appliedExpression);
        expressionParser?.parseExpression();
        return expressionParser?.getModel() ?? null;
    }
    setModel(model) {
        const parseModel = (model, isFirstParent) => {
            if (model.filterType === 'join') {
                const operator = this.advFilterExpSvc.parseJoinOperator(model);
                const expression = model.conditions
                    .map((condition) => parseModel(condition))
                    .filter((condition) => (0, ag_grid_community_1._exists)(condition))
                    .join(` ${operator} `);
                return isFirstParent || model.conditions.length <= 1 ? expression : `(${expression})`;
            }
            else {
                return this.advFilterExpSvc.parseColumnFilterModel(model);
            }
        };
        const expression = model ? parseModel(model, true) : null;
        this.setExpressionDisplayValue(expression);
        this.applyExpression();
        this.ctrl.refreshComp();
        this.ctrl.refreshBuilderComp();
    }
    getExpressionDisplayValue() {
        return this.expression;
    }
    setExpressionDisplayValue(expression) {
        this.expression = expression;
    }
    isCurrentExpressionApplied() {
        return this.appliedExpression === this.expression;
    }
    createExpressionParser(expression) {
        if (!expression) {
            return null;
        }
        return new filterExpressionParser_1.FilterExpressionParser({
            expression,
            colModel: this.colModel,
            dataTypeSvc: this.dataTypeSvc,
            valueSvc: this.valueSvc,
            advFilterExpSvc: this.advFilterExpSvc,
        });
    }
    getDefaultExpression(updateEntry) {
        const updatedValue = this.advFilterExpSvc.getColumnValue(updateEntry) + ' ';
        return {
            updatedValue,
            updatedPosition: updatedValue.length,
        };
    }
    isHeaderActive() {
        return !this.gos.get('advancedFilterParent');
    }
    getCtrl() {
        return this.ctrl;
    }
    setEnabled(enabled, silent) {
        const previousValue = this.enabled;
        const isValidRowModel = (0, ag_grid_community_1._isClientSideRowModel)(this.gos) || (0, ag_grid_community_1._isServerSideRowModel)(this.gos);
        if (enabled && !isValidRowModel) {
            (0, ag_grid_community_1._warn)(123);
        }
        this.enabled = enabled && isValidRowModel;
        if (!silent && this.enabled !== previousValue) {
            this.eventSvc.dispatchEvent({
                type: 'advancedFilterEnabledChanged',
                enabled: this.enabled,
            });
        }
    }
    applyExpression() {
        const expressionParser = this.createExpressionParser(this.expression);
        expressionParser?.parseExpression();
        this.applyExpressionFromParser(expressionParser);
    }
    applyExpressionFromParser(expressionParser) {
        this.isValid = !expressionParser || expressionParser.isValid();
        if (!expressionParser || !this.isValid) {
            this.expressionFunction = null;
            this.expressionParams = null;
            this.appliedExpression = null;
            return;
        }
        const { expressionFunction, params } = this.getFunction(expressionParser);
        this.expressionFunction = expressionFunction;
        this.expressionParams = params;
        this.appliedExpression = this.expression;
    }
    getFunction(expressionParser) {
        if (this.gos.get('suppressAdvancedFilterEval')) {
            return expressionParser.getFunctionParsed();
        }
        else {
            const { functionString, params } = expressionParser.getFunctionString();
            return {
                expressionFunction: new Function('expressionProxy', 'node', 'params', functionString),
                params,
            };
        }
    }
    updateValidity() {
        this.advFilterExpSvc.resetColumnCaches();
        const expressionParser = this.createExpressionParser(this.expression);
        expressionParser?.parseExpression();
        const isValid = !expressionParser || expressionParser.isValid();
        const updatedValidity = isValid !== this.isValid;
        this.applyExpressionFromParser(expressionParser);
        this.ctrl.refreshComp();
        this.ctrl.refreshBuilderComp();
        return updatedValidity;
    }
    onNewColumnsLoaded(event) {
        if (event.source !== 'gridInitializing' || !this.dataTypeSvc?.isPendingInference) {
            return;
        }
        this.ctrl.setInputDisabled(true);
        const [destroyFunc] = this.addManagedEventListeners({
            dataTypesInferred: () => {
                destroyFunc?.();
                this.ctrl.setInputDisabled(false);
            },
        });
    }
}
exports.AdvancedFilterService = AdvancedFilterService;


/***/ }),

/***/ 9546:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agAutocompleteCSS = void 0;
exports.agAutocompleteCSS = `.ag-autocomplete{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}}.ag-autocomplete-list-popup{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-autocomplete-list{height:calc(var(--ag-row-height)*6.5);min-width:200px;position:relative;width:100%}.ag-autocomplete-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:focus-visible:after{content:none}&:hover{background-color:var(--ag-row-hover-color)}}.ag-autocomplete-row{align-items:center;display:flex;flex:1 1 auto;overflow:hidden}.ag-autocomplete-row-label{margin:0 var(--ag-widget-container-horizontal-padding);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-autocomplete-row-selected{background-color:var(--ag-selected-row-background-color)}`;


/***/ }),

/***/ 2611:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAutocompleteSelector = exports.AgAutocomplete = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agAutocomplete_css_GENERATED_1 = __webpack_require__(9546);
const agAutocompleteList_1 = __webpack_require__(3359);
class AgAutocomplete extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
    }
    constructor() {
        super(
        /* html */ `
            <div class="ag-autocomplete" role="presentation">
                <ag-input-text-field data-ref="eAutocompleteInput"></ag-input-text-field>
            </div>`, [ag_grid_community_1.AgInputTextFieldSelector]);
        this.eAutocompleteInput = ag_grid_community_1.RefPlaceholder;
        this.isListOpen = false;
        this.lastPosition = 0;
        this.valid = true;
        this.registerCSS(agAutocomplete_css_GENERATED_1.agAutocompleteCSS);
    }
    postConstruct() {
        this.eAutocompleteInput.onValueChange((value) => this.onValueChanged(value));
        this.eAutocompleteInput.getInputElement().setAttribute('autocomplete', 'off');
        this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
        this.addGuiEventListener('click', this.updatePositionAndList.bind(this));
        this.addDestroyFunc(() => {
            this.destroyBean(this.autocompleteList);
        });
        this.addGuiEventListener('focusout', () => this.onFocusOut());
    }
    onValueChanged(value) {
        const parsedValue = (0, ag_grid_community_1._makeNull)(value);
        this.updateValue(parsedValue);
        this.updateAutocompleteList(parsedValue);
    }
    updateValue(value) {
        this.updateLastPosition();
        this.dispatchLocalEvent({
            type: 'eventValueChanged',
            value,
        });
        this.validate(value);
    }
    updateAutocompleteList(value) {
        const autocompleteListParams = this.listGenerator?.(value, this.lastPosition) ?? { enabled: false };
        const isListOpen = this.isListOpen;
        if (!autocompleteListParams.type || autocompleteListParams.type !== this.autocompleteListParams?.type) {
            if (isListOpen) {
                this.closeList();
            }
        }
        this.autocompleteListParams = autocompleteListParams;
        if (autocompleteListParams?.enabled) {
            if (!isListOpen) {
                this.openList();
            }
            const { searchString } = autocompleteListParams;
            this.autocompleteList.setSearch(searchString ?? '');
        }
        else {
            if (isListOpen) {
                this.closeList();
            }
        }
    }
    onKeyDown(event) {
        const key = event.key;
        this.updateLastPosition();
        switch (key) {
            case ag_grid_community_1.KeyCode.ENTER:
                this.onEnterKeyDown(event);
                break;
            case ag_grid_community_1.KeyCode.TAB:
                this.onTabKeyDown(event);
                break;
            case ag_grid_community_1.KeyCode.DOWN:
            case ag_grid_community_1.KeyCode.UP:
                this.onUpDownKeyDown(event, key);
                break;
            case ag_grid_community_1.KeyCode.LEFT:
            case ag_grid_community_1.KeyCode.RIGHT:
            case ag_grid_community_1.KeyCode.PAGE_HOME:
            case ag_grid_community_1.KeyCode.PAGE_END:
                // input position is updated after this is called, so do async
                setTimeout(() => {
                    this.updatePositionAndList();
                });
                break;
            case ag_grid_community_1.KeyCode.ESCAPE:
                this.onEscapeKeyDown(event);
                break;
            case ag_grid_community_1.KeyCode.SPACE:
                if (event.ctrlKey && !this.isListOpen) {
                    event.preventDefault();
                    this.forceOpenList();
                }
                break;
        }
    }
    confirmSelection() {
        const selectedValue = this.autocompleteList?.getSelectedValue();
        if (selectedValue) {
            this.closeList();
            this.dispatchLocalEvent({
                type: 'eventOptionSelected',
                value: this.getValue(),
                position: this.lastPosition,
                updateEntry: selectedValue,
                autocompleteType: this.autocompleteListParams.type,
            });
        }
    }
    onTabKeyDown(event) {
        if (this.isListOpen) {
            event.preventDefault();
            event.stopPropagation();
            this.confirmSelection();
        }
    }
    onEnterKeyDown(event) {
        event.preventDefault();
        if (this.isListOpen) {
            this.confirmSelection();
        }
        else {
            this.onCompleted();
        }
    }
    onUpDownKeyDown(event, key) {
        event.preventDefault();
        if (!this.isListOpen) {
            this.forceOpenList();
        }
        else {
            this.autocompleteList?.onNavigationKeyDown(event, key);
        }
    }
    onEscapeKeyDown(event) {
        if (this.isListOpen) {
            event.preventDefault();
            event.stopPropagation();
            this.closeList();
            this.setCaret(this.lastPosition, true);
        }
    }
    onFocusOut() {
        if (this.isListOpen) {
            this.closeList();
        }
    }
    updatePositionAndList() {
        this.updateLastPosition();
        this.updateAutocompleteList(this.eAutocompleteInput.getValue() ?? null);
    }
    setCaret(position, setFocus) {
        if (setFocus && (0, ag_grid_community_1._isNothingFocused)(this.beans)) {
            // clicking on the list loses focus, so restore
            this.eAutocompleteInput.getFocusableElement().focus();
        }
        const eInput = this.eAutocompleteInput.getInputElement();
        eInput.setSelectionRange(position, position);
        if (position === eInput.value.length) {
            // ensure the caret is visible
            eInput.scrollLeft = eInput.scrollWidth;
        }
    }
    forceOpenList() {
        this.onValueChanged(this.eAutocompleteInput.getValue());
    }
    updateLastPosition() {
        this.lastPosition = this.eAutocompleteInput.getInputElement().selectionStart ?? 0;
    }
    validate(value) {
        if (!this.validator) {
            return;
        }
        const validationMessage = (this.validationMessage = this.validator(value));
        this.eAutocompleteInput.getInputElement().setCustomValidity(validationMessage ?? '');
        this.valid = !validationMessage;
        this.dispatchLocalEvent({
            type: 'eventValidChanged',
            isValid: this.valid,
            validationMessage,
        });
    }
    openList() {
        this.isListOpen = true;
        // this is unmanaged as it gets destroyed/created each time it is opened
        this.autocompleteList = this.createBean(new agAutocompleteList_1.AgAutocompleteList({
            autocompleteEntries: this.autocompleteListParams.entries,
            onConfirmed: () => this.confirmSelection(),
            forceLastSelection: this.forceLastSelection,
        }));
        const ePopupGui = this.autocompleteList.getGui();
        const positionParams = {
            ePopup: ePopupGui,
            type: 'autocomplete',
            eventSource: this.getGui(),
            position: 'under',
            alignSide: this.gos.get('enableRtl') ? 'right' : 'left',
            keepWithinBounds: true,
        };
        const addPopupRes = this.popupSvc.addPopup({
            eChild: ePopupGui,
            anchorToElement: this.getGui(),
            positionCallback: () => this.popupSvc.positionPopupByComponent(positionParams),
            ariaLabel: this.listAriaLabel,
        });
        this.hidePopup = addPopupRes.hideFunc;
        this.autocompleteList.afterGuiAttached();
    }
    closeList() {
        this.isListOpen = false;
        this.hidePopup();
        this.destroyBean(this.autocompleteList);
        this.autocompleteList = null;
    }
    onCompleted() {
        if (this.isListOpen) {
            this.closeList();
        }
        this.dispatchLocalEvent({
            type: 'eventValueConfirmed',
            value: this.getValue(),
            isValid: this.isValid(),
        });
    }
    getValue() {
        return (0, ag_grid_community_1._makeNull)(this.eAutocompleteInput.getValue());
    }
    setInputPlaceholder(placeholder) {
        this.eAutocompleteInput.setInputPlaceholder(placeholder);
        return this;
    }
    setInputAriaLabel(label) {
        this.eAutocompleteInput.setInputAriaLabel(label);
        return this;
    }
    setListAriaLabel(label) {
        this.listAriaLabel = label;
        return this;
    }
    setListGenerator(listGenerator) {
        this.listGenerator = listGenerator;
        return this;
    }
    setValidator(validator) {
        this.validator = validator;
        return this;
    }
    isValid() {
        return this.valid;
    }
    setValue(params) {
        const { value, position, silent, updateListOnlyIfOpen, restoreFocus } = params;
        this.eAutocompleteInput.setValue(value, true);
        this.setCaret(position ?? this.lastPosition, restoreFocus);
        if (!silent) {
            this.updateValue(value);
        }
        if (!updateListOnlyIfOpen || this.isListOpen) {
            this.updateAutocompleteList(value);
        }
    }
    setForceLastSelection(forceLastSelection) {
        this.forceLastSelection = forceLastSelection;
        return this;
    }
    setInputDisabled(disabled) {
        this.eAutocompleteInput.setDisabled(disabled);
        return this;
    }
}
exports.AgAutocomplete = AgAutocomplete;
exports.AgAutocompleteSelector = {
    selector: 'AG-AUTOCOMPLETE',
    component: AgAutocomplete,
};


/***/ }),

/***/ 3359:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAutocompleteList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const virtualList_1 = __webpack_require__(7904);
const agAutocompleteRow_1 = __webpack_require__(9087);
class AgAutocompleteList extends ag_grid_community_1.PopupComponent {
    constructor(params) {
        super(/* html */ `<div class="ag-autocomplete-list-popup">
            <div data-ref="eList" class="ag-autocomplete-list"></div>
        <div>`);
        this.params = params;
        this.eList = ag_grid_community_1.RefPlaceholder;
        this.searchString = '';
    }
    postConstruct() {
        this.autocompleteEntries = this.params.autocompleteEntries;
        this.virtualList = this.createManagedBean(new virtualList_1.VirtualList({ cssIdentifier: 'autocomplete' }));
        this.virtualList.setComponentCreator(this.createRowComponent.bind(this));
        this.eList.appendChild(this.virtualList.getGui());
        this.virtualList.setModel({
            getRowCount: () => this.autocompleteEntries.length,
            getRow: (index) => this.autocompleteEntries[index],
        });
        const virtualListGui = this.virtualList.getGui();
        this.addManagedListeners(virtualListGui, {
            click: () => this.params.onConfirmed(),
            mousemove: this.onMouseMove.bind(this),
            mousedown: (e) => e.preventDefault(),
        });
        this.setSelectedValue(0);
    }
    onNavigationKeyDown(event, key) {
        // if we don't preventDefault the page body and/or grid scroll will move.
        event.preventDefault();
        const oldIndex = this.autocompleteEntries.indexOf(this.selectedValue);
        const newIndex = key === ag_grid_community_1.KeyCode.UP ? oldIndex - 1 : oldIndex + 1;
        this.checkSetSelectedValue(newIndex);
    }
    setSearch(searchString) {
        this.searchString = searchString;
        if ((0, ag_grid_community_1._exists)(searchString)) {
            this.runSearch();
        }
        else {
            // reset
            this.autocompleteEntries = this.params.autocompleteEntries;
            this.virtualList.refresh();
            this.checkSetSelectedValue(0);
        }
        this.updateSearchInList();
    }
    runContainsSearch(searchString, searchStrings) {
        let topMatch;
        let topMatchStartsWithSearchString = false;
        const lowerCaseSearchString = searchString.toLocaleLowerCase();
        const allMatches = searchStrings.filter((string) => {
            const lowerCaseString = string.toLocaleLowerCase();
            const index = lowerCaseString.indexOf(lowerCaseSearchString);
            const startsWithSearchString = index === 0;
            const isMatch = index >= 0;
            // top match is shortest value that starts with the search string, otherwise shortest value that includes the search string
            if (isMatch &&
                (!topMatch ||
                    (!topMatchStartsWithSearchString && startsWithSearchString) ||
                    (topMatchStartsWithSearchString === startsWithSearchString && string.length < topMatch.length))) {
                topMatch = string;
                topMatchStartsWithSearchString = startsWithSearchString;
            }
            return isMatch;
        });
        if (!topMatch && allMatches.length) {
            topMatch = allMatches[0];
        }
        return { topMatch, allMatches };
    }
    runSearch() {
        const { autocompleteEntries, useFuzzySearch, forceLastSelection } = this.params;
        const searchStrings = autocompleteEntries.map((v) => v.displayValue ?? v.key);
        let matchingStrings;
        let topSuggestion;
        if (useFuzzySearch) {
            matchingStrings = (0, ag_grid_community_1._fuzzySuggestions)({
                inputValue: this.searchString,
                allSuggestions: searchStrings,
                hideIrrelevant: true,
                addSequentialWeight: true,
            }).values;
            topSuggestion = matchingStrings.length ? matchingStrings[0] : undefined;
        }
        else {
            const containsMatches = this.runContainsSearch(this.searchString, searchStrings);
            matchingStrings = containsMatches.allMatches;
            topSuggestion = containsMatches.topMatch;
        }
        let filteredEntries = autocompleteEntries.filter(({ key, displayValue }) => matchingStrings.includes(displayValue ?? key));
        if (!filteredEntries.length &&
            this.selectedValue &&
            forceLastSelection?.(this.selectedValue, this.searchString)) {
            filteredEntries = [this.selectedValue];
        }
        this.autocompleteEntries = filteredEntries;
        this.virtualList.refresh();
        if (!topSuggestion) {
            return;
        }
        const topSuggestionIndex = matchingStrings.indexOf(topSuggestion);
        this.checkSetSelectedValue(topSuggestionIndex);
    }
    updateSearchInList() {
        this.virtualList.forEachRenderedRow((row) => row.setSearchString(this.searchString));
    }
    checkSetSelectedValue(index) {
        if (index >= 0 && index < this.autocompleteEntries.length) {
            this.setSelectedValue(index);
        }
    }
    setSelectedValue(index) {
        const value = this.autocompleteEntries[index];
        if (this.selectedValue === value) {
            return;
        }
        this.selectedValue = value;
        this.virtualList.ensureIndexVisible(index);
        this.virtualList.forEachRenderedRow((cmp, idx) => {
            cmp.updateSelected(index === idx);
        });
    }
    createRowComponent(value) {
        const row = new agAutocompleteRow_1.AgAutocompleteRow();
        this.createBean(row);
        row.setState(value.displayValue ?? value.key, value === this.selectedValue);
        return row;
    }
    onMouseMove(mouseEvent) {
        const virtualList = this.virtualList;
        const rect = virtualList.getGui().getBoundingClientRect();
        const scrollTop = virtualList.getScrollTop();
        const mouseY = mouseEvent.clientY - rect.top + scrollTop;
        const row = Math.floor(mouseY / virtualList.getRowHeight());
        this.checkSetSelectedValue(row);
    }
    afterGuiAttached() {
        this.virtualList.refresh();
    }
    getSelectedValue() {
        if (!this.autocompleteEntries.length) {
            return null;
        }
        return this.selectedValue ?? null;
    }
}
exports.AgAutocompleteList = AgAutocompleteList;


/***/ }),

/***/ 9087:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAutocompleteRow = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgAutocompleteRow extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `
        <div class="ag-autocomplete-row" role="presentation">
            <div class="ag-autocomplete-row-label"></div>
        </div>`);
        this.hasHighlighting = false;
    }
    setState(value, selected) {
        this.value = value;
        this.render();
        this.updateSelected(selected);
    }
    updateSelected(selected) {
        this.addOrRemoveCssClass('ag-autocomplete-row-selected', selected);
    }
    setSearchString(searchString) {
        let keepHighlighting = false;
        if ((0, ag_grid_community_1._exists)(searchString)) {
            const index = this.value?.toLocaleLowerCase().indexOf(searchString.toLocaleLowerCase());
            if (index >= 0) {
                keepHighlighting = true;
                this.hasHighlighting = true;
                const highlightEndIndex = index + searchString.length;
                const startPart = (0, ag_grid_community_1._escapeString)(this.value.slice(0, index));
                const highlightedPart = (0, ag_grid_community_1._escapeString)(this.value.slice(index, highlightEndIndex));
                const endPart = (0, ag_grid_community_1._escapeString)(this.value.slice(highlightEndIndex));
                this.getGui().lastElementChild.innerHTML = `${startPart}<b>${highlightedPart}</b>${endPart}`;
            }
        }
        if (!keepHighlighting && this.hasHighlighting) {
            this.hasHighlighting = false;
            this.render();
        }
    }
    render() {
        // putting in blank if missing, so at least the user can click on it
        this.getGui().lastElementChild.innerHTML = (0, ag_grid_community_1._escapeString)(this.value) ?? '&nbsp;';
    }
}
exports.AgAutocompleteRow = AgAutocompleteRow;


/***/ }),

/***/ 5219:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDropdownComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agRichSelect_1 = __webpack_require__(2005);
class AddDropdownComp extends agRichSelect_1.AgRichSelect {
    constructor(params) {
        super({
            ...params,
            template: /* html */ `
                <div class="ag-picker-field" role="presentation">
                    <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-picker-collapsed">
                        <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                        <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                        <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>`,
            agComponents: [ag_grid_community_1.AgInputTextFieldSelector],
        });
        this.params = params;
    }
    showPicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.showPicker());
    }
    hidePicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.hidePicker());
    }
    postConstruct() {
        super.postConstruct();
        const { wrapperClassName, ariaLabel } = this.params;
        (0, ag_grid_community_1._setDisplayed)(this.eDisplayField, false);
        if (wrapperClassName) {
            this.eWrapper.classList.add(wrapperClassName);
        }
        (0, ag_grid_community_1._setAriaLabelledBy)(this.eWrapper, '');
        (0, ag_grid_community_1._setAriaLabel)(this.eWrapper, ariaLabel);
    }
    onEnterKeyDown(event) {
        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
        if (this.isPickerDisplayed) {
            super.onEnterKeyDown(event);
        }
        else {
            event.preventDefault();
            this.showPicker();
        }
    }
}
exports.AddDropdownComp = AddDropdownComp;


/***/ }),

/***/ 8986:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterBuilderComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const virtualList_1 = __webpack_require__(7904);
const advancedFilterBuilderDragFeature_1 = __webpack_require__(2865);
const advancedFilterBuilderItemAddComp_1 = __webpack_require__(2172);
const advancedFilterBuilderItemComp_1 = __webpack_require__(9889);
class AdvancedFilterBuilderComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
        this.advancedFilter = beans.advancedFilter;
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.registry = beans.registry;
    }
    constructor() {
        super(/* html */ `
            <div role="presentation" class="ag-advanced-filter-builder" tabindex="-1">
                <div role="presentation" class="ag-advanced-filter-builder-list" data-ref="eList"></div>
                <div role="presentation" class="ag-advanced-filter-builder-button-panel">
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-apply-button" data-ref="eApplyFilterButton"></button>
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-cancel-button" data-ref="eCancelFilterButton"></button>
                </div>
            </div>`);
        this.eList = ag_grid_community_1.RefPlaceholder;
        this.eApplyFilterButton = ag_grid_community_1.RefPlaceholder;
        this.eCancelFilterButton = ag_grid_community_1.RefPlaceholder;
        this.validationMessage = null;
    }
    postConstruct() {
        const { showMoveButtons } = this.gos.get('advancedFilterBuilderParams') ?? {};
        this.showMove = !!showMoveButtons;
        this.addManagedPropertyListener('advancedFilterBuilderParams', ({ currentValue }) => {
            this.showMove = !!currentValue?.showMoveButtons;
            this.refreshList(false);
        });
        this.filterModel = this.setupFilterModel();
        this.setupVirtualList();
        this.dragFeature = this.createManagedBean(new advancedFilterBuilderDragFeature_1.AdvancedFilterBuilderDragFeature(this, this.virtualList));
        this.setupButtons();
    }
    refresh() {
        const virtualList = this.virtualList;
        let indexToFocus = virtualList.getLastFocusedRow();
        this.setupFilterModel();
        this.validateItems();
        this.refreshList(false);
        if (indexToFocus != null) {
            // last focused row is cleared on focus out, so if defined, we need to put the focus back
            if (!virtualList.getComponentAt(indexToFocus)) {
                indexToFocus = 0;
            }
            virtualList.focusRow(indexToFocus);
        }
    }
    getNumItems() {
        return this.items.length;
    }
    moveItem(item, destination) {
        if (!destination || !item) {
            return;
        }
        this.moveItemToIndex(item, destination.rowIndex, destination.position);
    }
    afterGuiAttached() {
        this.virtualList.awaitStable(() => this.virtualList.focusRow(0));
    }
    setupVirtualList() {
        const virtualList = (this.virtualList = this.createManagedBean(new virtualList_1.VirtualList({
            cssIdentifier: 'advanced-filter-builder',
            ariaRole: 'tree',
            listName: this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderList'),
        })));
        virtualList.setComponentCreator(this.createItemComponent.bind(this));
        virtualList.setComponentUpdater(this.updateItemComponent.bind(this));
        virtualList.setRowHeight(40);
        this.eList.appendChild(virtualList.getGui());
        virtualList.setModel({
            getRowCount: () => this.items.length,
            getRow: (index) => this.items[index],
            areRowsEqual: (oldRow, newRow) => oldRow === newRow,
        });
        this.buildList();
        virtualList.refresh();
    }
    setupButtons() {
        this.eApplyFilterButton.innerText = this.advFilterExpSvc.translate('advancedFilterBuilderApply');
        this.activateTabIndex([this.eApplyFilterButton]);
        this.addManagedElementListeners(this.eApplyFilterButton, {
            click: () => {
                this.advancedFilter.setModel(this.filterModel);
                this.filterManager?.onFilterChanged({ source: 'advancedFilter' });
                this.close();
            },
        });
        this.validationTooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.eApplyFilterButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.validationMessage,
            getTooltipShowDelayOverride: () => 1000,
        }));
        this.validate();
        const mouseListener = (isEnter) => this.addOrRemoveCssClass('ag-advanced-filter-builder-validation', isEnter);
        this.addManagedListeners(this.eApplyFilterButton, {
            mouseenter: () => mouseListener(true),
            mouseleave: () => mouseListener(false),
        });
        this.eCancelFilterButton.innerText = this.advFilterExpSvc.translate('advancedFilterBuilderCancel');
        this.activateTabIndex([this.eCancelFilterButton]);
        this.addManagedElementListeners(this.eCancelFilterButton, { click: () => this.close() });
    }
    removeItemFromParent(item) {
        const sourceParentIndex = item.parent.conditions.indexOf(item.filterModel);
        item.parent.conditions.splice(sourceParentIndex, 1);
        return sourceParentIndex;
    }
    moveItemToIndex(item, destinationRowIndex, destinationPosition) {
        const destinationItem = this.items[destinationRowIndex];
        const destinationIsParent = destinationItem.filterModel?.filterType === 'join' && destinationPosition === 'bottom';
        const destinationParent = destinationIsParent
            ? destinationItem.filterModel
            : destinationItem.parent;
        // trying to move before the root
        if (!destinationParent) {
            return;
        }
        // can't move into itself
        if (this.isChildOrSelf(destinationParent, item.filterModel) || destinationItem === item) {
            return;
        }
        this.removeItemFromParent(item);
        let destinationParentIndex;
        if (destinationIsParent) {
            destinationParentIndex = 0;
        }
        else {
            destinationParentIndex = destinationParent.conditions.indexOf(destinationItem.filterModel);
            if (destinationParentIndex === -1) {
                destinationParentIndex = destinationParent.conditions.length;
            }
            else if (destinationPosition === 'bottom') {
                destinationParentIndex += 1;
            }
        }
        destinationParent.conditions.splice(destinationParentIndex, 0, item.filterModel);
        this.refreshList(false);
    }
    isChildOrSelf(modelToCheck, potentialParentModel) {
        return (modelToCheck === potentialParentModel ||
            (potentialParentModel.filterType === 'join' &&
                potentialParentModel.conditions.some((condition) => this.isChildOrSelf(modelToCheck, condition))));
    }
    setupFilterModel() {
        const filterModel = this.formatFilterModel(this.advancedFilter.getModel());
        this.stringifiedModel = JSON.stringify(filterModel);
        return filterModel;
    }
    formatFilterModel(filterModel) {
        filterModel = filterModel ?? {
            filterType: 'join',
            type: 'AND',
            conditions: [],
        };
        if (filterModel.filterType !== 'join') {
            filterModel = {
                filterType: 'join',
                type: 'AND',
                conditions: [filterModel],
            };
        }
        return filterModel;
    }
    buildList() {
        const parseFilterModel = (filterModel, items, level, parent) => {
            items.push({ filterModel, level, parent, valid: true, showMove: this.showMove });
            if (filterModel.filterType === 'join') {
                filterModel.conditions.forEach((childFilterModel) => parseFilterModel(childFilterModel, items, level + 1, filterModel));
                if (level === 0) {
                    items.push({ filterModel: null, level: level + 1, parent: filterModel, valid: true });
                }
            }
        };
        this.items = [];
        parseFilterModel(this.filterModel, this.items, 0);
    }
    refreshList(softRefresh) {
        if (!softRefresh) {
            const invalidModels = [];
            this.items.forEach((item) => {
                if (!item.valid) {
                    invalidModels.push(item.filterModel);
                }
            });
            this.buildList();
            if (invalidModels.length) {
                this.items.forEach((item) => {
                    if (item.filterModel && invalidModels.includes(item.filterModel)) {
                        item.valid = false;
                    }
                });
            }
        }
        this.virtualList.refresh(softRefresh);
        this.validate();
    }
    updateItemComponent(item, comp) {
        const index = this.items.indexOf(item);
        const populateTreeLines = (filterModel, treeLines) => {
            const parentItem = this.items.find((itemToCheck) => itemToCheck.filterModel === filterModel);
            const parentFilterModel = parentItem?.parent;
            if (parentFilterModel) {
                const { conditions } = parentFilterModel;
                // check parent
                populateTreeLines(parentFilterModel, treeLines);
                treeLines.push(conditions[conditions.length - 1] === filterModel);
            }
        };
        const treeLines = [];
        const { filterModel } = item;
        if (filterModel) {
            populateTreeLines(filterModel, treeLines);
            // the add item button is always last child
            treeLines[0] = false;
        }
        const showStartTreeLine = filterModel?.filterType === 'join' && !!filterModel.conditions.length;
        comp.setState({
            disableMoveUp: index === 1,
            disableMoveDown: !this.canMoveDown(item, index),
            treeLines,
            showStartTreeLine,
        });
    }
    createItemComponent(item, focusWrapper) {
        const itemComp = this.createBean(item.filterModel
            ? new advancedFilterBuilderItemComp_1.AdvancedFilterBuilderItemComp(item, this.dragFeature, focusWrapper)
            : new advancedFilterBuilderItemAddComp_1.AdvancedFilterBuilderItemAddComp(item, focusWrapper));
        itemComp.addManagedListeners(itemComp, {
            advancedFilterBuilderRemoved: ({ item }) => this.removeItem(item),
            advancedFilterBuilderValueChanged: () => this.validate(),
            advancedFilterBuilderAdded: ({ item, isJoin }) => this.addItem(item, isJoin),
            advancedFilterBuilderMoved: ({ item, backwards }) => this.moveItemUpDown(item, backwards),
        });
        if (itemComp instanceof advancedFilterBuilderItemComp_1.AdvancedFilterBuilderItemComp) {
            this.updateItemComponent(item, itemComp);
        }
        return itemComp;
    }
    addItem(item, isJoin) {
        const { parent: itemParent, level, filterModel: itemFilterModel } = item;
        const itemIsJoin = itemFilterModel?.filterType === 'join';
        const filterModel = isJoin
            ? {
                filterType: 'join',
                type: 'AND',
                conditions: [],
            }
            : {};
        const parent = (itemIsJoin ? itemFilterModel : itemParent);
        let insertIndex = itemIsJoin ? 0 : parent.conditions.indexOf(itemFilterModel);
        if (insertIndex >= 0) {
            if (!itemIsJoin) {
                insertIndex += 1;
            }
            parent.conditions.splice(insertIndex, 0, filterModel);
        }
        else {
            parent.conditions.push(filterModel);
        }
        let index = this.items.indexOf(item);
        const softRefresh = index >= 0;
        if (softRefresh) {
            if (item.filterModel) {
                index++;
            }
            const newItems = [
                {
                    filterModel,
                    level: itemIsJoin ? level + 1 : level,
                    parent,
                    valid: isJoin,
                    showMove: this.showMove,
                },
            ];
            this.items.splice(index, 0, ...newItems);
        }
        this.refreshList(softRefresh);
        if (softRefresh) {
            this.virtualList.getComponentAt(index)?.afterAdd();
        }
    }
    removeItem(item) {
        const parent = item.parent;
        const { filterModel } = item;
        const parentIndex = parent.conditions.indexOf(filterModel);
        parent.conditions.splice(parentIndex, 1);
        const isJoin = item.filterModel?.filterType === 'join';
        const index = this.items.indexOf(item);
        // if it's a join, we don't know how many children there are, so always rebuild
        const softRefresh = !isJoin && index >= 0;
        if (softRefresh) {
            this.items.splice(index, 1);
        }
        this.refreshList(softRefresh);
        if (index >= 0) {
            this.virtualList.focusRow(index);
        }
    }
    moveItemUpDown(item, backwards) {
        const itemIndex = this.items.indexOf(item);
        const destinationIndex = backwards ? itemIndex - 1 : itemIndex + 1;
        if (destinationIndex === 0 || (!backwards && !this.canMoveDown(item, itemIndex))) {
            return;
        }
        const destinationItem = this.items[destinationIndex];
        const indexInParent = this.removeItemFromParent(item);
        const { level, filterModel, parent } = item;
        const { level: destinationLevel, filterModel: destinationFilterModel, parent: destinationParent, } = destinationItem;
        if (backwards) {
            if (destinationLevel === level && destinationFilterModel.filterType === 'join') {
                // destination is empty join. move to last child
                destinationFilterModel.conditions.push(filterModel);
            }
            else if (destinationLevel <= level) {
                // same parent or first child. move above destination in destination parent
                const destinationIndex = destinationParent.conditions.indexOf(destinationFilterModel);
                destinationParent.conditions.splice(destinationIndex, 0, filterModel);
            }
            else {
                // need to move up a level. move to end of previous item's children
                const newParentItem = parent.conditions[indexInParent - 1];
                newParentItem.conditions.push(filterModel);
            }
        }
        else {
            if (destinationLevel === level) {
                if (destinationFilterModel.filterType === 'join') {
                    // destination is join. move to first child
                    destinationFilterModel.conditions.splice(0, 0, filterModel);
                }
                else {
                    // switch positions
                    const destinationIndex = destinationParent.conditions.indexOf(destinationFilterModel);
                    destinationParent.conditions.splice(destinationIndex + 1, 0, filterModel);
                }
            }
            else {
                if (indexInParent < parent.conditions.length) {
                    // keep in parent, but swap with next child
                    parent.conditions.splice(indexInParent + 1, 0, filterModel);
                }
                else {
                    // need to move down a level. move after parent in its parent
                    const parentItem = this.items.find((itemToCheck) => itemToCheck.filterModel === parent);
                    const destinationIndex = parentItem.parent.conditions.indexOf(parentItem.filterModel) + 1;
                    parentItem.parent.conditions.splice(destinationIndex, 0, filterModel);
                }
            }
        }
        this.refreshList(false);
        const newIndex = this.items.findIndex(({ filterModel: filterModelToCheck }) => filterModelToCheck === filterModel);
        if (newIndex >= 0) {
            const comp = this.virtualList.getComponentAt(newIndex);
            if (comp instanceof advancedFilterBuilderItemComp_1.AdvancedFilterBuilderItemComp) {
                comp.focusMoveButton(backwards);
            }
        }
    }
    canMoveDown(item, index) {
        return !((item.level === 1 && index === this.items.length - 2) ||
            (item.level === 1 && item.parent.conditions[item.parent.conditions.length - 1] === item.filterModel));
    }
    close() {
        this.advancedFilter.getCtrl().toggleFilterBuilder({ source: 'ui' });
    }
    validate() {
        let disableApply = !this.items.every(({ valid }) => valid);
        if (!disableApply) {
            disableApply = JSON.stringify(this.filterModel) === this.stringifiedModel;
            if (disableApply) {
                this.validationMessage = this.advFilterExpSvc.translate('advancedFilterBuilderValidationAlreadyApplied');
            }
            else {
                this.validationMessage = null;
            }
        }
        else {
            this.validationMessage = this.advFilterExpSvc.translate('advancedFilterBuilderValidationIncomplete');
        }
        (0, ag_grid_community_1._setDisabled)(this.eApplyFilterButton, disableApply);
        this.validationTooltipFeature?.refreshTooltip();
    }
    validateItems() {
        const clearOperator = (filterModel) => {
            filterModel.type = undefined;
        };
        const clearOperand = (filterModel) => {
            delete filterModel.filter;
        };
        this.items.forEach((item) => {
            if (!item.valid || !item.filterModel || item.filterModel.filterType === 'join') {
                return;
            }
            const { filterModel } = item;
            const { colId } = filterModel;
            const hasColumn = this.advFilterExpSvc.getColumnAutocompleteEntries().find(({ key }) => key === colId);
            const columnDetails = this.advFilterExpSvc.getColumnDetails(filterModel.colId);
            if (!hasColumn || !columnDetails.column) {
                item.valid = false;
                filterModel.colId = undefined;
                clearOperator(filterModel);
                clearOperand(filterModel);
                return;
            }
            const operatorForType = this.advFilterExpSvc.getDataTypeExpressionOperator(columnDetails.baseCellDataType);
            const operator = operatorForType.operators[filterModel.type];
            if (!operator) {
                item.valid = false;
                clearOperator(filterModel);
                clearOperand(filterModel);
                return;
            }
            if (operator.numOperands > 0 && !(0, ag_grid_community_1._exists)(filterModel.filter)) {
                item.valid = false;
                return;
            }
        });
    }
}
exports.AdvancedFilterBuilderComp = AdvancedFilterBuilderComp;


/***/ }),

/***/ 2865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterBuilderDragFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const virtualListDragFeature_1 = __webpack_require__(5760);
class AdvancedFilterBuilderDragFeature extends ag_grid_community_1.BeanStub {
    constructor(comp, virtualList) {
        super();
        this.comp = comp;
        this.virtualList = virtualList;
    }
    postConstruct() {
        this.createManagedBean(new virtualListDragFeature_1.VirtualListDragFeature(this.comp, this.virtualList, {
            dragSourceType: ag_grid_community_1.DragSourceType.AdvancedFilterBuilder,
            listItemDragStartEvent: 'advancedFilterBuilderDragStarted',
            listItemDragEndEvent: 'advancedFilterBuilderDragEnded',
            eventSource: this,
            getCurrentDragValue: (listItemDragStartEvent) => this.getCurrentDragValue(listItemDragStartEvent),
            isMoveBlocked: () => false,
            getNumRows: (comp) => comp.getNumItems(),
            moveItem: (currentDragValue, lastHoveredListItem) => this.moveItem(currentDragValue, lastHoveredListItem),
        }));
    }
    getCurrentDragValue(listItemDragStartEvent) {
        return listItemDragStartEvent.item;
    }
    moveItem(currentDragValue, lastHoveredListItem) {
        this.comp.moveItem(currentDragValue, lastHoveredListItem);
    }
}
exports.AdvancedFilterBuilderDragFeature = AdvancedFilterBuilderDragFeature;


/***/ }),

/***/ 2172:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterBuilderItemAddComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const addDropdownComp_1 = __webpack_require__(5219);
const advancedFilterBuilderItemNavigationFeature_1 = __webpack_require__(1748);
const advancedFilterBuilderUtils_1 = __webpack_require__(6608);
class AdvancedFilterBuilderItemAddComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.registry = beans.registry;
    }
    constructor(item, focusWrapper) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div data-ref="eItem" class="ag-advanced-filter-builder-item" role="presentation">
                    <div class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true">
                        <div class="ag-advanced-filter-builder-item-tree-line-vertical-top ag-advanced-filter-builder-item-tree-line-horizontal"></div>
                    </div>
                </div>
            </div>
        `);
        this.item = item;
        this.focusWrapper = focusWrapper;
        this.eItem = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        (0, ag_grid_community_1._setAriaLevel)(this.focusWrapper, 2);
        const addButtonParams = (0, advancedFilterBuilderUtils_1.getAdvancedFilterBuilderAddButtonParams)((key) => this.advFilterExpSvc.translate(key), this.gos.get('advancedFilterBuilderParams')?.addSelectWidth);
        const eAddButton = this.createManagedBean(new addDropdownComp_1.AddDropdownComp(addButtonParams));
        this.addManagedListeners(eAddButton, {
            fieldPickerValueSelected: ({ value }) => {
                this.dispatchLocalEvent({
                    type: 'advancedFilterBuilderAdded',
                    item: this.item,
                    isJoin: value.key === 'join',
                });
            },
        });
        this.eItem.appendChild(eAddButton.getGui());
        this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => eAddButton.getGui(),
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advFilterExpSvc.translate('advancedFilterBuilderAddButtonTooltip'),
        }));
        this.createManagedBean(new advancedFilterBuilderItemNavigationFeature_1.AdvancedFilterBuilderItemNavigationFeature(this.getGui(), this.focusWrapper, eAddButton));
        (0, ag_grid_community_1._setAriaLabel)(this.focusWrapper, this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderItem', [
            this.advFilterExpSvc.translate('advancedFilterBuilderAddButtonTooltip'),
            `${this.item.level + 1}`,
        ]));
    }
    afterAdd() {
        // do nothing
    }
}
exports.AdvancedFilterBuilderItemAddComp = AdvancedFilterBuilderItemAddComp;


/***/ }),

/***/ 9889:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterBuilderItemComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const addDropdownComp_1 = __webpack_require__(5219);
const advancedFilterBuilderItemNavigationFeature_1 = __webpack_require__(1748);
const advancedFilterBuilderUtils_1 = __webpack_require__(6608);
const conditionPillWrapperComp_1 = __webpack_require__(6106);
const inputPillComp_1 = __webpack_require__(4042);
const joinPillWrapperComp_1 = __webpack_require__(1395);
const selectPillComp_1 = __webpack_require__(3036);
class AdvancedFilterBuilderItemComp extends ag_grid_community_1.TabGuardComp {
    wireBeans(beans) {
        this.dragAndDrop = beans.dragAndDrop;
        this.advFilterExpSvc = beans.advFilterExpSvc;
        this.registry = beans.registry;
    }
    constructor(item, dragFeature, focusWrapper) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div class="ag-advanced-filter-builder-item" role="presentation">
                    <div data-ref="eTreeLines" class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true"></div>
                    <span data-ref="eDragHandle" class="ag-drag-handle" aria-hidden="true"></span>
                    <span data-ref="eValidation" class="ag-advanced-filter-builder-item-button ag-advanced-filter-builder-invalid" aria-hidden="true"></span>
                </div>
                <div data-ref="eButtons" class="ag-advanced-filter-builder-item-buttons">
                    <span data-ref="eMoveUpButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <span data-ref="eMoveDownButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <div data-ref="eAddButton" role="presentation"></div>
                    <span data-ref="eRemoveButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                </div>
            </div>
        `);
        this.item = item;
        this.dragFeature = dragFeature;
        this.focusWrapper = focusWrapper;
        this.eTreeLines = ag_grid_community_1.RefPlaceholder;
        this.eDragHandle = ag_grid_community_1.RefPlaceholder;
        this.eButtons = ag_grid_community_1.RefPlaceholder;
        this.eValidation = ag_grid_community_1.RefPlaceholder;
        this.eMoveUpButton = ag_grid_community_1.RefPlaceholder;
        this.eMoveDownButton = ag_grid_community_1.RefPlaceholder;
        this.eAddButton = ag_grid_community_1.RefPlaceholder;
        this.eRemoveButton = ag_grid_community_1.RefPlaceholder;
        this.moveUpDisabled = false;
        this.moveDownDisabled = false;
    }
    postConstruct() {
        const { filterModel, level, showMove } = this.item;
        const isJoin = filterModel.filterType === 'join';
        this.ePillWrapper = this.createManagedBean(isJoin ? new joinPillWrapperComp_1.JoinPillWrapperComp() : new conditionPillWrapperComp_1.ConditionPillWrapperComp());
        this.ePillWrapper.init({ item: this.item, createPill: (params) => this.createPill(params) });
        this.eDragHandle.insertAdjacentElement('afterend', this.ePillWrapper.getGui());
        if (level === 0) {
            const eTreeLine = document.createElement('div');
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-vertical-bottom');
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-root');
            this.eTreeLines.appendChild(eTreeLine);
            (0, ag_grid_community_1._setDisplayed)(this.eDragHandle, false);
            (0, ag_grid_community_1._setDisplayed)(this.eButtons, false);
            (0, ag_grid_community_1._setAriaExpanded)(this.focusWrapper, true);
        }
        else {
            this.setupTreeLines(level);
            this.eDragHandle.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilderDrag', this.beans));
            this.setupValidation();
            this.setupMoveButtons(showMove);
            this.setupAddButton();
            this.setupRemoveButton();
            this.setupDragging();
            this.updateAriaExpanded();
        }
        (0, ag_grid_community_1._setAriaLevel)(this.focusWrapper, level + 1);
        this.initialiseTabGuard({});
        this.createManagedBean(new advancedFilterBuilderItemNavigationFeature_1.AdvancedFilterBuilderItemNavigationFeature(this.getGui(), this.focusWrapper, this.ePillWrapper));
        this.updateAriaLabel();
        this.addManagedListeners(this.ePillWrapper, {
            advancedFilterBuilderValueChanged: () => this.dispatchLocalEvent({
                type: 'advancedFilterBuilderValueChanged',
            }),
            advancedFilterBuilderValidChanged: () => this.updateValidity(),
        });
    }
    setState(params) {
        const { level } = this.item;
        if (level === 0) {
            return;
        }
        const { showMove } = this.item;
        const { disableMoveUp, disableMoveDown, treeLines, showStartTreeLine } = params;
        this.updateTreeLines(treeLines, showStartTreeLine);
        this.updateAriaExpanded();
        if (showMove) {
            this.moveUpDisabled = !!disableMoveUp;
            this.moveDownDisabled = !!disableMoveDown;
            this.eMoveUpButton.classList.toggle('ag-advanced-filter-builder-item-button-disabled', disableMoveUp);
            this.eMoveDownButton.classList.toggle('ag-advanced-filter-builder-item-button-disabled', disableMoveDown);
            (0, ag_grid_community_1._setAriaDisabled)(this.eMoveUpButton, !!disableMoveUp);
            (0, ag_grid_community_1._setAriaDisabled)(this.eMoveDownButton, !!disableMoveDown);
            this.moveUpTooltipFeature?.refreshTooltip();
            this.moveDownTooltipFeature?.refreshTooltip();
        }
    }
    focusMoveButton(backwards) {
        (backwards ? this.eMoveUpButton : this.eMoveDownButton).focus();
    }
    afterAdd() {
        this.ePillWrapper.getFocusableElement().focus();
    }
    setupTreeLines(level) {
        for (let i = 0; i < level; i++) {
            const eTreeLine = document.createElement('div');
            this.eTreeLines.appendChild(eTreeLine);
        }
    }
    updateTreeLines(treeLines, showStartTreeLine) {
        const lastTreeLineIndex = treeLines.length - 1;
        const { children } = this.eTreeLines;
        for (let i = 0; i < lastTreeLineIndex; i++) {
            const eTreeLine = children.item(i);
            if (eTreeLine) {
                eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical', !treeLines[i]);
            }
        }
        const eTreeLine = children.item(lastTreeLineIndex);
        if (eTreeLine) {
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-horizontal');
            const isLastChild = treeLines[lastTreeLineIndex];
            eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical-top', isLastChild);
            eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical', !isLastChild);
        }
        this.eDragHandle.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical-bottom', showStartTreeLine);
    }
    setupValidation() {
        this.eValidation.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilderInvalid', this.beans));
        this.validationTooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.eValidation,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.ePillWrapper.getValidationMessage(),
            getTooltipShowDelayOverride: () => 1000,
        }));
        this.updateValidity();
    }
    setupAddButton() {
        const addButtonParams = (0, advancedFilterBuilderUtils_1.getAdvancedFilterBuilderAddButtonParams)((key) => this.advFilterExpSvc.translate(key), this.gos.get('advancedFilterBuilderParams')?.addSelectWidth);
        const eAddButton = this.createManagedBean(new addDropdownComp_1.AddDropdownComp(addButtonParams));
        this.addManagedListeners(eAddButton, {
            fieldPickerValueSelected: ({ value }) => this.dispatchLocalEvent({
                type: 'advancedFilterBuilderAdded',
                item: this.item,
                isJoin: value.key === 'join',
            }),
        });
        this.eAddButton.appendChild(eAddButton.getGui());
        this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.eAddButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advFilterExpSvc.translate('advancedFilterBuilderAddButtonTooltip'),
        }));
    }
    setupRemoveButton() {
        this.eRemoveButton.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilderRemove', this.beans));
        this.addManagedListeners(this.eRemoveButton, {
            click: () => this.removeItem(),
            keydown: (event) => {
                switch (event.key) {
                    case ag_grid_community_1.KeyCode.ENTER:
                        event.preventDefault();
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        this.removeItem();
                        break;
                }
            },
        });
        this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.eRemoveButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advFilterExpSvc.translate('advancedFilterBuilderRemoveButtonTooltip'),
        }));
        (0, ag_grid_community_1._setAriaLabel)(this.eRemoveButton, this.advFilterExpSvc.translate('advancedFilterBuilderRemoveButtonTooltip'));
        this.activateTabIndex([this.eRemoveButton]);
    }
    setupMoveButtons(showMove) {
        if (showMove) {
            this.eMoveUpButton.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilderMoveUp', this.beans));
            this.addManagedListeners(this.eMoveUpButton, {
                click: () => this.moveItem(true),
                keydown: (event) => {
                    switch (event.key) {
                        case ag_grid_community_1.KeyCode.ENTER:
                            event.preventDefault();
                            (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                            this.moveItem(true);
                            break;
                    }
                },
            });
            this.moveUpTooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
                getGui: () => this.eMoveUpButton,
                getLocation: () => 'advancedFilter',
                getTooltipValue: () => this.moveUpDisabled
                    ? null
                    : this.advFilterExpSvc.translate('advancedFilterBuilderMoveUpButtonTooltip'),
            }));
            (0, ag_grid_community_1._setAriaLabel)(this.eMoveUpButton, this.advFilterExpSvc.translate('advancedFilterBuilderMoveUpButtonTooltip'));
            this.eMoveDownButton.appendChild((0, ag_grid_community_1._createIconNoSpan)('advancedFilterBuilderMoveDown', this.beans));
            this.addManagedListeners(this.eMoveDownButton, {
                click: () => this.moveItem(false),
                keydown: (event) => {
                    switch (event.key) {
                        case ag_grid_community_1.KeyCode.ENTER:
                            event.preventDefault();
                            (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                            this.moveItem(false);
                            break;
                    }
                },
            });
            this.moveDownTooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
                getGui: () => this.eMoveDownButton,
                getLocation: () => 'advancedFilter',
                getTooltipValue: () => this.moveDownDisabled
                    ? null
                    : this.advFilterExpSvc.translate('advancedFilterBuilderMoveDownButtonTooltip'),
            }));
            (0, ag_grid_community_1._setAriaLabel)(this.eMoveDownButton, this.advFilterExpSvc.translate('advancedFilterBuilderMoveDownButtonTooltip'));
            this.activateTabIndex([this.eMoveUpButton, this.eMoveDownButton]);
        }
        else {
            (0, ag_grid_community_1._setDisplayed)(this.eMoveUpButton, false);
            (0, ag_grid_community_1._setDisplayed)(this.eMoveDownButton, false);
        }
    }
    updateValidity() {
        (0, ag_grid_community_1._setVisible)(this.eValidation, !this.item.valid);
        this.validationTooltipFeature?.refreshTooltip();
        this.updateAriaLabel();
    }
    createPill(params) {
        const { key, cssClass, update, ariaLabel } = params;
        const onUpdated = (key) => {
            if (key == null) {
                return;
            }
            update(key);
            this.dispatchLocalEvent({
                type: 'advancedFilterBuilderValueChanged',
            });
        };
        if (params.isSelect) {
            const { getEditorParams, pickerAriaLabelKey, pickerAriaLabelValue, displayValue } = params;
            const advancedFilterBuilderParams = this.gos.get('advancedFilterBuilderParams');
            const minPickerWidth = `${advancedFilterBuilderParams?.pillSelectMinWidth ?? 140}px`;
            const maxPickerWidth = `${advancedFilterBuilderParams?.pillSelectMaxWidth ?? 200}px`;
            const comp = this.createBean(new selectPillComp_1.SelectPillComp({
                pickerAriaLabelKey,
                pickerAriaLabelValue,
                pickerType: 'ag-list',
                value: {
                    key,
                    displayValue,
                },
                valueFormatter: (value) => value == null ? null : value.displayValue ?? value.key,
                variableWidth: true,
                minPickerWidth,
                maxPickerWidth,
                getEditorParams,
                wrapperClassName: cssClass,
                ariaLabel,
                pickerIcon: 'advancedFilterBuilderSelectOpen',
            }));
            this.addManagedListeners(comp, {
                fieldPickerValueSelected: ({ value }) => onUpdated(value?.key),
            });
            return comp;
        }
        else {
            const { baseCellDataType, valueFormatter } = params;
            const comp = this.createBean(new inputPillComp_1.InputPillComp({
                value: key,
                valueFormatter,
                cssClass,
                type: this.getInputType(baseCellDataType),
                ariaLabel,
            }));
            this.addManagedListeners(comp, { fieldValueChanged: ({ value }) => onUpdated(value) });
            return comp;
        }
    }
    getInputType(baseCellDataType) {
        switch (baseCellDataType) {
            case 'text':
            case 'object':
            case 'boolean':
                return 'text';
            case 'number':
                return 'number';
            case 'date':
            case 'dateString':
                return 'date';
        }
    }
    setupDragging() {
        const dragSource = {
            type: ag_grid_community_1.DragSourceType.AdvancedFilterBuilder,
            eElement: this.eDragHandle,
            dragItemName: () => this.ePillWrapper.getDragName(),
            getDefaultIconName: () => 'notAllowed',
            getDragItem: () => ({}),
            onDragStarted: () => this.dragFeature.dispatchLocalEvent({
                type: 'advancedFilterBuilderDragStarted',
                item: this.item,
            }),
            onDragStopped: () => this.dragFeature.dispatchLocalEvent({
                type: 'advancedFilterBuilderDragEnded',
            }),
        };
        this.dragAndDrop.addDragSource(dragSource, true);
        this.addDestroyFunc(() => this.dragAndDrop.removeDragSource(dragSource));
    }
    updateAriaLabel() {
        const wrapperLabel = this.ePillWrapper.getAriaLabel();
        const level = `${this.item.level + 1}`;
        const validationMessage = this.ePillWrapper.getValidationMessage();
        let ariaLabel;
        if (validationMessage) {
            ariaLabel = this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderItemValidation', [
                wrapperLabel,
                level,
                validationMessage,
            ]);
        }
        else {
            ariaLabel = this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderItem', [wrapperLabel, level]);
        }
        (0, ag_grid_community_1._setAriaLabel)(this.focusWrapper, ariaLabel);
    }
    updateAriaExpanded() {
        (0, ag_grid_community_1._removeAriaExpanded)(this.focusWrapper);
        const { filterModel } = this.item;
        if (filterModel?.filterType === 'join' && filterModel.conditions.length) {
            (0, ag_grid_community_1._setAriaExpanded)(this.focusWrapper, true);
        }
    }
    removeItem() {
        this.dispatchLocalEvent({
            type: 'advancedFilterBuilderRemoved',
            item: this.item,
        });
    }
    moveItem(backwards) {
        this.dispatchLocalEvent({
            type: 'advancedFilterBuilderMoved',
            item: this.item,
            backwards,
        });
    }
}
exports.AdvancedFilterBuilderItemComp = AdvancedFilterBuilderItemComp;


/***/ }),

/***/ 1748:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedFilterBuilderItemNavigationFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AdvancedFilterBuilderItemNavigationFeature extends ag_grid_community_1.BeanStub {
    constructor(eGui, focusWrapper, eFocusableComp) {
        super();
        this.eGui = eGui;
        this.focusWrapper = focusWrapper;
        this.eFocusableComp = eFocusableComp;
    }
    postConstruct() {
        this.addManagedElementListeners(this.eGui, {
            keydown: (event) => {
                switch (event.key) {
                    case ag_grid_community_1.KeyCode.TAB:
                        if (!event.defaultPrevented) {
                            // tab guard handled the navigation. stop from reaching virtual list
                            (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        }
                        break;
                    case ag_grid_community_1.KeyCode.UP:
                    case ag_grid_community_1.KeyCode.DOWN:
                        // if this hasn't been handled by an editor, prevent virtual list navigation
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        break;
                    case ag_grid_community_1.KeyCode.ESCAPE:
                        if ((0, ag_grid_community_1._isStopPropagationForAgGrid)(event)) {
                            return;
                        }
                        if (this.eGui.contains((0, ag_grid_community_1._getActiveDomElement)(this.beans))) {
                            event.preventDefault();
                            (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                            this.focusWrapper.focus();
                        }
                        break;
                }
            },
        });
        const highlightClass = 'ag-advanced-filter-builder-virtual-list-item-highlight';
        this.addManagedListeners(this.focusWrapper, {
            keydown: (event) => {
                switch (event.key) {
                    case ag_grid_community_1.KeyCode.ENTER:
                        if ((0, ag_grid_community_1._isStopPropagationForAgGrid)(event)) {
                            return;
                        }
                        if ((0, ag_grid_community_1._getActiveDomElement)(this.beans) === this.focusWrapper) {
                            event.preventDefault();
                            (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                            this.eFocusableComp.getFocusableElement().focus();
                        }
                        break;
                }
            },
            focusin: () => {
                this.focusWrapper.classList.add(highlightClass);
            },
            focusout: (event) => {
                if (!this.focusWrapper.contains(event.relatedTarget)) {
                    this.focusWrapper.classList.remove(highlightClass);
                }
            },
        });
    }
}
exports.AdvancedFilterBuilderItemNavigationFeature = AdvancedFilterBuilderItemNavigationFeature;


/***/ }),

/***/ 6608:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAdvancedFilterBuilderAddButtonParams = void 0;
function getAdvancedFilterBuilderAddButtonParams(translate, maxPickerWidth) {
    return {
        pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderAddField',
        pickerAriaLabelValue: 'Advanced Filter Builder Add Field',
        pickerType: 'ag-list',
        valueList: [
            {
                key: 'condition',
                displayValue: translate('advancedFilterBuilderAddCondition'),
            },
            {
                key: 'join',
                displayValue: translate('advancedFilterBuilderAddJoin'),
            },
        ],
        valueFormatter: (value) => (value == null ? null : value.displayValue ?? value.key),
        pickerIcon: 'advancedFilterBuilderAdd',
        maxPickerWidth: `${maxPickerWidth ?? 120}px`,
        wrapperClassName: 'ag-advanced-filter-builder-item-button',
        ariaLabel: translate('advancedFilterBuilderAddButtonTooltip'),
    };
}
exports.getAdvancedFilterBuilderAddButtonParams = getAdvancedFilterBuilderAddButtonParams;


/***/ }),

/***/ 6106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConditionPillWrapperComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ConditionPillWrapperComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.advFilterExpSvc = beans.advFilterExpSvc;
    }
    constructor() {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `);
        this.validationMessage = null;
    }
    init(params) {
        const { item, createPill } = params;
        this.item = item;
        this.createPill = createPill;
        this.filterModel = item.filterModel;
        this.setupColumnCondition(this.filterModel);
        this.validate();
        this.addDestroyFunc(() => this.destroyBeans([this.eColumnPill, this.eOperatorPill, this.eOperandPill]));
    }
    getDragName() {
        return this.filterModel.colId
            ? this.advFilterExpSvc.parseColumnFilterModel(this.filterModel)
            : this.getDefaultColumnDisplayValue();
    }
    getAriaLabel() {
        return `${this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderFilterItem')} ${this.getDragName()}`;
    }
    getValidationMessage() {
        return this.validationMessage;
    }
    getFocusableElement() {
        return this.eColumnPill.getFocusableElement();
    }
    setupColumnCondition(filterModel) {
        const columnDetails = this.advFilterExpSvc.getColumnDetails(filterModel.colId);
        this.baseCellDataType = columnDetails.baseCellDataType;
        this.column = columnDetails.column;
        this.numOperands = this.getNumOperands(this.getOperatorKey());
        this.eColumnPill = this.createPill({
            key: this.getColumnKey(),
            displayValue: this.getColumnDisplayValue() ?? this.getDefaultColumnDisplayValue(),
            cssClass: 'ag-advanced-filter-builder-column-pill',
            isSelect: true,
            getEditorParams: () => ({ values: this.advFilterExpSvc.getColumnAutocompleteEntries() }),
            update: (key) => this.setColumnKey(key),
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderColumnSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Column Select Field',
            ariaLabel: this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderColumn'),
        });
        this.getGui().appendChild(this.eColumnPill.getGui());
        if ((0, ag_grid_community_1._exists)(this.getColumnKey())) {
            this.createOperatorPill();
            if (this.hasOperand()) {
                this.createOperandPill();
            }
        }
    }
    createOperatorPill() {
        this.eOperatorPill = this.createPill({
            key: this.getOperatorKey(),
            displayValue: this.getOperatorDisplayValue() ?? this.getDefaultOptionSelectValue(),
            cssClass: 'ag-advanced-filter-builder-option-pill',
            isSelect: true,
            getEditorParams: () => ({ values: this.getOperatorAutocompleteEntries() }),
            update: (key) => this.setOperatorKey(key),
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderOptionSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Option Select Field',
            ariaLabel: this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderOption'),
        });
        this.eColumnPill.getGui().insertAdjacentElement('afterend', this.eOperatorPill.getGui());
    }
    createOperandPill() {
        // Date inputs want iso string, so read straight from model. For numbers, convert to string
        const { filter } = this.filterModel;
        const key = (typeof filter === 'number' ? (0, ag_grid_community_1._toStringOrNull)(filter) : filter) ?? '';
        this.eOperandPill = this.createPill({
            key,
            // Convert from the input format to display format.
            // Input format matches model format except for numbers, but these get stringified anyway
            valueFormatter: (value) => this.advFilterExpSvc.getOperandDisplayValue({ ...this.filterModel, filter: value }, true),
            baseCellDataType: this.baseCellDataType,
            cssClass: 'ag-advanced-filter-builder-value-pill',
            isSelect: false,
            update: (key) => this.setOperand(key),
            ariaLabel: this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderValue'),
        });
        this.getGui().appendChild(this.eOperandPill.getGui());
    }
    getColumnKey() {
        return this.filterModel.colId;
    }
    getColumnDisplayValue() {
        return this.advFilterExpSvc.getColumnDisplayValue(this.filterModel);
    }
    getOperatorKey() {
        return this.filterModel.type;
    }
    getOperatorDisplayValue() {
        return this.advFilterExpSvc.getOperatorDisplayValue(this.filterModel);
    }
    getOperandDisplayValue() {
        return this.advFilterExpSvc.getOperandDisplayValue(this.filterModel, true);
    }
    hasOperand() {
        return this.numOperands > 0;
    }
    getOperatorAutocompleteEntries() {
        return this.column
            ? this.advFilterExpSvc.getOperatorAutocompleteEntries(this.column, this.baseCellDataType)
            : [];
    }
    setColumnKey(colId) {
        if (!this.eOperatorPill) {
            this.createOperatorPill();
        }
        const newColumnDetails = this.advFilterExpSvc.getColumnDetails(colId);
        this.column = newColumnDetails.column;
        const newBaseCellDataType = newColumnDetails.baseCellDataType;
        if (this.baseCellDataType !== newBaseCellDataType) {
            this.baseCellDataType = newBaseCellDataType;
            this.setOperatorKey(undefined);
            if (this.eOperatorPill) {
                (0, ag_grid_community_1._removeFromParent)(this.eOperatorPill.getGui());
                this.destroyBean(this.eOperatorPill);
                this.createOperatorPill();
            }
            this.validate();
        }
        this.filterModel.colId = colId;
        this.filterModel.filterType = this.baseCellDataType;
    }
    setOperatorKey(operator) {
        const newNumOperands = this.getNumOperands(operator);
        if (newNumOperands !== this.numOperands) {
            this.numOperands = newNumOperands;
            if (newNumOperands === 0) {
                this.destroyOperandPill();
            }
            else {
                this.createOperandPill();
                if (this.baseCellDataType !== 'number') {
                    this.setOperand('');
                }
            }
        }
        this.filterModel.type = operator;
        this.validate();
    }
    setOperand(operand) {
        let parsedOperand = operand;
        // Number comes back as string from input, so convert. Dates are already in iso string format
        if (this.baseCellDataType === 'number') {
            parsedOperand = (0, ag_grid_community_1._exists)(operand) ? Number(operand) : '';
        }
        this.filterModel.filter = parsedOperand;
        this.validate();
    }
    getNumOperands(operator) {
        return this.advFilterExpSvc.getExpressionOperator(this.baseCellDataType, operator)?.numOperands ?? 0;
    }
    destroyOperandPill() {
        delete this.filterModel.filter;
        this.getGui().removeChild(this.eOperandPill.getGui());
        this.destroyBean(this.eOperandPill);
        this.eOperandPill = undefined;
    }
    validate() {
        let validationMessage = null;
        if (!(0, ag_grid_community_1._exists)(this.getColumnKey())) {
            validationMessage = this.advFilterExpSvc.translate('advancedFilterBuilderValidationSelectColumn');
        }
        else if (!(0, ag_grid_community_1._exists)(this.getOperatorKey())) {
            validationMessage = this.advFilterExpSvc.translate('advancedFilterBuilderValidationSelectOption');
        }
        else if (this.numOperands > 0 && !(0, ag_grid_community_1._exists)(this.getOperandDisplayValue())) {
            validationMessage = this.advFilterExpSvc.translate('advancedFilterBuilderValidationEnterValue');
        }
        this.item.valid = !validationMessage;
        if (validationMessage !== this.validationMessage) {
            this.validationMessage = validationMessage;
            this.dispatchLocalEvent({
                type: 'advancedFilterBuilderValidChanged',
            });
        }
    }
    getDefaultColumnDisplayValue() {
        return this.advFilterExpSvc.translate('advancedFilterBuilderSelectColumn');
    }
    getDefaultOptionSelectValue() {
        return this.advFilterExpSvc.translate('advancedFilterBuilderSelectOption');
    }
}
exports.ConditionPillWrapperComp = ConditionPillWrapperComp;


/***/ }),

/***/ 4042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputPillComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class InputPillComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.advFilterExpSvc = beans.advFilterExpSvc;
    }
    constructor(params) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-pill-wrapper" role="presentation">
                <div data-ref="ePill" class="ag-advanced-filter-builder-pill" role="button">
                    <span data-ref="eLabel" class="ag-advanced-filter-builder-pill-display"></span>
                </div>
            </div>
        `);
        this.params = params;
        this.ePill = ag_grid_community_1.RefPlaceholder;
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        const { value, valueFormatter } = params;
        this.value = value;
        this.displayValue = valueFormatter(value);
    }
    postConstruct() {
        const { cssClass, ariaLabel } = this.params;
        this.ePill.classList.add(cssClass);
        this.activateTabIndex([this.ePill]);
        this.eLabel.id = `${this.getCompId()}`;
        (0, ag_grid_community_1._setAriaDescribedBy)(this.ePill, this.eLabel.id);
        (0, ag_grid_community_1._setAriaLabel)(this.ePill, ariaLabel);
        this.renderValue();
        this.addManagedListeners(this.ePill, {
            click: (event) => {
                event.preventDefault();
                this.showEditor();
            },
            keydown: (event) => {
                switch (event.key) {
                    case ag_grid_community_1.KeyCode.ENTER:
                        event.preventDefault();
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        this.showEditor();
                        break;
                }
            },
        });
        this.addDestroyFunc(() => this.destroyBean(this.eEditor));
    }
    getFocusableElement() {
        return this.ePill;
    }
    showEditor() {
        if (this.eEditor) {
            return;
        }
        (0, ag_grid_community_1._setDisplayed)(this.ePill, false);
        this.eEditor = this.createEditorComp(this.params.type);
        this.eEditor.setValue(this.value);
        const eEditorGui = this.eEditor.getGui();
        this.eEditor.addManagedElementListeners(eEditorGui, {
            keydown: (event) => {
                switch (event.key) {
                    case ag_grid_community_1.KeyCode.ENTER:
                        event.preventDefault();
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        this.updateValue(true);
                        break;
                    case ag_grid_community_1.KeyCode.ESCAPE:
                        event.preventDefault();
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
                        this.hideEditor(true);
                        break;
                }
            },
            focusout: () => this.updateValue(false),
        });
        this.getGui().appendChild(eEditorGui);
        this.eEditor.getFocusableElement().focus();
    }
    createEditorComp(type) {
        let comp;
        switch (type) {
            case 'text':
                comp = new ag_grid_community_1.AgInputTextField();
                break;
            case 'number':
                comp = new ag_grid_community_1.AgInputNumberField();
                break;
            case 'date':
                comp = new ag_grid_community_1.AgInputDateField();
                break;
        }
        return this.createBean(comp);
    }
    hideEditor(keepFocus) {
        const { eEditor } = this;
        if (!eEditor) {
            return;
        }
        this.eEditor = undefined;
        this.getGui().removeChild(eEditor.getGui());
        this.destroyBean(eEditor);
        (0, ag_grid_community_1._setDisplayed)(this.ePill, true);
        if (keepFocus) {
            this.ePill.focus();
        }
    }
    renderValue() {
        let value;
        const { displayValue, eLabel } = this;
        const { classList } = eLabel;
        classList.remove('ag-advanced-filter-builder-value-empty', 'ag-advanced-filter-builder-value-number', 'ag-advanced-filter-builder-value-text');
        if (!(0, ag_grid_community_1._exists)(displayValue)) {
            value = this.advFilterExpSvc.translate('advancedFilterBuilderEnterValue');
            classList.add('ag-advanced-filter-builder-value-empty');
        }
        else if (this.params.type === 'number') {
            value = displayValue;
            classList.add('ag-advanced-filter-builder-value-number');
        }
        else {
            value = `"${displayValue}"`;
            classList.add('ag-advanced-filter-builder-value-text');
        }
        eLabel.innerText = value;
    }
    updateValue(keepFocus) {
        if (!this.eEditor) {
            return;
        }
        const value = this.eEditor.getValue() ?? '';
        this.dispatchLocalEvent({
            type: 'fieldValueChanged',
            value,
        });
        this.value = value;
        this.displayValue = this.params.valueFormatter(value);
        this.renderValue();
        this.hideEditor(keepFocus);
    }
}
exports.InputPillComp = InputPillComp;


/***/ }),

/***/ 1395:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JoinPillWrapperComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class JoinPillWrapperComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.advFilterExpSvc = beans.advFilterExpSvc;
    }
    constructor() {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `);
    }
    init(params) {
        const { item, createPill } = params;
        const filterModel = item.filterModel;
        this.filterModel = filterModel;
        this.ePill = createPill({
            key: filterModel.type,
            displayValue: this.advFilterExpSvc.parseJoinOperator(filterModel),
            cssClass: 'ag-advanced-filter-builder-join-pill',
            isSelect: true,
            getEditorParams: () => ({
                values: this.advFilterExpSvc.getJoinOperatorAutocompleteEntries(),
            }),
            update: (key) => (filterModel.type = key),
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderJoinSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Join Operator Select Field',
            ariaLabel: this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderJoinOperator'),
        });
        this.getGui().appendChild(this.ePill.getGui());
        this.addDestroyFunc(() => this.destroyBean(this.ePill));
    }
    getDragName() {
        return this.advFilterExpSvc.parseJoinOperator(this.filterModel);
    }
    getAriaLabel() {
        return `${this.advFilterExpSvc.translate('ariaAdvancedFilterBuilderGroupItem')} ${this.getDragName()}`;
    }
    getValidationMessage() {
        return null;
    }
    getFocusableElement() {
        return this.ePill.getFocusableElement();
    }
}
exports.JoinPillWrapperComp = JoinPillWrapperComp;


/***/ }),

/***/ 3036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectPillComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agRichSelect_1 = __webpack_require__(2005);
class SelectPillComp extends agRichSelect_1.AgRichSelect {
    constructor(params) {
        super({
            ...params,
            template: /* html */ `
                <div class="ag-picker-field ag-advanced-filter-builder-pill-wrapper" role="presentation">
                    <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-advanced-filter-builder-pill ag-picker-collapsed">
                        <div data-ref="eDisplayField" class="ag-picker-field-display ag-advanced-filter-builder-pill-display"></div>
                        <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                        <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>`,
            agComponents: [ag_grid_community_1.AgInputTextFieldSelector],
        });
        this.params = params;
    }
    getFocusableElement() {
        return this.eWrapper;
    }
    showPicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.showPicker());
    }
    hidePicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.hidePicker());
    }
    postConstruct() {
        super.postConstruct();
        const { wrapperClassName, ariaLabel } = this.params;
        this.eWrapper.classList.add(wrapperClassName);
        (0, ag_grid_community_1._setAriaLabelledBy)(this.eWrapper, '');
        (0, ag_grid_community_1._setAriaLabel)(this.eWrapper, ariaLabel);
    }
    createPickerComponent() {
        if (!this.values) {
            const { values } = this.params.getEditorParams();
            this.values = values;
            const key = this.value.key;
            const value = values.find((value) => value.key === key) ?? {
                key,
                displayValue: this.value.displayValue,
            };
            this.value = value;
        }
        return super.createPickerComponent();
    }
    onEnterKeyDown(event) {
        (0, ag_grid_community_1._stopPropagationForAgGrid)(event);
        if (this.isPickerDisplayed) {
            super.onEnterKeyDown(event);
        }
        else {
            event.preventDefault();
            this.showPicker();
        }
    }
}
exports.SelectPillComp = SelectPillComp;


/***/ }),

/***/ 9023:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColFilterExpressionParser = exports.COL_FILTER_EXPRESSION_END_CHAR = exports.COL_FILTER_EXPRESSION_START_CHAR = void 0;
const filterExpressionUtils_1 = __webpack_require__(6487);
class ColumnParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.type = 'column';
        this.valid = true;
        this.hasStartChar = false;
        this.hasEndChar = false;
        this.colName = '';
    }
    parse(char, position) {
        if (char === exports.COL_FILTER_EXPRESSION_START_CHAR && !this.colName) {
            this.hasStartChar = true;
        }
        else if (char === exports.COL_FILTER_EXPRESSION_END_CHAR && this.hasStartChar) {
            const isMatch = this.parseColumn(false, position);
            if (isMatch) {
                this.hasEndChar = true;
                return false;
            }
            else {
                this.colName += char;
            }
        }
        else {
            this.colName += char;
        }
        return undefined;
    }
    getDisplayValue() {
        return ((this.hasStartChar ? exports.COL_FILTER_EXPRESSION_START_CHAR : '') +
            this.colName +
            (this.hasEndChar ? exports.COL_FILTER_EXPRESSION_END_CHAR : ''));
    }
    getColId() {
        return this.colId;
    }
    complete(position) {
        this.parseColumn(true, position);
    }
    getValidationError() {
        return this.valid
            ? null
            : {
                message: this.params.advFilterExpSvc.translate('advancedFilterValidationInvalidColumn'),
                startPosition: this.startPosition,
                endPosition: this.endPosition ?? this.params.expression.length - 1,
            };
    }
    parseColumn(fromComplete, endPosition) {
        this.endPosition = endPosition;
        const colValue = this.params.advFilterExpSvc.getColId(this.colName);
        if (colValue && this.hasStartChar) {
            this.colId = colValue.colId;
            (0, filterExpressionUtils_1.checkAndUpdateExpression)(this.params, this.colName, colValue.columnName, endPosition - 1);
            this.colName = colValue.columnName;
            this.column = this.params.colModel.getColDefCol(this.colId);
            if (this.column) {
                this.baseCellDataType = this.params.dataTypeSvc?.getBaseDataType(this.column) ?? 'text';
                return true;
            }
        }
        if (fromComplete) {
            this.valid = false;
        }
        this.baseCellDataType = 'text';
        return false;
    }
}
class OperatorParser {
    constructor(params, startPosition, baseCellDataType) {
        this.params = params;
        this.startPosition = startPosition;
        this.baseCellDataType = baseCellDataType;
        this.type = 'operator';
        this.valid = true;
        this.expectedNumOperands = 0;
        this.operator = '';
    }
    parse(char, position) {
        if (char === ' ' || char === ')') {
            const isMatch = this.parseOperator(false, position - 1);
            if (isMatch) {
                return true;
            }
            else {
                this.operator += char;
            }
        }
        else {
            this.operator += char;
        }
        return undefined;
    }
    complete(position) {
        this.parseOperator(true, position);
    }
    getValidationError() {
        return this.valid
            ? null
            : {
                message: this.params.advFilterExpSvc.translate('advancedFilterValidationInvalidOption'),
                startPosition: this.startPosition,
                endPosition: this.endPosition ?? this.params.expression.length - 1,
            };
    }
    getDisplayValue() {
        return this.operator;
    }
    getOperatorKey() {
        return this.parsedOperator;
    }
    parseOperator(fromComplete, endPosition) {
        const operatorForType = this.params.advFilterExpSvc.getDataTypeExpressionOperator(this.baseCellDataType);
        const parsedOperator = operatorForType.findOperator(this.operator);
        this.endPosition = endPosition;
        if (parsedOperator) {
            this.parsedOperator = parsedOperator;
            const operator = operatorForType.operators[parsedOperator];
            this.expectedNumOperands = operator.numOperands;
            const operatorDisplayValue = operator.displayValue;
            (0, filterExpressionUtils_1.checkAndUpdateExpression)(this.params, this.operator, operatorDisplayValue, endPosition);
            this.operator = operatorDisplayValue;
            return true;
        }
        const isPartialMatch = parsedOperator === null;
        if (fromComplete || !isPartialMatch) {
            this.valid = false;
        }
        return false;
    }
}
class OperandParser {
    constructor(params, startPosition, baseCellDataType, column) {
        this.params = params;
        this.startPosition = startPosition;
        this.baseCellDataType = baseCellDataType;
        this.column = column;
        this.type = 'operand';
        this.valid = true;
        this.operand = '';
        this.validationMessage = null;
    }
    parse(char, position) {
        if (char === ' ') {
            if (this.quotes) {
                this.operand += char;
            }
            else {
                this.parseOperand(false, position);
                return true;
            }
        }
        else if (char === ')') {
            if (this.baseCellDataType === 'number' || !this.quotes) {
                this.parseOperand(false, position - 1);
                return true;
            }
            else {
                this.operand += char;
            }
        }
        else if (!this.operand && !this.quotes && (char === `'` || char === `"`)) {
            this.quotes = char;
        }
        else if (this.quotes && char === this.quotes) {
            this.parseOperand(false, position);
            return false;
        }
        else {
            this.operand += char;
        }
        return undefined;
    }
    complete(position) {
        this.parseOperand(true, position);
    }
    getValidationError() {
        return this.validationMessage
            ? {
                message: this.validationMessage,
                startPosition: this.startPosition,
                endPosition: this.endPosition ?? this.params.expression.length - 1,
            }
            : null;
    }
    getRawValue() {
        return this.operand;
    }
    getModelValue() {
        return this.modelValue;
    }
    parseOperand(fromComplete, position) {
        const { advFilterExpSvc } = this.params;
        this.endPosition = position;
        this.modelValue = this.operand;
        if (fromComplete && this.quotes) {
            // missing end quote
            this.valid = false;
            this.validationMessage = advFilterExpSvc.translate('advancedFilterValidationMissingQuote');
        }
        else if (this.modelValue === '') {
            this.valid = false;
            this.validationMessage = advFilterExpSvc.translate('advancedFilterValidationMissingValue');
        }
        else {
            const modelValue = advFilterExpSvc.getOperandModelValue(this.operand, this.baseCellDataType, this.column);
            if (modelValue != null) {
                this.modelValue = modelValue;
            }
            switch (this.baseCellDataType) {
                case 'number':
                    if (this.quotes || isNaN(this.modelValue)) {
                        this.valid = false;
                        this.validationMessage = advFilterExpSvc.translate('advancedFilterValidationNotANumber');
                    }
                    break;
                case 'date':
                case 'dateString':
                    if (modelValue == null) {
                        this.valid = false;
                        this.validationMessage = advFilterExpSvc.translate('advancedFilterValidationInvalidDate');
                    }
                    break;
            }
        }
    }
}
exports.COL_FILTER_EXPRESSION_START_CHAR = '[';
exports.COL_FILTER_EXPRESSION_END_CHAR = ']';
class ColFilterExpressionParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.isAwaiting = true;
    }
    parseExpression() {
        let i = this.startPosition;
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === ' ' && this.isAwaiting) {
                // ignore duplicate spaces
            }
            else {
                this.isAwaiting = false;
                if (!this.parser) {
                    let parser;
                    if (!this.columnParser) {
                        this.columnParser = new ColumnParser(this.params, i);
                        parser = this.columnParser;
                    }
                    else if (!this.operatorParser) {
                        this.operatorParser = new OperatorParser(this.params, i, this.columnParser.baseCellDataType);
                        parser = this.operatorParser;
                    }
                    else {
                        this.operandParser = new OperandParser(this.params, i, this.columnParser.baseCellDataType, this.columnParser.column);
                        parser = this.operandParser;
                    }
                    this.parser = parser;
                }
                const hasCompletedOnPrevChar = this.parser.parse(char, i);
                if (hasCompletedOnPrevChar != null) {
                    if (this.isComplete()) {
                        return this.returnEndPosition(hasCompletedOnPrevChar ? i - 1 : i, true);
                    }
                    this.parser = undefined;
                    this.isAwaiting = true;
                }
            }
            i++;
        }
        this.parser?.complete?.(i - 1);
        return this.returnEndPosition(i);
    }
    isValid() {
        return (this.isComplete() &&
            this.columnParser.valid &&
            this.operatorParser.valid &&
            (!this.operandParser || this.operandParser.valid));
    }
    getValidationError() {
        const validationError = this.columnParser?.getValidationError() ??
            this.operatorParser?.getValidationError() ??
            this.operandParser?.getValidationError();
        if (validationError) {
            return validationError;
        }
        const endPosition = this.params.expression.length;
        let translateKey;
        if (!this.columnParser) {
            translateKey = 'advancedFilterValidationMissingColumn';
        }
        else if (!this.operatorParser) {
            translateKey = 'advancedFilterValidationMissingOption';
        }
        else if (this.operatorParser.expectedNumOperands && !this.operandParser) {
            translateKey = 'advancedFilterValidationMissingValue';
        }
        if (translateKey) {
            return {
                message: this.params.advFilterExpSvc.translate(translateKey),
                startPosition: endPosition,
                endPosition,
            };
        }
        return null;
    }
    getFunctionString(params) {
        return this.getFunctionCommon(params, (operandIndex, operatorIndex, colId, evaluatorParamsIndex) => {
            const escapedColId = (0, filterExpressionUtils_1.escapeQuotes)(colId);
            const operand = operandIndex == null ? '' : `, params.operands[${operandIndex}]`;
            return `params.operators[${operatorIndex}].evaluator(expressionProxy.getValue('${escapedColId}', node), node, params.evaluatorParams[${evaluatorParamsIndex}]${operand})`;
        });
    }
    getFunctionParsed(params) {
        return this.getFunctionCommon(params, (operandIndex, operatorIndex, colId, evaluatorParamsIndex) => {
            return (expressionProxy, node, p) => p.operators[operatorIndex].evaluator(expressionProxy.getValue(colId, node), node, p.evaluatorParams[evaluatorParamsIndex], operandIndex == null ? undefined : p.operands[operandIndex]);
        });
    }
    getAutocompleteListParams(position) {
        if (this.isColumnPosition(position)) {
            return this.getColumnAutocompleteListParams(position);
        }
        if (this.isOperatorPosition(position)) {
            return this.getOperatorAutocompleteListParams(position);
        }
        if (this.isBeyondEndPosition(position)) {
            return undefined;
        }
        return { enabled: false };
    }
    updateExpression(position, updateEntry, type) {
        const { expression } = this.params;
        if (this.isColumnPosition(position)) {
            return (0, filterExpressionUtils_1.updateExpression)(this.params.expression, this.startPosition, this.columnParser?.getColId()
                ? this.columnParser.endPosition
                : (0, filterExpressionUtils_1.findEndPosition)(expression, position).endPosition, this.params.advFilterExpSvc.getColumnValue(updateEntry), true);
        }
        else if (this.isOperatorPosition(position)) {
            const baseCellDataType = this.getBaseCellDataTypeFromOperatorAutocompleteType(type);
            const hasOperand = this.hasOperand(baseCellDataType, updateEntry.key);
            const doesOperandNeedQuotes = hasOperand && this.doesOperandNeedQuotes(baseCellDataType);
            let update;
            if (this.operatorParser?.startPosition != null && position < this.operatorParser.startPosition) {
                // in between multiple spaces, just insert direct
                update = (0, filterExpressionUtils_1.updateExpression)(expression, position, position, updateEntry.displayValue ?? updateEntry.key, hasOperand, doesOperandNeedQuotes);
            }
            else {
                let endPosition;
                let empty = false;
                if (this.operatorParser?.getOperatorKey()) {
                    endPosition = this.operatorParser.endPosition;
                }
                else {
                    const { endPosition: calculatedEndPosition, isEmpty } = (0, filterExpressionUtils_1.findEndPosition)(expression, position, true, true);
                    endPosition = calculatedEndPosition;
                    empty = isEmpty;
                }
                update = (0, filterExpressionUtils_1.updateExpression)(expression, (0, filterExpressionUtils_1.findStartPosition)(expression, this.columnParser.endPosition + 1, endPosition), endPosition, updateEntry.displayValue ?? updateEntry.key, hasOperand, doesOperandNeedQuotes, empty);
            }
            return { ...update, hideAutocomplete: !hasOperand };
        }
        return null;
    }
    getModel() {
        const colId = this.columnParser.getColId();
        const model = {
            filterType: this.columnParser.baseCellDataType,
            colId,
            type: this.operatorParser.getOperatorKey(),
        };
        if (this.operatorParser.expectedNumOperands) {
            model.filter = this.operandParser.getModelValue();
        }
        return model;
    }
    getFunctionCommon(params, processFunc) {
        const colId = this.columnParser.getColId();
        const operator = this.operatorParser?.getOperatorKey();
        const { operators, evaluatorParams, operands } = params;
        const operatorForColumn = this.params.advFilterExpSvc.getExpressionOperator(this.columnParser.baseCellDataType, operator);
        const operatorIndex = this.addToListAndGetIndex(operators, operatorForColumn);
        const evaluatorParamsForColumn = this.params.advFilterExpSvc.getExpressionEvaluatorParams(colId);
        const evaluatorParamsIndex = this.addToListAndGetIndex(evaluatorParams, evaluatorParamsForColumn);
        const operandIndex = this.operatorParser?.expectedNumOperands === 0
            ? undefined
            : this.addToListAndGetIndex(operands, this.getOperandValue());
        return processFunc(operandIndex, operatorIndex, colId, evaluatorParamsIndex);
    }
    getOperandValue() {
        let operand = this.operandParser.getRawValue();
        const { baseCellDataType, column } = this.columnParser;
        switch (baseCellDataType) {
            case 'number':
                operand = Number(operand);
                break;
            case 'date':
            case 'dateString':
                operand = this.params.valueSvc.parseValue(column, null, operand, undefined);
                break;
        }
        if (baseCellDataType === 'dateString') {
            const { dataTypeSvc } = this.params;
            return dataTypeSvc ? dataTypeSvc.getDateParserFunction(column)(operand) : operand;
        }
        return operand;
    }
    isComplete() {
        return !!(this.operatorParser &&
            (!this.operatorParser.expectedNumOperands ||
                (this.operatorParser.expectedNumOperands && this.operandParser)));
    }
    isColumnPosition(position) {
        return (!this.columnParser || this.columnParser.endPosition == null || position <= this.columnParser.endPosition + 1);
    }
    isOperatorPosition(position) {
        return (!this.operatorParser ||
            this.operatorParser.endPosition == null ||
            position <= this.operatorParser.endPosition + 1);
    }
    isBeyondEndPosition(position) {
        return (this.isComplete() &&
            this.endPosition != null &&
            position > this.endPosition + 1 &&
            this.endPosition + 1 < this.params.expression.length);
    }
    returnEndPosition(returnPosition, treatAsEnd) {
        this.endPosition = treatAsEnd ? returnPosition : returnPosition - 1;
        return returnPosition;
    }
    getColumnAutocompleteListParams(position) {
        return this.params.advFilterExpSvc.generateAutocompleteListParams(this.params.advFilterExpSvc.getColumnAutocompleteEntries(), 'column', this.getColumnSearchString(position));
    }
    getColumnSearchString(position) {
        const columnName = this.columnParser?.getDisplayValue() ?? '';
        const searchString = (0, filterExpressionUtils_1.getSearchString)(columnName, position, this.columnParser?.endPosition == null ? this.params.expression.length : this.columnParser.endPosition + 1);
        const containsStartChar = this.columnParser?.hasStartChar && searchString.length > 0;
        const containsEndChar = this.columnParser?.hasEndChar && searchString.length === columnName.length + 2;
        if (containsStartChar) {
            return searchString.slice(1, containsEndChar ? -1 : undefined);
        }
        return searchString;
    }
    getOperatorAutocompleteListParams(position) {
        const column = this.columnParser?.column;
        if (!column) {
            return { enabled: false };
        }
        const baseCellDataType = this.columnParser.baseCellDataType;
        const searchString = this.operatorParser?.startPosition != null && position < this.operatorParser.startPosition
            ? ''
            : (0, filterExpressionUtils_1.getSearchString)(this.operatorParser?.getDisplayValue() ?? '', position, this.operatorParser?.endPosition == null
                ? this.params.expression.length
                : this.operatorParser.endPosition + 1);
        return this.params.advFilterExpSvc.generateAutocompleteListParams(this.params.advFilterExpSvc.getOperatorAutocompleteEntries(column, baseCellDataType), `operator-${baseCellDataType}`, searchString);
    }
    getBaseCellDataTypeFromOperatorAutocompleteType(type) {
        return type?.replace('operator-', '');
    }
    hasOperand(baseCellDataType, operator) {
        return (!baseCellDataType ||
            !operator ||
            (this.params.advFilterExpSvc.getExpressionOperator(baseCellDataType, operator)?.numOperands ?? 0) > 0);
    }
    doesOperandNeedQuotes(baseCellDataType) {
        return baseCellDataType !== 'number';
    }
    addToListAndGetIndex(list, value) {
        const index = list.length;
        list.push(value);
        return index;
    }
}
exports.ColFilterExpressionParser = ColFilterExpressionParser;


/***/ }),

/***/ 9459:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BooleanFilterExpressionOperators = exports.ScalarFilterExpressionOperators = exports.TextFilterExpressionOperators = exports.findMatch = void 0;
// null = partial match, undefined = no match
function findMatch(searchValue, values, getDisplayValue) {
    let partialMatch = false;
    const searchValueLowerCase = searchValue.toLocaleLowerCase();
    const partialSearchValue = searchValueLowerCase + ' ';
    const parsedValue = Object.entries(values).find(([, value]) => {
        const displayValueLowerCase = getDisplayValue(value).toLocaleLowerCase();
        if (displayValueLowerCase.startsWith(partialSearchValue)) {
            partialMatch = true;
        }
        return displayValueLowerCase === searchValueLowerCase;
    });
    if (parsedValue) {
        return parsedValue[0];
    }
    else if (partialMatch) {
        return null;
    }
    else {
        return undefined;
    }
}
exports.findMatch = findMatch;
function getEntries(operators, activeOperatorKeys) {
    const keys = activeOperatorKeys ?? Object.keys(operators);
    return keys.map((key) => ({
        key,
        displayValue: operators[key].displayValue,
    }));
}
class TextFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate } = this.params;
        this.operators = {
            contains: {
                displayValue: translate('advancedFilterContains'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.includes(o)),
                numOperands: 1,
            },
            notContains: {
                displayValue: translate('advancedFilterNotContains'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, true, (v, o) => !v.includes(o)),
                numOperands: 1,
            },
            equals: {
                displayValue: translate('advancedFilterTextEquals'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v === o),
                numOperands: 1,
            },
            notEqual: {
                displayValue: translate('advancedFilterTextNotEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, true, (v, o) => v != o),
                numOperands: 1,
            },
            startsWith: {
                displayValue: translate('advancedFilterStartsWith'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.startsWith(o)),
                numOperands: 1,
            },
            endsWith: {
                displayValue: translate('advancedFilterEndsWith'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.endsWith(o)),
                numOperands: 1,
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null || (typeof value === 'string' && value.trim().length === 0),
                numOperands: 0,
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null && (typeof value !== 'string' || value.trim().length > 0),
                numOperands: 0,
            },
        };
    }
    evaluateExpression(value, node, params, operand, nullsMatch, expression) {
        if (value == null) {
            return nullsMatch;
        }
        return params.caseSensitive
            ? expression(params.valueConverter(value, node), operand)
            : expression(params.valueConverter(value, node).toLocaleLowerCase(), operand.toLocaleLowerCase());
    }
}
exports.TextFilterExpressionOperators = TextFilterExpressionOperators;
class ScalarFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate, equals } = this.params;
        this.operators = {
            equals: {
                displayValue: translate('advancedFilterEquals'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInEquals, equals),
                numOperands: 1,
            },
            notEqual: {
                displayValue: translate('advancedFilterNotEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInEquals, (v, o) => !equals(v, o)),
                numOperands: 1,
            },
            greaterThan: {
                displayValue: translate('advancedFilterGreaterThan'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInGreaterThan, (v, o) => v > o),
                numOperands: 1,
            },
            greaterThanOrEqual: {
                displayValue: translate('advancedFilterGreaterThanOrEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInGreaterThan, (v, o) => v >= o),
                numOperands: 1,
            },
            lessThan: {
                displayValue: translate('advancedFilterLessThan'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInLessThan, (v, o) => v < o),
                numOperands: 1,
            },
            lessThanOrEqual: {
                displayValue: translate('advancedFilterLessThanOrEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInLessThan, (v, o) => v <= o),
                numOperands: 1,
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null,
                numOperands: 0,
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null,
                numOperands: 0,
            },
        };
    }
    evaluateSingleOperandExpression(value, node, params, operand, nullsMatch, expression) {
        if (value == null) {
            return nullsMatch;
        }
        return expression(params.valueConverter(value, node), operand);
    }
}
exports.ScalarFilterExpressionOperators = ScalarFilterExpressionOperators;
class BooleanFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate } = this.params;
        this.operators = {
            true: {
                displayValue: translate('advancedFilterTrue'),
                evaluator: (value) => !!value,
                numOperands: 0,
            },
            false: {
                displayValue: translate('advancedFilterFalse'),
                evaluator: (value) => value === false,
                numOperands: 0,
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null,
                numOperands: 0,
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null,
                numOperands: 0,
            },
        };
    }
}
exports.BooleanFilterExpressionOperators = BooleanFilterExpressionOperators;


/***/ }),

/***/ 4899:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterExpressionParser = void 0;
const joinFilterExpressionParser_1 = __webpack_require__(9471);
class FilterExpressionParser {
    constructor(params) {
        this.params = params;
        this.valid = false;
    }
    parseExpression() {
        this.joinExpressionParser = new joinFilterExpressionParser_1.JoinFilterExpressionParser(this.params, 0);
        const i = this.joinExpressionParser.parseExpression();
        this.valid = i >= this.params.expression.length - 1 && this.joinExpressionParser.isValid();
        return this.params.expression;
    }
    isValid() {
        return this.valid;
    }
    getValidationMessage() {
        const error = this.joinExpressionParser.getValidationError();
        if (!error) {
            return null;
        }
        const { message, startPosition, endPosition } = error;
        return startPosition < this.params.expression.length
            ? this.params.advFilterExpSvc.translate('advancedFilterValidationMessage', [
                message,
                this.params.expression.slice(startPosition, endPosition + 1).trim(),
            ])
            : this.params.advFilterExpSvc.translate('advancedFilterValidationMessageAtEnd', [message]);
    }
    getFunctionString() {
        const params = this.createFunctionParams();
        return {
            functionString: `return ${this.joinExpressionParser.getFunctionString(params)};`,
            params,
        };
    }
    getFunctionParsed() {
        const params = this.createFunctionParams();
        return {
            expressionFunction: this.joinExpressionParser.getFunctionParsed(params),
            params,
        };
    }
    getAutocompleteListParams(position) {
        return this.joinExpressionParser.getAutocompleteListParams(position) ?? { enabled: false };
    }
    updateExpression(position, updateEntry, type) {
        return this.joinExpressionParser.updateExpression(position, updateEntry, type);
    }
    getModel() {
        return this.isValid() ? this.joinExpressionParser.getModel() : null;
    }
    createFunctionParams() {
        return {
            operands: [],
            operators: [],
            evaluatorParams: [],
        };
    }
}
exports.FilterExpressionParser = FilterExpressionParser;


/***/ }),

/***/ 6487:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeQuotes = exports.checkAndUpdateExpression = exports.findEndPosition = exports.findStartPosition = exports.updateExpression = exports.getSearchString = void 0;
function getSearchString(value, position, endPosition) {
    if (!value) {
        return '';
    }
    const numChars = endPosition - position;
    return numChars ? value.slice(0, value.length - numChars) : value;
}
exports.getSearchString = getSearchString;
function updateExpression(expression, startPosition, endPosition, updatedValuePart, appendSpace, appendQuote, empty) {
    const secondPartStartPosition = endPosition + (!expression.length || empty ? 0 : 1);
    let positionOffset = 0;
    if (appendSpace) {
        if (expression[secondPartStartPosition] === ' ') {
            // already a space, just move the position
            positionOffset = 1;
        }
        else {
            updatedValuePart += ' ';
            if (appendQuote) {
                updatedValuePart += `"`;
            }
        }
    }
    const updatedValue = expression.slice(0, startPosition) + updatedValuePart + expression.slice(secondPartStartPosition);
    return { updatedValue, updatedPosition: startPosition + updatedValuePart.length + positionOffset };
}
exports.updateExpression = updateExpression;
function findStartPosition(expression, position, endPosition) {
    let startPosition = position;
    while (startPosition < endPosition) {
        const char = expression[startPosition];
        if (char !== ' ') {
            break;
        }
        startPosition++;
    }
    return startPosition;
}
exports.findStartPosition = findStartPosition;
function findEndPosition(expression, position, includeCloseBracket, isStartPositionUnknown) {
    let endPosition = position;
    let isEmpty = false;
    while (endPosition < expression.length) {
        const char = expression[endPosition];
        if (char === '(') {
            if (isStartPositionUnknown && expression[endPosition - 1] === ' ') {
                isEmpty = true;
            }
            else {
                endPosition = endPosition - 1;
            }
            break;
        }
        else if (char === ' ' || (includeCloseBracket && char === ')')) {
            endPosition = endPosition - 1;
            break;
        }
        endPosition++;
    }
    return { endPosition, isEmpty };
}
exports.findEndPosition = findEndPosition;
function checkAndUpdateExpression(params, userValue, displayValue, endPosition) {
    if (displayValue !== userValue) {
        params.expression = updateExpression(params.expression, endPosition - userValue.length + 1, endPosition, displayValue).updatedValue;
    }
}
exports.checkAndUpdateExpression = checkAndUpdateExpression;
function escapeQuotes(value) {
    return value.replace(/(['"])/, '\\$1');
}
exports.escapeQuotes = escapeQuotes;


/***/ }),

/***/ 9471:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JoinFilterExpressionParser = void 0;
const colFilterExpressionParser_1 = __webpack_require__(9023);
const filterExpressionOperators_1 = __webpack_require__(9459);
const filterExpressionUtils_1 = __webpack_require__(6487);
class OperatorParser {
    constructor(params) {
        this.params = params;
        this.operators = [];
        this.operatorStartPositions = [];
        this.operatorEndPositions = [];
        this.activeOperator = 0;
        this.validationError = null;
    }
    parseExpression(i) {
        this.operators.push('');
        this.operatorStartPositions.push(i);
        this.operatorEndPositions.push(undefined);
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === ' ') {
                const isComplete = this.parseOperator(i - 1);
                if (isComplete) {
                    this.activeOperator++;
                    return i - 1;
                }
                else {
                    this.operators[this.activeOperator] += char;
                }
            }
            else {
                this.operators[this.activeOperator] += char;
            }
            i++;
        }
        this.parseOperator(i - 1);
        return i;
    }
    isValid() {
        return !this.validationError && (!this.operators.length || !!this.parsedOperator);
    }
    getValidationError() {
        return this.validationError;
    }
    getFunction() {
        return this.parsedOperator === 'OR' ? '||' : '&&';
    }
    getModel() {
        return this.parsedOperator === 'OR' ? 'OR' : 'AND';
    }
    getAutocompleteListParams(position, operatorIndex) {
        let searchString;
        if (operatorIndex == null) {
            searchString = '';
        }
        else {
            const operator = this.operators[operatorIndex];
            const operatorEndPosition = this.operatorEndPositions[operatorIndex];
            searchString = (0, filterExpressionUtils_1.getSearchString)(operator, position, operatorEndPosition == null ? this.params.expression.length : operatorEndPosition + 1);
        }
        let entries = this.params.advFilterExpSvc.getJoinOperatorAutocompleteEntries();
        if (operatorIndex || (operatorIndex == null && this.activeOperator)) {
            // if operator already chosen, don't allow other operators
            entries = entries.filter(({ key }) => key === this.parsedOperator);
        }
        return this.params.advFilterExpSvc.generateAutocompleteListParams(entries, 'join', searchString);
    }
    updateExpression(position, updateEntry, operatorIndex) {
        let { expression } = this.params;
        const updatedValuePart = updateEntry.displayValue ?? updateEntry.key;
        if (operatorIndex === 0) {
            // need to update all others
            for (let i = this.operatorEndPositions.length - 1; i > 0; i--) {
                const operatorEndPosition = this.operatorEndPositions[i];
                if (operatorEndPosition == null) {
                    continue;
                }
                expression = (0, filterExpressionUtils_1.updateExpression)(expression, this.operatorStartPositions[i], operatorEndPosition, updatedValuePart).updatedValue;
            }
        }
        // if we don't have a start position, haven't typed anything yet, so use current position
        const startPosition = this.operatorStartPositions.length > operatorIndex ? this.operatorStartPositions[operatorIndex] : position;
        const endPosition = (this.operatorEndPositions.length > operatorIndex ? this.operatorEndPositions[operatorIndex] : undefined) ??
            (0, filterExpressionUtils_1.findEndPosition)(expression, position, true).endPosition;
        return (0, filterExpressionUtils_1.updateExpression)(expression, startPosition, endPosition, updatedValuePart, true);
    }
    getNumOperators() {
        return this.operators.length;
    }
    getLastOperatorEndPosition() {
        return this.operatorEndPositions[this.operatorEndPositions.length - 1];
    }
    parseOperator(endPosition) {
        const operator = this.operators.length > this.activeOperator ? this.operators[this.activeOperator] : '';
        const joinOperators = this.params.advFilterExpSvc.getExpressionJoinOperators();
        const parsedValue = (0, filterExpressionOperators_1.findMatch)(operator, joinOperators, (v) => v);
        if (parsedValue) {
            // exact match
            this.operatorEndPositions[this.activeOperator] = endPosition;
            const displayValue = joinOperators[parsedValue];
            if (this.activeOperator) {
                if (parsedValue !== this.parsedOperator) {
                    if (!this.validationError) {
                        this.validationError = {
                            message: this.params.advFilterExpSvc.translate('advancedFilterValidationJoinOperatorMismatch'),
                            startPosition: endPosition - operator.length + 1,
                            endPosition,
                        };
                    }
                    return false;
                }
            }
            else {
                this.parsedOperator = parsedValue;
            }
            if (operator !== displayValue) {
                (0, filterExpressionUtils_1.checkAndUpdateExpression)(this.params, operator, displayValue, endPosition);
                this.operators[this.activeOperator] = displayValue;
            }
            return true;
        }
        else if (parsedValue === null) {
            // partial match
            return false;
        }
        else {
            // no match
            if (!this.validationError) {
                this.validationError = {
                    message: this.params.advFilterExpSvc.translate('advancedFilterValidationInvalidJoinOperator'),
                    startPosition: endPosition - operator.length + 1,
                    endPosition,
                };
            }
            return true;
        }
    }
}
class JoinFilterExpressionParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.expectingExpression = true;
        this.expectingOperator = false;
        this.expressionParsers = [];
        this.operatorParser = new OperatorParser(this.params);
        this.missingEndBracket = false;
        this.extraEndBracket = false;
    }
    parseExpression() {
        let i = this.startPosition;
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === '(' && !this.expectingOperator) {
                const nestedParser = new JoinFilterExpressionParser(this.params, i + 1);
                i = nestedParser.parseExpression();
                this.expressionParsers.push(nestedParser);
                this.expectingExpression = false;
                this.expectingOperator = true;
            }
            else if (char === ')') {
                this.endPosition = i - 1;
                if (this.startPosition === 0) {
                    this.extraEndBracket = true;
                }
                return i;
            }
            else if (char === ' ') {
                // ignore extra whitespace
            }
            else if (this.expectingExpression) {
                const nestedParser = new colFilterExpressionParser_1.ColFilterExpressionParser(this.params, i);
                i = nestedParser.parseExpression();
                this.expressionParsers.push(nestedParser);
                this.expectingExpression = false;
                this.expectingOperator = true;
            }
            else if (this.expectingOperator) {
                i = this.operatorParser.parseExpression(i);
                this.expectingOperator = false;
                this.expectingExpression = true;
            }
            i++;
        }
        if (this.startPosition > 0) {
            this.missingEndBracket = true;
        }
        return i;
    }
    isValid() {
        return (!this.missingEndBracket &&
            !this.extraEndBracket &&
            this.expressionParsers.length === this.operatorParser.getNumOperators() + 1 &&
            this.operatorParser.isValid() &&
            this.expressionParsers.every((expressionParser) => expressionParser.isValid()));
    }
    getValidationError() {
        const operatorError = this.operatorParser.getValidationError();
        for (let i = 0; i < this.expressionParsers.length; i++) {
            const expressionError = this.expressionParsers[i].getValidationError();
            if (expressionError) {
                return operatorError && operatorError.startPosition < expressionError.startPosition
                    ? operatorError
                    : expressionError;
            }
        }
        if (operatorError) {
            return operatorError;
        }
        if (this.extraEndBracket) {
            return {
                message: this.params.advFilterExpSvc.translate('advancedFilterValidationExtraEndBracket'),
                startPosition: this.endPosition + 1,
                endPosition: this.endPosition + 1,
            };
        }
        let translateKey;
        if (this.expressionParsers.length === this.operatorParser.getNumOperators()) {
            translateKey = 'advancedFilterValidationMissingCondition';
        }
        else if (this.missingEndBracket) {
            translateKey = 'advancedFilterValidationMissingEndBracket';
        }
        if (translateKey) {
            return {
                message: this.params.advFilterExpSvc.translate(translateKey),
                startPosition: this.params.expression.length,
                endPosition: this.params.expression.length,
            };
        }
        return null;
    }
    getFunctionString(params) {
        const hasMultipleExpressions = this.expressionParsers.length > 1;
        const expression = this.expressionParsers
            .map((expressionParser) => expressionParser.getFunctionString(params))
            .join(` ${this.operatorParser.getFunction()} `);
        return hasMultipleExpressions ? `(${expression})` : expression;
    }
    getFunctionParsed(params) {
        const operator = this.operatorParser.getFunction();
        const funcs = this.expressionParsers.map((expressionParser) => expressionParser.getFunctionParsed(params));
        const arrayFunc = operator === '&&' ? 'every' : 'some';
        return (expressionProxy, node, p) => funcs[arrayFunc]((func) => func(expressionProxy, node, p));
    }
    getAutocompleteListParams(position) {
        if (this.endPosition != null && position > this.endPosition + 1) {
            return undefined;
        }
        if (!this.expressionParsers.length) {
            return this.getColumnAutocompleteListParams();
        }
        const expressionParserIndex = this.getExpressionParserIndex(position);
        if (expressionParserIndex == null) {
            if (this.params.expression[position] === '(') {
                return { enabled: false };
            }
            // positioned before the expression, so new expression
            return this.getColumnAutocompleteListParams();
        }
        const expressionParser = this.expressionParsers[expressionParserIndex];
        const autocompleteType = expressionParser.getAutocompleteListParams(position);
        if (!autocompleteType) {
            // beyond the end of the expression
            if (expressionParserIndex < this.expressionParsers.length - 1) {
                // in the middle of two expressions
                return this.operatorParser.getAutocompleteListParams(position, expressionParserIndex);
            }
            if (this.expressionParsers.length === this.operatorParser.getNumOperators()) {
                const operatorEndPosition = this.operatorParser.getLastOperatorEndPosition();
                return operatorEndPosition == null || position <= operatorEndPosition + 1
                    ? this.operatorParser.getAutocompleteListParams(position, this.operatorParser.getNumOperators() - 1)
                    : this.getColumnAutocompleteListParams();
            }
            if (this.params.expression[position - 1] === ')') {
                return { enabled: false };
            }
            return this.operatorParser.getAutocompleteListParams(position);
        }
        return autocompleteType;
    }
    updateExpression(position, updateEntry, type) {
        const expression = this.params.expression;
        const expressionParserIndex = this.getExpressionParserIndex(position);
        if (expressionParserIndex == null) {
            // positioned before the expression
            const updatedValuePart = type === 'column'
                ? this.params.advFilterExpSvc.getColumnValue(updateEntry)
                : updateEntry.displayValue ?? updateEntry.key;
            return (0, filterExpressionUtils_1.updateExpression)(expression, this.startPosition, this.startPosition, updatedValuePart, true);
        }
        const expressionParser = this.expressionParsers[expressionParserIndex];
        const updatedExpression = expressionParser.updateExpression(position, updateEntry, type);
        if (updatedExpression == null) {
            if (type === 'column') {
                // beyond the end of the expression, just do simple update
                return (0, filterExpressionUtils_1.updateExpression)(expression, position, expression.length - 1, this.params.advFilterExpSvc.getColumnValue(updateEntry), true);
            }
            else if (this.endPosition != null && position > this.endPosition + 1) {
                return null;
            }
            else {
                return this.operatorParser.updateExpression(position, updateEntry, expressionParserIndex);
            }
        }
        return updatedExpression;
    }
    getModel() {
        if (this.expressionParsers.length > 1) {
            return {
                filterType: 'join',
                type: this.operatorParser.getModel(),
                conditions: this.expressionParsers.map((parser) => parser.getModel()),
            };
        }
        else {
            return this.expressionParsers[0].getModel();
        }
    }
    getColumnAutocompleteListParams() {
        return this.params.advFilterExpSvc.generateAutocompleteListParams(this.params.advFilterExpSvc.getColumnAutocompleteEntries(), 'column', '');
    }
    getExpressionParserIndex(position) {
        let expressionParserIndex;
        for (let i = 0; i < this.expressionParsers.length; i++) {
            const expressionParserToCheck = this.expressionParsers[i];
            if (expressionParserToCheck.startPosition > position) {
                break;
            }
            expressionParserIndex = i;
        }
        return expressionParserIndex;
    }
}
exports.JoinFilterExpressionParser = JoinFilterExpressionParser;


/***/ }),

/***/ 9206:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnterpriseCoreModule = exports.AgWatermark = void 0;
const gridLicenseManager_1 = __webpack_require__(3159);
const version_1 = __webpack_require__(7205);
var watermark_1 = __webpack_require__(3879);
Object.defineProperty(exports, "AgWatermark", ({ enumerable: true, get: function () { return watermark_1.AgWatermark; } }));
/**
 * @internal
 */
exports.EnterpriseCoreModule = {
    moduleName: 'EnterpriseCore',
    version: version_1.VERSION,
    beans: [gridLicenseManager_1.GridLicenseManager],
    icons: {
        // accordion open (filter tool panel group, charts group)
        accordionOpen: 'tree-open',
        // accordion closed (filter tool panel group, charts group)
        accordionClosed: 'tree-closed',
        // accordion indeterminate - shown when some children are expanded and
        //     others are collapsed (filter tool panel group, charts group)
        accordionIndeterminate: 'tree-indeterminate',
        // dialog title bar
        close: 'cross',
        // X (remove) on column 'pill' after adding it to a drop zone list
        cancel: 'cancel',
        // button in chart regular size window title bar (click to maximise)
        maximize: 'maximize',
        // button in chart maximised window title bar (click to make regular size)
        minimize: 'minimize',
        // drag handle used to pick up draggable columns
        columnDrag: 'grip',
    },
    dependsOn: [],
};


/***/ }),

/***/ 2529:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggColumnNameService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AggColumnNameService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'aggColNameSvc';
    }
    getHeaderName(column, headerName) {
        if (this.gos.get('suppressAggFuncInHeader')) {
            return headerName;
        }
        const { valueColsSvc, colModel, rowGroupColsSvc } = this.beans;
        // only columns with aggregation active can have aggregations
        const pivotValueColumn = column.getColDef().pivotValueColumn;
        const pivotActiveOnThisColumn = (0, ag_grid_community_1._exists)(pivotValueColumn);
        let aggFunc = null;
        let aggFuncFound;
        // otherwise we have a measure that is active, and we are doing aggregation on it
        if (pivotActiveOnThisColumn) {
            const valueColumns = valueColsSvc?.columns ?? [];
            const isCollapsedHeaderEnabled = this.gos.get('removePivotHeaderRowWhenSingleValueColumn') && valueColumns.length === 1;
            const isTotalColumn = column.getColDef().pivotTotalColumnIds !== undefined;
            if (isCollapsedHeaderEnabled && !isTotalColumn) {
                return headerName; // Skip decorating the header - in this case the label is the pivot key, not the value col
            }
            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;
            aggFuncFound = true;
        }
        else {
            const measureActive = column.isValueActive();
            const aggregationPresent = colModel.isPivotMode() || rowGroupColsSvc?.columns.length !== 0;
            if (measureActive && aggregationPresent) {
                aggFunc = column.getAggFunc();
                aggFuncFound = true;
            }
            else {
                aggFuncFound = false;
            }
        }
        if (aggFuncFound) {
            const aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'func';
            const localeTextFunc = this.getLocaleTextFunc();
            const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
            return `${aggFuncStringTranslated}(${headerName})`;
        }
        return headerName;
    }
}
exports.AggColumnNameService = AggColumnNameService;


/***/ }),

/***/ 5780:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggFuncService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const defaultAggFuncNames = {
    sum: 'Sum',
    first: 'First',
    last: 'Last',
    min: 'Min',
    max: 'Max',
    count: 'Count',
    avg: 'Average',
};
class AggFuncService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'aggFuncSvc';
        this.aggFuncsMap = {};
        this.initialised = false;
    }
    postConstruct() {
        this.init();
    }
    init() {
        if (this.initialised) {
            return;
        }
        this.initialiseWithDefaultAggregations();
        this.addAggFuncs(this.gos.get('aggFuncs'));
    }
    initialiseWithDefaultAggregations() {
        const aggMap = this.aggFuncsMap;
        aggMap['sum'] = aggSum;
        aggMap['first'] = aggFirst;
        aggMap['last'] = aggLast;
        aggMap['min'] = aggMin;
        aggMap['max'] = aggMax;
        aggMap['count'] = aggCount;
        aggMap['avg'] = aggAvg;
        this.initialised = true;
    }
    isAggFuncPossible(column, func) {
        const allKeys = this.getFuncNames(column);
        const allowed = allKeys.includes(func);
        const funcExists = (0, ag_grid_community_1._exists)(this.aggFuncsMap[func]);
        return allowed && funcExists;
    }
    getDefaultFuncLabel(fctName) {
        return defaultAggFuncNames[fctName] ?? fctName;
    }
    getDefaultAggFunc(column) {
        const defaultAgg = column.getColDef().defaultAggFunc;
        if ((0, ag_grid_community_1._exists)(defaultAgg) && this.isAggFuncPossible(column, defaultAgg)) {
            return defaultAgg;
        }
        if (this.isAggFuncPossible(column, 'sum')) {
            return 'sum';
        }
        const allKeys = this.getFuncNames(column);
        return allKeys?.length ? allKeys[0] : null;
    }
    addAggFuncs(aggFuncs) {
        this.init();
        if (!aggFuncs) {
            return;
        }
        Object.entries(aggFuncs).forEach(([key, aggFunc]) => {
            this.aggFuncsMap[key] = aggFunc;
        });
    }
    getAggFunc(name) {
        this.init();
        return this.aggFuncsMap[name];
    }
    getFuncNames(column) {
        const userAllowedFuncs = column.getColDef().allowedAggFuncs;
        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;
    }
    clear() {
        this.aggFuncsMap = {};
    }
}
exports.AggFuncService = AggFuncService;
function aggSum(params) {
    const { values } = params;
    let result = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (typeof value === 'number') {
            if (result === null) {
                result = value;
            }
            else {
                result += typeof result === 'number' ? value : BigInt(value);
            }
        }
        else if (typeof value === 'bigint') {
            if (result === null) {
                result = value;
            }
            else {
                result = (typeof result === 'bigint' ? result : BigInt(result)) + value;
            }
        }
    }
    return result;
}
function aggFirst(params) {
    return params.values.length > 0 ? params.values[0] : null;
}
function aggLast(params) {
    return params.values.length > 0 ? (0, ag_grid_community_1._last)(params.values) : null;
}
function aggMin(params) {
    const { values } = params;
    let result = null;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {
            result = value;
        }
    }
    return result;
}
function aggMax(params) {
    const { values } = params;
    let result = null;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {
            result = value;
        }
    }
    return result;
}
function aggCount(params) {
    const { values } = params;
    let result = 0;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        // check if the value is from a group, in which case use the group's count
        result += value != null && typeof value.value === 'number' ? value.value : 1;
    }
    // the previous aggregation data
    const existingAggData = params.rowNode?.aggData?.[params.column.getColId()];
    if (existingAggData && existingAggData.value === result) {
        // the underlying values haven't changed, return the old object to avoid triggering change detection
        return existingAggData;
    }
    // it's important to wrap it in the object so we can determine if this is a group level
    return {
        value: result,
        toString: function () {
            return this.value.toString();
        },
        // used for sorting
        toNumber: function () {
            return this.value;
        },
    };
}
// the average function is tricky as the multiple levels require weighted averages
// for the non-leaf node aggregations.
function aggAvg(params) {
    const { values } = params;
    let sum = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please
    let count = 0;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const currentValue = values[i];
        let valueToAdd = null;
        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {
            valueToAdd = currentValue;
            count++;
        }
        else if (currentValue != null &&
            (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') &&
            typeof currentValue.count === 'number') {
            // we are aggregating groups, so we take the aggregated values to calculated a weighted average
            valueToAdd =
                currentValue.value *
                    (typeof currentValue.value === 'number' ? currentValue.count : BigInt(currentValue.count));
            count += currentValue.count;
        }
        if (typeof valueToAdd === 'number') {
            sum += typeof sum === 'number' ? valueToAdd : BigInt(valueToAdd);
        }
        else if (typeof valueToAdd === 'bigint') {
            sum = (typeof sum === 'bigint' ? sum : BigInt(sum)) + valueToAdd;
        }
    }
    let value = null;
    // avoid divide by zero error
    if (count > 0) {
        value = sum / (typeof sum === 'number' ? count : BigInt(count));
    }
    // the previous aggregation data
    const existingAggData = params.rowNode?.aggData?.[params.column?.getColId()];
    if (existingAggData && existingAggData.count === count && existingAggData.value === value) {
        // the underlying values haven't changed, return the old object to avoid triggering change detection
        return existingAggData;
    }
    // the result will be an object. when this cell is rendered, only the avg is shown.
    // however when this cell is part of another aggregation, the count is also needed
    // to create a weighted average for the next level.
    return {
        count,
        value,
        // the grid by default uses toString to render values for an object, so this
        // is a trick to get the default cellRenderer to display the avg value
        toString: function () {
            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';
        },
        // used for sorting
        toNumber: function () {
            return this.value;
        },
    };
}


/***/ }),

/***/ 1872:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setColumnAggFunc = exports.clearAggFuncs = exports.addAggFuncs = void 0;
function addAggFuncs(beans, aggFuncs) {
    if (beans.aggFuncSvc) {
        beans.aggFuncSvc.addAggFuncs(aggFuncs);
    }
}
exports.addAggFuncs = addAggFuncs;
function clearAggFuncs(beans) {
    if (beans.aggFuncSvc) {
        beans.aggFuncSvc.clear();
    }
}
exports.clearAggFuncs = clearAggFuncs;
function setColumnAggFunc(beans, key, aggFunc) {
    beans.valueColsSvc?.setColumnAggFunc?.(key, aggFunc, 'api');
}
exports.setColumnAggFunc = setColumnAggFunc;


/***/ }),

/***/ 7032:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregationModule = exports.SharedAggregationModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const aggColumnNameService_1 = __webpack_require__(2529);
const aggFuncService_1 = __webpack_require__(5780);
const aggregationApi_1 = __webpack_require__(1872);
const aggregationStage_1 = __webpack_require__(3438);
const filterAggregatesStage_1 = __webpack_require__(6948);
const footerService_1 = __webpack_require__(182);
const valueColsSvc_1 = __webpack_require__(7926);
/**
 * @internal
 */
exports.SharedAggregationModule = {
    moduleName: 'SharedAggregation',
    version: version_1.VERSION,
    beans: [aggFuncService_1.AggFuncService, aggColumnNameService_1.AggColumnNameService, footerService_1.FooterService, valueColsSvc_1.ValueColsSvc],
    apiFunctions: {
        addAggFuncs: aggregationApi_1.addAggFuncs,
        clearAggFuncs: aggregationApi_1.clearAggFuncs,
        setColumnAggFunc: aggregationApi_1.setColumnAggFunc,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};
/**
 * @internal
 */
exports.AggregationModule = {
    moduleName: 'Aggregation',
    version: version_1.VERSION,
    beans: [aggregationStage_1.AggregationStage, filterAggregatesStage_1.FilterAggregatesStage],
    rowModels: ['clientSide'],
    dependsOn: [exports.SharedAggregationModule],
};


/***/ }),

/***/ 3438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregationStage = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AggregationStage extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'aggStage';
        this.refreshProps = new Set([
            'getGroupRowAgg',
            'alwaysAggregateAtRootLevel',
            'suppressAggFilteredOnly',
            'grandTotalRow',
        ]);
        this.step = 'aggregate';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.aggFuncSvc = beans.aggFuncSvc;
        this.pivotColsSvc = beans.pivotColsSvc;
        this.valueColsSvc = beans.valueColsSvc;
        this.pivotResultCols = beans.pivotResultCols;
        this.valueSvc = beans.valueSvc;
    }
    // it's possible to recompute the aggregate without doing the other parts
    // + api.refreshClientSideRowModel('aggregate')
    execute(params) {
        // if changed path is active, it means we came from a) change detection or b) transaction update.
        // for both of these, if no value columns are present, it means there is nothing to aggregate now
        // and there is no cleanup to be done (as value columns don't change between transactions or change
        // detections). if no value columns and no changed path, means we have to go through all nodes in
        // case we need to clean up agg data from before.
        const noValueColumns = !this.valueColsSvc?.columns?.length;
        const noUserAgg = !this.gos.getCallback('getGroupRowAgg');
        if (noValueColumns && noUserAgg && params.changedPath?.active) {
            return;
        }
        const aggDetails = this.createAggDetails(params);
        this.recursivelyCreateAggData(aggDetails);
    }
    createAggDetails(params) {
        const pivotActive = this.colModel.isPivotActive();
        const measureColumns = this.valueColsSvc?.columns;
        const pivotColumns = pivotActive && this.pivotColsSvc ? this.pivotColsSvc.columns : [];
        const aggDetails = {
            alwaysAggregateAtRootLevel: this.gos.get('alwaysAggregateAtRootLevel'),
            groupIncludeTotalFooter: !!(0, ag_grid_community_1._getGrandTotalRow)(this.gos),
            changedPath: params.changedPath,
            valueColumns: measureColumns ?? [],
            pivotColumns: pivotColumns,
            filteredOnly: !this.isSuppressAggFilteredOnly(),
            userAggFunc: this.gos.getCallback('getGroupRowAgg'),
        };
        return aggDetails;
    }
    isSuppressAggFilteredOnly() {
        const isGroupAggFiltering = (0, ag_grid_community_1._getGroupAggFiltering)(this.gos) !== undefined;
        return isGroupAggFiltering || this.gos.get('suppressAggFilteredOnly');
    }
    recursivelyCreateAggData(aggDetails) {
        const callback = (rowNode) => {
            const hasNoChildren = !rowNode.hasChildren();
            if (hasNoChildren) {
                // this check is needed for TreeData, in case the node is no longer a child,
                // but it was a child previously.
                if (rowNode.aggData) {
                    this.setAggData(rowNode, null);
                }
                // never agg data for leaf nodes
                return;
            }
            //Optionally enable the aggregation at the root Node
            const isRootNode = rowNode.level === -1;
            // if total footer is displayed, the value is in use
            if (isRootNode && !aggDetails.groupIncludeTotalFooter) {
                const notPivoting = !this.colModel.isPivotMode();
                if (!aggDetails.alwaysAggregateAtRootLevel && notPivoting) {
                    this.setAggData(rowNode, null);
                    return;
                }
            }
            this.aggregateRowNode(rowNode, aggDetails);
        };
        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);
    }
    aggregateRowNode(rowNode, aggDetails) {
        const measureColumnsMissing = aggDetails.valueColumns.length === 0;
        const pivotColumnsMissing = aggDetails.pivotColumns.length === 0;
        let aggResult;
        if (aggDetails.userAggFunc) {
            aggResult = aggDetails.userAggFunc({ nodes: rowNode.childrenAfterFilter });
        }
        else if (measureColumnsMissing) {
            aggResult = null;
        }
        else if (pivotColumnsMissing) {
            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);
        }
        else {
            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);
        }
        this.setAggData(rowNode, aggResult);
        // if we are grouping, then it's possible there is a sibling footer
        // to the group, so update the data here also if there is one
        if (rowNode.sibling) {
            this.setAggData(rowNode.sibling, aggResult);
        }
    }
    aggregateRowNodeUsingValuesAndPivot(rowNode) {
        const result = {};
        const secondaryColumns = this.pivotResultCols?.getPivotResultCols()?.list ?? [];
        let canSkipTotalColumns = true;
        for (let i = 0; i < secondaryColumns.length; i++) {
            const secondaryCol = secondaryColumns[i];
            const colDef = secondaryCol.getColDef();
            if (colDef.pivotTotalColumnIds != null) {
                canSkipTotalColumns = false;
                continue;
            }
            const keys = colDef.pivotKeys ?? [];
            let values;
            if (rowNode.leafGroup) {
                // lowest level group, get the values from the mapped set
                values = this.getValuesFromMappedSet(rowNode.childrenMapped, keys, colDef.pivotValueColumn);
            }
            else {
                // value columns and pivot columns, non-leaf group
                values = this.getValuesPivotNonLeaf(rowNode, colDef.colId);
            }
            // bit of a memory drain storing null/undefined, but seems to speed up performance.
            result[colDef.colId] = this.aggregateValues(values, colDef.pivotValueColumn.getAggFunc(), colDef.pivotValueColumn, rowNode, secondaryCol);
        }
        if (!canSkipTotalColumns) {
            for (let i = 0; i < secondaryColumns.length; i++) {
                const secondaryCol = secondaryColumns[i];
                const colDef = secondaryCol.getColDef();
                if (colDef.pivotTotalColumnIds == null || !colDef.pivotTotalColumnIds.length) {
                    continue;
                }
                const aggResults = colDef.pivotTotalColumnIds.map((currentColId) => result[currentColId]);
                // bit of a memory drain storing null/undefined, but seems to speed up performance.
                result[colDef.colId] = this.aggregateValues(aggResults, colDef.pivotValueColumn.getAggFunc(), colDef.pivotValueColumn, rowNode, secondaryCol);
            }
        }
        return result;
    }
    aggregateRowNodeUsingValuesOnly(rowNode, aggDetails) {
        const result = {};
        const { changedPath, valueColumns, filteredOnly } = aggDetails;
        const changedValueColumns = changedPath.active
            ? changedPath.getValueColumnsForNode(rowNode, valueColumns)
            : valueColumns;
        const notChangedValueColumns = changedPath.active
            ? changedPath.getNotValueColumnsForNode(rowNode, valueColumns)
            : null;
        const values2d = this.getValuesNormal(rowNode, changedValueColumns, filteredOnly);
        const oldValues = rowNode.aggData;
        changedValueColumns.forEach((valueColumn, index) => {
            result[valueColumn.getId()] = this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);
        });
        if (notChangedValueColumns && oldValues) {
            notChangedValueColumns.forEach((valueColumn) => {
                result[valueColumn.getId()] = oldValues[valueColumn.getId()];
            });
        }
        return result;
    }
    getValuesPivotNonLeaf(rowNode, colId) {
        return rowNode.childrenAfterFilter.map((childNode) => childNode.aggData[colId]);
    }
    getValuesFromMappedSet(mappedSet, keys, valueColumn) {
        let mapPointer = mappedSet;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            mapPointer = mapPointer ? mapPointer[key] : null;
        }
        if (!mapPointer) {
            return [];
        }
        return mapPointer.map((rowNode) => this.valueSvc.getValue(valueColumn, rowNode));
    }
    getValuesNormal(rowNode, valueColumns, filteredOnly) {
        // create 2d array, of all values for all valueColumns
        const values = [];
        valueColumns.forEach(() => values.push([]));
        const valueColumnCount = valueColumns.length;
        const nodeList = filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;
        const rowCount = nodeList.length;
        for (let i = 0; i < rowCount; i++) {
            const childNode = nodeList[i];
            for (let j = 0; j < valueColumnCount; j++) {
                const valueColumn = valueColumns[j];
                // if the row is a group, then it will only have an agg result value,
                // which means valueGetter is never used.
                const value = this.valueSvc.getValue(valueColumn, childNode);
                values[j].push(value);
            }
        }
        return values;
    }
    aggregateValues(values, aggFuncOrString, column, rowNode, pivotResultColumn) {
        const aggFunc = typeof aggFuncOrString === 'string' ? this.aggFuncSvc.getAggFunc(aggFuncOrString) : aggFuncOrString;
        if (typeof aggFunc !== 'function') {
            (0, ag_grid_community_1._error)(109, { aggFuncOrString });
            return null;
        }
        const aggFuncAny = aggFunc;
        const params = this.gos.addGridCommonParams({
            values: values,
            column: column,
            colDef: column ? column.getColDef() : undefined,
            pivotResultColumn: pivotResultColumn,
            rowNode: rowNode,
            data: rowNode ? rowNode.data : undefined,
        }); // the "as any" is needed to allow the deprecation warning messages
        return aggFuncAny(params);
    }
    setAggData(rowNode, newAggData) {
        const oldAggData = rowNode.aggData;
        rowNode.aggData = newAggData;
        // if no event service, nobody has registered for events, so no need fire event
        if (rowNode.__localEventService) {
            const eventFunc = (colId) => {
                const value = rowNode.aggData ? rowNode.aggData[colId] : undefined;
                const oldValue = oldAggData ? oldAggData[colId] : undefined;
                if (value === oldValue) {
                    return;
                }
                // do a quick lookup - despite the event it's possible the column no longer exists
                const column = this.colModel.getCol(colId);
                if (!column) {
                    return;
                }
                rowNode.dispatchCellChangedEvent(column, value, oldValue);
            };
            if (oldAggData) {
                for (const key of Object.keys(oldAggData)) {
                    eventFunc(key); // raise for old keys
                }
            }
            if (newAggData) {
                for (const key of Object.keys(newAggData)) {
                    if (!oldAggData || !(key in oldAggData)) {
                        eventFunc(key); // new key, event not yet raised
                    }
                }
            }
        }
    }
}
exports.AggregationStage = AggregationStage;


/***/ }),

/***/ 6948:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterAggregatesStage = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class FilterAggregatesStage extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'filterAggStage';
        this.refreshProps = new Set([]);
        this.step = 'filter_aggregates';
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    execute(params) {
        const isPivotMode = this.beans.colModel.isPivotMode();
        const isAggFilterActive = this.filterManager?.isAggregateFilterPresent() || this.filterManager?.isAggregateQuickFilterPresent();
        // This is the default filter for applying only to leaf nodes, realistically this should not apply as primary agg columns,
        // should not be applied by the filterManager if getGroupAggFiltering is missing. Predicate will apply filters to leaf level.
        const defaultPrimaryColumnPredicate = (params) => !params.node.group;
        // Default secondary column predicate, selecting only leaf level groups.
        const defaultSecondaryColumnPredicate = (params) => params.node.leafGroup;
        // The predicate to determine whether filters should apply to this row. Either defined by the user in groupAggFiltering or a default depending
        // on current pivot mode status.
        const applyFilterToNode = (0, ag_grid_community_1._getGroupAggFiltering)(this.gos) ||
            (isPivotMode ? defaultSecondaryColumnPredicate : defaultPrimaryColumnPredicate);
        const { changedPath } = params;
        const preserveChildren = (node, recursive = false) => {
            if (node.childrenAfterFilter) {
                node.childrenAfterAggFilter = node.childrenAfterFilter;
                if (recursive) {
                    node.childrenAfterAggFilter.forEach((child) => preserveChildren(child, recursive));
                }
                this.setAllChildrenCount(node);
            }
            if (node.sibling) {
                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
            }
        };
        const filterChildren = (node) => {
            node.childrenAfterAggFilter =
                node.childrenAfterFilter?.filter((child) => {
                    const shouldFilterRow = applyFilterToNode({ node: child });
                    if (shouldFilterRow) {
                        const doesNodePassFilter = this.filterManager.doesRowPassAggregateFilters({ rowNode: child });
                        if (doesNodePassFilter) {
                            // Node has passed, so preserve children
                            preserveChildren(child, true);
                            return true;
                        }
                    }
                    const hasChildPassed = child.childrenAfterAggFilter?.length;
                    return hasChildPassed;
                }) || null;
            this.setAllChildrenCount(node);
            if (node.sibling) {
                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
            }
        };
        changedPath.forEachChangedNodeDepthFirst(isAggFilterActive ? filterChildren : preserveChildren, true);
    }
    /** for tree data, we include all children, groups and leafs */
    setAllChildrenCountTreeData(rowNode) {
        const childrenAfterAggFilter = rowNode.childrenAfterAggFilter;
        let allChildrenCount = 0;
        if (childrenAfterAggFilter) {
            const length = childrenAfterAggFilter.length;
            allChildrenCount = length; // include direct children too
            for (let i = 0; i < length; ++i) {
                allChildrenCount += childrenAfterAggFilter[i].allChildrenCount ?? 0; // include children of children
            }
        }
        rowNode.setAllChildrenCount(
        // Maintain the historical behaviour:
        // - allChildrenCount is 0 in the root if there are no children
        // - allChildrenCount is null in any non-root row if there are no children
        allChildrenCount === 0 && rowNode.level >= 0 ? null : allChildrenCount);
    }
    /* for grid data, we only count the leafs */
    setAllChildrenCountGridGrouping(rowNode) {
        let allChildrenCount = 0;
        rowNode.childrenAfterAggFilter.forEach((child) => {
            if (child.group) {
                allChildrenCount += child.allChildrenCount;
            }
            else {
                allChildrenCount++;
            }
        });
        rowNode.setAllChildrenCount(allChildrenCount);
    }
    setAllChildrenCount(rowNode) {
        if (!rowNode.hasChildren()) {
            rowNode.setAllChildrenCount(null);
            return;
        }
        if (this.gos.get('treeData')) {
            this.setAllChildrenCountTreeData(rowNode);
        }
        else {
            this.setAllChildrenCountGridGrouping(rowNode);
        }
    }
}
exports.FilterAggregatesStage = FilterAggregatesStage;


/***/ }),

/***/ 182:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FooterService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const footerUtils_1 = __webpack_require__(6432);
class FooterService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'footerSvc';
    }
    addNodes(params, nodes, callback, includeFooterNodes, rootNode, position) {
        const parentNode = nodes[0]?.parent;
        if (!parentNode)
            return;
        let { index } = params;
        const grandTotal = includeFooterNodes && (0, ag_grid_community_1._getGrandTotalRow)(this.gos);
        const isGroupIncludeFooter = (0, ag_grid_community_1._getGroupTotalRowCallback)(this.gos);
        const groupTotal = includeFooterNodes && isGroupIncludeFooter({ node: parentNode });
        const isRootNode = parentNode === rootNode;
        if (isRootNode) {
            if (grandTotal === position) {
                (0, footerUtils_1._createRowNodeFooter)(parentNode, this.beans);
                callback(parentNode.sibling, index++);
            }
            return;
        }
        if (groupTotal === position) {
            (0, footerUtils_1._createRowNodeFooter)(parentNode, this.beans);
            callback(parentNode.sibling, index++);
        }
    }
    getTopDisplayIndex(rowsToDisplay, topLevelIndex, childrenAfterSort, getDefaultIndex) {
        let adjustedIndex = topLevelIndex;
        if (rowsToDisplay[0].footer) {
            // if footer is first displayed row and looking for first row, return footer
            if (topLevelIndex === 0) {
                return 0;
            }
            // if first row is footer, offset index to check sorted rows by 1
            adjustedIndex -= 1;
        }
        const lastRow = rowsToDisplay[rowsToDisplay.length - 1];
        const indexOutsideGroupBounds = adjustedIndex >= childrenAfterSort.length;
        // if last row is footer, and attempting to retrieve row of too high index, return footer row index
        if (lastRow.footer && indexOutsideGroupBounds) {
            return lastRow.rowIndex;
        }
        return getDefaultIndex(adjustedIndex);
    }
}
exports.FooterService = FooterService;


/***/ }),

/***/ 6432:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._destroyRowNodeFooter = exports._createRowNodeFooter = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
/**
 * When creating sibling nodes (e.g. footers), we don't copy these properties as they
 * cause the sibling to have properties which should be unique to the row.
 *
 * Note that `keyof T` does not include private members of `T`, so these need to be
 * added explicitly to this list. Take care when adding or renaming private properties
 * of `RowNode`.
 */
const IGNORED_SIBLING_PROPERTIES = new Set(['__localEventService', '__objectId', 'sticky', '__autoHeights', '__checkAutoHeightsDebounced']);
function _createRowNodeFooter(rowNode, beans) {
    // only create footer node once, otherwise we have daemons and
    // the animate screws up with the daemons hanging around
    if (rowNode.sibling) {
        return;
    }
    const footerNode = new ag_grid_community_1.RowNode(beans);
    Object.keys(rowNode).forEach((key) => {
        if (IGNORED_SIBLING_PROPERTIES.has(key)) {
            return;
        }
        footerNode[key] = rowNode[key];
    });
    footerNode.footer = true;
    footerNode.setRowTop(null);
    footerNode.setRowIndex(null);
    // manually set oldRowTop to null so we discard any
    // previous information about its position.
    footerNode.oldRowTop = null;
    footerNode.id = 'rowGroupFooter_' + rowNode.id;
    // get both header and footer to reference each other as siblings. this is never undone,
    // only overwritten. so if a group is expanded, then contracted, it will have a ghost
    // sibling - but that's fine, as we can ignore this if the header is contracted.
    footerNode.sibling = rowNode;
    rowNode.sibling = footerNode;
}
exports._createRowNodeFooter = _createRowNodeFooter;
function _destroyRowNodeFooter(rowNode) {
    if (!rowNode.sibling) {
        return;
    }
    rowNode.sibling.setRowTop(null);
    rowNode.sibling.setRowIndex(null);
    rowNode.sibling = undefined;
}
exports._destroyRowNodeFooter = _destroyRowNodeFooter;


/***/ }),

/***/ 7926:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueColsSvc = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ValueColsSvc extends ag_grid_community_1.BaseColsService {
    constructor() {
        super(...arguments);
        this.beanName = 'valueColsSvc';
        this.eventName = 'columnValueChanged';
        this.columnProcessors = {
            set: (column, added, source) => this.setValueActive(added, column, source),
            add: (column, added, source) => this.setValueActive(true, column, source),
            remove: (column, added, source) => this.setValueActive(false, column, source),
        };
        this.columnExtractors = {
            setFlagFunc: (col, flag, source) => this.setColValueActive(col, flag, source),
            getIndexFunc: () => undefined,
            getInitialIndexFunc: () => undefined,
            getValueFunc: (colDef) => {
                const aggFunc = colDef.aggFunc;
                // null or empty string means clear
                if (aggFunc === null || aggFunc === '') {
                    return null;
                }
                if (aggFunc === undefined) {
                    return;
                }
                return !!aggFunc;
            },
            getInitialValueFunc: (colDef) => {
                // return false if any of the following: null, undefined, empty string
                return colDef.initialAggFunc != null && colDef.initialAggFunc != '';
            },
        };
        this.modifyColumnsNoEventsCallbacks = {
            addCol: (column) => this.columns.push(column),
            removeCol: (column) => (0, ag_grid_community_1._removeFromArray)(this.columns, column),
        };
    }
    extractCols(source, oldProvidedCols) {
        this.columns = super.extractCols(source, oldProvidedCols);
        // all new columns added will have aggFunc missing, so set it to what is in the colDef
        this.columns.forEach((col) => {
            const colDef = col.getColDef();
            // if aggFunc provided, we always override, as reactive property
            if (colDef.aggFunc != null && colDef.aggFunc != '') {
                this.setColAggFunc(col, colDef.aggFunc);
            }
            else {
                // otherwise we use initialAggFunc only if no agg func set - which happens when new column only
                if (!col.getAggFunc()) {
                    this.setColAggFunc(col, colDef.initialAggFunc);
                }
            }
        });
        return this.columns;
    }
    setColumnAggFunc(key, aggFunc, source) {
        if (!key) {
            return;
        }
        const column = this.colModel.getColDefCol(key);
        if (!column) {
            return;
        }
        this.setColAggFunc(column, aggFunc);
        this.dispatchColumnChangedEvent(this.eventSvc, this.eventName, [column], source);
    }
    syncColumnWithState(column, source, getValue) {
        // noop
        const aggFunc = getValue('aggFunc').value1;
        if (aggFunc !== undefined) {
            if (typeof aggFunc === 'string') {
                this.setColAggFunc(column, aggFunc);
                if (!column.isValueActive()) {
                    this.setColValueActive(column, true, source);
                    this.modifyColumnsNoEventsCallbacks.addCol(column);
                }
            }
            else {
                if ((0, ag_grid_community_1._exists)(aggFunc)) {
                    // stateItem.aggFunc must be a string
                    (0, ag_grid_community_1._warn)(33);
                }
                // Note: we do not call column.setAggFunc(null), so that next time we aggregate
                // by this column (eg drag the column to the agg section int he toolpanel) it will
                // default to the last aggregation function.
                if (column.isValueActive()) {
                    this.setColValueActive(column, false, source);
                    this.modifyColumnsNoEventsCallbacks.removeCol(column);
                }
            }
        }
    }
    setValueActive(active, column, source) {
        if (active === column.isValueActive()) {
            return;
        }
        this.setColValueActive(column, active, source);
        if (active && !column.getAggFunc() && this.aggFuncSvc) {
            const initialAggFunc = this.aggFuncSvc.getDefaultAggFunc(column);
            this.setColAggFunc(column, initialAggFunc);
        }
    }
    setColAggFunc(column, aggFunc) {
        column.aggFunc = aggFunc;
        column.dispatchStateUpdatedEvent('aggFunc');
    }
    setColValueActive(column, value, source) {
        if (column.aggregationActive !== value) {
            column.aggregationActive = value;
            column.dispatchColEvent('columnValueChanged', source);
        }
    }
}
exports.ValueColsSvc = ValueColsSvc;


/***/ }),

/***/ 1809:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllEnterpriseModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const advancedFilterModule_1 = __webpack_require__(7976);
const integratedChartsModule_1 = __webpack_require__(1527);
const clipboardModule_1 = __webpack_require__(3766);
const columnsToolPanelModule_1 = __webpack_require__(6455);
const excelExportModule_1 = __webpack_require__(2886);
const filtersToolPanelModule_1 = __webpack_require__(2515);
const masterDetailModule_1 = __webpack_require__(1594);
const menuModule_1 = __webpack_require__(7130);
const multiFilterModule_1 = __webpack_require__(5434);
const pivotModule_1 = __webpack_require__(5470);
const rangeSelectionModule_1 = __webpack_require__(266);
const richSelectModule_1 = __webpack_require__(9327);
const rowGroupingModule_1 = __webpack_require__(1442);
const serverSideRowModelModule_1 = __webpack_require__(9074);
const setFilterModule_1 = __webpack_require__(9002);
const sideBarModule_1 = __webpack_require__(6358);
const sparklinesModule_1 = __webpack_require__(2949);
const statusBarModule_1 = __webpack_require__(8450);
const treeDataModule_1 = __webpack_require__(9428);
const version_1 = __webpack_require__(7205);
const viewportRowModelModule_1 = __webpack_require__(7794);
const dependsOn = [
    ag_grid_community_1.AllCommunityModule,
    clipboardModule_1.ClipboardModule,
    columnsToolPanelModule_1.ColumnsToolPanelModule,
    excelExportModule_1.ExcelExportModule,
    filtersToolPanelModule_1.FiltersToolPanelModule,
    masterDetailModule_1.MasterDetailModule,
    menuModule_1.ColumnMenuModule,
    menuModule_1.ContextMenuModule,
    rangeSelectionModule_1.CellSelectionModule,
    richSelectModule_1.RichSelectModule,
    rowGroupingModule_1.RowGroupingModule,
    rowGroupingModule_1.RowGroupingPanelModule,
    rowGroupingModule_1.GroupFilterModule,
    serverSideRowModelModule_1.ServerSideRowModelModule,
    serverSideRowModelModule_1.ServerSideRowModelApiModule,
    setFilterModule_1.SetFilterModule,
    multiFilterModule_1.MultiFilterModule,
    advancedFilterModule_1.AdvancedFilterModule,
    sideBarModule_1.SideBarModule,
    statusBarModule_1.StatusBarModule,
    viewportRowModelModule_1.ViewportRowModelModule,
    pivotModule_1.PivotModule,
    treeDataModule_1.TreeDataModule,
];
const moduleName = 'AllEnterprise';
/**
 * @feature All Enterprise and Community features
 * Registers all the Grid features: Community and Enterprise.
 * If using Integrated Charts or Sparklines then the relevant AG Charts module must be provided.
 * @example
 * // All Enterprise features
 * import { ModuleRegistry } from 'ag-grid-community';
 * import { AllEnterpriseModule } from 'ag-grid-enterprise';
 *
 * ModuleRegistry.registerModules([ AllEnterpriseModule ]);
 * @example
 * // All Enterprise features including Integrated Charts and Sparklines
 * import { ModuleRegistry } from 'ag-grid-community';
 * import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
 * import { AllEnterpriseModule } from 'ag-grid-enterprise';
 *
 * ModuleRegistry.registerModules([ AllEnterpriseModule.with(AgChartsEnterpriseModule) ]);
 *
 */
exports.AllEnterpriseModule = {
    with: (params) => ({
        moduleName,
        version: version_1.VERSION,
        dependsOn: [...dependsOn, integratedChartsModule_1.IntegratedChartsModule.with(params), sparklinesModule_1.SparklinesModule.with(params)],
    }),
    moduleName,
    version: version_1.VERSION,
    dependsOn: dependsOn,
};


/***/ }),

/***/ 7672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkeletonCellRendererModule = exports.LoadingCellRendererModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const loadingCellRenderer_1 = __webpack_require__(1565);
const skeletonCellRenderer_1 = __webpack_require__(780);
/**
 * @internal
 */
exports.LoadingCellRendererModule = {
    moduleName: 'LoadingCellRenderer',
    version: version_1.VERSION,
    userComponents: {
        agLoadingCellRenderer: loadingCellRenderer_1.LoadingCellRenderer,
    },
    icons: {
        // rotating spinner shown by the loading cell renderer
        groupLoading: 'loading',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};
/**
 * @internal
 */
exports.SkeletonCellRendererModule = {
    moduleName: 'SkeletonCellRenderer',
    version: version_1.VERSION,
    userComponents: {
        agSkeletonCellRenderer: skeletonCellRenderer_1.SkeletonCellRenderer,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};


/***/ }),

/***/ 1565:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingCellRenderer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class LoadingCellRenderer extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`);
        this.eLoadingIcon = ag_grid_community_1.RefPlaceholder;
        this.eLoadingText = ag_grid_community_1.RefPlaceholder;
    }
    init(params) {
        params.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }
    setupFailed() {
        const localeTextFunc = this.getLocaleTextFunc();
        this.eLoadingText.innerText = localeTextFunc('loadingError', 'ERR');
    }
    setupLoading() {
        const eLoadingIcon = (0, ag_grid_community_1._createIconNoSpan)('groupLoading', this.beans, null);
        if (eLoadingIcon) {
            this.eLoadingIcon.appendChild(eLoadingIcon);
        }
        const localeTextFunc = this.getLocaleTextFunc();
        this.eLoadingText.innerText = localeTextFunc('loadingOoo', 'Loading');
    }
    refresh(_params) {
        return false;
    }
}
exports.LoadingCellRenderer = LoadingCellRenderer;


/***/ }),

/***/ 780:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkeletonCellRenderer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class SkeletonCellRenderer extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-skeleton-container"></div>`);
    }
    init(params) {
        const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
        this.getGui().setAttribute('id', id);
        this.addDestroyFunc(() => (0, ag_grid_community_1._setAriaLabelledBy)(params.eParentOfValue));
        (0, ag_grid_community_1._setAriaLabelledBy)(params.eParentOfValue, id);
        params.node.failedLoad ? this.setupFailed() : this.setupLoading(params);
    }
    setupFailed() {
        const localeTextFunc = this.getLocaleTextFunc();
        this.getGui().innerText = localeTextFunc('loadingError', 'ERR');
        const ariaFailed = localeTextFunc('ariaSkeletonCellLoadingFailed', 'Row failed to load');
        (0, ag_grid_community_1._setAriaLabel)(this.getGui(), ariaFailed);
    }
    setupLoading(params) {
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        const skeletonEffect = eDocument.createElement('div');
        skeletonEffect.classList.add('ag-skeleton-effect');
        // Use the row index to derive a width value for the skeleton cell
        // to avoid them having uniform width when rendering
        const rowIndex = params.node.rowIndex;
        if (rowIndex != null) {
            // Base value of 75% with variation between [-25%, 25%]. We alternate between sin and
            // cos to achieve a semi-random appearance without actually needing a random number.
            // We avoid using random numbers because then skeletons have consistent widths after
            // being scrolled on and off screen.
            const width = 75 + 25 * (rowIndex % 2 === 0 ? Math.sin(rowIndex) : Math.cos(rowIndex));
            skeletonEffect.style.width = `${width}%`;
        }
        this.getGui().appendChild(skeletonEffect);
        const localeTextFunc = this.getLocaleTextFunc();
        const ariaLoading = localeTextFunc('ariaSkeletonCellLoading', 'Row data is loading');
        (0, ag_grid_community_1._setAriaLabel)(this.getGui(), ariaLoading);
    }
    refresh(_params) {
        return false;
    }
}
exports.SkeletonCellRenderer = SkeletonCellRenderer;


/***/ }),

/***/ 2459:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgChartsExports = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
/** Bean to expose the AG Charts apis from a single location and not require a code dependency on ag-charts-community */
class AgChartsExports extends ag_grid_community_1.BeanStub {
    constructor(params) {
        super();
        this.beanName = 'agChartsExports';
        this.isEnterprise = false;
        this.create = params.create;
        this._Theme = params._Theme;
        this._Scene = params._Scene;
        this.isEnterprise = params.isEnterprise;
        this._Util = params._Util;
    }
}
exports.AgChartsExports = AgChartsExports;


/***/ }),

/***/ 3251:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartController = exports.DEFAULT_THEMES = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const chartTheme_1 = __webpack_require__(8987);
const chartDataModel_1 = __webpack_require__(8592);
const chartParamsValidator_1 = __webpack_require__(8889);
const seriesTypeMapper_1 = __webpack_require__(4237);
exports.DEFAULT_THEMES = ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];
class ChartController extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.rangeSvc = beans.rangeSvc;
        this.agChartsExports = beans.agChartsExports;
    }
    constructor(model) {
        super();
        this.model = model;
        this.isEnterprise = () => this.agChartsExports.isEnterprise;
    }
    postConstruct() {
        this.setChartRange();
        if (this.model.unlinked) {
            if (this.rangeSvc) {
                this.rangeSvc.setCellRanges([]);
            }
        }
        const listener = this.updateForGridChange.bind(this, {});
        this.addManagedEventListeners({
            cellSelectionChanged: (event) => {
                if (event.id && event.id === this.model.chartId) {
                    this.updateForRangeChange();
                }
            },
            columnMoved: listener,
            columnPinned: listener,
            columnVisible: listener,
            columnRowGroupChanged: listener,
            modelUpdated: listener,
            cellValueChanged: this.updateForDataChange.bind(this),
        });
    }
    update(params) {
        if (!this.validUpdateType(params))
            return false;
        const validationResult = (0, chartParamsValidator_1.validateUpdateParams)(params, this.agChartsExports.isEnterprise);
        if (!validationResult)
            return false;
        const validParams = validationResult === true ? params : validationResult;
        this.applyValidatedChartParams(validParams);
        return true;
    }
    applyValidatedChartParams(params) {
        const { chartId, chartType, chartThemeName, unlinkChart } = params;
        // create a common base for the chart model parameters (this covers pivot chart updates)
        const common = {
            chartId: chartId,
            pivotChart: this.model.pivotChart,
            chartType: chartType ?? this.model.chartType,
            chartThemeName: chartThemeName ?? this.model.chartThemeName,
            unlinkChart: unlinkChart ?? this.model.unlinked,
            cellRange: this.model.suppliedCellRange,
            switchCategorySeries: this.model.switchCategorySeries,
            aggFunc: this.model.aggFunc,
            seriesChartTypes: undefined,
            suppressChartRanges: false,
            crossFiltering: false,
        };
        const chartModelParams = { ...common };
        // modify the chart model properties based on the type of update
        switch (params.type) {
            case 'rangeChartUpdate':
                chartModelParams.cellRange = this.createCellRange(params) ?? this.model.suppliedCellRange;
                chartModelParams.switchCategorySeries = params.switchCategorySeries ?? this.model.switchCategorySeries;
                chartModelParams.aggFunc = params.aggFunc ?? this.model.aggFunc;
                chartModelParams.seriesChartTypes = params.seriesChartTypes;
                chartModelParams.suppressChartRanges = params.suppressChartRanges ?? this.model.suppressChartRanges;
                chartModelParams.seriesGroupType = params.seriesGroupType ?? this.model.seriesGroupType;
                break;
            case 'crossFilterChartUpdate':
                chartModelParams.cellRange = this.createCellRange(params) ?? this.model.suppliedCellRange;
                chartModelParams.switchCategorySeries = false;
                chartModelParams.aggFunc = params.aggFunc ?? this.model.aggFunc;
                chartModelParams.crossFiltering = true;
                chartModelParams.suppressChartRanges = params.suppressChartRanges ?? this.model.suppressChartRanges;
                break;
            case 'pivotChartUpdate':
                chartModelParams.switchCategorySeries = false;
                break;
        }
        this.model.updateModel(chartModelParams);
        // if the chart should be unlinked or chart ranges suppressed, remove all cell ranges; otherwise, set the chart range
        const removeChartCellRanges = chartModelParams.unlinkChart || chartModelParams.suppressChartRanges;
        removeChartCellRanges ? this.rangeSvc?.setCellRanges([]) : this.setChartRange();
    }
    updateForGridChange(params) {
        if (this.model.unlinked) {
            return;
        }
        const { maintainColState, setColsFromRange } = params ?? {};
        this.model.updateCellRanges({ maintainColState, setColsFromRange });
        this.model.updateData();
        this.setChartRange();
    }
    updateForDataChange() {
        if (this.model.unlinked) {
            return;
        }
        this.model.updateData();
        this.raiseChartModelUpdateEvent();
    }
    updateForRangeChange() {
        this.updateForGridChange({ setColsFromRange: true });
        this.raiseChartRangeSelectionChangedEvent();
    }
    updateForPanelChange(params) {
        this.model.updateCellRanges(params);
        this.model.updateData();
        if (params.skipAnimation) {
            this.getChartProxy().getChartRef().skipAnimations();
        }
        this.setChartRange();
        this.raiseChartRangeSelectionChangedEvent();
    }
    updateThemeOverrides(updatedOverrides) {
        this.chartProxy.updateThemeOverrides(updatedOverrides);
    }
    getChartUpdateParams(updatedOverrides) {
        const selectedCols = this.getSelectedValueColState();
        const fields = selectedCols.map((c) => ({ colId: c.colId, displayName: c.displayName }));
        const data = this.getChartData();
        const selectedDimensions = this.getSelectedDimensions();
        const params = {
            data,
            groupData: this.model.groupChartData,
            grouping: this.isGrouping(),
            categories: selectedDimensions.map((selectedDimension) => ({
                id: selectedDimension.colId,
                name: selectedDimension.displayName,
                chartDataType: this.model.categoryAxisType ?? this.model.getChartDataType(selectedDimension.colId),
            })),
            fields,
            chartId: this.getChartId(),
            getCrossFilteringContext: () => ({ lastSelectedChartId: 'xxx' }),
            seriesChartTypes: this.getSeriesChartTypes(),
            updatedOverrides: updatedOverrides,
            seriesGroupType: this.model.seriesGroupType,
        };
        return this.isCategorySeriesSwitched() ? this.invertCategorySeriesParams(params) : params;
    }
    invertCategorySeriesParams(params) {
        const [category] = params.categories;
        // Create a single synthetic output category that will contain the series name values
        const categories = [{ id: chartDataModel_1.DEFAULT_CHART_CATEGORY, name: '' }];
        // Create an output series corresponding to each row in the input data
        const fields = params.data.map((value, index) => {
            const categoryKey = `${category.id}:${index}`;
            const categoryValue = value[category.id];
            const seriesLabel = categoryValue == null ? '' : String(categoryValue);
            return { colId: categoryKey, displayName: seriesLabel };
        });
        // Create an output data row corresponding to each selected series column
        const data = params.fields.map((field) => {
            // Create a new output row labeled with the series column name
            const row = {
                [chartDataModel_1.DEFAULT_CHART_CATEGORY]: field.displayName,
            };
            // Append fields corresponding to each row in the input data
            for (const [index, value] of params.data.entries()) {
                const categoryKey = `${category.id}:${index}`;
                const seriesLabelValue = value[field.colId];
                row[categoryKey] = seriesLabelValue;
            }
            return row;
        });
        return {
            ...params,
            categories,
            fields,
            data,
        };
    }
    getChartModel() {
        const modelType = this.model.pivotChart ? 'pivot' : 'range';
        const seriesChartTypes = this.isComboChart() ? this.model.comboChartModel.seriesChartTypes : undefined;
        return {
            modelType,
            chartId: this.model.chartId,
            chartType: this.model.chartType,
            chartThemeName: this.getChartThemeName(),
            chartOptions: this.chartProxy.getChartThemeOverrides(),
            chartPalette: this.chartProxy.getChartPalette(),
            cellRange: this.getCellRangeParams(),
            switchCategorySeries: this.model.switchCategorySeries,
            suppressChartRanges: this.model.suppressChartRanges,
            aggFunc: this.model.aggFunc,
            unlinkChart: this.model.unlinked,
            seriesChartTypes,
            seriesGroupType: this.model.seriesGroupType,
        };
    }
    getChartId() {
        return this.model.chartId;
    }
    getChartData() {
        return this.model.chartData;
    }
    getChartType() {
        return this.model.chartType;
    }
    setChartType(chartType) {
        this.updateMultiSeriesAndCategory(this.model.chartType, chartType);
        this.model.chartType = chartType;
        this.model.comboChartModel.updateSeriesChartTypes();
        // Reset the inverted category/series toggle whenever the chart type changes
        this.model.switchCategorySeries = false;
        this.model.categoryAxisType = undefined;
        this.model.seriesGroupType = undefined;
        this.raiseChartModelUpdateEvent();
        this.raiseChartOptionsChangedEvent();
    }
    isCategorySeriesSwitched() {
        return this.model.switchCategorySeries && !this.model.isGrouping();
    }
    switchCategorySeries(inverted) {
        if (!(0, seriesTypeMapper_1.supportsInvertedCategorySeries)(this.getChartType()))
            return;
        this.model.switchCategorySeries = inverted;
        this.raiseChartModelUpdateEvent();
    }
    getAggFunc() {
        return this.model.aggFunc;
    }
    setAggFunc(value, silent) {
        if (this.model.aggFunc === value)
            return;
        this.model.aggFunc = value;
        if (silent)
            return;
        this.model.updateData();
        this.raiseChartModelUpdateEvent();
    }
    updateMultiSeriesAndCategory(previousChartType, chartType) {
        // If we are changing from a multi-category/series chart type to a single-category/series chart type,
        // ensure that only the allowed number of selected category/series column remain selected
        const updateForMax = (columns, maxNum) => {
            let numSelected = 0;
            for (const colState of columns) {
                if (!colState.selected)
                    continue;
                if (numSelected >= maxNum) {
                    colState.selected = false;
                }
                else {
                    numSelected++;
                }
            }
            if (numSelected === 0) {
                columns[0].selected = true;
            }
        };
        const maxNumDimensions = (0, seriesTypeMapper_1.getMaxNumCategories)(chartType);
        const maxNumSeries = (0, seriesTypeMapper_1.getMaxNumSeries)(chartType);
        const updateDimensionColState = maxNumDimensions != null && ((0, seriesTypeMapper_1.getMaxNumCategories)(previousChartType) ?? 100) > (maxNumDimensions ?? 100);
        const updateValueColState = maxNumSeries != null && ((0, seriesTypeMapper_1.getMaxNumSeries)(previousChartType) ?? 100) > (maxNumSeries ?? 100);
        if (updateDimensionColState) {
            updateForMax(this.model.dimensionColState, maxNumDimensions);
        }
        if (updateValueColState) {
            updateForMax(this.model.valueColState, maxNumSeries);
        }
        if (updateDimensionColState || updateValueColState) {
            this.model.resetCellRanges(updateDimensionColState, updateValueColState);
            this.setChartRange(true);
        }
    }
    setChartThemeName(chartThemeName, silent) {
        this.model.chartThemeName = chartThemeName;
        if (!silent) {
            this.raiseChartModelUpdateEvent();
            this.raiseChartOptionsChangedEvent();
        }
    }
    getChartThemeName() {
        return this.model.chartThemeName;
    }
    isPivotChart() {
        return this.model.pivotChart;
    }
    isPivotMode() {
        return this.model.isPivotMode();
    }
    isGrouping() {
        return this.model.isGrouping();
    }
    isCrossFilterChart() {
        return this.model.crossFiltering;
    }
    getThemeNames() {
        return this.gos.get('chartThemes') || exports.DEFAULT_THEMES;
    }
    getThemes() {
        const themeNames = this.getThemeNames();
        return themeNames.map((themeName) => {
            const stockTheme = (0, chartTheme_1.isStockTheme)(themeName, this.agChartsExports._Theme);
            const theme = stockTheme ? themeName : this.chartProxy.lookupCustomChartTheme(themeName);
            return this.agChartsExports._Theme.getChartTheme(theme);
        });
    }
    getPalettes() {
        const themes = this.getThemes();
        return themes.map((theme) => {
            return theme.palette;
        });
    }
    getThemeTemplateParameters() {
        const themes = this.getThemes();
        return themes.map((theme) => {
            return theme.getTemplateParameters();
        });
    }
    getValueColState() {
        return this.model.valueColState.map(this.displayNameMapper.bind(this));
    }
    getSelectedValueColState() {
        return this.getValueColState().filter((cs) => cs.selected);
    }
    getSelectedDimensions() {
        return this.model.getSelectedDimensions();
    }
    displayNameMapper(col) {
        const { column } = col;
        if (column) {
            col.displayName = this.model.getColDisplayName(column, this.model.isPivotMode());
        }
        else {
            const colNames = this.model.colNames[col.colId];
            col.displayName = colNames ? colNames.join(' - ') : this.model.getColDisplayName(column);
        }
        return col;
    }
    getColStateForMenu() {
        return { dimensionCols: this.model.dimensionColState, valueCols: this.getValueColState() };
    }
    setChartRange(silent = false) {
        if (this.rangeSvc && !this.model.suppressChartRanges && !this.model.unlinked) {
            this.rangeSvc.setCellRanges(this.getCellRanges());
        }
        if (!silent) {
            this.raiseChartModelUpdateEvent();
        }
    }
    detachChartRange() {
        // when chart is detached it won't listen to changes from the grid
        this.model.unlinked = !this.model.unlinked;
        if (this.model.unlinked) {
            // remove range from grid
            if (this.rangeSvc) {
                this.rangeSvc.setCellRanges([]);
            }
        }
        else {
            // update chart data may have changed
            this.updateForGridChange();
        }
        this.dispatchLocalEvent({ type: 'chartLinkedChanged' });
    }
    setChartProxy(chartProxy) {
        this.chartProxy = chartProxy;
    }
    getChartProxy() {
        return this.chartProxy;
    }
    isActiveXYChart() {
        return ['scatter', 'bubble'].includes(this.getChartType());
    }
    isChartLinked() {
        return !this.model.unlinked;
    }
    customComboExists() {
        const savedCustomSeriesChartTypes = this.model.comboChartModel.savedCustomSeriesChartTypes;
        return savedCustomSeriesChartTypes && savedCustomSeriesChartTypes.length > 0;
    }
    getSeriesChartTypes() {
        return this.model.comboChartModel.seriesChartTypes;
    }
    isComboChart(chartType) {
        return this.model.isComboChart(chartType);
    }
    updateSeriesChartType(colId, chartType, secondaryAxis) {
        const seriesChartType = this.model.comboChartModel.seriesChartTypes.find((s) => s.colId === colId);
        if (seriesChartType) {
            // once a combo chart has been modified it is now a 'customCombo' chart
            const updateChartType = this.model.chartType !== 'customCombo';
            if (updateChartType) {
                this.model.chartType = 'customCombo';
            }
            const prevSeriesChartType = seriesChartType.chartType;
            if (chartType != null) {
                seriesChartType.chartType = chartType;
            }
            if (secondaryAxis != null) {
                seriesChartType.secondaryAxis = secondaryAxis;
            }
            // replace existing custom series types with this latest version
            this.model.comboChartModel.savedCustomSeriesChartTypes = this.model.comboChartModel.seriesChartTypes;
            // series chart types can be modified, i.e. column chart types should be moved to primary axis
            this.model.comboChartModel.updateSeriesChartTypes();
            this.updateForDataChange();
            if (updateChartType) {
                // update the settings panel by raising an 'chartTypeChanged' event
                this.dispatchLocalEvent({
                    type: 'chartTypeChanged',
                });
            }
            if (prevSeriesChartType !== chartType) {
                // update the format panel by raising an chartSeriesChartTypeChanged event
                this.dispatchLocalEvent({
                    type: 'chartSeriesChartTypeChanged',
                });
            }
            this.raiseChartOptionsChangedEvent();
        }
    }
    getActiveSeriesChartTypes() {
        const selectedColIds = this.getSelectedValueColState().map((c) => c.colId);
        return this.getSeriesChartTypes().filter((s) => selectedColIds.includes(s.colId));
    }
    getChartSeriesTypes(chartType) {
        const targetChartType = chartType ?? this.getChartType();
        return this.isComboChart(targetChartType) ? ['line', 'bar', 'area'] : [(0, seriesTypeMapper_1.getSeriesType)(targetChartType)];
    }
    getChartSeriesType() {
        const seriesChartTypes = this.getSeriesChartTypes();
        if (seriesChartTypes.length === 0) {
            return 'bar';
        }
        const ct = seriesChartTypes[0].chartType;
        if (ct === 'columnLineCombo') {
            return 'bar';
        }
        if (ct === 'areaColumnCombo') {
            return 'area';
        }
        return (0, seriesTypeMapper_1.getSeriesType)(ct);
    }
    getCellRanges() {
        return [this.model.dimensionCellRange, this.model.valueCellRange].filter((r) => r);
    }
    createCellRange(params) {
        return (params.cellRange &&
            this.rangeSvc?.createPartialCellRangeFromRangeParams(params.cellRange, true));
    }
    validUpdateType(params) {
        if (!params.type) {
            (0, ag_grid_community_1._warn)(136);
            return false;
        }
        const chartTypeMap = {
            'Range Chart': () => !this.isPivotChart() && !this.isCrossFilterChart(),
            'Pivot Chart': () => this.isPivotChart(),
            'Cross Filter Chart': () => this.isCrossFilterChart(),
        };
        const currentChartType = Object.keys(chartTypeMap).find((type) => chartTypeMap[type]()) ?? 'Range Chart';
        const valid = params.type === `${currentChartType[0].toLowerCase()}${currentChartType.slice(1).replace(/ /g, '')}Update`;
        if (!valid) {
            (0, ag_grid_community_1._warn)(137, { currentChartType, type: params.type });
        }
        return valid;
    }
    getCellRangeParams() {
        const cellRanges = this.getCellRanges();
        const firstCellRange = cellRanges[0];
        const startRow = (firstCellRange && firstCellRange.startRow) || null;
        const endRow = (firstCellRange && firstCellRange.endRow) || null;
        return {
            rowStartIndex: startRow && startRow.rowIndex,
            rowStartPinned: startRow && startRow.rowPinned,
            rowEndIndex: endRow && endRow.rowIndex,
            rowEndPinned: endRow && endRow.rowPinned,
            columns: cellRanges.reduce((columns, value) => columns.concat(value.columns.map((c) => c.getId())), []),
        };
    }
    setCategoryAxisType(categoryAxisType) {
        this.model.categoryAxisType = categoryAxisType;
        this.raiseChartModelUpdateEvent();
    }
    getSeriesGroupType() {
        return this.model.seriesGroupType ?? this.chartProxy.getSeriesGroupType();
    }
    setSeriesGroupType(seriesGroupType) {
        this.model.seriesGroupType = seriesGroupType;
        this.raiseChartModelUpdateEvent();
    }
    raiseChartModelUpdateEvent() {
        this.dispatchLocalEvent({ type: 'chartModelUpdate' });
    }
    raiseChartUpdatedEvent() {
        this.dispatchLocalEvent({ type: 'chartUpdated' });
    }
    raiseChartApiUpdateEvent() {
        this.dispatchLocalEvent({ type: 'chartApiUpdate' });
    }
    raiseChartOptionsChangedEvent() {
        const { chartId, chartType } = this.getChartModel();
        this.eventSvc.dispatchEvent({
            type: 'chartOptionsChanged',
            chartId,
            chartType,
            chartThemeName: this.getChartThemeName(),
            chartOptions: this.chartProxy.getChartThemeOverrides(),
        });
    }
    raiseChartRangeSelectionChangedEvent() {
        this.eventSvc.dispatchEvent({
            type: 'chartRangeSelectionChanged',
            id: this.model.chartId,
            chartId: this.model.chartId,
            cellRange: this.getCellRangeParams(),
        });
    }
    destroy() {
        super.destroy();
        if (this.rangeSvc) {
            this.rangeSvc.setCellRanges([]);
        }
    }
}
exports.ChartController = ChartController;


/***/ }),

/***/ 7216:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AreaChartProxy = void 0;
const cartesianChartProxy_1 = __webpack_require__(8631);
class AreaChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const axes = [
            {
                type: this.getXAxisType(params),
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
        // Add a default label formatter to show '%' for normalized charts if none is provided
        if (this.isNormalised()) {
            const numberAxis = axes[1];
            numberAxis.label = { ...numberAxis.label, formatter: (params) => Math.round(params.value) + '%' };
        }
        return axes;
    }
    getSeries(params) {
        const [category] = params.categories;
        const series = params.fields.map((f) => ({
            type: this.standaloneChartType,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName,
            normalizedTo: this.chartType === 'normalizedArea' ? 100 : undefined,
            stacked: ['normalizedArea', 'stackedArea'].includes(this.chartType),
        }));
        return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(series, params) : series;
    }
    isNormalised() {
        return !this.crossFiltering && this.chartType === 'normalizedArea';
    }
}
exports.AreaChartProxy = AreaChartProxy;


/***/ }),

/***/ 3116:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BarChartProxy = void 0;
const color_1 = __webpack_require__(3610);
const seriesTypeMapper_1 = __webpack_require__(4237);
const cartesianChartProxy_1 = __webpack_require__(8631);
const HORIZONTAL_CHART_TYPES = new Set(['bar', 'groupedBar', 'stackedBar', 'normalizedBar']);
class BarChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const axes = [
            {
                type: this.getXAxisType(params),
                position: this.isHorizontal() ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: this.isHorizontal() ? 'bottom' : 'left',
            },
        ];
        // Add a default label formatter to show '%' for normalized charts if none is provided
        if (this.isNormalised()) {
            const numberAxis = axes[1];
            numberAxis.label = { ...numberAxis.label, formatter: (params) => Math.round(params.value) + '%' };
        }
        return axes;
    }
    getSeries(params) {
        const [category] = params.categories;
        const series = params.fields.map((f) => ({
            type: this.standaloneChartType,
            direction: this.isHorizontal() ? 'horizontal' : 'vertical',
            stacked: this.crossFiltering || (0, seriesTypeMapper_1.isStacked)(this.chartType),
            normalizedTo: this.isNormalised() ? 100 : undefined,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName,
        }));
        return this.crossFiltering ? this.extractCrossFilterSeries(series) : series;
    }
    extractCrossFilterSeries(series) {
        const palette = this.getChartPalette();
        const updatePrimarySeries = (seriesOptions, index) => {
            return {
                ...seriesOptions,
                highlightStyle: { item: { fill: undefined } },
                fill: palette?.fills?.[index],
                stroke: palette?.strokes?.[index],
                listeners: {
                    nodeClick: this.crossFilterCallback,
                },
            };
        };
        const updateFilteredOutSeries = (seriesOptions) => {
            const yKey = seriesOptions.yKey + '-filtered-out';
            return {
                ...seriesOptions,
                yKey,
                fill: (0, color_1.hexToRGBA)(seriesOptions.fill, '0.3'),
                stroke: (0, color_1.hexToRGBA)(seriesOptions.stroke, '0.3'),
                showInLegend: false,
            };
        };
        const allSeries = [];
        for (let i = 0; i < series.length; i++) {
            const originalSeries = series[i];
            // update primary series
            allSeries.push(updatePrimarySeries(originalSeries, i));
            // add 'filtered-out' series
            allSeries.push(updateFilteredOutSeries(updatePrimarySeries(originalSeries, i)));
        }
        return allSeries;
    }
    isNormalised() {
        const normalisedCharts = ['normalizedColumn', 'normalizedBar'];
        return !this.crossFiltering && normalisedCharts.includes(this.chartType);
    }
    isHorizontal() {
        return HORIZONTAL_CHART_TYPES.has(this.chartType);
    }
}
exports.BarChartProxy = BarChartProxy;


/***/ }),

/***/ 8631:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartesianChartProxy = void 0;
const chartProxy_1 = __webpack_require__(6738);
class CartesianChartProxy extends chartProxy_1.ChartProxy {
    constructor(params) {
        super(params);
        this.crossFilteringAllPoints = new Set();
        this.crossFilteringSelectedPoints = [];
    }
    getUpdateOptions(params, commonChartOptions) {
        const axes = this.getAxes(params, commonChartOptions);
        return {
            ...commonChartOptions,
            data: this.getData(params, axes),
            axes,
            series: this.getSeries(params),
        };
    }
    getData(params, axes) {
        const supportsCrossFiltering = ['area', 'line'].includes(this.standaloneChartType);
        return this.crossFiltering && supportsCrossFiltering
            ? this.getCrossFilterData(params)
            : this.getDataTransformedData(params, axes);
    }
    getDataTransformedData(params, axes) {
        // assumed that the first axis is always the "category" axis
        const xAxisType = axes[0].type;
        const { categories, data } = params;
        const [category] = categories;
        switch (xAxisType) {
            case 'category':
                return this.transformCategoryData(data, category.id);
            case 'time':
                return this.transformTimeData(data, category.id);
            default:
                return data;
        }
    }
    getXAxisType(params) {
        if (params.grouping) {
            return 'grouped-category';
        }
        else if (this.isXAxisOfType(params, 'time', (value) => value instanceof Date)) {
            return 'time';
        }
        else if (this.isXAxisOfType(params, 'number')) {
            return 'number';
        }
        return 'category';
    }
    isXAxisOfType(params, type, isInstance) {
        const [category] = params.categories;
        if (category?.chartDataType) {
            return category.chartDataType === type;
        }
        if (!isInstance) {
            return false;
        }
        const testDatum = params.data[0];
        if (!testDatum) {
            return false;
        }
        return isInstance(testDatum[category.id]);
    }
    transformTimeData(data, categoryKey) {
        const firstValue = data[0]?.[categoryKey];
        if (firstValue instanceof Date) {
            return data;
        }
        return data.map((datum) => {
            const value = datum[categoryKey];
            return typeof value === 'string'
                ? {
                    ...datum,
                    [categoryKey]: new Date(value),
                }
                : datum;
        });
    }
    crossFilteringReset() {
        this.crossFilteringSelectedPoints = [];
        this.crossFilteringAllPoints.clear();
    }
    crossFilteringPointSelected(point) {
        return this.crossFilteringSelectedPoints.length == 0 || this.crossFilteringSelectedPoints.includes(point);
    }
    crossFilteringDeselectedPoints() {
        return (this.crossFilteringSelectedPoints.length > 0 &&
            this.crossFilteringAllPoints.size !== this.crossFilteringSelectedPoints.length);
    }
    extractLineAreaCrossFilterSeries(series, params) {
        const [category] = params.categories;
        const getYKey = (yKey) => {
            if (this.standaloneChartType === 'area') {
                const lastSelectedChartId = params.getCrossFilteringContext().lastSelectedChartId;
                return lastSelectedChartId === params.chartId ? yKey + '-total' : yKey;
            }
            return yKey + '-total';
        };
        return series.map((s) => {
            s.yKey = getYKey(s.yKey);
            s.listeners = {
                nodeClick: (e) => {
                    const value = e.datum[s.xKey];
                    const multiSelection = e.event.metaKey || e.event.ctrlKey;
                    this.crossFilteringAddSelectedPoint(multiSelection, value);
                    this.crossFilterCallback(e);
                },
            };
            s.marker = {
                itemStyler: (p) => {
                    const value = p.datum[category.id];
                    return {
                        fill: p.highlighted ? 'yellow' : p.fill,
                        size: p.highlighted ? 14 : this.crossFilteringPointSelected(value) ? 8 : 0,
                    };
                },
            };
            if (this.standaloneChartType === 'area') {
                s.fillOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1;
            }
            if (this.standaloneChartType === 'line') {
                s.strokeOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1;
            }
            return s;
        });
    }
    getCrossFilterData(params) {
        this.crossFilteringAllPoints.clear();
        const [category] = params.categories;
        const colId = params.fields[0].colId;
        const filteredOutColId = `${colId}-filtered-out`;
        const lastSelectedChartId = params.getCrossFilteringContext().lastSelectedChartId;
        return params.data.map((d) => {
            const value = d[category.id];
            this.crossFilteringAllPoints.add(value);
            const pointSelected = this.crossFilteringPointSelected(value);
            if (this.standaloneChartType === 'area' && lastSelectedChartId === params.chartId) {
                d[`${colId}-total`] = pointSelected ? d[colId] : d[colId] + d[filteredOutColId];
            }
            if (this.standaloneChartType === 'line') {
                d[`${colId}-total`] = pointSelected ? d[colId] : d[colId] + d[filteredOutColId];
            }
            return d;
        });
    }
    crossFilteringAddSelectedPoint(multiSelection, value) {
        multiSelection ? this.crossFilteringSelectedPoints.push(value) : (this.crossFilteringSelectedPoints = [value]);
    }
    isHorizontal(commonChartOptions) {
        const seriesType = this.standaloneChartType;
        if (seriesType !== 'waterfall' && seriesType !== 'box-plot' && seriesType !== 'range-bar') {
            return false;
        }
        const theme = commonChartOptions.theme;
        const isHorizontal = (theme) => {
            const direction = theme?.overrides?.[seriesType]?.series?.direction;
            if (direction != null) {
                return direction === 'horizontal';
            }
            if (typeof theme?.baseTheme === 'object') {
                return isHorizontal(theme.baseTheme);
            }
            return false;
        };
        return isHorizontal(theme);
    }
}
exports.CartesianChartProxy = CartesianChartProxy;


/***/ }),

/***/ 1051:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistogramChartProxy = void 0;
const cartesianChartProxy_1 = __webpack_require__(8631);
class HistogramChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const firstField = params.fields[0]; // multiple series are not supported!
        return [
            {
                type: this.standaloneChartType,
                xKey: firstField.colId,
                xName: firstField.displayName,
                yName: this.chartProxyParams.translate('histogramFrequency'),
                areaPlot: false, // only constant width is supported via integrated charts
            },
        ];
    }
    getAxes(_params) {
        return [
            {
                type: 'number',
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
    }
}
exports.HistogramChartProxy = HistogramChartProxy;


/***/ }),

/***/ 9235:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineChartProxy = void 0;
const cartesianChartProxy_1 = __webpack_require__(8631);
class LineChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const axes = [
            {
                type: this.getXAxisType(params),
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
        // Add a default label formatter to show '%' for normalized charts if none is provided
        if (this.isNormalised()) {
            const numberAxis = axes[1];
            numberAxis.label = { ...numberAxis.label, formatter: (params) => Math.round(params.value) + '%' };
        }
        return axes;
    }
    getSeries(params) {
        const [category] = params.categories;
        const stacked = ['normalizedLine', 'stackedLine'].includes(this.chartType);
        const series = params.fields.map((f) => ({
            type: this.standaloneChartType,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName,
            normalizedTo: stacked && this.isNormalised() ? 100 : undefined,
            stacked,
        }));
        return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(series, params) : series;
    }
    isNormalised() {
        const normalisedCharts = ['normalizedLine'];
        return !this.crossFiltering && normalisedCharts.includes(this.chartType);
    }
}
exports.LineChartProxy = LineChartProxy;


/***/ }),

/***/ 7015:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterChartProxy = void 0;
const chartDataModel_1 = __webpack_require__(8592);
const cartesianChartProxy_1 = __webpack_require__(8631);
class ScatterChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(_params) {
        return [
            {
                type: 'number',
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
    }
    getSeries(params) {
        const [category] = params.categories;
        const paired = this.isPaired();
        const seriesDefinitions = this.getSeriesDefinitions(params.fields, paired);
        const labelFieldDefinition = category.id === chartDataModel_1.DEFAULT_CHART_CATEGORY ? undefined : category;
        const series = seriesDefinitions.map((seriesDefinition) => {
            if (seriesDefinition?.sizeField) {
                const opts = {
                    type: 'bubble',
                    xKey: seriesDefinition.xField.colId,
                    xName: seriesDefinition.xField.displayName ?? undefined,
                    yKey: seriesDefinition.yField.colId,
                    yName: seriesDefinition.yField.displayName ?? undefined,
                    title: `${seriesDefinition.yField.displayName} vs ${seriesDefinition.xField.displayName}`,
                    sizeKey: seriesDefinition.sizeField.colId,
                    sizeName: seriesDefinition.sizeField.displayName ?? '',
                    labelKey: labelFieldDefinition ? labelFieldDefinition.id : seriesDefinition.yField.colId,
                    labelName: labelFieldDefinition ? labelFieldDefinition.name : undefined,
                };
                return opts;
            }
            const opts = {
                type: 'scatter',
                xKey: seriesDefinition.xField.colId,
                xName: seriesDefinition.xField.displayName ?? undefined,
                yKey: seriesDefinition.yField.colId,
                yName: seriesDefinition.yField.displayName ?? undefined,
                title: `${seriesDefinition.yField.displayName} vs ${seriesDefinition.xField.displayName}`,
                labelKey: labelFieldDefinition ? labelFieldDefinition.id : seriesDefinition.yField.colId,
                labelName: labelFieldDefinition ? labelFieldDefinition.name : undefined,
            };
            return opts;
        });
        return this.crossFiltering ? this.extractCrossFilterSeries(series, params) : series;
    }
    extractCrossFilterSeries(series, params) {
        const { data } = params;
        const palette = this.getChartPalette();
        const filteredOutKey = (key) => `${key}-filtered-out`;
        const calcMarkerDomain = (data, sizeKey) => {
            const markerDomain = [Infinity, -Infinity];
            if (sizeKey != null) {
                for (const datum of data) {
                    const value = datum[sizeKey] ?? datum[filteredOutKey(sizeKey)];
                    if (value < markerDomain[0]) {
                        markerDomain[0] = value;
                    }
                    if (value > markerDomain[1]) {
                        markerDomain[1] = value;
                    }
                }
            }
            if (markerDomain[0] <= markerDomain[1]) {
                return markerDomain;
            }
            return undefined;
        };
        const updatePrimarySeries = (series, idx) => {
            const fill = palette?.fills?.[idx];
            const stroke = palette?.strokes?.[idx];
            let markerDomain = undefined;
            if (series.type === 'bubble') {
                const { sizeKey } = series;
                markerDomain = calcMarkerDomain(data, sizeKey);
            }
            return {
                ...series,
                fill,
                stroke,
                domain: markerDomain,
                highlightStyle: { item: { fill: 'yellow' } },
                listeners: {
                    ...series.listeners,
                    nodeClick: this.crossFilterCallback,
                },
            };
        };
        const updateFilteredOutSeries = (series) => {
            const { yKey, xKey } = series;
            let alteredSizeKey = {};
            if (series.type === 'bubble') {
                alteredSizeKey = { sizeKey: filteredOutKey(series.sizeKey) };
            }
            return {
                ...series,
                ...alteredSizeKey,
                yKey: filteredOutKey(yKey),
                xKey: filteredOutKey(xKey),
                fillOpacity: 0.3,
                strokeOpacity: 0.3,
                showInLegend: false,
                listeners: {
                    ...series.listeners,
                    nodeClick: (e) => {
                        const value = e.datum[filteredOutKey(xKey)];
                        // Need to remove the `-filtered-out` suffixes from the event so that
                        // upstream processing maps the event correctly onto grid column ids.
                        const filterableEvent = {
                            ...e,
                            xKey,
                            datum: { ...e.datum, [xKey]: value },
                        };
                        this.crossFilterCallback(filterableEvent);
                    },
                },
            };
        };
        const updatedSeries = series.map(updatePrimarySeries);
        return [...updatedSeries, ...updatedSeries.map(updateFilteredOutSeries)];
    }
    getSeriesDefinitions(fields, paired) {
        if (fields.length < 2) {
            return [];
        }
        const isBubbleChart = this.chartType === 'bubble';
        if (paired) {
            if (isBubbleChart) {
                return fields
                    .map((currentXField, i) => i % 3 === 0
                    ? {
                        xField: currentXField,
                        yField: fields[i + 1],
                        sizeField: fields[i + 2],
                    }
                    : null)
                    .filter((x) => x && x.yField && x.sizeField);
            }
            return fields
                .map((currentXField, i) => i % 2 === 0
                ? {
                    xField: currentXField,
                    yField: fields[i + 1],
                }
                : null)
                .filter((x) => x && x.yField);
        }
        const xField = fields[0];
        if (isBubbleChart) {
            return fields
                .map((yField, i) => i % 2 === 1
                ? {
                    xField,
                    yField,
                    sizeField: fields[i + 1],
                }
                : null)
                .filter((x) => x && x.sizeField);
        }
        return fields.filter((value, i) => i > 0).map((yField) => ({ xField, yField }));
    }
}
exports.ScatterChartProxy = ScatterChartProxy;


/***/ }),

/***/ 9303:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaterfallChartProxy = void 0;
const cartesianChartProxy_1 = __webpack_require__(8631);
class WaterfallChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params, commonChartOptions) {
        return [
            {
                type: this.getXAxisType(params),
                position: this.isHorizontal(commonChartOptions) ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: this.isHorizontal(commonChartOptions) ? 'bottom' : 'left',
            },
        ];
    }
    getSeries(params) {
        const [category] = params.categories;
        const [firstField] = params.fields;
        const firstSeries = {
            type: this.standaloneChartType,
            xKey: category.id,
            xName: category.name,
            yKey: firstField.colId,
            yName: firstField.displayName ?? undefined,
        };
        return [firstSeries]; // waterfall only supports a single series!
    }
}
exports.WaterfallChartProxy = WaterfallChartProxy;


/***/ }),

/***/ 6738:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartProxy = void 0;
const integration_1 = __webpack_require__(9687);
const object_1 = __webpack_require__(2210);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartTheme_1 = __webpack_require__(8987);
class ChartProxy {
    constructor(chartProxyParams) {
        this.chartProxyParams = chartProxyParams;
        this.clearThemeOverrides = false;
        this.agChartsExports = chartProxyParams.agChartsExports;
        this.chart = chartProxyParams.chartInstance;
        this.chartType = chartProxyParams.chartType;
        this.crossFiltering = chartProxyParams.crossFiltering;
        this.crossFilterCallback = chartProxyParams.crossFilterCallback;
        this.standaloneChartType = (0, seriesTypeMapper_1.getSeriesType)(this.chartType);
        if (this.chart == null) {
            this.chart = chartProxyParams.agChartsExports.create(this.getCommonChartOptions());
        }
        else {
            // On chart change, reset formatting panel changes.
            this.clearThemeOverrides = true;
        }
    }
    crossFilteringReset() {
        // only required in cartesian charts
    }
    update(params) {
        this.getChartRef().update(this.getUpdateOptions(params, this.getCommonChartOptions(params.updatedOverrides)));
    }
    updateThemeOverrides(themeOverrides) {
        this.getChartRef().updateDelta({ theme: { overrides: themeOverrides } });
    }
    getChart() {
        return (0, integration_1.deproxy)(this.chart);
    }
    getChartRef() {
        return this.chart;
    }
    downloadChart(dimensions, fileName, fileFormat) {
        const { chart } = this;
        const rawChart = (0, integration_1.deproxy)(chart);
        const imageFileName = fileName || (rawChart.title ? rawChart.title.text : 'chart');
        const { width, height } = dimensions || {};
        chart.download({ width, height, fileName: imageFileName, fileFormat });
    }
    getChartImageDataURL(type) {
        return this.getChart().getCanvasDataURL(type);
    }
    getChartOptions() {
        return this.chart.getOptions();
    }
    getChartThemeOverrides() {
        const chartOptionsTheme = this.getChartOptions().theme;
        return chartOptionsTheme.overrides ?? {};
    }
    getChartPalette() {
        return this.agChartsExports._Theme.getChartTheme(this.getChartOptions().theme).palette;
    }
    setPaired(paired) {
        // Special handling to make scatter charts operate in paired mode by default, where
        // columns alternate between being X and Y (and size for bubble). In standard mode,
        // the first column is used for X and every other column is treated as Y
        // (or alternates between Y and size for bubble)
        const seriesType = (0, seriesTypeMapper_1.getSeriesType)(this.chartProxyParams.chartType);
        this.chart.updateDelta({ theme: { overrides: { [seriesType]: { paired } } } });
    }
    isPaired() {
        const seriesType = (0, seriesTypeMapper_1.getSeriesType)(this.chartProxyParams.chartType);
        return (0, object_1.get)(this.getChartThemeOverrides(), `${seriesType}.paired`, true);
    }
    lookupCustomChartTheme(themeName) {
        return (0, chartTheme_1.lookupCustomChartTheme)(this.chartProxyParams, themeName);
    }
    getSeriesGroupType() {
        return undefined;
    }
    transformCategoryData(data, categoryKey) {
        // replace the values for the selected category with a complex object to allow for duplicated categories
        return data.map((d, index) => {
            const value = d[categoryKey];
            const valueString = value && value.toString ? value.toString() : '';
            const datum = { ...d };
            datum[categoryKey] = { id: index, value, toString: () => valueString };
            return datum;
        });
    }
    getCommonChartOptions(updatedOverrides) {
        // Only apply active overrides if chart is initialised.
        const existingOptions = (this.clearThemeOverrides ? {} : this.chart?.getOptions() ?? {});
        const formattingPanelOverrides = this.chart != null ? this.getActiveFormattingPanelOverrides() : undefined;
        this.clearThemeOverrides = false;
        const theme = (0, chartTheme_1.createAgChartTheme)(this.chartProxyParams, this, this.agChartsExports.isEnterprise, this.getChartThemeDefaults(), updatedOverrides ?? formattingPanelOverrides);
        const newOptions = {
            ...existingOptions,
            mode: 'integrated',
        };
        newOptions.theme = theme;
        newOptions.container = this.chartProxyParams.parentElement;
        return newOptions;
    }
    getChartThemeDefaults() {
        const seriesOverrides = this.getSeriesChartThemeDefaults();
        const seriesChartOptions = seriesOverrides
            ? {
                [this.standaloneChartType]: seriesOverrides,
            }
            : {};
        const crosshair = {
            enabled: true,
            snap: true,
            label: {
                enabled: false,
            },
        };
        const common = this.agChartsExports.isEnterprise
            ? {
                zoom: {
                    enabled: true,
                },
                animation: {
                    enabled: true,
                    duration: 500,
                },
                axes: {
                    number: { crosshair },
                    category: { crosshair },
                    log: { crosshair },
                    time: { crosshair },
                },
            }
            : {};
        common.minHeight = 0;
        common.minWidth = 0;
        common.navigator = {
            enabled: false,
        };
        return {
            common,
            ...seriesChartOptions,
        };
    }
    getSeriesChartThemeDefaults() {
        return undefined;
    }
    getActiveFormattingPanelOverrides() {
        if (this.clearThemeOverrides) {
            return {};
        }
        const inUseTheme = this.chart?.getOptions().theme;
        return inUseTheme?.overrides ?? {};
    }
    destroy({ keepChartInstance = false } = {}) {
        if (keepChartInstance) {
            // Reset Charts animation state, so that future updates to this re-used chart instance
            // behave as-if the chart is brand new. When switching chartTypes, this means we hide
            // the fact we are reusing the chart instance; the user sees a new chart which behaves
            // as-if it is a completely new and distinct chart instance.
            this.chart.resetAnimations();
            return this.chart;
        }
        this.destroyChart();
    }
    destroyChart() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = undefined;
        }
    }
}
exports.ChartProxy = ChartProxy;


/***/ }),

/***/ 8987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lookupCustomChartTheme = exports.isStockTheme = exports.createAgChartTheme = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const axisTypeMapper_1 = __webpack_require__(2753);
const object_1 = __webpack_require__(2210);
const seriesTypeMapper_1 = __webpack_require__(4237);
function createAgChartTheme(chartProxyParams, proxy, isEnterprise, chartThemeDefaults, updatedOverrides) {
    const { chartOptionsToRestore, chartPaletteToRestore, chartThemeToRestore, agChartsExports } = chartProxyParams;
    const themeName = getSelectedTheme(chartProxyParams);
    const stockTheme = isStockTheme(themeName, agChartsExports._Theme);
    const rootTheme = stockTheme
        ? { baseTheme: themeName }
        : lookupCustomChartTheme(chartProxyParams, themeName) ?? {};
    const gridOptionsThemeOverrides = chartProxyParams.getGridOptionsChartThemeOverrides();
    const apiThemeOverrides = chartProxyParams.apiChartThemeOverrides;
    const standaloneChartType = (0, seriesTypeMapper_1.getSeriesType)(chartProxyParams.chartType);
    const crossFilteringOverrides = chartProxyParams.crossFiltering
        ? createCrossFilterThemeOverrides(proxy, chartProxyParams, standaloneChartType)
        : undefined;
    const isTitleEnabled = () => {
        const isTitleEnabled = (obj) => {
            if (!obj) {
                return false;
            }
            return Object.keys(obj).some((key) => (0, object_1.get)(obj[key], 'title.enabled', false));
        };
        return isTitleEnabled(gridOptionsThemeOverrides) || isTitleEnabled(apiThemeOverrides);
    };
    // Overrides in ascending precedence ordering.
    const overrides = [
        stockTheme ? inbuiltStockThemeOverrides(chartProxyParams, isEnterprise, isTitleEnabled()) : undefined,
        pieAndDonutOverrides(),
        chartThemeDefaults,
        crossFilteringOverrides,
        gridOptionsThemeOverrides,
        apiThemeOverrides,
        { ...(chartOptionsToRestore ?? {}) },
        updatedOverrides,
    ];
    // Recursively nest theme overrides so they are applied with correct precedence in
    // Standalone Charts - this is an undocumented feature.
    // Outermost theme overrides will be the formatting panel configured values, so they are
    // differentiated from grid-config and inbuilt overrides.
    const theme = overrides
        .filter((v) => !!v)
        .reduce((r, n) => ({
        baseTheme: r,
        overrides: n,
    }), rootTheme);
    // Avoid explicitly setting the `theme.palette` property unless we're using the restored theme
    // AND the palette is actually different.
    if (chartPaletteToRestore && themeName === chartThemeToRestore) {
        const rootThemePalette = chartProxyParams.agChartsExports._Theme.getChartTheme(rootTheme).palette;
        if (!isIdenticalPalette(chartPaletteToRestore, rootThemePalette)) {
            theme.palette = chartPaletteToRestore;
        }
    }
    return theme;
}
exports.createAgChartTheme = createAgChartTheme;
function isIdenticalPalette(paletteA, paletteB) {
    const arrayCompare = (arrA, arrB) => {
        if (arrA === arrB)
            return true;
        if (arrA?.length !== arrB?.length)
            return false;
        return arrA?.every((v, i) => v === arrB?.[i]) ?? false;
    };
    return arrayCompare(paletteA.fills, paletteB.fills) && arrayCompare(paletteA.strokes, paletteB.strokes);
}
function isStockTheme(themeName, theme) {
    return Object.keys(theme.themes).includes(themeName);
}
exports.isStockTheme = isStockTheme;
function createCrossFilterThemeOverrides(proxy, chartProxyParams, seriesType) {
    const legend = {
        listeners: {
            legendItemClick: (e) => {
                const chart = proxy.getChart();
                const eligibleSeriesIds = [e.seriesId, `${e.seriesId}-filtered-out`];
                chart.series
                    .filter((s) => eligibleSeriesIds.includes(s.id))
                    .forEach((s) => s.toggleSeriesItem(undefined, 'category', e.itemId, undefined));
            },
        },
    };
    return {
        [seriesType]: {
            tooltip: {
                delay: 500,
            },
            legend,
            listeners: {
                click: (e) => chartProxyParams.crossFilterCallback(e, true),
            },
        },
    };
}
const STATIC_INBUILT_STOCK_THEME_AXES_OVERRIDES = axisTypeMapper_1.ALL_AXIS_TYPES.reduce((r, n) => ({ ...r, [n]: { title: { _enabledFromTheme: true } } }), {});
function inbuiltStockThemeOverrides(params, isEnterprise, titleEnabled) {
    const extraPadding = params.getExtraPaddingDirections();
    return {
        common: {
            ...(isEnterprise ? { animation: { duration: 500 } } : undefined),
            axes: STATIC_INBUILT_STOCK_THEME_AXES_OVERRIDES,
            padding: {
                // don't add extra padding when a title is present!
                top: !titleEnabled && extraPadding.includes('top') ? 40 : 20,
                right: extraPadding.includes('right') ? 30 : 20,
                bottom: extraPadding.includes('bottom') ? 40 : 20,
                left: extraPadding.includes('left') ? 30 : 20,
            },
            suppressFieldDotNotation: true,
        },
    };
}
function pieAndDonutOverrides() {
    return {
        pie: {
            series: {
                title: { _enabledFromTheme: true },
                calloutLabel: { _enabledFromTheme: true },
                sectorLabel: {
                    enabled: false,
                    _enabledFromTheme: true,
                },
            },
        },
        donut: {
            series: {
                title: { _enabledFromTheme: true },
                calloutLabel: { _enabledFromTheme: true },
                sectorLabel: {
                    enabled: false,
                    _enabledFromTheme: true,
                },
            },
        },
    };
}
function getSelectedTheme(chartProxyParams) {
    let chartThemeName = chartProxyParams.getChartThemeName();
    const availableThemes = chartProxyParams.getChartThemes();
    if (!availableThemes.includes(chartThemeName)) {
        chartThemeName = availableThemes[0];
    }
    return chartThemeName;
}
function lookupCustomChartTheme(chartProxyParams, name) {
    const { customChartThemes } = chartProxyParams;
    const customChartTheme = customChartThemes && customChartThemes[name];
    if (!customChartTheme) {
        (0, ag_grid_community_1._warn)(140, { name });
    }
    return customChartTheme;
}
exports.lookupCustomChartTheme = lookupCustomChartTheme;


/***/ }),

/***/ 8995:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComboChartProxy = void 0;
const seriesTypeMapper_1 = __webpack_require__(4237);
const cartesianChartProxy_1 = __webpack_require__(8631);
class ComboChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const fields = params ? params.fields : [];
        const fieldsMap = new Map(fields.map((f) => [f.colId, f]));
        const { primaryYKeys, secondaryYKeys } = this.getYKeys(fields, params.seriesChartTypes);
        const axes = [
            {
                type: this.getXAxisType(params),
                position: 'bottom',
            },
        ];
        if (primaryYKeys.length > 0) {
            axes.push({
                type: 'number',
                keys: primaryYKeys,
                position: 'left',
            });
        }
        if (secondaryYKeys.length > 0) {
            secondaryYKeys.forEach((secondaryYKey) => {
                const field = fieldsMap.get(secondaryYKey);
                const secondaryAxisIsVisible = field && field.colId === secondaryYKey;
                if (!secondaryAxisIsVisible) {
                    return;
                }
                const secondaryAxisOptions = {
                    type: 'number',
                    keys: [secondaryYKey],
                    position: 'right',
                };
                axes.push(secondaryAxisOptions);
            });
        }
        return axes;
    }
    getSeries(params) {
        const { fields, seriesChartTypes } = params;
        const [category] = params.categories;
        return fields.map((field) => {
            const seriesChartType = seriesChartTypes.find((s) => s.colId === field.colId);
            if (seriesChartType) {
                const chartType = seriesChartType.chartType;
                const grouped = ['groupedColumn', 'groupedBar'].includes(chartType);
                const groupedOpts = grouped ? { grouped: true } : {};
                return {
                    type: (0, seriesTypeMapper_1.getSeriesType)(chartType),
                    xKey: category.id,
                    yKey: field.colId,
                    yName: field.displayName,
                    stacked: ['stackedArea', 'stackedColumn'].includes(chartType),
                    ...groupedOpts,
                };
            }
        });
    }
    getYKeys(fields, seriesChartTypes) {
        const primaryYKeys = [];
        const secondaryYKeys = [];
        fields.forEach((field) => {
            const colId = field.colId;
            const seriesChartType = seriesChartTypes.find((s) => s.colId === colId);
            if (seriesChartType) {
                seriesChartType.secondaryAxis ? secondaryYKeys.push(colId) : primaryYKeys.push(colId);
            }
        });
        return { primaryYKeys, secondaryYKeys };
    }
}
exports.ComboChartProxy = ComboChartProxy;


/***/ }),

/***/ 7879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnterpriseChartProxyFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const histogramChartProxy_1 = __webpack_require__(1051);
const waterfallChartProxy_1 = __webpack_require__(9303);
const hierarchicalChartProxy_1 = __webpack_require__(3511);
const polarChartProxy_1 = __webpack_require__(9899);
const heatmapChartProxy_1 = __webpack_require__(7562);
const boxPlotChartProxy_1 = __webpack_require__(5413);
const rangeChartProxy_1 = __webpack_require__(6926);
class EnterpriseChartProxyFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'enterpriseChartProxyFactory';
    }
    createChartProxy(chartProxyParams) {
        switch (chartProxyParams.chartType) {
            case 'histogram':
                return new histogramChartProxy_1.HistogramChartProxy(chartProxyParams);
            case 'radarLine':
            case 'radarArea':
            case 'nightingale':
            case 'radialColumn':
            case 'radialBar':
                return new polarChartProxy_1.PolarChartProxy(chartProxyParams);
            case 'rangeBar':
            case 'rangeArea':
                return new rangeChartProxy_1.RangeChartProxy(chartProxyParams);
            case 'boxPlot':
                return new boxPlotChartProxy_1.BoxPlotChartProxy(chartProxyParams);
            case 'treemap':
            case 'sunburst':
                return new hierarchicalChartProxy_1.HierarchicalChartProxy(chartProxyParams);
            case 'heatmap':
                return new heatmapChartProxy_1.HeatmapChartProxy(chartProxyParams);
            case 'waterfall':
                return new waterfallChartProxy_1.WaterfallChartProxy(chartProxyParams);
        }
        return undefined;
    }
}
exports.EnterpriseChartProxyFactory = EnterpriseChartProxyFactory;


/***/ }),

/***/ 3511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HierarchicalChartProxy = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const chartProxy_1 = __webpack_require__(6738);
const hierarchicalChartUtils_1 = __webpack_require__(6326);
class HierarchicalChartProxy extends chartProxy_1.ChartProxy {
    constructor(chartProxyParams) {
        super(chartProxyParams);
    }
    getUpdateOptions(params, commonChartOptions) {
        const { fields } = params;
        // Hierarchical charts support up to two input series, corresponding to size and color respectively
        const [sizeField, colorField] = fields;
        return {
            ...commonChartOptions,
            series: this.getSeries(sizeField, colorField),
            data: this.getData(params, sizeField, colorField),
        };
    }
    getSeriesChartThemeDefaults() {
        return {
            gradientLegend: {
                gradient: {
                    preferredLength: 200,
                },
            },
        };
    }
    getSeries(sizeField, colorField) {
        return [
            {
                type: this.standaloneChartType,
                labelKey: hierarchicalChartUtils_1.CATEGORY_LABEL_KEY,
                // Size and color fields are inferred from the range data
                sizeKey: sizeField?.colId,
                sizeName: sizeField?.displayName ?? undefined,
                colorKey: colorField?.colId,
                colorName: colorField?.displayName ?? undefined,
            },
        ];
    }
    getData(params, sizeField, colorField) {
        const { categories, data, groupData, grouping: isGrouped } = params;
        if (isGrouped) {
            const processedData = colorField
                ? data.concat(groupData?.map((groupDatum) => {
                    const newDatum = { ...groupDatum };
                    delete newDatum[sizeField.colId];
                    return newDatum;
                }) ?? [])
                : data;
            return (0, hierarchicalChartUtils_1.createAutoGroupHierarchy)(processedData, (item) => item[ag_grid_community_1.GROUP_AUTO_COLUMN_ID]?.labels ?? null);
        }
        else {
            const categoryKeys = categories.map(({ id }) => id);
            return (0, hierarchicalChartUtils_1.createCategoryHierarchy)(data, categoryKeys);
        }
    }
}
exports.HierarchicalChartProxy = HierarchicalChartProxy;


/***/ }),

/***/ 6326:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAutoGroupHierarchy = exports.createCategoryHierarchy = exports.CATEGORY_LABEL_KEY = void 0;
exports.CATEGORY_LABEL_KEY = 'AG-GRID-DEFAULT-LABEL-KEY';
function createCategoryHierarchy(data, categoryKeys) {
    const hierarchy = buildNestedHierarchy(data, getItemDepth, getItemCategoryLabel);
    return formatCategoryHierarchy(hierarchy);
    function getItemDepth(_item) {
        return categoryKeys.length;
    }
    function getItemCategoryLabel(item, categoryIndex) {
        const categoryKey = categoryKeys[categoryIndex];
        const categoryValue = item[categoryKey];
        return getCategoryLabel(categoryValue);
    }
    function getCategoryLabel(value) {
        if (value == null)
            return null;
        return String(value);
    }
}
exports.createCategoryHierarchy = createCategoryHierarchy;
function createAutoGroupHierarchy(data, getItemLabels) {
    const hierarchy = buildNestedHierarchy(data, getItemDepth, getItemGroupLabel);
    return formatCategoryHierarchy(hierarchy);
    function getItemDepth(item) {
        return getItemLabels(item)?.length ?? 0;
    }
    function getItemGroupLabel(item, groupIndex) {
        const labels = getItemLabels(item);
        if (!labels)
            return null;
        // Autogroup label values are ordered from the leaf outwards
        const labelIndex = labels.length - 1 - groupIndex;
        return labels[labelIndex];
    }
}
exports.createAutoGroupHierarchy = createAutoGroupHierarchy;
/* Utility functions for building and formatting nested category hierarchies */
/** Convert an abstract nested hierarchy structure into an ag-charts-compatible 'category-grouped' data structure */
function formatCategoryHierarchy(hierarchy, key = null, isChild) {
    const { depth, rootValues, value, children: inputChildren } = hierarchy;
    if (rootValues) {
        return rootValues.map((item) => ({ [exports.CATEGORY_LABEL_KEY]: key, ...item }));
    }
    else if (depth === 0) {
        return [{ [exports.CATEGORY_LABEL_KEY]: key, ...value }];
    }
    const children = [];
    for (const [childKey, childHierarchy] of inputChildren.entries()) {
        children.push(...formatCategoryHierarchy(childHierarchy, childKey, true));
    }
    return isChild
        ? [
            {
                [exports.CATEGORY_LABEL_KEY]: key,
                children,
                ...(value ?? {}),
            },
        ]
        : children;
}
/** Build an arbitrarily deeply nested hierarchy from a flat list of input items */
function buildNestedHierarchy(data, getItemDepth, getItemGroupKey) {
    const hierarchy = { depth: 0, children: new Map() };
    data.forEach((item) => {
        const itemDepth = getItemDepth(item);
        createNestedItemHierarchy(item, itemDepth, getItemGroupKey, 0, hierarchy);
    });
    return hierarchy;
    function createNestedItemHierarchy(item, itemDepth, getItemGroupKey, currentDepth, hierarchy) {
        if (currentDepth === itemDepth) {
            if (currentDepth === 0) {
                if (!hierarchy.rootValues) {
                    hierarchy.rootValues = [];
                }
                hierarchy.rootValues.push(item);
            }
            else {
                hierarchy.value = item;
            }
            return hierarchy;
        }
        else {
            const key = getItemGroupKey(item, currentDepth);
            const existingChildHierarchy = hierarchy.children.get(key);
            const childHierarchy = createNestedItemHierarchy(item, itemDepth, getItemGroupKey, currentDepth + 1, existingChildHierarchy || { depth: 0, children: new Map() });
            hierarchy.children.set(key, childHierarchy);
            hierarchy.depth = Math.max(1 + childHierarchy.depth, hierarchy.depth);
            return hierarchy;
        }
    }
}


/***/ }),

/***/ 4104:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PieChartProxy = void 0;
const chartProxy_1 = __webpack_require__(6738);
function calculateOffsets(offset) {
    const outerRadiusOffset = offset.currentOffset;
    offset.currentOffset -= offset.offsetAmount;
    const innerRadiusOffset = offset.currentOffset;
    offset.currentOffset -= offset.offsetAmount;
    return { outerRadiusOffset, innerRadiusOffset };
}
class PieChartProxy extends chartProxy_1.ChartProxy {
    constructor(params) {
        super(params);
    }
    getUpdateOptions(params, commonChartOptions) {
        return {
            ...commonChartOptions,
            data: this.crossFiltering ? this.getCrossFilterData(params) : params.data,
            series: this.getSeries(params),
        };
    }
    getSeries(params) {
        const [category] = params.categories;
        const numFields = params.fields.length;
        const offset = {
            currentOffset: 0,
            offsetAmount: numFields > 1 ? 20 : 40,
        };
        const series = this.getFields(params).map((f) => {
            // options shared by 'pie' and 'donut' charts
            const options = {
                type: this.standaloneChartType,
                angleKey: f.colId,
                angleName: f.displayName,
                sectorLabelKey: f.colId,
                calloutLabelName: category.name,
                calloutLabelKey: category.id,
            };
            if (this.chartType === 'donut' || this.chartType === 'doughnut') {
                const { outerRadiusOffset, innerRadiusOffset } = calculateOffsets(offset);
                const title = f.displayName
                    ? {
                        title: { text: f.displayName, showInLegend: numFields > 1 },
                    }
                    : undefined;
                // augment shared options with 'donut' specific options
                return {
                    ...options,
                    type: 'donut',
                    outerRadiusOffset,
                    innerRadiusOffset,
                    ...title,
                    calloutLine: {
                        colors: this.getChartPalette()?.strokes,
                    },
                };
            }
            return options;
        });
        return this.crossFiltering ? this.extractCrossFilterSeries(series) : series;
    }
    getCrossFilterData(params) {
        const colId = params.fields[0].colId;
        const filteredOutColId = `${colId}-filtered-out`;
        return params.data.map((d) => {
            const total = d[colId] + d[filteredOutColId];
            d[`${colId}-total`] = total;
            d[filteredOutColId] = 1; // normalise to 1
            d[colId] = d[colId] / total; // fraction of 1
            return d;
        });
    }
    extractCrossFilterSeries(series) {
        const palette = this.getChartPalette();
        const primaryOptions = (seriesOptions) => {
            return {
                ...seriesOptions,
                legendItemKey: seriesOptions.calloutLabelKey,
                calloutLabel: { enabled: false },
                highlightStyle: { item: { fill: undefined } },
                radiusKey: seriesOptions.angleKey,
                angleKey: seriesOptions.angleKey + '-total',
                radiusMin: 0,
                radiusMax: 1,
                listeners: {
                    nodeClick: this.crossFilterCallback,
                },
            };
        };
        const filteredOutOptions = (seriesOptions, angleKey) => {
            return {
                ...primaryOpts,
                radiusKey: angleKey + '-filtered-out',
                fills: this.changeOpacity(seriesOptions.fills ?? palette?.fills ?? [], 0.3),
                strokes: this.changeOpacity(seriesOptions.strokes ?? palette?.strokes ?? [], 0.3),
                showInLegend: false,
            };
        };
        // currently, only single 'donut' cross-filter series are supported
        const primarySeries = series[0];
        // update primary series
        const angleKey = primarySeries.angleKey;
        const primaryOpts = primaryOptions(primarySeries);
        return [filteredOutOptions(primaryOptions(primarySeries), angleKey), primaryOpts];
    }
    getFields(params) {
        // pie charts only support a single series, donut charts support multiple series
        return this.chartType === 'pie' ? params.fields.slice(0, 1) : params.fields;
    }
    changeOpacity(fills, alpha) {
        const Color = this.agChartsExports._Util.Color;
        return fills.map((fill) => {
            const c = Color.fromString(fill);
            return new Color(c.r, c.g, c.b, alpha).toHexString();
        });
    }
}
exports.PieChartProxy = PieChartProxy;


/***/ }),

/***/ 9899:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PolarChartProxy = void 0;
const chartProxy_1 = __webpack_require__(6738);
class PolarChartProxy extends chartProxy_1.ChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(_) {
        const radialBar = this.standaloneChartType === 'radial-bar';
        return [
            { type: radialBar ? 'angle-number' : 'angle-category' },
            { type: radialBar ? 'radius-category' : 'radius-number' },
        ];
    }
    getSeries(params) {
        const { fields, categories, seriesGroupType } = params;
        const [category] = categories;
        const radialBar = this.standaloneChartType === 'radial-bar';
        const seriesGroupTypeOptions = this.getSeriesGroupTypeOptions(seriesGroupType);
        return fields.map((f) => ({
            type: this.standaloneChartType,
            angleKey: radialBar ? f.colId : category.id,
            angleName: radialBar ? f.displayName ?? undefined : category.name,
            radiusKey: radialBar ? category.id : f.colId,
            radiusName: radialBar ? category.name : f.displayName ?? undefined,
            ...seriesGroupTypeOptions,
        }));
    }
    getSeriesGroupType() {
        const standaloneChartType = this.standaloneChartType;
        if (!['nightingale', 'radial-bar', 'radial-column'].includes(standaloneChartType)) {
            return undefined;
        }
        const firstSeriesProperties = this.getChart().series?.[0]?.properties.toJson();
        const getStackedValue = () => (firstSeriesProperties.normalizedTo ? 'normalized' : 'stacked');
        if (standaloneChartType === 'nightingale') {
            return firstSeriesProperties.grouped ? 'grouped' : getStackedValue();
        }
        else {
            return firstSeriesProperties.stacked ? getStackedValue() : 'grouped';
        }
    }
    getUpdateOptions(params, commonChartOptions) {
        const axes = this.getAxes(params);
        return {
            ...commonChartOptions,
            data: this.getData(params, axes),
            axes,
            series: this.getSeries(params),
        };
    }
    getData(params, axes) {
        const isCategoryAxis = axes.some((axis) => axis.type === 'angle-category' || axis.type === 'radius-category');
        if (isCategoryAxis) {
            const [category] = params.categories;
            return this.transformCategoryData(params.data, category.id);
        }
        else {
            return params.data;
        }
    }
    getSeriesGroupTypeOptions(seriesGroupType) {
        if (!seriesGroupType) {
            return {};
        }
        return {
            grouped: seriesGroupType === 'grouped' || undefined,
            stacked: seriesGroupType !== 'grouped' || undefined,
            normalizedTo: seriesGroupType === 'normalized' ? 100 : undefined,
        };
    }
}
exports.PolarChartProxy = PolarChartProxy;


/***/ }),

/***/ 7562:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeatmapChartProxy = exports.HEATMAP_VALUE_KEY = exports.HEATMAP_SERIES_KEY = exports.HEATMAP_CATEGORY_KEY = void 0;
const array_1 = __webpack_require__(1480);
const chartProxy_1 = __webpack_require__(6738);
exports.HEATMAP_CATEGORY_KEY = 'AG-GRID-DEFAULT-HEATMAP-CATEGORY-KEY';
exports.HEATMAP_SERIES_KEY = 'AG-GRID-DEFAULT-HEATMAP-SERIES-KEY';
exports.HEATMAP_VALUE_KEY = 'AG-GRID-DEFAULT-HEATMAP-VALUE-KEY';
class HeatmapChartProxy extends chartProxy_1.ChartProxy {
    constructor(params) {
        super(params);
    }
    getUpdateOptions(params, commonChartOptions) {
        const xSeriesKey = exports.HEATMAP_SERIES_KEY;
        const xValueKey = exports.HEATMAP_VALUE_KEY;
        const yKey = exports.HEATMAP_CATEGORY_KEY;
        return {
            ...commonChartOptions,
            series: this.getSeries(params, xSeriesKey, xValueKey, yKey),
            data: this.getData(params, xSeriesKey, xValueKey, yKey),
        };
    }
    getSeries(params, xSeriesKey, xValueKey, yKey) {
        const [category] = params.categories;
        return [
            {
                type: this.standaloneChartType,
                // The axis keys reference synthetic fields based on the category values and series column names
                yKey,
                xKey: xSeriesKey,
                // The color key references a synthetic field based on the series column value for a specific cell
                colorKey: xValueKey,
                yName: category.name,
                // We don't know how to label the 'x' series, as it is a synthetic series created from the set of all input columns
                // In future releases we may want to consider inferring the series label from column groupings etc
                xName: undefined,
                colorName: undefined,
            },
        ];
    }
    getData(params, xSeriesKey, xValueKey, yKey) {
        const [category] = params.categories;
        // Heatmap chart expects a flat array of data, with each row representing a single cell in the heatmap
        // This means we need to explode the list of input rows into their individual cells
        return (0, array_1.flatMap)(params.data, (datum, index) => {
            // We need to create a unique y value object for each row to prevent unintended category grouping
            // when there are multiple rows with the same category value
            const value = datum[category.id];
            const valueString = value == null ? '' : String(value);
            const yValue = { id: index, value, toString: () => valueString };
            // Return a flat list of output data items corresponding to each cell,
            // appending the synthetic series and category fields to the cell data
            return params.fields.map(({ colId, displayName }) => ({
                ...datum,
                [xSeriesKey]: displayName,
                [xValueKey]: datum[colId],
                [yKey]: yValue,
            }));
        });
    }
    getSeriesChartThemeDefaults() {
        return {
            gradientLegend: {
                gradient: {
                    preferredLength: 200,
                },
            },
            series: {
                tooltip: {
                    renderer: renderHeatmapTooltip,
                },
            },
        };
    }
}
exports.HeatmapChartProxy = HeatmapChartProxy;
function renderHeatmapTooltip(params) {
    const { xKey, yKey, colorKey, yName, datum } = params;
    const table = [
        { label: yName, value: datum[yKey] },
        { label: datum[xKey], value: colorKey && datum[colorKey] },
    ];
    return {
        title: '',
        data: table.map(({ label, value }) => ({ label: String(label), value: String(value) })),
    };
}


/***/ }),

/***/ 5413:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoxPlotChartProxy = void 0;
const statisticalChartProxy_1 = __webpack_require__(879);
class BoxPlotChartProxy extends statisticalChartProxy_1.StatisticalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const [category] = params.categories;
        return params.fields.map((field, seriesIndex) => ({
            type: this.standaloneChartType,
            // xKey/xName refer to category buckets
            xKey: category.id,
            xName: category.name,
            // yName is used to label the series
            yName: field.displayName ?? undefined,
            // custom field labels shown in the tooltip
            minName: 'Min',
            q1Name: 'Q1',
            medianName: 'Median',
            q3Name: 'Q3',
            maxName: 'Max',
            // generated 'synthetic fields' from getData()
            minKey: `min:${seriesIndex}`,
            q1Key: `q1:${seriesIndex}`,
            medianKey: `median:${seriesIndex}`,
            q3Key: `q3:${seriesIndex}`,
            maxKey: `max:${seriesIndex}`,
        }));
    }
    getData(params) {
        return this.computeSeriesStatistics(params, (seriesValues) => {
            const sortedValues = seriesValues.sort((a, b) => a - b);
            return {
                min: sortedValues[0],
                q1: this.quantile(sortedValues, 0.25),
                median: this.quantile(sortedValues, 0.5),
                q3: this.quantile(sortedValues, 0.75),
                max: sortedValues[sortedValues.length - 1],
            };
        });
    }
    quantile(sortedValues, q) {
        const position = (sortedValues.length - 1) * q;
        const indexBelow = Math.floor(position);
        const aboveValue = position - indexBelow;
        if (sortedValues[indexBelow + 1] !== undefined) {
            return sortedValues[indexBelow] + aboveValue * (sortedValues[indexBelow + 1] - sortedValues[indexBelow]);
        }
        return sortedValues[indexBelow];
    }
}
exports.BoxPlotChartProxy = BoxPlotChartProxy;


/***/ }),

/***/ 6926:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeChartProxy = void 0;
const statisticalChartProxy_1 = __webpack_require__(879);
class RangeChartProxy extends statisticalChartProxy_1.StatisticalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const [category] = params.categories;
        return params.fields.map((field, seriesIndex) => ({
            type: this.standaloneChartType,
            // xKey/xName refer to category buckets
            xKey: category.id,
            xName: category.name,
            // yName is used to label the series
            yName: field.displayName ?? undefined,
            // custom field labels shown in the tooltip
            yLowName: 'Min',
            yHighName: 'Max',
            // generated 'synthetic fields' from getData()
            yLowKey: `min:${seriesIndex}`,
            yHighKey: `max:${seriesIndex}`,
        }));
    }
    getData(params) {
        return this.computeSeriesStatistics(params, (seriesValues) => {
            return {
                min: Math.min(...seriesValues),
                max: Math.max(...seriesValues),
            };
        });
    }
}
exports.RangeChartProxy = RangeChartProxy;


/***/ }),

/***/ 879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatisticalChartProxy = void 0;
const chartDataModel_1 = __webpack_require__(8592);
const cartesianChartProxy_1 = __webpack_require__(8631);
class StatisticalChartProxy extends cartesianChartProxy_1.CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params, commonChartOptions) {
        return [
            {
                type: this.getXAxisType(params),
                position: this.isHorizontal(commonChartOptions) ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: this.isHorizontal(commonChartOptions) ? 'bottom' : 'left',
            },
        ];
    }
    computeSeriesStatistics(params, computeStatsFn) {
        const { data, fields } = params;
        const [category] = params.categories;
        const categoryKey = category.id || chartDataModel_1.DEFAULT_CHART_CATEGORY;
        const groupedData = this.groupDataByCategory(categoryKey, data);
        return Array.from(groupedData).map(([categoryValue, categoryData]) => {
            const categoryResult = { [category.id]: categoryValue };
            fields.forEach((field, seriesIndex) => {
                // `null` & `NaN` values are omitted from calculations
                const seriesValues = categoryData
                    .map((datum) => datum[field.colId])
                    .filter((value) => typeof value === 'number' && !isNaN(value));
                Object.entries(computeStatsFn(seriesValues)).forEach(([statKey, value]) => {
                    const propertyKey = `${statKey}:${seriesIndex}`;
                    // when no data exists, stat properties are added to results with `null` values!
                    categoryResult[propertyKey] = seriesValues.length > 0 ? value : null;
                });
            });
            return categoryResult;
        });
    }
    groupDataByCategory(categoryKey, data) {
        const getCategory = (datum) => {
            if (categoryKey === chartDataModel_1.DEFAULT_CHART_CATEGORY) {
                return 1;
            }
            const categoryValue = datum[categoryKey];
            if (categoryValue === null || categoryValue === undefined) {
                return ''; // use a blank category for `null` or `undefined` values
            }
            return categoryValue instanceof Date ? categoryValue.getTime() : categoryValue;
        };
        return data.reduce((acc, datum) => {
            const category = getCategory(datum);
            const existingCategoryData = acc.get(category);
            if (existingCategoryData) {
                existingCategoryData.push(datum);
            }
            else {
                acc.set(category, [datum]);
            }
            return acc;
        }, new Map());
    }
}
exports.StatisticalChartProxy = StatisticalChartProxy;


/***/ }),

/***/ 9208:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartDatasource = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const chartDataModel_1 = __webpack_require__(8592);
class ChartDatasource extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.sortSvc = beans.sortSvc;
        this.gridRowModel = beans.rowModel;
        this.colModel = beans.colModel;
        this.valueSvc = beans.valueSvc;
        this.pivotResultCols = beans.pivotResultCols;
        this.rowNodeSorter = beans.rowNodeSorter;
        this.aggStage = beans.aggStage;
    }
    getData(params) {
        if (params.crossFiltering) {
            if (params.grouping) {
                (0, ag_grid_community_1._warn)(141);
                return { chartData: [], colNames: {} };
            }
            if (!(0, ag_grid_community_1._isClientSideRowModel)(this.gos)) {
                (0, ag_grid_community_1._warn)(142);
                return { chartData: [], colNames: {} };
            }
        }
        const isServerSide = (0, ag_grid_community_1._isServerSideRowModel)(this.gos);
        if (isServerSide && params.pivoting) {
            this.updatePivotKeysForSSRM();
        }
        const result = this.extractRowsFromGridRowModel(params);
        result.chartData = this.aggregateRowsByDimension(params, result.chartData);
        return result;
    }
    extractRowsFromGridRowModel(params) {
        const { crossFiltering, startRow, endRow, valueCols, dimensionCols, grouping } = params;
        let extractedRowData = [];
        const colNames = {};
        // maps used to keep track of expanded groups that need to be removed
        const groupNodeIndexes = {};
        const groupsToRemove = {};
        // only used when cross filtering
        let filteredNodes = {};
        let allRowNodes = [];
        let numRows;
        if (crossFiltering) {
            filteredNodes = this.getFilteredRowNodes();
            allRowNodes = this.getAllRowNodes();
            numRows = allRowNodes.length;
        }
        else {
            // make sure enough rows in range to chart. if user filters and less rows, then end row will be
            // the last displayed row, not where the range ends.
            const modelLastRow = this.gridRowModel.getRowCount() - 1;
            // inclusivity is wrong for end row, so can't detect 0 rows properly
            const hasNoRange = startRow === endRow && startRow === 0 && dimensionCols.length === 0 && valueCols.length === 0;
            if (hasNoRange) {
                numRows = 0;
            }
            else {
                const rangeLastRow = endRow >= 0 ? Math.min(endRow, modelLastRow) : modelLastRow;
                numRows = rangeLastRow - startRow + 1;
            }
        }
        if (numRows > 0) {
            valueCols.forEach((col) => {
                let colNamesArr = [];
                // pivot keys should be added first
                const pivotKeys = col.getColDef().pivotKeys;
                if (pivotKeys) {
                    colNamesArr = pivotKeys.slice();
                }
                // then add column header name to results
                const headerName = col.getColDef().headerName;
                if (headerName) {
                    colNamesArr.push(headerName);
                }
                // add array of column names to results
                if (colNamesArr.length > 0) {
                    colNames[col.getId()] = colNamesArr;
                }
            });
        }
        let numRemovedNodes = 0;
        for (let i = 0; i < numRows; i++) {
            const rowNode = crossFiltering ? allRowNodes[i] : this.gridRowModel.getRow(i + startRow);
            if (rowNode.footer || rowNode.detail) {
                numRemovedNodes++;
                continue;
            }
            const data = {};
            // first get data for dimensions columns
            dimensionCols.forEach((col) => {
                const colId = col.colId;
                const column = this.colModel.getCol(colId);
                if (column) {
                    const valueObject = this.valueSvc.getValue(column, rowNode);
                    // when grouping we also need to build up multi category labels for charts
                    if (grouping) {
                        const valueString = valueObject?.toString ? String(valueObject.toString()) : '';
                        // traverse parents to extract group label path
                        const labels = this.getGroupLabels(rowNode, valueString);
                        data[colId] = labels.slice().reverse();
                        // keep track of group node indexes, so they can be padded when other groups are expanded
                        if (rowNode.group) {
                            groupNodeIndexes[labels.toString()] = i - numRemovedNodes;
                        }
                        // if node (group or leaf) has parents then it is expanded and should be removed
                        const groupKey = labels.slice(1, labels.length).toString();
                        if (groupKey) {
                            groupsToRemove[groupKey] = groupNodeIndexes[groupKey];
                        }
                    }
                    else {
                        // leaf nodes can be directly added to dimension columns
                        data[colId] = valueObject;
                    }
                }
                else {
                    // introduce a default category when no dimensions exist with a value based off row index (+1)
                    data[chartDataModel_1.DEFAULT_CHART_CATEGORY] = i + 1;
                }
            });
            // then get data for value columns
            valueCols.forEach((col) => {
                const colId = col.getColId();
                if (crossFiltering) {
                    const filteredOutColId = colId + '-filtered-out';
                    // add data value to value column
                    const value = this.valueSvc.getValue(col, rowNode);
                    const actualValue = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;
                    if (filteredNodes[rowNode.id]) {
                        data[colId] = actualValue;
                        data[filteredOutColId] = params.aggFunc || params.isScatter ? undefined : 0;
                    }
                    else {
                        data[colId] = params.aggFunc || params.isScatter ? undefined : 0;
                        data[filteredOutColId] = actualValue;
                    }
                }
                else {
                    // add data value to value column
                    let value = this.valueSvc.getValue(col, rowNode);
                    // aggregated value
                    if (value && Object.prototype.hasOwnProperty.call(value, 'toString')) {
                        value = parseFloat(value.toString());
                    }
                    data[colId] = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;
                }
            });
            // add data to results
            extractedRowData.push(data);
        }
        let groupChartData;
        if (grouping) {
            const groupIndexesToRemove = Object.values(groupsToRemove);
            const allData = extractedRowData;
            extractedRowData = [];
            groupChartData = [];
            for (let i = 0; i < allData.length; i++) {
                (groupIndexesToRemove.includes(i) ? groupChartData : extractedRowData).push(allData[i]);
            }
        }
        return { chartData: extractedRowData, colNames, groupChartData };
    }
    aggregateRowsByDimension(params, dataFromGrid) {
        const dimensionCols = params.dimensionCols;
        if (!params.aggFunc || dimensionCols.length === 0) {
            return dataFromGrid;
        }
        const lastCol = (0, ag_grid_community_1._last)(dimensionCols);
        const lastColId = lastCol && lastCol.colId;
        const map = {};
        const dataAggregated = [];
        dataFromGrid.forEach((data) => {
            let currentMap = map;
            dimensionCols.forEach((col) => {
                const colId = col.colId;
                const key = data[colId];
                if (colId === lastColId) {
                    let groupItem = currentMap[key];
                    if (!groupItem) {
                        groupItem = { __children: [] };
                        dimensionCols.forEach((dimCol) => {
                            const dimColId = dimCol.colId;
                            groupItem[dimColId] = data[dimColId];
                        });
                        currentMap[key] = groupItem;
                        dataAggregated.push(groupItem);
                    }
                    groupItem.__children.push(data);
                }
                else {
                    // map of maps
                    if (!currentMap[key]) {
                        currentMap[key] = {};
                    }
                    currentMap = currentMap[key];
                }
            });
        });
        if (this.gos.assertModuleRegistered('SharedRowGrouping', 1)) {
            const aggStage = this.aggStage;
            dataAggregated.forEach((groupItem) => params.valueCols.forEach((col) => {
                if (params.crossFiltering) {
                    params.valueCols.forEach((valueCol) => {
                        const colId = valueCol.getColId();
                        // filtered data
                        const dataToAgg = groupItem.__children
                            .filter((child) => typeof child[colId] !== 'undefined')
                            .map((child) => child[colId]);
                        const aggResult = aggStage.aggregateValues(dataToAgg, params.aggFunc);
                        groupItem[valueCol.getId()] =
                            aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;
                        // filtered out data
                        const filteredOutColId = `${colId}-filtered-out`;
                        const dataToAggFiltered = groupItem.__children
                            .filter((child) => typeof child[filteredOutColId] !== 'undefined')
                            .map((child) => child[filteredOutColId]);
                        const aggResultFiltered = aggStage.aggregateValues(dataToAggFiltered, params.aggFunc);
                        groupItem[filteredOutColId] =
                            aggResultFiltered && typeof aggResultFiltered.value !== 'undefined'
                                ? aggResultFiltered.value
                                : aggResultFiltered;
                    });
                }
                else {
                    const dataToAgg = groupItem.__children.map((child) => child[col.getId()]);
                    const aggResult = aggStage.aggregateValues(dataToAgg, params.aggFunc);
                    groupItem[col.getId()] =
                        aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;
                }
            }));
        }
        return dataAggregated;
    }
    updatePivotKeysForSSRM() {
        const secondaryColumns = this.pivotResultCols?.getPivotResultCols()?.list;
        if (!secondaryColumns) {
            return;
        }
        // we don't know what the application will use for the pivot key separator (i.e. '_' or '|' ) as the
        // secondary columns are provided to grid by the application via api.setSecondaryColumns()
        const pivotKeySeparator = this.extractPivotKeySeparator(secondaryColumns);
        // `pivotKeys` is not used by the SSRM for pivoting, so it is safe to reuse this colDef property. This way
        // the same logic can be used for CSRM and SSRM to extract legend names in extractRowsFromGridRowModel()
        secondaryColumns.forEach((col) => {
            if (pivotKeySeparator === '') {
                col.getColDef().pivotKeys = [];
            }
            else {
                const keys = col.getColId().split(pivotKeySeparator);
                col.getColDef().pivotKeys = keys.slice(0, keys.length - 1);
            }
        });
    }
    extractPivotKeySeparator(secondaryColumns) {
        if (secondaryColumns.length === 0) {
            return '';
        }
        const extractSeparator = (columnGroup, childId) => {
            const groupId = columnGroup.getGroupId();
            if (!columnGroup.getParent()) {
                // removing groupId ('2000') from childId ('2000|Swimming') yields '|Swimming' so first char is separator
                return childId.split(groupId)[1][0];
            }
            return extractSeparator(columnGroup.getParent(), groupId);
        };
        const firstSecondaryCol = secondaryColumns[0];
        if (firstSecondaryCol.getParent() == null) {
            return '';
        }
        return extractSeparator(firstSecondaryCol.getParent(), firstSecondaryCol.getColId());
    }
    getGroupLabels(rowNode, initialLabel) {
        const labels = [initialLabel];
        while (rowNode && rowNode.level !== 0) {
            rowNode = rowNode.parent;
            if (rowNode) {
                labels.push(rowNode.key);
            }
        }
        return labels;
    }
    getFilteredRowNodes() {
        const filteredNodes = {};
        this.gridRowModel.forEachNodeAfterFilterAndSort((rowNode) => {
            filteredNodes[rowNode.id] = rowNode;
        });
        return filteredNodes;
    }
    getAllRowNodes() {
        const allRowNodes = [];
        this.gridRowModel.forEachNode((rowNode) => {
            allRowNodes.push(rowNode);
        });
        return this.sortRowNodes(allRowNodes);
    }
    sortRowNodes(rowNodes) {
        const sortOptions = this.sortSvc?.getSortOptions();
        if (!sortOptions || sortOptions.length == 0 || !this.rowNodeSorter) {
            return rowNodes;
        }
        return this.rowNodeSorter.doFullSort(rowNodes, sortOptions);
    }
}
exports.ChartDatasource = ChartDatasource;


/***/ }),

/***/ 7760:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridChartComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agDialog_1 = __webpack_require__(8775);
const chartController_1 = __webpack_require__(3251);
const areaChartProxy_1 = __webpack_require__(7216);
const barChartProxy_1 = __webpack_require__(3116);
const lineChartProxy_1 = __webpack_require__(9235);
const scatterChartProxy_1 = __webpack_require__(7015);
const comboChartProxy_1 = __webpack_require__(8995);
const pieChartProxy_1 = __webpack_require__(4104);
const chartMenu_1 = __webpack_require__(3608);
const chartMenuParamsFactory_1 = __webpack_require__(3786);
const chartDataModel_1 = __webpack_require__(8592);
const chartMenuService_1 = __webpack_require__(7492);
const chartOptionsService_1 = __webpack_require__(6297);
const seriesTypeMapper_1 = __webpack_require__(4237);
class GridChartComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.crossFilterService = beans.chartCrossFilterSvc;
        this.chartTranslation = beans.chartTranslation;
        this.chartMenuSvc = beans.chartMenuSvc;
        this.focusSvc = beans.focusSvc;
        this.popupSvc = beans.popupSvc;
        this.enterpriseChartProxyFactory = beans.enterpriseChartProxyFactory;
        this.environment = beans.environment;
    }
    constructor(params) {
        super(/* html */ `
            <div style="height: 100%; width: 100%;">
                <div class="ag-chart" data-ref="eWrapper">
                    <div data-ref="eChartContainer" class="ag-chart-components-wrapper ag-chart-menu-hidden">
                        <div data-ref="eChart" class="ag-chart-canvas-wrapper"></div>
                        <div data-ref="eEmpty" class="ag-chart-empty-text ag-unselectable"></div>
                    </div>
                    <div data-ref="eMenuContainer" class="ag-chart-docked-container"></div>
                </div>
            </div>
            `);
        this.eChart = ag_grid_community_1.RefPlaceholder;
        this.eWrapper = ag_grid_community_1.RefPlaceholder;
        this.eChartContainer = ag_grid_community_1.RefPlaceholder;
        this.eMenuContainer = ag_grid_community_1.RefPlaceholder;
        this.eEmpty = ag_grid_community_1.RefPlaceholder;
        this.params = params;
    }
    postConstruct() {
        const modelParams = {
            ...this.params,
            chartType: (0, seriesTypeMapper_1.getCanonicalChartType)(this.params.chartType),
            chartThemeName: this.getThemeName(),
        };
        const isRtl = this.gos.get('enableRtl');
        this.eWrapper.classList.add(isRtl ? 'ag-rtl' : 'ag-ltr');
        // only the chart controller interacts with the chart model
        const model = this.createBean(new chartDataModel_1.ChartDataModel(modelParams));
        this.chartController = this.createManagedBean(new chartController_1.ChartController(model));
        this.chartOptionsService = this.createManagedBean(new chartOptionsService_1.ChartOptionsService(this.chartController));
        this.validateCustomThemes();
        // create chart before dialog to ensure dialog is correct size
        this.createChart();
        if (this.params.insideDialog) {
            this.addDialog();
        }
        else {
            // don't add the theme if we're in a dialog, since dialogs already
            // add a theme, and legacy themes don't like being applied twice
            this.addManagedEventListeners({
                gridStylesChanged: this.updateTheme.bind(this),
            });
            this.updateTheme();
        }
        this.addMenu();
        this.addManagedElementListeners(this.getGui(), { focusin: this.setActiveChartCellRange.bind(this) });
        this.addManagedListeners(this.chartController, { chartModelUpdate: this.update.bind(this) });
        this.addManagedPropertyListeners(['chartThemeOverrides', 'chartThemes'], this.reactivePropertyUpdate.bind(this));
        this.update();
        this.raiseChartCreatedEvent();
    }
    updateTheme() {
        this.environment.applyThemeClasses(this.getGui());
    }
    createChart() {
        // if chart already exists, destroy it and remove it from DOM
        let chartInstance = undefined;
        if (this.chartProxy) {
            chartInstance = this.chartProxy.destroy({ keepChartInstance: true });
        }
        const crossFilterCallback = (event, reset) => {
            const ctx = this.params.crossFilteringContext;
            ctx.lastSelectedChartId = reset ? '' : this.chartController.getChartId();
            if (reset) {
                this.params.crossFilteringResetCallback();
            }
            this.crossFilterService.filter(event, reset);
        };
        const chartType = this.chartController.getChartType();
        const chartProxyParams = {
            agChartsExports: this.beans.agChartsExports,
            chartType,
            chartInstance,
            getChartThemeName: this.getChartThemeName.bind(this),
            getChartThemes: this.getChartThemes.bind(this),
            customChartThemes: this.gos.get('customChartThemes'),
            getGridOptionsChartThemeOverrides: () => this.getGridOptionsChartThemeOverrides(),
            getExtraPaddingDirections: () => this.chartMenu?.getExtraPaddingDirections() ?? [],
            apiChartThemeOverrides: this.params.chartThemeOverrides,
            crossFiltering: this.params.crossFiltering ?? false,
            crossFilterCallback,
            parentElement: this.eChart,
            grouping: this.chartController.isGrouping(),
            chartThemeToRestore: this.params.chartThemeName,
            chartOptionsToRestore: this.params.chartOptionsToRestore,
            chartPaletteToRestore: this.params.chartPaletteToRestore,
            seriesChartTypes: this.chartController.getSeriesChartTypes(),
            translate: (toTranslate) => this.chartTranslation.translate(toTranslate),
        };
        // ensure 'restoring' options are not reused when switching chart types
        this.params.chartOptionsToRestore = undefined;
        // set local state used to detect when chart changes
        this.chartType = chartType;
        this.chartProxy = this.createChartProxy(chartProxyParams);
        if (!this.chartProxy) {
            (0, ag_grid_community_1._warn)(138, { chartType: chartProxyParams.chartType });
            return;
        }
        this.chartController.setChartProxy(this.chartProxy);
        this.createMenuContext();
    }
    createMenuContext() {
        if (this.chartMenuContext) {
            return;
        }
        const chartMenuParamsFactory = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(this.chartOptionsService.getChartThemeOverridesProxy()));
        const chartAxisMenuParamsFactory = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(this.chartOptionsService.getAxisThemeOverridesProxy()));
        this.chartMenuContext = {
            chartController: this.chartController,
            chartOptionsService: this.chartOptionsService,
            chartMenuParamsFactory,
            chartAxisMenuParamsFactory,
        };
    }
    getChartThemeName() {
        return this.chartController.getChartThemeName();
    }
    getChartThemes() {
        return this.chartController.getThemeNames();
    }
    getGridOptionsChartThemeOverrides() {
        return this.gos.get('chartThemeOverrides');
    }
    createChartProxy(chartProxyParams) {
        const { chartType } = chartProxyParams;
        switch (chartType) {
            case 'column':
            case 'bar':
            case 'groupedColumn':
            case 'stackedColumn':
            case 'normalizedColumn':
            case 'groupedBar':
            case 'stackedBar':
            case 'normalizedBar':
                return new barChartProxy_1.BarChartProxy(chartProxyParams);
            case 'pie':
            case 'donut':
            case 'doughnut':
                return new pieChartProxy_1.PieChartProxy(chartProxyParams);
            case 'area':
            case 'stackedArea':
            case 'normalizedArea':
                return new areaChartProxy_1.AreaChartProxy(chartProxyParams);
            case 'line':
            case 'stackedLine':
            case 'normalizedLine':
                return new lineChartProxy_1.LineChartProxy(chartProxyParams);
            case 'scatter':
            case 'bubble':
                return new scatterChartProxy_1.ScatterChartProxy(chartProxyParams);
            case 'columnLineCombo':
            case 'areaColumnCombo':
            case 'customCombo':
                return new comboChartProxy_1.ComboChartProxy(chartProxyParams);
        }
        const enterpriseChartProxy = this.enterpriseChartProxyFactory?.createChartProxy(chartProxyParams);
        if (!enterpriseChartProxy) {
            throw (0, ag_grid_community_1._errMsg)(251, { chartType });
        }
        return enterpriseChartProxy;
    }
    addDialog() {
        const title = this.chartTranslation.translate(this.params.pivotChart ? 'pivotChartTitle' : 'rangeChartTitle');
        const { width, height } = this.getBestDialogSize();
        const afterGuiAttached = this.params.focusDialogOnOpen
            ? () => setTimeout(() => (0, ag_grid_community_1._focusInto)(this.getGui()))
            : undefined;
        this.chartDialog = new agDialog_1.AgDialog({
            resizable: true,
            movable: true,
            maximizable: true,
            title,
            width,
            height,
            component: this,
            centered: true,
            closable: true,
            afterGuiAttached,
            postProcessPopupParams: {
                type: 'chart',
            },
        });
        this.createBean(this.chartDialog);
        this.chartDialog.addEventListener('destroyed', () => {
            this.destroy();
            this.chartMenuSvc.hideAdvancedSettings();
            const lastFocusedCell = this.focusSvc.getFocusedCell();
            setTimeout(() => {
                if (this.focusSvc.isAlive()) {
                    // focus Service may have been destroyed if both grid and chart destroyed together
                    if (lastFocusedCell) {
                        this.focusSvc.setFocusedCell({ ...lastFocusedCell, forceBrowserFocus: true });
                    }
                    else {
                        (0, ag_grid_community_1._focusGridInnerElement)(this.beans);
                    }
                }
            });
        });
    }
    getBestDialogSize() {
        const popupParent = this.popupSvc.getPopupParent();
        const maxWidth = (0, ag_grid_community_1._getAbsoluteWidth)(popupParent) * 0.75;
        const maxHeight = (0, ag_grid_community_1._getAbsoluteHeight)(popupParent) * 0.75;
        const ratio = 0.553;
        const chart = this.chartProxy.getChart();
        let width = this.params.insideDialog ? 850 : chart.width;
        let height = this.params.insideDialog ? 470 : chart.height;
        if (width > maxWidth || height > maxHeight) {
            width = Math.min(width, maxWidth);
            height = Math.round(width * ratio);
            if (height > maxHeight) {
                height = maxHeight;
                width = Math.min(width, Math.round(height / ratio));
            }
        }
        return { width, height };
    }
    addMenu() {
        if (!this.params.crossFiltering) {
            this.chartMenu = this.createBean(new chartMenu_1.ChartMenu(this.eChartContainer, this.eMenuContainer, this.chartMenuContext));
            this.eChartContainer.appendChild(this.chartMenu.getGui());
        }
    }
    update(params) {
        // update chart model for api.updateChart()
        if (params?.chartId) {
            const validUpdate = this.chartController.update(params);
            if (!validUpdate) {
                return; // warning already logged!
            }
        }
        const updatedChartType = this.chartTypeChanged(params);
        // If the chart type has changed, grab the theme overrides from the exisiting chart before destroying it,
        // so that we can retain any compatible theme overrides across different chart types.
        const persistedThemeOverrides = updatedChartType || this.chartEmpty
            ? ((updatedChartType) => {
                const currentChartType = this.chartType;
                const targetChartType = updatedChartType;
                const existingChartInstance = this.chartProxy.getChart();
                const existingChartOptions = existingChartInstance?.getOptions();
                const existingAxes = existingChartInstance?.axes;
                return this.chartOptionsService.getPersistedChartThemeOverrides(existingChartOptions, existingAxes, currentChartType, targetChartType ?? currentChartType);
            })(updatedChartType)
            : undefined;
        // recreate chart if chart type has changed
        if (updatedChartType)
            this.createChart();
        // combine any provided theme overrides with any retained theme overrides from changing chart type
        if (persistedThemeOverrides && params?.chartThemeOverrides) {
            (0, ag_grid_community_1._mergeDeep)(persistedThemeOverrides, params.chartThemeOverrides);
        }
        const updatedThemeOverrides = persistedThemeOverrides ?? params?.chartThemeOverrides;
        // update chart options if chart type hasn't changed or if overrides are supplied
        this.updateChart(updatedThemeOverrides);
        if (params?.chartId) {
            this.chartProxy
                .getChart()
                .waitForUpdate()
                .then(() => {
                this.chartController.raiseChartApiUpdateEvent();
            });
        }
    }
    updateChart(updatedOverrides) {
        const { chartProxy } = this;
        const selectedCols = this.chartController.getSelectedValueColState();
        const data = this.chartController.getChartData();
        const chartEmpty = this.handleEmptyChart(data, selectedCols.length);
        this.chartEmpty = chartEmpty;
        if (chartEmpty) {
            // We don't have enough data to reinstantiate the chart with the new chart type,
            // but we still want to persist any theme overrides for when the data is present
            if (updatedOverrides)
                this.chartController.updateThemeOverrides(updatedOverrides);
            return;
        }
        const chartUpdateParams = this.chartController.getChartUpdateParams(updatedOverrides);
        chartProxy.update(chartUpdateParams);
        this.chartProxy
            .getChart()
            .waitForUpdate()
            .then(() => {
            this.chartController.raiseChartUpdatedEvent();
        });
    }
    chartTypeChanged(updateParams) {
        const [currentType, updatedChartType] = [this.chartController.getChartType(), updateParams?.chartType];
        const targetChartType = updatedChartType ? (0, seriesTypeMapper_1.getCanonicalChartType)(updatedChartType) : undefined;
        // If the grid chart component is out of sync with the existing chart instance type, return the correct chart type
        if (this.chartType !== currentType)
            return targetChartType ?? currentType;
        // If the target chart type is different to the current chart type, return the new chart type
        if (targetChartType && currentType !== targetChartType)
            return targetChartType;
        // Otherwise nothing has changed
        return null;
    }
    getChartModel() {
        return this.chartController.getChartModel();
    }
    getChartImageDataURL(fileFormat) {
        return this.chartProxy.getChartImageDataURL(fileFormat);
    }
    handleEmptyChart(data, numFields) {
        const pivotModeDisabled = this.chartController.isPivotChart() && !this.chartController.isPivotMode();
        // Determine the minimum number of fields based on the chart type
        const chartType = this.chartController.getChartType();
        let minFieldsRequired = 1;
        if (this.chartController.isActiveXYChart()) {
            minFieldsRequired = chartType === 'bubble' ? 3 : 2;
        }
        else if ((0, seriesTypeMapper_1.isHierarchical)((0, seriesTypeMapper_1.getSeriesType)(chartType))) {
            minFieldsRequired = 0;
        }
        const isEmptyChart = numFields < minFieldsRequired || data.length === 0;
        if (this.eChart) {
            const isEmpty = pivotModeDisabled || isEmptyChart;
            (0, ag_grid_community_1._setDisplayed)(this.eChart, !isEmpty);
            (0, ag_grid_community_1._setDisplayed)(this.eEmpty, isEmpty);
        }
        if (pivotModeDisabled) {
            this.eEmpty.innerText = this.chartTranslation.translate('pivotChartRequiresPivotMode');
            return true;
        }
        if (isEmptyChart) {
            this.eEmpty.innerText = this.chartTranslation.translate('noDataToChart');
            return true;
        }
        return false;
    }
    downloadChart(dimensions, fileName, fileFormat) {
        this.chartProxy.downloadChart(dimensions, fileName, fileFormat);
    }
    openChartToolPanel(panel) {
        const menuPanel = panel ? chartMenuService_1.CHART_TOOL_PANEL_MENU_OPTIONS[panel] : panel;
        this.chartMenu.showMenu({ panel: menuPanel });
    }
    closeChartToolPanel() {
        this.chartMenu.hideMenu();
    }
    getChartId() {
        return this.chartController.getChartId();
    }
    getUnderlyingChart() {
        return this.chartProxy.getChartRef();
    }
    crossFilteringReset() {
        this.chartProxy.crossFilteringReset();
    }
    setActiveChartCellRange(focusEvent) {
        if (this.getGui().contains(focusEvent.relatedTarget)) {
            return;
        }
        this.chartController.setChartRange(true);
    }
    getThemeName() {
        const availableChartThemes = this.gos.get('chartThemes') || chartController_1.DEFAULT_THEMES;
        if (availableChartThemes.length === 0) {
            throw new Error((0, ag_grid_community_1._errMsg)(254));
        }
        const { chartThemeName } = this.params;
        return availableChartThemes.includes(chartThemeName) ? chartThemeName : availableChartThemes[0];
    }
    getAllKeysInObjects(objects) {
        const allValues = {};
        objects
            .filter((obj) => obj != null)
            .forEach((obj) => {
            Object.keys(obj).forEach((key) => (allValues[key] = null));
        });
        return Object.keys(allValues);
    }
    validateCustomThemes() {
        const suppliedThemes = this.getChartThemes();
        const customChartThemes = this.gos.get('customChartThemes');
        if (customChartThemes) {
            this.getAllKeysInObjects([customChartThemes]).forEach((customThemeName) => {
                if (!suppliedThemes.includes(customThemeName)) {
                    (0, ag_grid_community_1._warn)(139, { customThemeName });
                }
            });
        }
    }
    reactivePropertyUpdate() {
        // switch to the first theme if the current theme is unavailable
        this.chartController.setChartThemeName(this.getThemeName(), true);
        const chartId = this.getChartId();
        const modelType = this.chartController.isCrossFilterChart() ? 'crossFilter' : this.getChartModel().modelType;
        // standalone requires that `undefined` / `null` values are supplied as `{}`
        const chartThemeOverrides = this.gos.get('chartThemeOverrides') || {};
        this.update({
            type: `${modelType}ChartUpdate`,
            chartId,
            chartThemeOverrides,
        });
    }
    raiseChartCreatedEvent() {
        this.chartProxy
            .getChart()
            .waitForUpdate()
            .then(() => {
            this.eventSvc.dispatchEvent({
                type: 'chartCreated',
                chartId: this.chartController.getChartId(),
            });
        });
    }
    raiseChartDestroyedEvent() {
        this.eventSvc.dispatchEvent({
            type: 'chartDestroyed',
            chartId: this.chartController.getChartId(),
        });
    }
    destroy() {
        super.destroy();
        if (this.chartProxy) {
            this.chartProxy.destroy();
        }
        this.destroyBean(this.chartMenu);
        // don't want to invoke destroy() on the Dialog (prevents destroy loop)
        if (this.chartDialog && this.chartDialog.isAlive()) {
            this.destroyBean(this.chartDialog);
        }
        this.onDestroyColorSchemeChangeListener?.();
        // if the user is providing containers for the charts, we need to clean up, otherwise the old chart
        // data will still be visible although the chart is no longer bound to the grid
        const eGui = this.getGui();
        (0, ag_grid_community_1._clearElement)(eGui);
        // remove from parent, so if user provided container, we detach from the provided dom element
        (0, ag_grid_community_1._removeFromParent)(eGui);
        this.raiseChartDestroyedEvent();
    }
}
exports.GridChartComp = GridChartComp;


/***/ }),

/***/ 6353:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedSettingsMenuFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agDialog_1 = __webpack_require__(8775);
const advancedSettingsPanel_1 = __webpack_require__(5776);
class AdvancedSettingsMenuFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'advSettingsMenuFactory';
    }
    showMenu(chartMenuContext, eventSource) {
        this.hideMenu();
        const menu = this.createBean(new AdvancedSettingsMenu(chartMenuContext));
        this.activeDialog = this.createBean(new agDialog_1.AgDialog({
            title: this.beans.chartTranslation.translate('advancedSettings'),
            component: menu,
            width: 300,
            height: 400,
            resizable: true,
            movable: true,
            centered: true,
            closable: true,
            afterGuiAttached: () => {
                (0, ag_grid_community_1._findFocusableElements)(menu.getGui())[0]?.focus();
            },
            closedCallback: () => {
                this.activeMenu = this.destroyBean(this.activeMenu);
                this.activeDialog = undefined;
                eventSource?.focus({ preventScroll: true });
            },
        }));
        this.activeMenu = menu;
    }
    hideMenu() {
        if (this.activeDialog) {
            this.destroyBean(this.activeDialog);
        }
    }
    destroy() {
        this.activeMenu = this.destroyBean(this.activeMenu);
        this.activeDialog = this.destroyBean(this.activeDialog);
        super.destroy();
    }
}
exports.AdvancedSettingsMenuFactory = AdvancedSettingsMenuFactory;
class AdvancedSettingsMenu extends ag_grid_community_1.TabGuardComp {
    constructor(chartMenuContext) {
        super(/* html */ `<div class="ag-chart-advanced-settings"></div>`);
        this.chartMenuContext = chartMenuContext;
    }
    postConstruct() {
        this.advancedSettingsPanel = this.createManagedBean(new advancedSettingsPanel_1.AdvancedSettingsPanel(this.chartMenuContext));
        this.getGui().appendChild(this.advancedSettingsPanel.getGui());
        this.initialiseTabGuard({
            onTabKeyDown: this.onTabKeyDown.bind(this),
            focusTrapActive: true,
        });
    }
    onTabKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        e.preventDefault();
        const backwards = e.shiftKey;
        const panelGui = this.advancedSettingsPanel.getGui();
        const nextEl = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, panelGui, false, backwards);
        if (nextEl) {
            nextEl.focus();
        }
        else {
            const focusableElements = (0, ag_grid_community_1._findFocusableElements)(panelGui);
            if (focusableElements.length) {
                focusableElements[backwards ? focusableElements.length - 1 : 0].focus();
            }
        }
    }
}


/***/ }),

/***/ 5776:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedSettingsPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartPanelFeature_1 = __webpack_require__(1299);
const animationPanel_1 = __webpack_require__(6671);
const crosshairPanel_1 = __webpack_require__(2337);
const navigatorPanel_1 = __webpack_require__(2738);
const zoomPanel_1 = __webpack_require__(3320);
const INTERACTIVITY_GROUPS = ['navigator', 'zoom', 'animation', 'crosshair'];
class AdvancedSettingsPanel extends ag_grid_community_1.Component {
    constructor(chartMenuContext) {
        super(/* html */ `<div class="ag-chart-advanced-settings-wrapper"></div>`);
        this.chartMenuContext = chartMenuContext;
    }
    postConstruct() {
        this.chartPanelFeature = this.createManagedBean(new chartPanelFeature_1.ChartPanelFeature(this.chartMenuContext.chartController, this.getGui(), 'ag-chart-advanced-settings-section', (chartType, seriesType) => this.createPanels(chartType, seriesType)));
        this.chartPanelFeature.refreshPanels();
    }
    createPanels(chartType, seriesType) {
        INTERACTIVITY_GROUPS.forEach((group) => {
            if (!this.isGroupPanelShownForSeries(group, seriesType)) {
                return;
            }
            const comp = this.createPanel(group);
            this.chartPanelFeature.addComponent(comp);
        });
    }
    isGroupPanelShownForSeries(group, seriesType) {
        return group === 'animation' || (0, seriesTypeMapper_1.isCartesian)(seriesType);
    }
    createPanel(group) {
        const { chartMenuParamsFactory, chartAxisMenuParamsFactory } = this.chartMenuContext;
        switch (group) {
            case 'navigator':
                return new navigatorPanel_1.NavigatorPanel(chartMenuParamsFactory);
            case 'zoom':
                return new zoomPanel_1.ZoomPanel(chartMenuParamsFactory);
            case 'animation':
                return new animationPanel_1.AnimationPanel(chartMenuParamsFactory);
            case 'crosshair':
                return new crosshairPanel_1.CrosshairPanel(chartAxisMenuParamsFactory);
        }
    }
}
exports.AdvancedSettingsPanel = AdvancedSettingsPanel;


/***/ }),

/***/ 6671:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
class AnimationPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuParamsFactory) {
        super();
        this.chartMenuParamsFactory = chartMenuParamsFactory;
    }
    postConstruct() {
        const animationGroupParams = this.chartMenuParamsFactory.addEnableParams('animation.enabled', {
            cssIdentifier: 'charts-advanced-settings-top-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('animation'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const animationHeightInputParams = this.chartMenuParamsFactory.getDefaultNumberInputParams('animation.duration', 'durationMillis', {
            min: 0,
        });
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="animationGroup">
                <ag-input-number-field data-ref="animationHeightInput"></ag-input>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgInputNumberFieldSelector], {
            animationGroup: animationGroupParams,
            animationHeightInput: animationHeightInputParams,
        });
    }
}
exports.AnimationPanel = AnimationPanel;


/***/ }),

/***/ 2337:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CrosshairPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
class CrosshairPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuParamsFactory) {
        super();
        this.chartMenuParamsFactory = chartMenuParamsFactory;
    }
    postConstruct() {
        const crosshairGroupParams = this.chartMenuParamsFactory.addEnableParams('crosshair.enabled', {
            cssIdentifier: 'charts-advanced-settings-top-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('crosshair'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const crosshairLabelCheckboxParams = this.chartMenuParamsFactory.getDefaultCheckboxParams('crosshair.label.enabled', 'crosshairLabel');
        const crosshairSnapCheckboxParams = this.chartMenuParamsFactory.getDefaultCheckboxParams('crosshair.snap', 'crosshairSnap');
        const crosshairStrokeColorPickerParams = this.chartMenuParamsFactory.getDefaultColorPickerParams('crosshair.stroke', 'color');
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="crosshairGroup">
                <ag-checkbox data-ref="crosshairLabelCheckbox"></ag-checkbox>
                <ag-checkbox data-ref="crosshairSnapCheckbox"></ag-checkbox>
                <ag-color-picker data-ref="crosshairStrokeColorPicker"></ag-color-picker>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgCheckboxSelector, agColorPicker_1.AgColorPickerSelector], {
            crosshairGroup: crosshairGroupParams,
            crosshairLabelCheckbox: crosshairLabelCheckboxParams,
            crosshairSnapCheckbox: crosshairSnapCheckboxParams,
            crosshairStrokeColorPicker: crosshairStrokeColorPickerParams,
        });
    }
}
exports.CrosshairPanel = CrosshairPanel;


/***/ }),

/***/ 2738:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigatorPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class NavigatorPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuParamsFactory) {
        super();
        this.chartMenuParamsFactory = chartMenuParamsFactory;
    }
    postConstruct() {
        const navigatorGroupParams = this.chartMenuParamsFactory.addEnableParams('navigator.enabled', {
            cssIdentifier: 'charts-advanced-settings-top-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('navigator'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const navigatorHeightSliderParams = this.chartMenuParamsFactory.getDefaultSliderParams('navigator.height', 'height', 60);
        navigatorHeightSliderParams.minValue = 10;
        const navigatorMiniChartCheckboxParams = this.chartMenuParamsFactory.getDefaultCheckboxParams('navigator.miniChart.enabled', 'miniChart');
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="navigatorGroup">
                <ag-slider data-ref="navigatorHeightSlider"></ag-slider>
                <ag-checkbox data-ref="navigatorMiniChartCheckbox"></ag-checkbox>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agSlider_1.AgSliderSelector, ag_grid_community_1.AgCheckboxSelector], {
            navigatorGroup: navigatorGroupParams,
            navigatorHeightSlider: navigatorHeightSliderParams,
            navigatorMiniChartCheckbox: navigatorMiniChartCheckboxParams,
        });
    }
}
exports.NavigatorPanel = NavigatorPanel;


/***/ }),

/***/ 3320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZoomPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class ZoomPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuParamsFactory) {
        super();
        this.chartMenuParamsFactory = chartMenuParamsFactory;
        this.zoomScrollingStepInput = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const zoomGroupParams = this.chartMenuParamsFactory.addEnableParams('zoom.enabled', {
            cssIdentifier: 'charts-advanced-settings-top-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('zoom'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const zoomScrollingCheckboxParams = this.chartMenuParamsFactory.getDefaultCheckboxParams('zoom.enableScrolling', 'scrollingZoom');
        const zoomScrollingStepSliderParams = this.chartMenuParamsFactory.getDefaultSliderParams('zoom.scrollingStep', 'scrollingStep', 1);
        zoomScrollingStepSliderParams.step = 0.01;
        zoomScrollingStepSliderParams.minValue = zoomScrollingStepSliderParams.step;
        const zoomSelectingCheckboxParams = this.chartMenuParamsFactory.getDefaultCheckboxParams('zoom.enableSelecting', 'selectingZoom');
        // Enable/disable the scrolling step input according to whether the scrolling checkbox is checked
        zoomScrollingCheckboxParams.onValueChange = ((onValueChange) => (value) => {
            if (!onValueChange)
                return;
            onValueChange(value);
            this.zoomScrollingStepInput.setDisabled(!value);
        })(zoomScrollingCheckboxParams.onValueChange);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="zoomGroup">
                <ag-checkbox data-ref="zoomSelectingCheckbox"></ag-checkbox>
                <ag-checkbox data-ref="zoomScrollingCheckbox"></ag-checkbox>
                <ag-slider data-ref="zoomScrollingStepInput"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgCheckboxSelector, agSlider_1.AgSliderSelector], {
            zoomGroup: zoomGroupParams,
            zoomScrollingCheckbox: zoomScrollingCheckboxParams,
            zoomScrollingStepInput: zoomScrollingStepSliderParams,
            zoomSelectingCheckbox: zoomSelectingCheckboxParams,
        });
        // Set the initial state of the scrolling step input according to whether the scrolling checkbox is checked
        this.zoomScrollingStepInput.setDisabled(!zoomScrollingCheckboxParams.value);
    }
}
exports.ZoomPanel = ZoomPanel;


/***/ }),

/***/ 3608:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartMenu = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPanel_1 = __webpack_require__(7325);
const chartToolbar_1 = __webpack_require__(4967);
const tabbedChartMenu_1 = __webpack_require__(5518);
class ChartMenu extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartMenuSvc = beans.chartMenuSvc;
        this.chartMenuListFactory = beans.chartMenuListFactory;
        this.environment = beans.environment;
    }
    constructor(eChartContainer, eMenuPanelContainer, chartMenuContext) {
        super(/* html */ `<div class="ag-chart-menu-wrapper"></div>`);
        this.eChartContainer = eChartContainer;
        this.eMenuPanelContainer = eMenuPanelContainer;
        this.chartMenuContext = chartMenuContext;
        this.buttons = {
            chartLink: { iconName: 'linked', callback: () => this.chartMenuSvc.toggleLinked(this.chartMenuContext) },
            chartUnlink: {
                iconName: 'unlinked',
                callback: () => this.chartMenuSvc.toggleLinked(this.chartMenuContext),
            },
            chartDownload: {
                iconName: 'chartsDownload',
                callback: () => this.chartMenuSvc.downloadChart(this.chartMenuContext),
            },
            chartMenu: { iconName: 'chartsMenu', callback: (eventSource) => this.showMenuList(eventSource) },
        };
        this.panels = [];
        this.menuVisible = false;
        this.chartController = chartMenuContext.chartController;
    }
    postConstruct() {
        this.chartToolbar = this.createManagedBean(new chartToolbar_1.ChartToolbar());
        this.getGui().appendChild(this.chartToolbar.getGui());
        this.refreshToolbarAndPanels();
        this.addManagedEventListeners({
            chartCreated: (e) => {
                if (e.chartId === this.chartController.getChartId()) {
                    const showDefaultToolPanel = Boolean(this.gos.get('chartToolPanelsDef')?.defaultToolPanel);
                    if (showDefaultToolPanel) {
                        this.showMenu({ panel: this.defaultPanel, suppressFocus: true });
                    }
                }
            },
        });
        this.addManagedListeners(this.chartController, {
            chartLinkedChanged: this.refreshToolbarAndPanels.bind(this),
        });
        this.refreshMenuClasses();
        this.addManagedListeners(this.chartController, { chartApiUpdate: this.refreshToolbarAndPanels.bind(this) });
    }
    isVisible() {
        return this.menuVisible;
    }
    getExtraPaddingDirections() {
        return ['chartMenu', 'chartLink', 'chartUnlink', 'chartDownload'].some((v) => this.chartToolbarOptions.includes(v))
            ? ['top']
            : [];
    }
    refreshToolbarAndPanels() {
        this.initToolbarOptionsAndPanels();
        this.updateToolbar();
    }
    initToolbarOptionsAndPanels() {
        const { panels, defaultPanel } = this.chartMenuSvc.getChartToolPanels(this.chartController);
        this.panels = panels;
        this.defaultPanel = defaultPanel;
        this.chartToolbarOptions = this.chartMenuSvc.getChartToolbarOptions();
    }
    updateToolbar() {
        const buttons = this.chartToolbarOptions.map((buttonName) => {
            const { iconName, callback } = this.buttons[buttonName];
            return {
                buttonName,
                iconName,
                callback,
            };
        });
        this.chartToolbar.updateParams({ buttons });
    }
    createMenuPanel(defaultTab) {
        const menuPanel = (this.menuPanel = this.createBean(new agPanel_1.AgPanel({
            height: '100%',
            closable: true,
            hideTitleBar: true,
            cssIdentifier: 'chart-menu',
        })));
        menuPanel.setParentComponent(this);
        this.eMenuPanelContainer.appendChild(menuPanel.getGui());
        this.tabbedMenu = this.createBean(new tabbedChartMenu_1.TabbedChartMenu(this.panels, this.chartMenuContext));
        this.addManagedListeners(this.tabbedMenu, {
            closed: () => {
                this.hideMenu();
            },
        });
        this.addManagedListeners(menuPanel, { destroyed: () => this.destroyBean(this.tabbedMenu) });
        return new ag_grid_community_1.AgPromise((res) => {
            window.setTimeout(() => {
                menuPanel.setBodyComponent(this.tabbedMenu);
                this.tabbedMenu.showTab(defaultTab);
                res(menuPanel);
            }, 100);
        });
    }
    showContainer(eventSource, suppressFocus) {
        if (!this.menuPanel) {
            return;
        }
        this.menuVisible = true;
        this.refreshMenuClasses();
        this.tabbedMenu.showMenu(eventSource, suppressFocus);
    }
    showMenu(params) {
        const { panel, eventSource, suppressFocus } = params ?? {};
        if (this.menuPanel && !panel) {
            this.showContainer(eventSource, suppressFocus);
        }
        else {
            const menuPanel = panel || this.defaultPanel;
            let tab = this.panels.indexOf(menuPanel);
            if (tab < 0) {
                (0, ag_grid_community_1._warn)(143, { panel });
                tab = this.panels.indexOf(this.defaultPanel);
            }
            if (this.menuPanel) {
                this.tabbedMenu.showTab(tab);
                this.showContainer(eventSource, suppressFocus);
            }
            else {
                this.createMenuPanel(tab).then(() => this.showContainer(eventSource, suppressFocus));
            }
        }
    }
    hideMenu() {
        this.menuVisible = false;
        this.refreshMenuClasses();
    }
    refreshMenuClasses() {
        this.eChartContainer.classList.toggle('ag-chart-menu-visible', this.menuVisible);
        this.eChartContainer.classList.toggle('ag-chart-menu-hidden', !this.menuVisible);
    }
    showMenuList(eventSource) {
        this.chartMenuListFactory.showMenuList({
            eventSource,
            showMenu: () => this.showMenu({ eventSource }),
            chartMenuContext: this.chartMenuContext,
        });
    }
    destroy() {
        super.destroy();
        if (this.menuPanel && this.menuPanel.isAlive()) {
            this.destroyBean(this.menuPanel);
        }
        if (this.tabbedMenu && this.tabbedMenu.isAlive()) {
            this.destroyBean(this.tabbedMenu);
        }
    }
}
exports.ChartMenu = ChartMenu;


/***/ }),

/***/ 6292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartMenuListFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agMenuList_1 = __webpack_require__(9476);
class ChartMenuListFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartMenuListFactory';
    }
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
        this.chartMenuSvc = beans.chartMenuSvc;
        this.chartTranslation = beans.chartTranslation;
    }
    showMenuList(params) {
        const { eventSource, showMenu, chartMenuContext } = params;
        const areChartToolPanelsEnabled = this.chartMenuSvc.doChartToolPanelsExist(chartMenuContext.chartController);
        const menuItems = this.mapWithStockItems(this.getMenuItems(chartMenuContext.chartController, areChartToolPanelsEnabled), chartMenuContext, showMenu, eventSource, areChartToolPanelsEnabled);
        if (!menuItems.length) {
            return;
        }
        const chartMenuList = this.createBean(new ChartMenuList(menuItems));
        this.activeChartMenuList = chartMenuList;
        let multiplier = -1;
        let alignSide = 'left';
        if (this.gos.get('enableRtl')) {
            multiplier = 1;
            alignSide = 'right';
        }
        const eGui = chartMenuList.getGui();
        this.popupSvc.addPopup({
            modal: true,
            eChild: eGui,
            closeOnEsc: true,
            closedCallback: () => {
                this.destroyBean(chartMenuList);
                this.activeChartMenuList = undefined;
                if ((0, ag_grid_community_1._isNothingFocused)(this.beans)) {
                    eventSource.focus({ preventScroll: true });
                }
            },
            afterGuiAttached: (params) => chartMenuList.afterGuiAttached(params),
            positionCallback: () => {
                {
                    this.popupSvc.positionPopupByComponent({
                        type: 'chartMenu',
                        eventSource,
                        ePopup: eGui,
                        alignSide,
                        nudgeX: 4 * multiplier,
                        nudgeY: 4,
                        position: 'under',
                        keepWithinBounds: true,
                    });
                }
            },
            ariaLabel: 'Chart Menu',
        });
    }
    getMenuItems(chartController, areChartToolPanelsEnabled) {
        const defaultItems = [
            ...(areChartToolPanelsEnabled ? ['chartEdit'] : []),
            ...(chartController.isEnterprise() ? ['chartAdvancedSettings'] : []),
            chartController.isChartLinked() ? 'chartUnlink' : 'chartLink',
            'chartDownload',
        ];
        const chartMenuItems = this.gos.get('chartMenuItems');
        if (!chartMenuItems) {
            return defaultItems;
        }
        else if (Array.isArray(chartMenuItems)) {
            return chartMenuItems;
        }
        else {
            return chartMenuItems(this.gos.addGridCommonParams({
                defaultItems,
            }));
        }
    }
    mapWithStockItems(originalList, chartMenuContext, showMenu, eventSource, areChartToolPanelsEnabled) {
        if (!originalList) {
            return [];
        }
        const resultList = [];
        originalList.forEach((menuItemOrString) => {
            let result;
            if (typeof menuItemOrString === 'string') {
                result = this.getStockMenuItem(menuItemOrString, chartMenuContext, showMenu, eventSource, areChartToolPanelsEnabled);
            }
            else {
                result = { ...menuItemOrString };
            }
            if (!result) {
                return;
            }
            const { subMenu } = result;
            if (Array.isArray(subMenu)) {
                result.subMenu = this.mapWithStockItems(subMenu, chartMenuContext, showMenu, eventSource, areChartToolPanelsEnabled);
            }
            resultList.push(result);
        });
        return resultList;
    }
    getStockMenuItem(key, chartMenuContext, showMenu, eventSource, areChartToolPanelsEnabled) {
        switch (key) {
            case 'chartEdit':
                return areChartToolPanelsEnabled
                    ? this.createMenuItem(this.chartTranslation.translate('chartEdit'), 'chartsMenuEdit', showMenu)
                    : null;
            case 'chartAdvancedSettings':
                return this.createMenuItem(this.chartTranslation.translate('chartAdvancedSettings'), 'chartsMenuAdvancedSettings', () => this.chartMenuSvc.openAdvancedSettings(chartMenuContext, eventSource));
            case 'chartUnlink':
                return chartMenuContext.chartController.isChartLinked()
                    ? this.createMenuItem(this.chartTranslation.translate('chartUnlink'), 'unlinked', () => this.chartMenuSvc.toggleLinked(chartMenuContext))
                    : null;
            case 'chartLink':
                return !chartMenuContext.chartController.isChartLinked()
                    ? this.createMenuItem(this.chartTranslation.translate('chartLink'), 'linked', () => this.chartMenuSvc.toggleLinked(chartMenuContext))
                    : null;
            case 'chartDownload':
                return this.createMenuItem(this.chartTranslation.translate('chartDownload'), 'chartsDownload', () => this.chartMenuSvc.downloadChart(chartMenuContext));
        }
        return null;
    }
    createMenuItem(name, iconName, action) {
        return {
            name,
            icon: (0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans, null),
            action,
        };
    }
    destroy() {
        this.destroyBean(this.activeChartMenuList);
        super.destroy();
    }
}
exports.ChartMenuListFactory = ChartMenuListFactory;
class ChartMenuList extends ag_grid_community_1.Component {
    constructor(menuItems) {
        super(/* html */ `
            <div data-ref="eChartsMenu" role="presentation" class="ag-menu ag-chart-menu-popup"></div>
        `);
        this.menuItems = menuItems;
        this.eChartsMenu = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.mainMenuList = this.createManagedBean(new agMenuList_1.AgMenuList(0));
        this.mainMenuList.addMenuItems(this.menuItems);
        this.mainMenuList.addEventListener('closeMenu', this.onHidePopup.bind(this));
        this.eChartsMenu.appendChild(this.mainMenuList.getGui());
    }
    onHidePopup() {
        this.hidePopupFunc?.();
    }
    afterGuiAttached({ hidePopup }) {
        if (hidePopup) {
            this.hidePopupFunc = hidePopup;
            this.addDestroyFunc(hidePopup);
        }
        (0, ag_grid_community_1._focusInto)(this.mainMenuList.getGui());
    }
}


/***/ }),

/***/ 3786:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartMenuParamsFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ChartMenuParamsFactory extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartOptionsProxy) {
        super();
        this.chartOptionsProxy = chartOptionsProxy;
    }
    getDefaultColorPickerParams(expression, labelKey, options) {
        return this.addValueParams(expression, {
            label: this.chartTranslation.translate(labelKey ?? 'color'),
            labelWidth: 'flex',
            inputWidth: 'flex',
            labelAlignment: 'top',
            pickerGap: 6,
        }, options);
    }
    getDefaultNumberInputParams(expression, labelKey, options) {
        return this.addValueParams(expression, {
            label: this.chartTranslation.translate(labelKey),
            labelAlignment: 'top',
            labelWidth: 'flex',
            inputWidth: 'flex',
            precision: options?.precision,
            step: options?.step,
            min: options?.min,
            max: options?.max,
        }, {
            parseInputValue: (value) => {
                const numberValue = Number(value);
                return isNaN(numberValue) ? undefined : numberValue;
            },
            formatInputValue: (value) => {
                return value == null ? '' : `${value}`;
            },
        });
    }
    getDefaultSliderParams(expression, labelKey, defaultMaxValue, isArray) {
        let value = this.chartOptionsProxy.getValue(expression) ?? 0;
        if (isArray && Array.isArray(value)) {
            value = value[0];
        }
        const params = this.getDefaultSliderParamsWithoutValueParams(value, labelKey, defaultMaxValue);
        params.onValueChange = (value) => this.chartOptionsProxy.setValue(expression, isArray ? [value] : value);
        return params;
    }
    getDefaultSliderParamsWithoutValueParams(value, labelKey, defaultMaxValue) {
        return {
            label: this.chartTranslation.translate(labelKey),
            minValue: 0,
            maxValue: Math.max(value, defaultMaxValue),
            textFieldWidth: 45,
            value: `${value}`,
        };
    }
    getDefaultCheckboxParams(expression, labelKey, options) {
        const value = this.chartOptionsProxy.getValue(expression);
        const params = {
            label: this.chartTranslation.translate(labelKey),
            value,
            readOnly: options?.readOnly,
            passive: options?.passive,
        };
        params.onValueChange = (value) => {
            this.chartOptionsProxy.setValue(expression, typeof value === 'boolean' ? value : undefined);
        };
        return params;
    }
    getDefaultSelectParams(expression, labelKey, dropdownOptions) {
        return this.getDefaultSelectParamsWithoutValueParams(labelKey, dropdownOptions, this.chartOptionsProxy.getValue(expression), (value) => {
            this.chartOptionsProxy.setValue(expression, value);
        });
    }
    getDefaultSelectParamsWithoutValueParams(labelKey, options, value, onValueChange) {
        return {
            label: this.chartTranslation.translate(labelKey),
            labelAlignment: 'top',
            options,
            pickerGap: 6,
            value,
            onValueChange,
        };
    }
    getDefaultFontPanelParams(expression, labelKey) {
        const keyMapper = (key) => `${expression}.${key}`;
        return this.addEnableParams(keyMapper('enabled'), {
            name: this.chartTranslation.translate(labelKey),
            suppressEnabledCheckbox: false,
            chartMenuParamsFactory: this,
            keyMapper,
        });
    }
    addValueParams(expression, params, options) {
        const optionsValue = this.chartOptionsProxy.getValue(expression);
        params.value = options?.formatInputValue ? options.formatInputValue(optionsValue) : optionsValue;
        params.onValueChange = (value) => {
            const optionsValue = options?.parseInputValue ? options.parseInputValue(value) : value;
            this.chartOptionsProxy.setValue(expression, optionsValue);
        };
        return params;
    }
    addEnableParams(expression, params) {
        params.enabled = this.chartOptionsProxy.getValue(expression) ?? false;
        params.onEnableChange = (value) => this.chartOptionsProxy.setValue(expression, value);
        return params;
    }
    getChartOptions() {
        return this.chartOptionsProxy;
    }
}
exports.ChartMenuParamsFactory = ChartMenuParamsFactory;


/***/ }),

/***/ 1299:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartPanelFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const seriesTypeMapper_1 = __webpack_require__(4237);
class ChartPanelFeature extends ag_grid_community_1.BeanStub {
    constructor(chartController, eGui, cssClass, createPanels) {
        super();
        this.chartController = chartController;
        this.eGui = eGui;
        this.cssClass = cssClass;
        this.createPanels = createPanels;
        this.panels = [];
    }
    postConstruct() {
        this.addManagedListeners(this.chartController, {
            chartUpdated: () => this.refreshPanels(true),
            chartApiUpdate: () => this.refreshPanels(false),
        });
    }
    addComponent(component) {
        this.createBean(component);
        this.panels.push(component);
        component.addCssClass(this.cssClass);
        this.eGui.appendChild(component.getGui());
    }
    refreshPanels(reuse) {
        const chartType = this.chartController.getChartType();
        const isGrouping = this.chartController.isGrouping();
        const seriesType = (0, seriesTypeMapper_1.getSeriesType)(chartType);
        if (reuse && chartType === this.chartType && isGrouping === this.isGrouping) {
            // existing panels can be re-used
            return;
        }
        this.destroyPanels();
        this.createPanels(chartType, seriesType);
        this.chartType = chartType;
        this.isGrouping = isGrouping;
    }
    destroyPanels() {
        this.panels.forEach((panel) => {
            (0, ag_grid_community_1._removeFromParent)(panel.getGui());
            this.destroyBean(panel);
        });
        this.panels = [];
    }
    destroy() {
        this.destroyPanels();
        super.destroy();
    }
}
exports.ChartPanelFeature = ChartPanelFeature;


/***/ }),

/***/ 4967:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartToolbar = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ChartToolbar extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor() {
        super(/* html */ `<div class="ag-chart-menu" data-ref="eMenu"></div>`);
        this.eMenu = ag_grid_community_1.RefPlaceholder;
        this.buttonListenersDestroyFuncs = [];
    }
    updateParams(params) {
        const { buttons } = params;
        this.createButtons(buttons);
    }
    createButtons(buttons) {
        this.buttonListenersDestroyFuncs.forEach((func) => func?.());
        this.buttonListenersDestroyFuncs = [];
        const menuEl = this.eMenu;
        (0, ag_grid_community_1._clearElement)(menuEl);
        buttons.forEach((buttonConfig) => {
            const { buttonName, iconName, callback } = buttonConfig;
            const buttonEl = this.createButton(iconName);
            const tooltipTitle = this.chartTranslation.translate((buttonName + 'ToolbarTooltip'));
            if (tooltipTitle && buttonEl instanceof HTMLElement) {
                buttonEl.title = tooltipTitle;
            }
            this.buttonListenersDestroyFuncs.push(...this.addManagedElementListeners(buttonEl, {
                click: (event) => callback(event.currentTarget),
            }));
            menuEl.appendChild(buttonEl);
        });
    }
    createButton(iconName) {
        const buttonEl = (0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans);
        buttonEl.classList.add('ag-chart-menu-icon');
        const wrapperEl = (0, ag_grid_community_1._getDocument)(this.beans).createElement('button');
        wrapperEl.appendChild(buttonEl);
        wrapperEl.classList.add('ag-chart-menu-toolbar-button');
        return wrapperEl;
    }
    destroy() {
        this.buttonListenersDestroyFuncs = [];
        super.destroy();
    }
}
exports.ChartToolbar = ChartToolbar;


/***/ }),

/***/ 2477:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoriesDataPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const chartDataModel_1 = __webpack_require__(8592);
const dragDataPanel_1 = __webpack_require__(6532);
const DEFAULT_AGG_FUNC = 'sum';
class CategoriesDataPanel extends dragDataPanel_1.DragDataPanel {
    constructor(chartController, title, allowMultipleSelection, dimensionCols, isOpen) {
        const maxSelection = undefined;
        super(chartController, allowMultipleSelection, maxSelection, /* html */ `<div id="categoriesGroup"></div>`);
        this.title = title;
        this.dimensionCols = dimensionCols;
        this.isOpen = isOpen;
    }
    postConstruct() {
        this.groupComp = this.createBean(new agGroupComponent_1.AgGroupComponent({
            title: this.title,
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data',
            expanded: this.isOpen,
        }));
        this.createGroup(this.dimensionCols, (col) => col.displayName ?? '', 'categoryAdd', 'categorySelect', () => !this.chartController.getAggFunc());
        this.createAggFuncControls(this.dimensionCols);
        this.getGui().appendChild(this.groupComp.getGui());
    }
    refresh(dimensionCols) {
        this.valuePillSelect?.setValues(dimensionCols, dimensionCols.filter((col) => col.selected));
        this.refreshValueSelect(dimensionCols);
        this.refreshAggFuncControls(dimensionCols, this.chartController.getAggFunc());
    }
    createAggFuncControls(dimensionCols) {
        const aggFunc = this.chartController.getAggFunc();
        this.groupComp.addItem((this.aggFuncToggle = this.createBean(new ag_grid_community_1.AgToggleButton({
            label: this.chartTranslation.translate('aggregate'),
            labelAlignment: 'left',
            labelWidth: 'flex',
            inputWidth: 'flex',
            value: aggFunc != undefined,
            onValueChange: (value) => {
                const aggFunc = value ? DEFAULT_AGG_FUNC : undefined;
                this.chartController.setAggFunc(aggFunc);
                this.aggFuncSelect?.setValue(aggFunc, true);
                this.aggFuncSelect?.setDisplayed(aggFunc != undefined);
            },
        }))));
        this.groupComp.addItem((this.aggFuncSelect = this.createBean(new ag_grid_community_1.AgSelect({
            options: [
                { value: 'sum', text: this.chartTranslation.translate('sum') },
                { value: 'first', text: this.chartTranslation.translate('first') },
                { value: 'last', text: this.chartTranslation.translate('last') },
                { value: 'min', text: this.chartTranslation.translate('min') },
                { value: 'max', text: this.chartTranslation.translate('max') },
                { value: 'count', text: this.chartTranslation.translate('count') },
                { value: 'avg', text: this.chartTranslation.translate('avg') },
            ],
            value: typeof aggFunc === 'string' ? aggFunc : undefined,
            onValueChange: (value) => {
                this.chartController.setAggFunc(value);
            },
        }))));
        this.refreshAggFuncControls(dimensionCols, aggFunc);
    }
    refreshAggFuncControls(dimensionCols, aggFunc) {
        const selectedDimensions = dimensionCols.filter((col) => col.selected);
        const supportsAggregation = selectedDimensions.some((col) => col.colId !== chartDataModel_1.DEFAULT_CHART_CATEGORY);
        this.aggFuncToggle?.setValue(aggFunc != undefined);
        this.aggFuncSelect?.setValue(typeof aggFunc === 'string' ? aggFunc : undefined, true);
        this.aggFuncToggle?.setDisplayed(supportsAggregation);
        this.aggFuncSelect?.setDisplayed(supportsAggregation && aggFunc != undefined);
    }
    clearAggFuncControls() {
        this.aggFuncToggle = this.destroyBean(this.aggFuncToggle);
        this.aggFuncSelect = this.destroyBean(this.aggFuncSelect);
    }
    destroy() {
        this.clearAggFuncControls();
        this.groupComp = this.destroyBean(this.groupComp);
        super.destroy();
    }
}
exports.CategoriesDataPanel = CategoriesDataPanel;


/***/ }),

/***/ 1504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartDataPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const seriesTypeMapper_1 = __webpack_require__(4237);
const categoriesDataPanel_1 = __webpack_require__(2477);
const chartSpecificDataPanel_1 = __webpack_require__(5524);
const seriesChartTypePanel_1 = __webpack_require__(1625);
const seriesDataPanel_1 = __webpack_require__(3365);
const DefaultDataPanelDef = {
    groups: [
        { type: 'categories', isOpen: true },
        { type: 'series', isOpen: true },
        { type: 'seriesChartType', isOpen: true },
        { type: 'chartSpecific', isOpen: true },
    ],
};
class ChartDataPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
        this.chartSvc = beans.chartSvc;
    }
    constructor(chartMenuContext) {
        super(/* html */ `<div class="ag-chart-data-wrapper ag-scrollable-container"></div>`);
        this.chartMenuContext = chartMenuContext;
        this.isSwitchCategorySeriesToggled = false;
        this.restoreSwitchCategorySeriesToggleFocus = false;
        this.panels = [];
        this.chartController = chartMenuContext.chartController;
    }
    postConstruct() {
        this.createSwitchCategorySeriesToggle();
        this.isSwitchCategorySeriesToggled = this.chartController.isCategorySeriesSwitched();
        this.updatePanels();
        const listener = this.updatePanels.bind(this);
        this.addManagedListeners(this.chartController, {
            chartModelUpdate: listener,
            chartApiUpdate: listener,
        });
    }
    destroy() {
        this.clearPanelComponents();
        super.destroy();
    }
    updatePanels() {
        const currentChartType = this.chartType;
        const isSwitchCategorySeriesToggledCurrent = this.isSwitchCategorySeriesToggled;
        const { dimensionCols, valueCols } = this.chartController.getColStateForMenu();
        this.chartType = this.chartController.getChartType();
        // Determine the state of the category/series toggle
        this.isSwitchCategorySeriesToggled = this.chartController.isCategorySeriesSwitched();
        const hasChangedSwitchCategorySeries = this.isSwitchCategorySeriesToggled !== isSwitchCategorySeriesToggledCurrent;
        // Attempt to re-use existing panels where possible in order to maintain keyboard focus
        if (this.canRefresh(currentChartType, this.chartType) && !hasChangedSwitchCategorySeries) {
            this.categoriesDataPanel?.refresh(dimensionCols);
            this.seriesDataPanel?.refresh(valueCols);
            this.seriesChartTypePanel?.refresh(valueCols);
            this.chartSpecificPanel?.refresh();
        }
        else {
            this.recreatePanels(dimensionCols, valueCols);
        }
        // Ensure the category/series toggle UI control is up-to-date
        const isSwitchCategorySeriesDisplayed = (0, seriesTypeMapper_1.supportsInvertedCategorySeries)(this.chartType) &&
            this.chartSvc.isEnterprise() &&
            !this.chartController.isGrouping();
        (0, ag_grid_community_1._setDisplayed)(this.switchCategorySeriesToggle.getGui(), isSwitchCategorySeriesDisplayed);
        if (hasChangedSwitchCategorySeries) {
            this.switchCategorySeriesToggle?.setValue(this.chartController.isCategorySeriesSwitched());
        }
        if (this.restoreSwitchCategorySeriesToggleFocus) {
            this.restoreSwitchCategorySeriesToggleFocus = false;
            if (isSwitchCategorySeriesDisplayed) {
                this.switchCategorySeriesToggle.getFocusableElement().focus();
            }
        }
    }
    canRefresh(oldChartType, newChartType) {
        if (oldChartType === undefined)
            return false;
        if (oldChartType === newChartType) {
            return true;
        }
        const isCombo = (chartType) => ['columnLineCombo', 'areaColumnCombo', 'customCombo'].includes(chartType);
        if (isCombo(oldChartType) && isCombo(newChartType)) {
            return true;
        }
        return false;
    }
    recreatePanels(dimensionCols, valueCols) {
        this.clearPanelComponents();
        const { chartType } = this;
        if (!chartType)
            return;
        const isCategorySeriesSwitched = this.chartController.isCategorySeriesSwitched();
        this.getDataPanelDef().groups?.forEach(({ type, isOpen }) => {
            if (type === (isCategorySeriesSwitched ? 'series' : 'categories')) {
                this.categoriesDataPanel = this.createBean(new categoriesDataPanel_1.CategoriesDataPanel(this.chartController, this.getCategoryGroupTitle(isCategorySeriesSwitched), this.getCategoryGroupMultipleSelect(chartType, isCategorySeriesSwitched), dimensionCols, isOpen));
                this.panels.push(this.categoriesDataPanel);
            }
            else if (type === (isCategorySeriesSwitched ? 'categories' : 'series')) {
                this.seriesDataPanel = this.createBean(new seriesDataPanel_1.SeriesDataPanel(this.chartController, this.chartMenuContext.chartOptionsService, this.getSeriesGroupTitle(isCategorySeriesSwitched), this.getSeriesGroupMultipleSelect(chartType, isCategorySeriesSwitched), this.getSeriesGroupMaxSelection(chartType, isCategorySeriesSwitched), valueCols, isOpen));
                this.panels.push(this.seriesDataPanel);
            }
            else if (type === 'seriesChartType') {
                if (this.chartController.isComboChart()) {
                    this.seriesChartTypePanel = this.createBean(new seriesChartTypePanel_1.SeriesChartTypePanel(this.chartController, valueCols, isOpen));
                    this.panels.push(this.seriesChartTypePanel);
                }
            }
            else if (type === 'chartSpecific') {
                this.chartSpecificPanel = this.createBean(new chartSpecificDataPanel_1.ChartSpecificDataPanel(this.chartMenuContext, isOpen));
                this.panels.push(this.chartSpecificPanel);
            }
            else {
                (0, ag_grid_community_1._warn)(144, { type });
            }
        });
        (isCategorySeriesSwitched ? this.categoriesDataPanel : this.seriesDataPanel)?.addItem(this.switchCategorySeriesToggle.getGui());
        this.addPanelComponents();
    }
    addPanelComponents() {
        if (!this.panels.length) {
            return;
        }
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        const fragment = eDocument.createDocumentFragment();
        for (const panel of this.panels) {
            panel.addCssClass('ag-chart-data-section');
            fragment.appendChild(panel.getGui());
        }
        this.getGui().appendChild(fragment);
    }
    clearPanelComponents() {
        const eGui = this.getGui();
        this.panels.forEach((panel) => {
            eGui.removeChild(panel.getGui());
            this.destroyBean(panel);
        });
        this.panels = [];
    }
    getDataPanelDef() {
        return this.gos.get('chartToolPanelsDef')?.dataPanel ?? DefaultDataPanelDef;
    }
    getCategoryGroupTitle(isCategorySeriesSwitched) {
        if (isCategorySeriesSwitched)
            return this.chartTranslation.translate('seriesLabels');
        return this.chartTranslation.translate(this.chartController.isActiveXYChart() ? 'labels' : 'categories');
    }
    getCategoryGroupMultipleSelect(chartType, isCategorySeriesSwitched) {
        if (isCategorySeriesSwitched)
            return false;
        return (0, seriesTypeMapper_1.getMaxNumCategories)(chartType) !== 1;
    }
    getSeriesGroupTitle(isCategorySeriesSwitched) {
        if (isCategorySeriesSwitched)
            return this.chartTranslation.translate('categoryValues');
        return this.chartTranslation.translate(this.chartController.isActiveXYChart() ? 'xyValues' : 'series');
    }
    getSeriesGroupMultipleSelect(chartType, isCategorySeriesSwitched) {
        return this.getSeriesGroupMaxSelection(chartType, isCategorySeriesSwitched) !== 1;
    }
    getSeriesGroupMaxSelection(chartType, isCategorySeriesSwitched) {
        if (isCategorySeriesSwitched)
            return undefined;
        return (0, seriesTypeMapper_1.getMaxNumSeries)(chartType);
    }
    createSwitchCategorySeriesToggle() {
        this.switchCategorySeriesToggle = this.createManagedBean(new ag_grid_community_1.AgToggleButton({
            label: this.chartTranslation.translate('switchCategorySeries'),
            labelAlignment: 'left',
            labelWidth: 'flex',
            inputWidth: 'flex',
            value: this.chartController.isCategorySeriesSwitched(),
            onValueChange: (value) => {
                this.restoreSwitchCategorySeriesToggleFocus = true;
                this.chartController.switchCategorySeries(value);
            },
        }));
    }
}
exports.ChartDataPanel = ChartDataPanel;


/***/ }),

/***/ 5524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartSpecificDataPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartMenuParamsFactory_1 = __webpack_require__(3786);
class ChartSpecificDataPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
        this.chartSvc = beans.chartSvc;
    }
    constructor(chartMenuContext, isOpen) {
        super();
        this.chartMenuContext = chartMenuContext;
        this.isOpen = isOpen;
        this.chartSpecificGroup = ag_grid_community_1.RefPlaceholder;
        this.hasContent = false;
    }
    postConstruct() {
        const title = this.getTitle();
        const chartSpecificGroupParams = {
            title,
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data',
            expanded: this.isOpen,
            items: [...this.createDirectionSelect(), this.createGroupTypeSelect()],
        };
        this.setTemplate(
        /* html */ `
            <div id="chartSpecificGroup">
                <ag-group-component data-ref="chartSpecificGroup"></ag-group-component>
            </div>`, [agGroupComponent_1.AgGroupComponentSelector], {
            chartSpecificGroup: chartSpecificGroupParams,
        });
        this.setDisplayed(this.hasContent);
    }
    refresh() {
        this.hasContent = false;
        this.chartSpecificGroup.setTitle(this.getTitle());
        this.updateDirectionSelect();
        this.updateGroupTypeSelect();
        this.setDisplayed(this.hasContent);
    }
    getTitle() {
        const chartType = this.chartMenuContext.chartController.getChartType();
        return this.chartTranslation.translate((0, seriesTypeMapper_1.getFullChartNameTranslationKey)(chartType));
    }
    createDirectionSelect() {
        if (!this.chartSvc.isEnterprise()) {
            return [];
        }
        const { chartOptionsService, chartController } = this.chartMenuContext;
        const chartOptionsSeriesProxy = chartOptionsService.getSeriesOptionsProxy(() => (0, seriesTypeMapper_1.getSeriesType)(chartController.getChartType()));
        const chartSeriesMenuParamsFactory = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(chartOptionsSeriesProxy));
        const options = ['horizontal', 'vertical'].map((value) => ({
            value,
            text: this.chartTranslation.translate(value),
        }));
        const params = chartSeriesMenuParamsFactory.getDefaultSelectParams('direction', 'direction', options);
        const onValueChange = params.onValueChange;
        params.onValueChange = (value) => {
            onValueChange(value);
            // series and axes configuration are based on direction
            chartController.raiseChartModelUpdateEvent();
        };
        this.directionSelect = this.createManagedBean(new ag_grid_community_1.AgSelect(params));
        this.updateDirectionSelect();
        return [this.directionSelect];
    }
    updateDirectionSelect() {
        const isDisplayed = (0, seriesTypeMapper_1.canSwitchDirection)(this.chartMenuContext.chartController.getChartType());
        this.updateDisplayed(this.directionSelect, isDisplayed);
    }
    createGroupTypeSelect() {
        const { chartController, chartMenuParamsFactory } = this.chartMenuContext;
        this.groupTypeSelect = this.createManagedBean(new ag_grid_community_1.AgSelect(chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams('seriesGroupType', seriesTypeMapper_1.SERIES_GROUP_TYPES.map((value) => ({
            value,
            text: this.chartTranslation.translate(`${value}SeriesGroupType`),
        })), chartController.getSeriesGroupType(), (value) => chartController.setSeriesGroupType(value))));
        this.updateGroupTypeSelect();
        return this.groupTypeSelect;
    }
    updateGroupTypeSelect() {
        const isDisplayed = ['radialColumn', 'radialBar', 'nightingale'].includes(this.chartMenuContext.chartController.getChartType());
        this.updateDisplayed(this.groupTypeSelect, isDisplayed);
    }
    updateDisplayed(select, isDisplayed) {
        select?.setDisplayed(isDisplayed);
        if (select) {
            this.hasContent = this.hasContent || isDisplayed;
        }
    }
}
exports.ChartSpecificDataPanel = ChartSpecificDataPanel;


/***/ }),

/***/ 6532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragDataPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPillSelect_1 = __webpack_require__(2406);
const chartDataModel_1 = __webpack_require__(8592);
class DragDataPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartController, allowMultipleSelection, maxSelection, template) {
        super(template);
        this.chartController = chartController;
        this.allowMultipleSelection = allowMultipleSelection;
        this.maxSelection = maxSelection;
    }
    addItem(eItem) {
        this.groupComp.addItem(eItem);
    }
    createGroup(columns, valueFormatter, selectLabelKey, dragSourceId, skipAnimation) {
        if (this.allowMultipleSelection) {
            const selectedValueList = columns.filter((col) => col.selected);
            this.valuePillSelect = this.groupComp.createManagedBean(new agPillSelect_1.AgPillSelect({
                valueList: columns,
                selectedValueList,
                valueFormatter,
                selectPlaceholder: this.chartTranslation.translate(selectLabelKey),
                dragSourceId,
                onValuesChange: (params) => this.onValueChange(params),
                maxSelection: this.maxSelection,
            }));
            this.groupComp.addItem(this.valuePillSelect);
        }
        else {
            const params = this.createValueSelectParams(columns);
            params.onValueChange = (updatedColState) => {
                columns.forEach((col) => {
                    col.selected = false;
                });
                updatedColState.selected = true;
                // Clear the category aggregation function if the default ordinal category is selected
                if (updatedColState.colId === chartDataModel_1.DEFAULT_CHART_CATEGORY) {
                    this.chartController.setAggFunc(undefined, true);
                }
                this.chartController.updateForPanelChange({ updatedColState, skipAnimation: skipAnimation?.() });
            };
            this.valueSelect = this.groupComp.createManagedBean(new ag_grid_community_1.AgSelect(params));
            this.groupComp.addItem(this.valueSelect);
        }
    }
    refreshValueSelect(columns) {
        if (!this.valueSelect) {
            return;
        }
        const { options, value } = this.createValueSelectParams(columns);
        this.valueSelect.clearOptions().addOptions(options).setValue(value, true);
    }
    createValueSelectParams(columns) {
        let selectedValue;
        const options = columns.map((value) => {
            const text = value.displayName ?? '';
            if (value.selected) {
                selectedValue = value;
            }
            return {
                value,
                text,
            };
        });
        return {
            options,
            value: selectedValue,
        };
    }
    onValueChange({ added, updated, removed, selected }) {
        let updatedColState;
        let resetOrder;
        const updateOrder = () => {
            selected.forEach((col, index) => {
                col.order = index;
            });
            resetOrder = true;
        };
        if (added.length) {
            updatedColState = added[0];
            updatedColState.selected = true;
            updateOrder();
        }
        else if (removed.length) {
            updatedColState = removed[0];
            updatedColState.selected = false;
        }
        else if (updated.length) {
            updateOrder();
            updatedColState = updated[0];
        }
        if (updatedColState) {
            this.chartController.updateForPanelChange({ updatedColState, resetOrder });
        }
    }
    destroy() {
        this.valuePillSelect = undefined;
        this.valueSelect = undefined;
        super.destroy();
    }
}
exports.DragDataPanel = DragDataPanel;


/***/ }),

/***/ 1625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeriesChartTypePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const seriesTypeMapper_1 = __webpack_require__(4237);
class SeriesChartTypePanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartController, columns, isOpen) {
        super(/* html */ `<div id="seriesChartTypeGroup"></div>`);
        this.chartController = chartController;
        this.columns = columns;
        this.isOpen = isOpen;
        this.selectedColIds = [];
        this.chartTypeComps = new Map();
        this.secondaryAxisComps = new Map();
    }
    postConstruct() {
        this.createSeriesChartTypeGroup(this.columns);
    }
    refresh(columns) {
        if (!(0, ag_grid_community_1._areEqual)(this.getValidColIds(columns), this.selectedColIds)) {
            this.recreate(columns);
        }
        else {
            this.refreshComps();
        }
    }
    recreate(columns) {
        this.isOpen = this.seriesChartTypeGroupComp.isExpanded();
        (0, ag_grid_community_1._clearElement)(this.getGui());
        this.destroyBean(this.seriesChartTypeGroupComp);
        this.columns = columns;
        this.selectedColIds = [];
        this.clearComps();
        this.postConstruct();
    }
    getValidColIds(columns) {
        const seriesChartTypes = this.chartController.getSeriesChartTypes();
        return columns
            .filter((col) => col.selected && !!seriesChartTypes.filter((s) => s.colId === col.colId)[0])
            .map(({ colId }) => colId);
    }
    createSeriesChartTypeGroup(columns) {
        this.seriesChartTypeGroupComp = this.createBean(new agGroupComponent_1.AgGroupComponent({
            title: this.chartTranslation.translate('seriesChartType'),
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data',
            expanded: this.isOpen,
        }));
        const seriesChartTypes = this.chartController.getSeriesChartTypes();
        columns.forEach((col) => {
            if (!col.selected) {
                return;
            }
            const seriesChartType = seriesChartTypes.filter((s) => s.colId === col.colId)[0];
            if (!seriesChartType) {
                return;
            }
            this.selectedColIds.push(col.colId);
            const seriesItemGroup = this.seriesChartTypeGroupComp.createManagedBean(new agGroupComponent_1.AgGroupComponent({
                title: col.displayName,
                enabled: true,
                suppressEnabledCheckbox: true,
                suppressOpenCloseIcons: true,
                cssIdentifier: 'charts-format-sub-level',
            }));
            const isSecondaryAxisDisabled = (chartType) => ['groupedColumn', 'stackedColumn', 'stackedArea'].includes(chartType);
            const secondaryAxisComp = this.seriesChartTypeGroupComp.createManagedBean(new ag_grid_community_1.AgCheckbox({
                label: this.chartTranslation.translate('secondaryAxis'),
                labelWidth: 'flex',
                disabled: isSecondaryAxisDisabled(seriesChartType.chartType),
                value: !!seriesChartType.secondaryAxis,
                onValueChange: (enabled) => this.chartController.updateSeriesChartType(col.colId, undefined, enabled),
            }));
            seriesItemGroup.addItem(secondaryAxisComp);
            const options = ['line', 'area', 'stackedArea', 'groupedColumn', 'stackedColumn'].map((value) => ({
                value,
                text: this.chartTranslation.translate((0, seriesTypeMapper_1.getFullChartNameTranslationKey)(value)),
            }));
            const chartTypeComp = seriesItemGroup.createManagedBean(new ag_grid_community_1.AgSelect({
                options,
                value: seriesChartType.chartType,
                onValueChange: (chartType) => this.chartController.updateSeriesChartType(col.colId, chartType),
            }));
            seriesItemGroup.addItem(chartTypeComp);
            this.seriesChartTypeGroupComp.addItem(seriesItemGroup);
            this.chartTypeComps.set(col.colId, chartTypeComp);
            this.secondaryAxisComps.set(col.colId, secondaryAxisComp);
        });
        this.getGui().appendChild(this.seriesChartTypeGroupComp.getGui());
    }
    refreshComps() {
        const seriesChartTypes = this.chartController.getSeriesChartTypes();
        this.selectedColIds.forEach((colId) => {
            const seriesChartType = seriesChartTypes.find((chartType) => chartType.colId === colId);
            if (!seriesChartType) {
                return;
            }
            const chartTypeComp = this.chartTypeComps.get(colId);
            const secondaryAxisComp = this.secondaryAxisComps.get(colId);
            chartTypeComp?.setValue(seriesChartType.chartType);
            secondaryAxisComp?.setValue(!!seriesChartType.secondaryAxis);
            secondaryAxisComp?.setDisabled(this.isSecondaryAxisDisabled(seriesChartType.chartType));
        });
    }
    clearComps() {
        this.chartTypeComps.clear();
        this.secondaryAxisComps.clear();
    }
    isSecondaryAxisDisabled(chartType) {
        return ['groupedColumn', 'stackedColumn', 'stackedArea'].includes(chartType);
    }
    destroy() {
        this.clearComps();
        this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp);
        super.destroy();
    }
}
exports.SeriesChartTypePanel = SeriesChartTypePanel;


/***/ }),

/***/ 3365:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeriesDataPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const dragDataPanel_1 = __webpack_require__(6532);
class SeriesDataPanel extends dragDataPanel_1.DragDataPanel {
    constructor(chartController, chartOptionsService, title, allowMultipleSelect, maxSelection, valueCols, isOpen) {
        super(chartController, allowMultipleSelect, maxSelection, /* html */ `<div id="seriesGroup"></div>`);
        this.chartOptionsService = chartOptionsService;
        this.title = title;
        this.valueCols = valueCols;
        this.isOpen = isOpen;
    }
    postConstruct() {
        this.groupComp = this.createBean(new agGroupComponent_1.AgGroupComponent({
            title: this.title,
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data',
            expanded: this.isOpen,
        }));
        if (this.chartController.isActiveXYChart()) {
            const pairedModeToggle = this.groupComp.createManagedBean(new ag_grid_community_1.AgToggleButton({
                label: this.chartTranslation.translate('paired'),
                labelAlignment: 'left',
                labelWidth: 'flex',
                inputWidth: 'flex',
                value: this.chartOptionsService.getPairedMode(),
                onValueChange: (newValue) => {
                    this.chartOptionsService.setPairedMode(!!newValue);
                    this.chartController.updateForGridChange({ maintainColState: true });
                },
            }));
            this.groupComp.addItem(pairedModeToggle);
        }
        this.createGroup(this.valueCols, this.generateGetSeriesLabel(this.valueCols), 'seriesAdd', 'seriesSelect');
        this.getGui().appendChild(this.groupComp.getGui());
    }
    refresh(valueCols) {
        this.valuePillSelect?.setValueFormatter(this.generateGetSeriesLabel(valueCols));
        this.valuePillSelect?.setValues(valueCols, valueCols.filter((col) => col.selected));
        this.refreshValueSelect(valueCols);
    }
    generateGetSeriesLabel(valueCols) {
        if (!this.chartController.isActiveXYChart()) {
            return (col) => col.displayName ?? '';
        }
        const selectedCols = valueCols.filter((col) => col.selected);
        const isBubble = this.chartController.getChartType() === 'bubble';
        const isInPairedMode = this.chartOptionsService.getPairedMode();
        const indexToAxisLabel = new Map();
        indexToAxisLabel.set(0, 'X');
        indexToAxisLabel.set(1, 'Y');
        indexToAxisLabel.set(2, 'size');
        return (col) => {
            const escapedLabel = col.displayName ?? '';
            if (!col.selected) {
                return escapedLabel;
            }
            const index = selectedCols.indexOf(col);
            if (index === -1) {
                return escapedLabel;
            }
            let axisLabel;
            if (isInPairedMode) {
                axisLabel = indexToAxisLabel.get(index % (isBubble ? 3 : 2));
            }
            else {
                if (index === 0) {
                    axisLabel = 'X';
                }
                else {
                    axisLabel = isBubble && index % 2 === 0 ? 'size' : 'Y';
                }
            }
            return `${escapedLabel} (${axisLabel})`;
        };
    }
    destroy() {
        this.groupComp = this.destroyBean(this.groupComp);
        super.destroy();
    }
}
exports.SeriesDataPanel = SeriesDataPanel;


/***/ }),

/***/ 5248:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AxisTicksPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
class AxisTicksPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const { chartMenuUtils } = this;
        const axisTicksGroupParams = chartMenuUtils.addEnableParams('tick.enabled', {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('ticks'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const axisTicksColorPickerParams = chartMenuUtils.getDefaultColorPickerParams('tick.stroke');
        const axisTicksWidthSliderParams = chartMenuUtils.getDefaultSliderParams('tick.width', 'width', 10);
        const axisTicksSizeSliderParams = chartMenuUtils.getDefaultSliderParams('tick.size', 'length', 30);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="axisTicksGroup">
                <ag-color-picker data-ref="axisTicksColorPicker"></ag-color-picker>
                <ag-slider data-ref="axisTicksWidthSlider"></ag-slider>
                <ag-slider data-ref="axisTicksSizeSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            axisTicksGroup: axisTicksGroupParams,
            axisTicksColorPicker: axisTicksColorPickerParams,
            axisTicksWidthSlider: axisTicksWidthSliderParams,
            axisTicksSizeSlider: axisTicksSizeSliderParams,
        });
    }
}
exports.AxisTicksPanel = AxisTicksPanel;


/***/ }),

/***/ 5002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartesianAxisPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agAngleSelect_1 = __webpack_require__(1750);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
const chartMenuParamsFactory_1 = __webpack_require__(3786);
const fontPanel_1 = __webpack_require__(7730);
const axisTicksPanel_1 = __webpack_require__(5248);
const gridLinePanel_1 = __webpack_require__(4513);
const DEFAULT_TIME_AXIS_FORMAT = '%d %B %Y';
class CartesianAxisPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(axisType, options) {
        super();
        this.axisType = axisType;
        this.options = options;
        this.axisGroup = ag_grid_community_1.RefPlaceholder;
        this.axisTypeSelect = ag_grid_community_1.RefPlaceholder;
        this.axisPositionSelect = ag_grid_community_1.RefPlaceholder;
        this.axisTimeFormatSelect = ag_grid_community_1.RefPlaceholder;
        this.activePanels = [];
        this.axisLabelUpdateFuncs = [];
        const { chartOptionsService, seriesType } = options;
        this.chartOptionsSeriesProxy = chartOptionsService.getSeriesOptionsProxy(() => seriesType);
    }
    postConstruct() {
        const { isExpandedOnInit: expanded, chartOptionsService, chartController, registerGroupComponent, } = this.options;
        const labelKey = this.axisType;
        const axisGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.translate(labelKey),
            expanded,
            suppressEnabledCheckbox: true,
        };
        const chartAxisOptionsProxy = chartOptionsService.getCartesianAxisOptionsProxy(this.axisType);
        const chartAxisOptions = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(chartAxisOptionsProxy));
        const chartAxisThemeOverrides = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(chartOptionsService.getCartesianAxisThemeOverridesProxy(this.axisType)));
        const axisTypeSelectParams = this.getAxisTypeSelectParams(chartAxisOptions, chartOptionsService.getCartesianAxisAppliedThemeOverridesProxy(this.axisType));
        const axisPositionSelectParams = this.getAxisPositionSelectParams(chartAxisOptions);
        const axisTimeFormatSelectParams = this.getAxisTimeFormatSelectParams(chartAxisOptions);
        const axisColorInputParams = this.getAxisColorInputParams(chartAxisThemeOverrides);
        const axisLineWidthSliderParams = this.getAxisLineWidthSliderParams(chartAxisThemeOverrides);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="axisGroup">
                <ag-select data-ref="axisTypeSelect"></ag-select>
                <ag-select data-ref="axisTimeFormatSelect"></ag-select>
                <ag-select data-ref="axisPositionSelect"></ag-select>
                <ag-color-picker data-ref="axisColorInput"></ag-color-picker>
                <ag-slider data-ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgSelectSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            axisGroup: axisGroupParams,
            axisTypeSelect: axisTypeSelectParams ?? undefined,
            axisPositionSelect: axisPositionSelectParams ?? undefined,
            axisTimeFormatSelect: axisTimeFormatSelectParams ?? undefined,
            axisColorInput: axisColorInputParams,
            axisLineWidthSlider: axisLineWidthSliderParams,
        });
        registerGroupComponent(this.axisGroup);
        this.axisTypeSelect.setDisplayed(!!axisTypeSelectParams.options?.length);
        if (!axisPositionSelectParams)
            this.removeTemplateComponent(this.axisPositionSelect);
        const updateTimeFormatVisibility = () => {
            const isTimeAxis = chartAxisOptionsProxy.getValue('type') === 'time';
            (0, ag_grid_community_1._setDisplayed)(this.axisTimeFormatSelect.getGui(), isTimeAxis);
        };
        if (!axisTimeFormatSelectParams) {
            this.removeTemplateComponent(this.axisTimeFormatSelect);
        }
        else {
            // Conditionally hide the time format input based on the currently selected axis type
            updateTimeFormatVisibility();
            // Update the visibility whenever the axis type changes
            this.addManagedEventListeners({
                chartOptionsChanged: () => {
                    updateTimeFormatVisibility();
                },
            });
        }
        this.initGridLines(chartAxisThemeOverrides);
        this.initAxisTicks(chartAxisThemeOverrides);
        this.initAxisLabels(chartAxisThemeOverrides);
        const updateAxisLabelRotations = () => this.axisLabelUpdateFuncs.forEach((func) => func());
        this.addManagedListeners(chartController, {
            chartUpdated: updateAxisLabelRotations,
            chartModelUpdate: () => setTimeout(() => {
                if (!this.isAlive()) {
                    return;
                }
                // make sure this runs after the actual chart update has happened
                this.refreshAxisTypeSelect(chartAxisOptions);
                updateTimeFormatVisibility();
            }),
        });
    }
    getAxisTypeSelectParams(chartAxisOptions, chartAxisAppliedThemeOverrides) {
        const chartOptions = chartAxisOptions.getChartOptions();
        const axisTypeSelectOptions = this.getAxisTypeSelectOptions();
        const params = chartAxisOptions.getDefaultSelectParams('type', 'axisType', axisTypeSelectOptions);
        params.onValueChange = (value) => {
            const previousAxisType = chartOptions.getValue('type');
            if (value === previousAxisType)
                return;
            // If the axis type is changed, we need to carry over all the accumulated theme overrides
            // that have been applied to the existing axis type so far
            const previousAxisThemeOverrides = chartAxisAppliedThemeOverrides.getValue('*');
            // Optionally update the axis label format when switching between time and non-time axes
            const previousAxisIsTimeAxis = previousAxisType === 'time';
            const updatedAxisIsTimeAxis = value === 'time';
            const updatedLabelFormat = previousAxisIsTimeAxis !== updatedAxisIsTimeAxis
                ? updatedAxisIsTimeAxis
                    ? DEFAULT_TIME_AXIS_FORMAT
                    : undefined
                : null;
            // Update the axis type (and label format if necessary)
            this.options.chartOptionsService.setCartesianCategoryAxisType(this.axisType, value);
            if (updatedLabelFormat !== null) {
                const existingLabel = chartOptions.getValue('label') ?? {};
                chartOptions.setValue('label', {
                    ...existingLabel,
                    format: updatedLabelFormat,
                });
            }
            // Reapply the previous theme overrides to the new axis type
            chartAxisAppliedThemeOverrides.setValue('*', previousAxisThemeOverrides);
        };
        return params;
    }
    refreshAxisTypeSelect(chartAxisOptions) {
        const options = this.getAxisTypeSelectOptions();
        const hasOptions = !!options.length;
        this.axisTypeSelect.setDisplayed(hasOptions);
        if (!hasOptions) {
            return;
        }
        this.axisTypeSelect
            .clearOptions()
            .addOptions(options)
            .setValue(chartAxisOptions.getChartOptions().getValue('type'));
    }
    getAxisTypeSelectOptions() {
        const { chartController } = this.options;
        const chartType = chartController.getChartType();
        const supportsNumericalAxis = () => {
            const testDatum = chartController.getChartData()[0];
            if (!testDatum) {
                return false;
            }
            return chartController.getSelectedDimensions().every((col) => !isNaN(parseFloat(testDatum[col.colId])));
        };
        if (['heatmap', 'histogram', 'boxPlot', 'rangeBar', 'scatter', 'bubble'].includes(chartType) ||
            chartController.isGrouping() ||
            !this.isCategoryAxis() ||
            chartController.isCategorySeriesSwitched() ||
            !supportsNumericalAxis()) {
            return [];
        }
        return ['category', 'number', 'time'].map((value) => ({
            value,
            text: this.translate(value),
        }));
    }
    isCategoryAxis() {
        const isHorizontal = this.chartOptionsSeriesProxy.getValue('direction') === 'horizontal';
        return (isHorizontal && this.axisType === 'yAxis') || (!isHorizontal && this.axisType === 'xAxis');
    }
    getAxisPositionSelectParams(chartAxisOptions) {
        const axisPositionSelectOptions = ((chartType, axisType) => {
            switch (chartType) {
                // Some chart types do not support configuring the axis position
                case 'heatmap':
                    return null;
                default:
                    switch (axisType) {
                        // Horizontal axis position can be changed between top and bottom
                        case 'xAxis':
                            return [
                                { value: 'top', text: this.translate('top') },
                                { value: 'bottom', text: this.translate('bottom') },
                            ];
                        // Vertical axis position can be changed between left and right
                        case 'yAxis':
                            return [
                                { value: 'left', text: this.translate('left') },
                                { value: 'right', text: this.translate('right') },
                            ];
                    }
            }
        })(this.options.chartController.getChartType(), this.axisType);
        if (!axisPositionSelectOptions)
            return null;
        return chartAxisOptions.getDefaultSelectParams('position', 'position', axisPositionSelectOptions);
    }
    getAxisTimeFormatSelectParams(chartAxisOptions) {
        if (!this.isCategoryAxis()) {
            return null;
        }
        const axisTimeFormatSelectOptions = [
            { value: '%d/%m/%Y', text: this.translate('timeFormatSlashesDDMMYYYY') },
            { value: '%m/%d/%Y', text: this.translate('timeFormatSlashesMMDDYYYY') },
            { value: '%d/%m/%y', text: this.translate('timeFormatSlashesDDMMYY') },
            { value: '%m/%d/%y', text: this.translate('timeFormatSlashesMMDDYY') },
            { value: '%d.%e.%y', text: this.translate('timeFormatDotsDDMYY') },
            { value: '%e.%d.%y', text: this.translate('timeFormatDotsMDDYY') },
            { value: '%Y-%m-%d', text: this.translate('timeFormatDashesYYYYMMDD') },
            { value: '%d %B %Y', text: this.translate('timeFormatSpacesDDMMMMYYYY') },
            { value: '%H:%M:%S', text: this.translate('timeFormatHHMMSS') },
            { value: '%I:%M:%S %p', text: this.translate('timeFormatHHMMSSAmPm') },
        ];
        return chartAxisOptions.getDefaultSelectParams('label.format', 'timeFormat', axisTimeFormatSelectOptions);
    }
    getAxisColorInputParams(chartAxisThemeOverrides) {
        return chartAxisThemeOverrides.getDefaultColorPickerParams('line.stroke');
    }
    getAxisLineWidthSliderParams(chartAxisThemeOverrides) {
        const chartOptions = chartAxisThemeOverrides.getChartOptions();
        // Note that there is no separate checkbox for enabling/disabling the axis line. Whenever the line width is
        // changed, the value for `line.enabled` is inferred based on the whether the `line.width` value is non-zero.
        const getAxisLineWidth = () => {
            const isAxisLineEnabled = chartOptions.getValue('line.enabled');
            if (!isAxisLineEnabled)
                return null;
            return chartOptions.getValue('line.width');
        };
        const setAxisLineWidth = (value) => {
            chartOptions.setValues([
                { expression: 'line.enabled', value: value != null },
                { expression: 'line.width', value: value ?? 0 },
            ]);
        };
        const axisLineWidthSliderParams = chartAxisThemeOverrides.getDefaultSliderParamsWithoutValueParams(getAxisLineWidth() ?? 0, 'thickness', 10);
        axisLineWidthSliderParams.onValueChange = (newValue) => {
            setAxisLineWidth(newValue === 0 ? null : newValue);
        };
        return axisLineWidthSliderParams;
    }
    initGridLines(chartAxisThemeOverrides) {
        const chartType = this.options.chartController.getChartType();
        // Some chart types do not support configuring grid lines
        if (chartType === 'heatmap') {
            return;
        }
        const gridLineComp = this.createBean(new gridLinePanel_1.GridLinePanel(chartAxisThemeOverrides));
        this.axisGroup.addItem(gridLineComp);
        this.activePanels.push(gridLineComp);
    }
    initAxisTicks(chartAxisThemeOverrides) {
        if (!this.hasConfigurableAxisTicks())
            return;
        const axisTicksComp = this.createBean(new axisTicksPanel_1.AxisTicksPanel(chartAxisThemeOverrides));
        this.axisGroup.addItem(axisTicksComp);
        this.activePanels.push(axisTicksComp);
    }
    hasConfigurableAxisTicks() {
        // Axis ticks are disabled for some chart types
        const chartType = this.options.chartController.getChartType();
        switch (chartType) {
            case 'radarLine':
            case 'radarArea':
            case 'rangeBar':
            case 'boxPlot':
            case 'waterfall':
                return false;
            default:
                return true;
        }
    }
    initAxisLabels(chartAxisThemeOverrides) {
        const params = {
            name: this.translate('labels'),
            enabled: true,
            suppressEnabledCheckbox: true,
            chartMenuParamsFactory: chartAxisThemeOverrides,
            keyMapper: (key) => `label.${key}`,
        };
        const labelPanelComp = this.createBean(new fontPanel_1.FontPanel(params));
        this.axisGroup.addItem(labelPanelComp);
        this.activePanels.push(labelPanelComp);
        this.addAdditionalLabelComps(labelPanelComp, chartAxisThemeOverrides);
    }
    addAdditionalLabelComps(labelPanelComp, chartAxisThemeOverrides) {
        this.addLabelPadding(labelPanelComp, chartAxisThemeOverrides);
        const rotationComp = this.createRotationWidget('labelRotation', chartAxisThemeOverrides);
        const autoRotateCb = this.initLabelRotation(rotationComp, chartAxisThemeOverrides);
        labelPanelComp.addItem(autoRotateCb);
        labelPanelComp.addItem(rotationComp);
    }
    initLabelRotation(rotationComp, chartAxisThemeOverrides) {
        const chartOptions = chartAxisThemeOverrides.getChartOptions();
        const getLabelRotationValue = () => {
            return chartOptions.getValue('label.rotation');
        };
        const getLabelAutoRotateValue = () => {
            return chartOptions.getValue('label.autoRotate');
        };
        const updateAutoRotate = (autoRotate) => {
            // Remember the existing rotation before we clear it from the options
            if (autoRotate)
                this.prevRotation = getLabelRotationValue();
            // For the autoRotate option to take effect, we need to additionally clear the rotation option value
            chartOptions.setValues([
                { expression: 'label.autoRotate', value: autoRotate },
                // Clear the rotation option when activating auto-rotate, reinstate the previous value when deactivating
                { expression: 'label.rotation', value: autoRotate ? undefined : this.prevRotation },
            ]);
            rotationComp.setDisplayed(!autoRotate);
        };
        const rotation = getLabelRotationValue();
        const autoRotate = typeof rotation === 'number' ? false : getLabelAutoRotateValue();
        const autoRotateCheckbox = this.createBean(new ag_grid_community_1.AgCheckbox({
            label: this.translate('autoRotate'),
            value: autoRotate,
            onValueChange: updateAutoRotate,
        }));
        // init rotation comp state
        rotationComp.setDisplayed(!autoRotate);
        return autoRotateCheckbox;
    }
    createRotationWidget(labelKey, chartAxisThemeOverrides) {
        const chartOptions = chartAxisThemeOverrides.getChartOptions();
        const getLabelRotationValue = () => {
            return chartOptions.getValue('label.rotation');
        };
        const setLabelRotationValue = (value) => {
            return chartOptions.setValue('label.rotation', value);
        };
        const degreesSymbol = String.fromCharCode(176);
        const label = `${this.chartTranslation.translate(labelKey)} ${degreesSymbol}`;
        const angleSelect = new agAngleSelect_1.AgAngleSelect({
            label,
            labelWidth: 'flex',
            value: getLabelRotationValue() ?? 0,
            onValueChange: setLabelRotationValue,
        });
        // the axis label rotation needs to be updated when the default category changes in the data panel
        this.axisLabelUpdateFuncs.push(() => {
            angleSelect.setValue(getLabelRotationValue() ?? 0);
        });
        return this.createBean(angleSelect);
    }
    addLabelPadding(labelPanelComp, chartAxisThemeOverrides) {
        const labelPaddingSlider = this.createBean(new agSlider_1.AgSlider(chartAxisThemeOverrides.getDefaultSliderParams('label.spacing', 'padding', 30)));
        labelPanelComp.addItem(labelPaddingSlider);
    }
    translate(key) {
        return this.chartTranslation.translate(key);
    }
    removeTemplateComponent(component) {
        (0, ag_grid_community_1._removeFromParent)(component.getGui());
        this.destroyBean(component);
    }
    destroyActivePanels() {
        this.activePanels.forEach((panel) => {
            (0, ag_grid_community_1._removeFromParent)(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
exports.CartesianAxisPanel = CartesianAxisPanel;


/***/ }),

/***/ 4513:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridLinePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
class GridLinePanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
        this.chartOptions = chartMenuUtils.getChartOptions();
    }
    postConstruct() {
        const gridLineGroupParams = this.chartMenuUtils.addEnableParams('gridLine.enabled', {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('gridLines'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const gridLineColorPickerParams = this.getGridLineColorPickerParams('color');
        const gridLineWidthSliderParams = this.getGridLineWidthSliderParams('thickness');
        const gridLineLineDashSliderParams = this.getGridLineDashSliderParams('lineDash');
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="gridLineGroup">
                <ag-color-picker data-ref="gridLineColorPicker"></ag-color-picker>
                <ag-slider data-ref="gridLineWidthSlider"></ag-slider>
                <ag-slider data-ref="gridLineLineDashSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            gridLineGroup: gridLineGroupParams,
            gridLineColorPicker: gridLineColorPickerParams,
            gridLineWidthSlider: gridLineWidthSliderParams,
            gridLineLineDashSlider: gridLineLineDashSliderParams,
        });
    }
    getGridLineColorPickerParams(labelKey) {
        return this.chartMenuUtils.getDefaultColorPickerParams('gridLine.style', labelKey, {
            formatInputValue: (value) => {
                return value?.[0]?.stroke;
            },
            parseInputValue: (value) => {
                const styles = this.chartOptions.getValue('gridLine.style') ?? [];
                if (styles.length === 0)
                    return [{ stroke: value, lineDash: [] }];
                return [{ ...styles[0], stroke: value }];
            },
        });
    }
    getGridLineWidthSliderParams(labelKey) {
        return this.chartMenuUtils.getDefaultSliderParams('gridLine.width', labelKey, 10);
    }
    getGridLineDashSliderParams(labelKey) {
        const initialStyles = this.chartOptions.getValue('gridLine.style');
        const initialValue = initialStyles?.[0]?.lineDash?.[0];
        const params = this.chartMenuUtils.getDefaultSliderParamsWithoutValueParams(initialValue ?? 0, labelKey, 30);
        params.onValueChange = (value) => {
            const stroke = this.chartOptions.getValue('gridLine.style.0.stroke');
            this.chartOptions.setValue('gridLine.style', [
                { lineDash: [value], stroke },
            ]);
        };
        return params;
    }
}
exports.GridLinePanel = GridLinePanel;


/***/ }),

/***/ 956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PolarAxisPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
const seriesTypeMapper_1 = __webpack_require__(4237);
const fontPanel_1 = __webpack_require__(7730);
class PolarAxisPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(options) {
        super();
        this.options = options;
        this.axisGroup = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const { isExpandedOnInit: expanded, chartAxisMenuParamsFactory, registerGroupComponent } = this.options;
        const axisGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.translate('polarAxis'),
            expanded,
            suppressEnabledCheckbox: true,
        };
        const axisColorInputParams = chartAxisMenuParamsFactory.getDefaultColorPickerParams('line.stroke');
        const axisLineWidthSliderParams = chartAxisMenuParamsFactory.getDefaultSliderParams('line.width', 'thickness', 10);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="axisGroup">
                <ag-color-picker data-ref="axisColorInput"></ag-color-picker>
                <ag-slider data-ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            axisGroup: axisGroupParams,
            axisColorInput: axisColorInputParams,
            axisLineWidthSlider: axisLineWidthSliderParams,
        });
        registerGroupComponent(this.axisGroup);
        this.initAxis();
        this.initAxisLabels();
        this.initRadiusAxis();
    }
    initAxis() {
        const chartType = this.options.chartController.getChartType();
        const hasConfigurableAxisShape = ['radarLine', 'radarArea'].includes(chartType);
        if (hasConfigurableAxisShape) {
            const options = [
                { value: 'circle', text: this.translate('circle') },
                { value: 'polygon', text: this.translate('polygon') },
            ];
            this.axisGroup.addItem(this.createSelect({
                labelKey: 'shape',
                options: options,
                property: 'shape',
            }));
        }
        if (chartType !== 'pie') {
            this.axisGroup.addItem(this.createSlider({
                labelKey: 'innerRadius',
                defaultMaxValue: 1,
                property: 'innerRadiusRatio',
            }));
        }
    }
    initAxisLabels() {
        const params = {
            name: this.translate('labels'),
            enabled: true,
            suppressEnabledCheckbox: true,
            chartMenuParamsFactory: this.options.chartAxisMenuParamsFactory,
            keyMapper: (key) => `label.${key}`,
        };
        const labelPanelComp = this.createManagedBean(new fontPanel_1.FontPanel(params));
        const labelOrientationComp = this.createOrientationWidget();
        labelPanelComp.addItem(labelOrientationComp);
        this.axisGroup.addItem(labelPanelComp);
    }
    createOrientationWidget() {
        const options = [
            { value: 'fixed', text: this.translate('fixed') },
            { value: 'parallel', text: this.translate('parallel') },
            { value: 'perpendicular', text: this.translate('perpendicular') },
        ];
        return this.createSelect({
            labelKey: 'orientation',
            options,
            property: 'label.orientation',
        });
    }
    initRadiusAxis() {
        const chartSeriesType = (0, seriesTypeMapper_1.getSeriesType)(this.options.chartController.getChartType());
        if (!(0, seriesTypeMapper_1.isRadial)(chartSeriesType))
            return;
        const items = [
            this.createSlider({
                labelKey: 'groupPadding',
                defaultMaxValue: 1,
                property: 'paddingInner',
            }),
            this.createSlider({
                labelKey: 'seriesPadding',
                defaultMaxValue: 1,
                property: 'groupPaddingInner',
            }),
        ];
        const paddingPanelComp = this.createManagedBean(new agGroupComponent_1.AgGroupComponent({
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            enabled: true,
            suppressEnabledCheckbox: true,
            title: this.translate('padding'),
            items,
        }))
            .hideEnabledCheckbox(true)
            .hideOpenCloseIcons(true);
        this.axisGroup.addItem(paddingPanelComp);
    }
    createSlider(config) {
        const { labelKey, defaultMaxValue, step = 0.05, property } = config;
        const params = this.options.chartAxisMenuParamsFactory.getDefaultSliderParams(property, labelKey, defaultMaxValue);
        params.step = step;
        return this.createManagedBean(new agSlider_1.AgSlider(params));
    }
    createSelect(config) {
        const { labelKey, options, property } = config;
        return this.createManagedBean(new ag_grid_community_1.AgSelect(this.options.chartAxisMenuParamsFactory.getDefaultSelectParams(property, labelKey, options)));
    }
    translate(key) {
        return this.chartTranslation.translate(key);
    }
}
exports.PolarAxisPanel = PolarAxisPanel;


/***/ }),

/***/ 4742:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackgroundPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
class BackgroundPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const chartBackgroundGroupParams = this.chartMenuUtils.addEnableParams('background.visible', {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('background'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const colorPickerParams = this.chartMenuUtils.getDefaultColorPickerParams('background.fill');
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="chartBackgroundGroup">
                <ag-color-picker data-ref="colorPicker"></ag-color-picker>
            </ag-group-component>
        <div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector], {
            chartBackgroundGroup: chartBackgroundGroupParams,
            colorPicker: colorPickerParams,
        });
    }
}
exports.BackgroundPanel = BackgroundPanel;


/***/ }),

/***/ 3628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const backgroundPanel_1 = __webpack_require__(4742);
const paddingPanel_1 = __webpack_require__(2567);
class ChartPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(options) {
        super();
        this.options = options;
        this.chartGroup = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const { chartController, chartMenuParamsFactory, isExpandedOnInit: expanded, registerGroupComponent, } = this.options;
        const chartGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('chartStyle'),
            expanded,
            suppressEnabledCheckbox: true,
            items: [
                this.createManagedBean(new paddingPanel_1.PaddingPanel(chartMenuParamsFactory, chartController)),
                this.createManagedBean(new backgroundPanel_1.BackgroundPanel(chartMenuParamsFactory)),
            ],
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="chartGroup"></ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector], { chartGroup: chartGroupParams });
        registerGroupComponent(this.chartGroup);
    }
}
exports.ChartPanel = ChartPanel;


/***/ }),

/***/ 2567:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaddingPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class PaddingPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils, chartController) {
        super();
        this.chartMenuUtils = chartMenuUtils;
        this.chartController = chartController;
        this.paddingTopSlider = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const chartPaddingGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('padding'),
            suppressEnabledCheckbox: true,
        };
        const getSliderParams = (property) => this.chartMenuUtils.getDefaultSliderParams('padding.' + property, property, 200);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="chartPaddingGroup">
                <ag-slider data-ref="paddingTopSlider"></ag-slider>
                <ag-slider data-ref="paddingRightSlider"></ag-slider>
                <ag-slider data-ref="paddingBottomSlider"></ag-slider>
                <ag-slider data-ref="paddingLeftSlider"></ag-slider>
            </ag-group-component>
        <div>`, [agGroupComponent_1.AgGroupComponentSelector, agSlider_1.AgSliderSelector], {
            chartPaddingGroup: chartPaddingGroupParams,
            paddingTopSlider: getSliderParams('top'),
            paddingRightSlider: getSliderParams('right'),
            paddingBottomSlider: getSliderParams('bottom'),
            paddingLeftSlider: getSliderParams('left'),
        });
        this.addManagedEventListeners({
            chartOptionsChanged: (e) => {
                this.updateTopPadding(e.chartOptions);
            },
        });
    }
    updateTopPadding(chartOptions) {
        // keep 'top' padding in sync with chart as toggling chart title on / off change the 'top' padding
        const topPadding = [...this.chartController.getChartSeriesTypes(), 'common']
            .map((seriesType) => chartOptions[seriesType]?.padding?.top)
            .find((value) => value != null);
        if (topPadding != null) {
            this.paddingTopSlider.setValue(`${topPadding}`);
        }
    }
}
exports.PaddingPanel = PaddingPanel;


/***/ }),

/***/ 7730:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FontPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
function _capitalise(str) {
    return str[0].toUpperCase() + str.substring(1).toLowerCase();
}
class FontPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(params) {
        super();
        this.params = params;
        this.fontGroup = ag_grid_community_1.RefPlaceholder;
        this.activeComps = [];
        this.chartOptions = params.chartMenuParamsFactory.getChartOptions();
    }
    postConstruct() {
        const { cssIdentifier = 'charts-format-sub-level', name: title, enabled, onEnableChange, suppressEnabledCheckbox, chartMenuParamsFactory, keyMapper, } = this.params;
        const fontGroupParams = {
            cssIdentifier,
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title,
            enabled,
            suppressEnabledCheckbox: true,
            onEnableChange: (enabled) => {
                if (onEnableChange) {
                    onEnableChange(enabled);
                }
            },
            useToggle: !suppressEnabledCheckbox,
        };
        this.setTemplate(
        /* html */ `<div class="ag-font-panel">
        <ag-group-component data-ref="fontGroup">
            <ag-select data-ref="familySelect"></ag-select>
            <ag-select data-ref="weightStyleSelect"></ag-select>
            <div class="ag-charts-font-size-color">
                <ag-select data-ref="sizeSelect"></ag-select>
                <ag-color-picker data-ref="colorPicker"></ag-color-picker>
            </div>
        </ag-group-component>
    </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgSelectSelector, agColorPicker_1.AgColorPickerSelector], {
            fontGroup: fontGroupParams,
            familySelect: this.getFamilySelectParams(),
            weightStyleSelect: this.getWeightStyleSelectParams(),
            sizeSelect: this.getSizeSelectParams(),
            colorPicker: chartMenuParamsFactory.getDefaultColorPickerParams(keyMapper('color')),
        });
        this.addOrRemoveCssClass('ag-font-panel-no-header', !title);
    }
    addItem(comp, prepend) {
        if (prepend) {
            this.fontGroup.prependItem(comp);
        }
        else {
            this.fontGroup.addItem(comp);
        }
        this.activeComps.push(comp);
    }
    setEnabled(enabled) {
        this.fontGroup.setEnabled(enabled);
    }
    getFamilySelectParams() {
        const families = [
            'Arial, sans-serif',
            'Aria Black, sans-serif',
            'Book Antiqua,  serif',
            'Charcoal, sans-serif',
            'Comic Sans MS, cursive',
            'Courier, monospace',
            'Courier New, monospace',
            'Gadget, sans-serif',
            'Geneva, sans-serif',
            'Helvetica, sans-serif',
            'Impact, sans-serif',
            'Lucida Console, monospace',
            'Lucida Grande, sans-serif',
            'Lucida Sans Unicode,  sans-serif',
            'Monaco, monospace',
            'Palatino Linotype, serif',
            'Palatino, serif',
            'Times New Roman, serif',
            'Times, serif',
            'Verdana, sans-serif',
        ];
        const family = this.getInitialFontValue('fontFamily');
        let initialValue = families[0];
        if (family) {
            // check for known values using lowercase
            const lowerCaseValues = families.map((f) => f.toLowerCase());
            const valueIndex = lowerCaseValues.indexOf(family.toLowerCase());
            if (valueIndex >= 0) {
                initialValue = families[valueIndex];
            }
            else {
                // add user provided value to list
                const capitalisedFontValue = _capitalise(family);
                families.push(capitalisedFontValue);
                initialValue = capitalisedFontValue;
            }
        }
        const options = families.sort().map((value) => ({ value, text: value }));
        return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams('font', options, `${initialValue}`, (newValue) => this.setFont({ fontFamily: newValue }));
    }
    getSizeSelectParams() {
        const sizes = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36];
        const size = this.getInitialFontValue('fontSize');
        if (!sizes.includes(size)) {
            sizes.push(size);
        }
        const options = sizes.sort((a, b) => a - b).map((value) => ({ value: `${value}`, text: `${value}` }));
        return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams('size', options, `${size}`, (newValue) => this.setFont({ fontSize: parseInt(newValue, 10) }));
    }
    getWeightStyleSelectParams() {
        const weight = this.getInitialFontValue('fontWeight') ?? 'normal';
        const style = this.getInitialFontValue('fontStyle') ?? 'normal';
        const weightStyles = [
            { name: 'normal', weight: 'normal', style: 'normal' },
            { name: 'bold', weight: 'bold', style: 'normal' },
            { name: 'italic', weight: 'normal', style: 'italic' },
            { name: 'boldItalic', weight: 'bold', style: 'italic' },
        ];
        let selectedOption = weightStyles.find((x) => x.weight === weight && x.style === style);
        if (!selectedOption) {
            selectedOption = { name: 'predefined', weight, style };
            weightStyles.unshift(selectedOption);
        }
        const options = weightStyles.map((ws) => ({
            value: ws.name,
            text: this.chartTranslation.translate(ws.name),
        }));
        return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams('weight', options, selectedOption.name, (newValue) => {
            const selectedWeightStyle = weightStyles.find((x) => x.name === newValue);
            this.setFont({ fontWeight: selectedWeightStyle.weight, fontStyle: selectedWeightStyle.style });
        });
    }
    destroyActiveComps() {
        this.activeComps.forEach((comp) => {
            (0, ag_grid_community_1._removeFromParent)(comp.getGui());
            this.destroyBean(comp);
        });
    }
    destroy() {
        this.destroyActiveComps();
        super.destroy();
    }
    setFont(font) {
        const { keyMapper } = this.params;
        Object.entries(font).forEach(([fontKey, value]) => {
            if (value) {
                this.chartOptions.setValue(keyMapper(fontKey), value);
            }
        });
    }
    getInitialFontValue(fontKey) {
        const { keyMapper } = this.params;
        return this.chartOptions.getValue(keyMapper(fontKey));
    }
}
exports.FontPanel = FontPanel;


/***/ }),

/***/ 3160:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormatPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartPanelFeature_1 = __webpack_require__(1299);
const cartesianAxisPanel_1 = __webpack_require__(5002);
const polarAxisPanel_1 = __webpack_require__(956);
const chartPanel_1 = __webpack_require__(3628);
const groupExpansionFeature_1 = __webpack_require__(8693);
const legendPanel_1 = __webpack_require__(3316);
const seriesPanel_1 = __webpack_require__(2496);
const titlesPanel_1 = __webpack_require__(5272);
const DefaultFormatPanelDef = {
    groups: [{ type: 'chart' }, { type: 'titles' }, { type: 'legend' }, { type: 'series' }, { type: 'axis' }],
};
class FormatPanel extends ag_grid_community_1.Component {
    constructor(chartMenuContext) {
        super(/* html */ `<div class="ag-chart-format-wrapper"></div>`);
        this.chartMenuContext = chartMenuContext;
    }
    postConstruct() {
        this.groupExpansionFeature = this.createManagedBean(new groupExpansionFeature_1.GroupExpansionFeature(this.getGui()));
        this.chartPanelFeature = this.createManagedBean(new chartPanelFeature_1.ChartPanelFeature(this.chartMenuContext.chartController, this.getGui(), 'ag-chart-format-section', (_chartType, seriesType) => this.createPanels(seriesType)));
        this.chartPanelFeature.refreshPanels();
    }
    createPanels(seriesType) {
        let panelExpandedOnInit = false;
        this.getFormatPanelDef().groups?.forEach(({ type: group, isOpen: isExpandedOnInit = false }) => {
            // ensure the group should be displayed for the current series type
            if (!this.isGroupPanelShownInSeries(group, seriesType)) {
                return;
            }
            if (isExpandedOnInit) {
                if (panelExpandedOnInit) {
                    (0, ag_grid_community_1._warn)(145, { group });
                }
                panelExpandedOnInit = true;
            }
            const registerGroupComponent = (groupComponent) => this.groupExpansionFeature.addGroupComponent(groupComponent);
            const opts = {
                ...this.chartMenuContext,
                isExpandedOnInit,
                seriesType,
                registerGroupComponent,
            };
            switch (group) {
                case 'chart':
                    this.chartPanelFeature.addComponent(new chartPanel_1.ChartPanel(opts));
                    break;
                case 'titles':
                    this.chartPanelFeature.addComponent(new titlesPanel_1.TitlesPanel(opts));
                    break;
                case 'legend':
                    this.chartPanelFeature.addComponent(new legendPanel_1.LegendPanel(opts));
                    break;
                case 'axis':
                    // Polar charts have different axis options from cartesian charts, so choose the appropriate panels
                    if ((0, seriesTypeMapper_1.isPolar)(seriesType)) {
                        this.chartPanelFeature.addComponent(new polarAxisPanel_1.PolarAxisPanel(opts));
                    }
                    else if ((0, seriesTypeMapper_1.isCartesian)(seriesType)) {
                        this.chartPanelFeature.addComponent(new cartesianAxisPanel_1.CartesianAxisPanel('xAxis', opts));
                        this.chartPanelFeature.addComponent(new cartesianAxisPanel_1.CartesianAxisPanel('yAxis', opts));
                    }
                    break;
                case 'horizontalAxis':
                    this.chartPanelFeature.addComponent(new cartesianAxisPanel_1.CartesianAxisPanel('xAxis', opts));
                    break;
                case 'verticalAxis':
                    this.chartPanelFeature.addComponent(new cartesianAxisPanel_1.CartesianAxisPanel('yAxis', opts));
                    break;
                case 'series':
                    this.chartPanelFeature.addComponent(new seriesPanel_1.SeriesPanel(opts));
                    break;
                default:
                    (0, ag_grid_community_1._warn)(147, { group });
            }
        });
    }
    getFormatPanelDef() {
        const userProvidedFormatPanelDef = this.gos.get('chartToolPanelsDef')?.formatPanel;
        return userProvidedFormatPanelDef ? userProvidedFormatPanelDef : DefaultFormatPanelDef;
    }
    isGroupPanelShownInSeries(group, seriesType) {
        return (['chart', 'titles', 'legend', 'series'].includes(group) ||
            ((0, seriesTypeMapper_1.isCartesian)(seriesType) && ['axis', 'horizontalAxis', 'verticalAxis'].includes(group)) ||
            ((0, seriesTypeMapper_1.isPolar)(seriesType) && group === 'axis'));
    }
}
exports.FormatPanel = FormatPanel;


/***/ }),

/***/ 8693:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupExpansionFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
// handles single group expansion
class GroupExpansionFeature extends ag_grid_community_1.BeanStub {
    constructor(groupContainer) {
        super();
        this.groupContainer = groupContainer;
        this.id = 0;
        this.groupComponents = new Map();
    }
    addGroupComponent(groupComponent) {
        const id = this.id++;
        this.groupComponents.set(id, groupComponent);
        if (groupComponent.isExpanded()) {
            this.expandedGroupComponent = id;
        }
        groupComponent.onExpandedChange((expanded) => {
            if (expanded) {
                const previouslyExpandedGroupComponent = this.expandedGroupComponent;
                this.expandedGroupComponent = id;
                if (previouslyExpandedGroupComponent != null) {
                    const groupComponentGui = groupComponent.getGui();
                    const groupPositionInViewport = groupComponentGui.offsetTop - this.groupContainer.parentElement.scrollTop;
                    this.groupComponents.get(previouslyExpandedGroupComponent)?.toggleGroupExpand(false, true);
                    // if the group above is collapsed, the expanded component will be in the wrong place, so scroll
                    let newScrollTop = groupComponentGui.offsetTop - groupPositionInViewport;
                    if (newScrollTop < 0) {
                        newScrollTop = 0;
                    }
                    if (newScrollTop !== this.groupContainer.parentElement.scrollTop) {
                        this.groupContainer.parentElement.scrollTop = newScrollTop;
                    }
                }
            }
            else {
                this.expandedGroupComponent = undefined;
            }
        });
    }
    destroy() {
        this.groupComponents.clear();
        super.destroy();
    }
}
exports.GroupExpansionFeature = GroupExpansionFeature;


/***/ }),

/***/ 3316:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegendPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
const fontPanel_1 = __webpack_require__(7730);
class LegendPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(options) {
        super();
        this.options = options;
        this.legendGroup = ag_grid_community_1.RefPlaceholder;
        this.isGradient = ['treemap', 'sunburst', 'heatmap'].includes(options.seriesType);
        this.key = this.isGradient ? 'gradientLegend' : 'legend';
    }
    postConstruct() {
        const { chartMenuParamsFactory, isExpandedOnInit: expanded, registerGroupComponent } = this.options;
        const positionSelect = this.createManagedBean(new ag_grid_community_1.AgSelect(chartMenuParamsFactory.getDefaultSelectParams(`${this.key}.position`, 'position', ['top', 'right', 'bottom', 'left'].map((position) => ({
            value: position,
            text: this.chartTranslation.translate(position),
        })))));
        const enabledGroup = this.createManagedBean(new agGroupComponent_1.AgGroupComponent(chartMenuParamsFactory.addEnableParams(`${this.key}.enabled`, {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('legendEnabled'),
            suppressEnabledCheckbox: true,
            useToggle: true,
            items: [
                this.createLabelPanel(chartMenuParamsFactory),
                positionSelect,
                ...this.getItems(chartMenuParamsFactory),
            ],
        })));
        const legendGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('legend'),
            suppressEnabledCheckbox: true,
            expanded,
            items: [enabledGroup],
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="legendGroup">
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector], {
            legendGroup: legendGroupParams,
        });
        registerGroupComponent(this.legendGroup);
    }
    getItems(chartMenuParamsFactory) {
        const createSlider = (expression, labelKey, defaultMaxValue) => this.createManagedBean(new agSlider_1.AgSlider(chartMenuParamsFactory.getDefaultSliderParams(`${this.key}.${expression}`, labelKey, defaultMaxValue)));
        if (this.isGradient) {
            return [
                this.createManagedBean(new ag_grid_community_1.AgCheckbox(chartMenuParamsFactory.addValueParams('gradientLegend.reverseOrder', {
                    label: this.chartTranslation.translate('reverseDirection'),
                    labelWidth: 'flex',
                }))),
                createSlider('gradient.thickness', 'thickness', 40),
                createSlider('gradient.preferredLength', 'preferredLength', 300),
                createSlider('spacing', 'spacing', 200),
            ];
        }
        return [
            createSlider('spacing', 'spacing', 200),
            createSlider('item.marker.size', 'markerSize', 40),
            createSlider('item.marker.strokeWidth', 'markerStroke', 10),
            createSlider('item.marker.padding', 'itemSpacing', 20),
            createSlider('item.paddingX', 'layoutHorizontalSpacing', 50),
            createSlider('item.paddingY', 'layoutVerticalSpacing', 50),
        ];
    }
    createLabelPanel(chartMenuParamsFactory) {
        const rootKey = this.isGradient ? 'gradientLegend.scale.label' : 'legend.item.label';
        const params = {
            enabled: true,
            suppressEnabledCheckbox: true,
            chartMenuParamsFactory,
            keyMapper: (key) => `${rootKey}.${key}`,
            cssIdentifier: 'charts-format-sub-level-no-header',
        };
        return this.createManagedBean(new fontPanel_1.FontPanel(params));
    }
}
exports.LegendPanel = LegendPanel;


/***/ }),

/***/ 6279:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CalloutPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class CalloutPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const calloutGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('callout'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="calloutGroup">
                <ag-slider data-ref="calloutLengthSlider"></ag-slider>
                <ag-slider data-ref="calloutStrokeWidthSlider"></ag-slider>
                <ag-slider data-ref="labelOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agSlider_1.AgSliderSelector], {
            calloutGroup: calloutGroupParams,
            calloutLengthSlider: this.chartMenuUtils.getDefaultSliderParams('calloutLine.length', 'length', 40),
            calloutStrokeWidthSlider: this.chartMenuUtils.getDefaultSliderParams('calloutLine.strokeWidth', 'strokeWidth', 10),
            labelOffsetSlider: this.chartMenuUtils.getDefaultSliderParams('calloutLabel.offset', 'offset', 30),
        });
    }
}
exports.CalloutPanel = CalloutPanel;


/***/ }),

/***/ 2948:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CapsPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class CapsPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const capsGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('cap'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        const capLengthRatioSliderParams = this.chartMenuUtils.getDefaultSliderParams('cap.lengthRatio', 'capLengthRatio', 1);
        capLengthRatioSliderParams.step = 0.05;
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="capsGroup">
                <ag-slider data-ref="capLengthRatioSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agSlider_1.AgSliderSelector], {
            capsGroup: capsGroupParams,
            capLengthRatioSlider: capLengthRatioSliderParams,
        });
    }
}
exports.CapsPanel = CapsPanel;


/***/ }),

/***/ 1428:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectorLinePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
class ConnectorLinePanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const lineGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('connectorLine'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="lineGroup">
                <ag-color-picker data-ref="lineColorPicker"></ag-color-picker>
                <ag-slider data-ref="lineStrokeWidthSlider"></ag-slider>
                <ag-slider data-ref="lineOpacitySlider"></ag-slider>
                <ag-slider data-ref="lineDashSlider"></ag-slider>                
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            lineGroup: lineGroupParams,
            lineColorPicker: this.chartMenuUtils.getDefaultColorPickerParams('line.stroke'),
            lineStrokeWidthSlider: this.getSliderParams('strokeWidth', 10, 'line.strokeWidth'),
            lineDashSlider: this.getSliderParams('lineDash', 30, 'line.lineDash', 1, true),
            lineOpacitySlider: this.getSliderParams('strokeOpacity', 1, 'line.strokeOpacity', 0.05),
        });
    }
    getSliderParams(labelKey, maxValue, seriesOptionKey, step = 1, isArray = false) {
        const params = this.chartMenuUtils.getDefaultSliderParams(seriesOptionKey, labelKey, maxValue, isArray);
        params.step = step;
        return params;
    }
}
exports.ConnectorLinePanel = ConnectorLinePanel;


/***/ }),

/***/ 1902:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MarkersPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
const seriesUtils_1 = __webpack_require__(1307);
class MarkersPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const seriesMarkersGroupParams = this.chartMenuUtils.addEnableParams('marker.enabled', {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('markers'),
            suppressEnabledCheckbox: true,
            useToggle: true,
            suppressOpenCloseIcons: true,
        });
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="seriesMarkersGroup">
                <ag-select data-ref="seriesMarkerShapeSelect"></ag-select>
                <ag-slider data-ref="seriesMarkerSizeSlider"></ag-slider>
                <ag-slider data-ref="seriesMarkerStrokeWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgSelectSelector, agSlider_1.AgSliderSelector], {
            seriesMarkersGroup: seriesMarkersGroupParams,
            seriesMarkerShapeSelect: this.chartMenuUtils.getDefaultSelectParams('marker.shape', 'shape', (0, seriesUtils_1.getShapeSelectOptions)(this.chartTranslation)),
            seriesMarkerSizeSlider: this.chartMenuUtils.getDefaultSliderParams('marker.size', 'size', 60),
            seriesMarkerStrokeWidthSlider: this.chartMenuUtils.getDefaultSliderParams('marker.strokeWidth', 'strokeWidth', 10),
        });
    }
}
exports.MarkersPanel = MarkersPanel;


/***/ }),

/***/ 1730:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeriesItemsPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
const fontPanel_1 = __webpack_require__(7730);
class SeriesItemsPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
        this.seriesItemsGroup = ag_grid_community_1.RefPlaceholder;
        this.activePanels = [];
    }
    postConstruct() {
        const seriesItemsGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('seriesItems'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="seriesItemsGroup">
                <ag-select data-ref="seriesItemSelect"></ag-select>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, ag_grid_community_1.AgSelectSelector], {
            seriesItemsGroup: seriesItemsGroupParams,
            seriesItemSelect: this.getSeriesItemsParams(),
        });
        this.initSeriesControls();
    }
    getSeriesItemsParams() {
        const options = [
            { value: 'positive', text: this.chartTranslation.translate('seriesItemPositive') },
            { value: 'negative', text: this.chartTranslation.translate('seriesItemNegative') },
        ];
        const seriesItemChangedCallback = (newValue) => {
            this.destroyActivePanels();
            this.initSeriesControls(newValue);
        };
        return this.chartMenuUtils.getDefaultSelectParamsWithoutValueParams('seriesItemType', options, 'positive', seriesItemChangedCallback);
    }
    initSeriesControls(itemType = 'positive') {
        this.initSlider('strokeWidth', 10, `item.${itemType}.strokeWidth`);
        this.initSlider('lineDash', 30, `item.${itemType}.lineDash`, 1, true);
        this.initSlider('strokeOpacity', 1, `item.${itemType}.strokeOpacity`, 0.05, false);
        this.initSlider('fillOpacity', 1, `item.${itemType}.fillOpacity`, 0.05, false);
        this.initItemLabels(itemType);
    }
    initSlider(labelKey, maxValue, seriesOptionKey, step = 1, isArray = false) {
        const params = this.chartMenuUtils.getDefaultSliderParams(seriesOptionKey, labelKey, maxValue, isArray);
        params.step = step;
        const itemSlider = this.seriesItemsGroup.createManagedBean(new agSlider_1.AgSlider(params));
        this.seriesItemsGroup.addItem(itemSlider);
        this.activePanels.push(itemSlider);
    }
    initItemLabels(itemType) {
        const sectorParams = this.chartMenuUtils.getDefaultFontPanelParams(`item.${itemType}.label`, 'seriesItemLabels');
        const labelPanelComp = this.createBean(new fontPanel_1.FontPanel(sectorParams));
        this.seriesItemsGroup.addItem(labelPanelComp);
        this.activePanels.push(labelPanelComp);
    }
    destroyActivePanels() {
        this.activePanels.forEach((panel) => {
            (0, ag_grid_community_1._removeFromParent)(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
exports.SeriesItemsPanel = SeriesItemsPanel;


/***/ }),

/***/ 2496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeriesPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartMenuParamsFactory_1 = __webpack_require__(3786);
const fontPanel_1 = __webpack_require__(7730);
const calloutPanel_1 = __webpack_require__(6279);
const capsPanel_1 = __webpack_require__(2948);
const connectorLinePanel_1 = __webpack_require__(1428);
const markersPanel_1 = __webpack_require__(1902);
const seriesItemsPanel_1 = __webpack_require__(1730);
const seriesUtils_1 = __webpack_require__(1307);
const shadowPanel_1 = __webpack_require__(1919);
const tileSpacingPanel_1 = __webpack_require__(4880);
const whiskersPanel_1 = __webpack_require__(991);
const tooltips = 'tooltips';
const strokeWidth = 'strokeWidth';
const lineDash = 'lineDash';
const lineOpacity = 'lineOpacity';
const fillOpacity = 'fillOpacity';
const labels = 'labels';
const shadow = 'shadow';
class SeriesPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(options) {
        super();
        this.options = options;
        this.seriesGroup = ag_grid_community_1.RefPlaceholder;
        this.activePanels = [];
        this.widgetFuncs = {
            lineWidth: () => this.initStrokeWidth('lineWidth'),
            [strokeWidth]: () => this.initStrokeWidth('strokeWidth'),
            lineColor: () => this.initLineColor(),
            [lineDash]: () => this.initLineDash(),
            [lineOpacity]: () => this.initOpacity('strokeOpacity'),
            [fillOpacity]: () => this.initOpacity('fillOpacity'),
            markers: () => new markersPanel_1.MarkersPanel(this.chartMenuUtils),
            [labels]: () => this.initLabels(),
            sectorLabels: () => this.initSectorLabels(),
            [shadow]: () => new shadowPanel_1.ShadowPanel(this.chartMenuUtils),
            [tooltips]: () => this.initTooltips(),
            bins: () => this.initBins(),
            whiskers: () => new whiskersPanel_1.WhiskersPanel(this.chartMenuUtils),
            caps: () => new capsPanel_1.CapsPanel(this.chartMenuUtils),
            connectorLine: () => new connectorLinePanel_1.ConnectorLinePanel(this.chartMenuUtils),
            seriesItems: () => new seriesItemsPanel_1.SeriesItemsPanel(this.chartMenuUtils),
            tileSpacing: () => new tileSpacingPanel_1.TileSpacingPanel(this.chartMenuUtils),
            shape: () => this.initShape(),
            size: () => this.initSize('size', 'size'),
            minSize: () => this.initSize('size', 'minSize'),
            maxSize: () => this.initSize('maxSize', 'maxSize'),
        };
        this.seriesWidgetMappings = {
            bar: [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, labels, shadow],
            pie: [tooltips, strokeWidth, lineOpacity, fillOpacity, labels, 'sectorLabels', shadow],
            donut: [tooltips, strokeWidth, lineOpacity, fillOpacity, labels, 'sectorLabels', shadow],
            line: [tooltips, 'lineWidth', lineDash, lineOpacity, 'markers', labels],
            scatter: [tooltips, 'shape', 'size', strokeWidth, labels],
            bubble: [tooltips, 'shape', 'minSize', 'maxSize', strokeWidth, labels],
            area: [tooltips, 'lineWidth', lineDash, lineOpacity, fillOpacity, 'markers', labels, shadow],
            histogram: [tooltips, 'bins', strokeWidth, lineDash, lineOpacity, fillOpacity, labels, shadow],
            'radial-column': [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, labels],
            'radial-bar': [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, labels],
            'radar-line': [tooltips, strokeWidth, lineDash, lineOpacity, 'markers', labels],
            'radar-area': [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, 'markers', labels],
            nightingale: [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, labels],
            'box-plot': [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, 'whiskers', 'caps'],
            'range-bar': [tooltips, strokeWidth, lineDash, lineOpacity, fillOpacity, labels],
            'range-area': [tooltips, 'lineWidth', lineDash, lineOpacity, fillOpacity, 'markers', labels, shadow],
            treemap: [tooltips, 'tileSpacing'],
            sunburst: [tooltips],
            heatmap: [tooltips, labels, 'lineColor', 'lineWidth', lineOpacity],
            waterfall: [tooltips, 'connectorLine', 'seriesItems'],
        };
        this.seriesType = options.seriesType;
    }
    postConstruct() {
        const { isExpandedOnInit: expanded, chartOptionsService, chartController, registerGroupComponent, } = this.options;
        const seriesGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.translate('series'),
            expanded,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="seriesGroup">
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector], { seriesGroup: seriesGroupParams });
        registerGroupComponent(this.seriesGroup);
        this.chartMenuUtils = this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(chartOptionsService.getSeriesOptionsProxy(() => this.seriesType)));
        this.addManagedListeners(chartController, { chartSeriesChartTypeChanged: this.refreshWidgets.bind(this) });
        this.refreshWidgets();
    }
    refreshWidgets() {
        const { chartController } = this.options;
        this.destroyActivePanels();
        const chart = chartController.getChartProxy().getChart();
        chart
            .waitForUpdate()
            .then(() => {
            const componentWasRemoved = !this.isAlive();
            if (componentWasRemoved) {
                // It's possible that the component was unmounted during the async delay in updating the chart.
                // If this is the case we want to bail out to avoid operating on stale UI components.
                return;
            }
            if (chartController.isComboChart()) {
                this.updateSeriesType();
                this.initSeriesSelect();
            }
            (this.seriesWidgetMappings[this.seriesType] ?? []).forEach((w) => {
                const widgetFuncResult = this.widgetFuncs[w]();
                let widget;
                if (Array.isArray(widgetFuncResult)) {
                    const comp = this.createBean(widgetFuncResult[0]);
                    widget = comp;
                    widgetFuncResult[1](comp);
                }
                else {
                    widget = this.createBean(widgetFuncResult);
                }
                this.seriesGroup.addItem(widget);
                this.activePanels.push(widget);
            });
        })
            .catch((e) => (0, ag_grid_community_1._error)(105, { e }));
    }
    initSeriesSelect() {
        const seriesSelect = this.createBean(new ag_grid_community_1.AgSelect(this.chartMenuUtils.getDefaultSelectParamsWithoutValueParams('seriesType', this.getSeriesSelectOptions(), `${this.seriesType}`, (newValue) => {
            this.seriesType = newValue;
            this.refreshWidgets();
        })));
        this.seriesGroup.addItem(seriesSelect);
        this.activePanels.push(seriesSelect);
    }
    initTooltips() {
        return new ag_grid_community_1.AgToggleButton(this.chartMenuUtils.addValueParams('tooltip.enabled', {
            label: this.translate('tooltips'),
            labelAlignment: 'left',
            labelWidth: 'flex',
            inputWidth: 'flex',
        }));
    }
    initLineColor() {
        return new agColorPicker_1.AgColorPicker(this.chartMenuUtils.getDefaultColorPickerParams('stroke', 'strokeColor'));
    }
    initStrokeWidth(labelKey) {
        return new agSlider_1.AgSlider(this.chartMenuUtils.getDefaultSliderParams('strokeWidth', labelKey, 10));
    }
    initLineDash() {
        return new agSlider_1.AgSlider(this.chartMenuUtils.getDefaultSliderParams('lineDash', 'lineDash', 30, true));
    }
    initOpacity(type) {
        const params = this.chartMenuUtils.getDefaultSliderParams(type, type, 1);
        params.step = 0.05;
        return new agSlider_1.AgSlider(params);
    }
    initLabels() {
        const isPieChart = (0, seriesTypeMapper_1.isPieChartSeries)(this.seriesType);
        const seriesOptionLabelProperty = isPieChart ? 'calloutLabel' : 'label';
        const labelKey = isPieChart ? 'calloutLabels' : 'labels';
        const labelParams = this.chartMenuUtils.getDefaultFontPanelParams(seriesOptionLabelProperty, labelKey);
        const fontPanel = new fontPanel_1.FontPanel(labelParams);
        const addItems = (labelPanelComp) => {
            if (isPieChart) {
                const calloutPanelComp = labelPanelComp.createManagedBean(new calloutPanel_1.CalloutPanel(this.chartMenuUtils));
                labelPanelComp.addItem(calloutPanelComp);
                this.activePanels.push(calloutPanelComp);
            }
            if (this.seriesType === 'range-bar') {
                // Add label placement dropdown
                const options = [
                    { value: 'inside', text: this.translate('inside') },
                    { value: 'outside', text: this.translate('outside') },
                ];
                const placementSelect = labelPanelComp.createManagedBean(new ag_grid_community_1.AgSelect(this.chartMenuUtils.getDefaultSelectParams('label.placement', 'labelPlacement', options)));
                labelPanelComp.addItem(placementSelect);
                this.activePanels.push(placementSelect);
                // Add padding slider
                const paddingSlider = labelPanelComp.createManagedBean(new agSlider_1.AgSlider(this.chartMenuUtils.getDefaultSliderParams('label.padding', 'padding', 200)));
                labelPanelComp.addItem(paddingSlider);
                this.activePanels.push(paddingSlider);
            }
        };
        return [fontPanel, addItems];
    }
    initSectorLabels() {
        const sectorParams = this.chartMenuUtils.getDefaultFontPanelParams('sectorLabel', 'sectorLabels');
        const fontPanel = new fontPanel_1.FontPanel(sectorParams);
        const addItems = (sectorPanelComp) => {
            const positionRatioParams = this.chartMenuUtils.getDefaultSliderParams('sectorLabel.positionRatio', 'positionRatio', 1);
            positionRatioParams.step = 0.05;
            const positionRatioComp = sectorPanelComp.createManagedBean(new agSlider_1.AgSlider(positionRatioParams));
            sectorPanelComp.addItem(positionRatioComp);
        };
        return [fontPanel, addItems];
    }
    initBins() {
        const params = this.chartMenuUtils.getDefaultSliderParams('binCount', 'histogramBinCount', 20);
        const chartOptions = this.chartMenuUtils.getChartOptions();
        // this needs fixing
        const value = (chartOptions.getValue('bins') ?? chartOptions.getValue('calculatedBins', true)).length;
        params.value = `${value}`;
        params.maxValue = Math.max(value, 20);
        return new agSlider_1.AgSlider(params);
    }
    initShape() {
        return new ag_grid_community_1.AgSelect(this.chartMenuUtils.getDefaultSelectParams('shape', 'shape', (0, seriesUtils_1.getShapeSelectOptions)(this.chartTranslation)));
    }
    initSize(expression, labelKey) {
        return new agSlider_1.AgSlider(this.chartMenuUtils.getDefaultSliderParams(expression, labelKey, 60));
    }
    getSeriesSelectOptions() {
        const activeSeriesTypes = this.getActiveSeriesTypes();
        return ['area', 'bar', 'line']
            .filter((seriesType) => activeSeriesTypes.includes(seriesType))
            .map((value) => ({ value, text: this.translate(value) }));
    }
    updateSeriesType() {
        const activeSeriesTypes = this.getActiveSeriesTypes();
        const invalidSeriesType = !activeSeriesTypes.includes(this.seriesType);
        if (invalidSeriesType && activeSeriesTypes.length > 0) {
            this.seriesType = activeSeriesTypes[0]; // default to first active series type
        }
    }
    getActiveSeriesTypes() {
        return this.options.chartController.getActiveSeriesChartTypes().map((s) => (0, seriesTypeMapper_1.getSeriesType)(s.chartType));
    }
    translate(key) {
        return this.chartTranslation.translate(key);
    }
    destroyActivePanels() {
        this.activePanels.forEach((panel) => {
            (0, ag_grid_community_1._removeFromParent)(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
exports.SeriesPanel = SeriesPanel;


/***/ }),

/***/ 1307:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getShapeSelectOptions = void 0;
function getShapeSelectOptions(chartTranslation) {
    return ['square', 'circle', 'cross', 'diamond', 'plus', 'triangle', 'heart'].map((value) => ({
        value,
        text: chartTranslation.translate(value),
    }));
}
exports.getShapeSelectOptions = getShapeSelectOptions;


/***/ }),

/***/ 1919:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShadowPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
class ShadowPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils, propertyKey = 'shadow') {
        super();
        this.chartMenuUtils = chartMenuUtils;
        this.propertyKey = propertyKey;
    }
    postConstruct() {
        // Determine the path within the series options object to get/set the individual shadow options
        const propertyNamespace = this.propertyKey;
        const shadowGroupParams = this.chartMenuUtils.addEnableParams(`${propertyNamespace}.enabled`, {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            title: this.chartTranslation.translate('shadow'),
            suppressEnabledCheckbox: true,
            useToggle: true,
        });
        const shadowColorPickerParams = this.chartMenuUtils.getDefaultColorPickerParams(`${propertyNamespace}.color`);
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="shadowGroup">
                <ag-color-picker data-ref="shadowColorPicker"></ag-color-picker>
                <ag-slider data-ref="shadowBlurSlider"></ag-slider>
                <ag-slider data-ref="shadowXOffsetSlider"></ag-slider>
                <ag-slider data-ref="shadowYOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            shadowGroup: shadowGroupParams,
            shadowColorPicker: shadowColorPickerParams,
            shadowBlurSlider: this.getSliderParams('blur', 0, 20),
            shadowXOffsetSlider: this.getSliderParams('xOffset', -10, 10),
            shadowYOffsetSlider: this.getSliderParams('yOffset', -10, 10),
        });
    }
    getSliderParams(property, minValue, defaultMaxValue) {
        const expression = `${this.propertyKey}.${property}`;
        const params = this.chartMenuUtils.getDefaultSliderParams(expression, property, defaultMaxValue);
        params.minValue = minValue;
        return params;
    }
}
exports.ShadowPanel = ShadowPanel;


/***/ }),

/***/ 4880:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileSpacingPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agSlider_1 = __webpack_require__(5000);
class TileSpacingPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="groupSpacing">
                <ag-slider data-ref="groupPaddingSlider"></ag-slider>
                <ag-slider data-ref="groupSpacingSlider"></ag-slider>
            </ag-group-component>
            <ag-group-component data-ref="tileSpacing">
                <ag-slider data-ref="tilePaddingSlider"></ag-slider>
                <ag-slider data-ref="tileSpacingSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agSlider_1.AgSliderSelector], {
            groupSpacing: { ...groupParams, title: this.chartTranslation.translate('group') },
            tileSpacing: { ...groupParams, title: this.chartTranslation.translate('tile') },
            groupPaddingSlider: this.getSliderParams('padding', 'group.padding'),
            groupSpacingSlider: this.getSliderParams('spacing', 'group.gap'),
            tilePaddingSlider: this.getSliderParams('padding', 'tile.padding'),
            tileSpacingSlider: this.getSliderParams('spacing', 'tile.gap'),
        });
    }
    getSliderParams(labelKey, key) {
        return this.chartMenuUtils.getDefaultSliderParams(key, labelKey, 10);
    }
}
exports.TileSpacingPanel = TileSpacingPanel;


/***/ }),

/***/ 991:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhiskersPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agColorPicker_1 = __webpack_require__(1296);
const agSlider_1 = __webpack_require__(5000);
class WhiskersPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils) {
        super();
        this.chartMenuUtils = chartMenuUtils;
    }
    postConstruct() {
        const whiskersGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('whisker'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="whiskersGroup">
                <ag-color-picker data-ref="whiskerColorPicker"></ag-color-picker>
                <ag-slider data-ref="whiskerThicknessSlider"></ag-slider>
                <ag-slider data-ref="whiskerOpacitySlider"></ag-slider>
                <ag-slider data-ref="whiskerLineDashSlider"></ag-slider>
                <ag-slider data-ref="whiskerLineDashOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector, agColorPicker_1.AgColorPickerSelector, agSlider_1.AgSliderSelector], {
            whiskersGroup: whiskersGroupParams,
            whiskerColorPicker: this.chartMenuUtils.getDefaultColorPickerParams('whisker.stroke'),
            whiskerThicknessSlider: this.chartMenuUtils.getDefaultSliderParams('whisker.strokeWidth', 'strokeWidth', 10),
            whiskerOpacitySlider: this.chartMenuUtils.getDefaultSliderParams('whisker.strokeOpacity', 'strokeOpacity', 1),
            whiskerLineDashSlider: this.chartMenuUtils.getDefaultSliderParams('whisker.lineDash', 'lineDash', 30, true),
            whiskerLineDashOffsetSlider: this.chartMenuUtils.getDefaultSliderParams('whisker.lineDashOffset', 'lineDashOffset', 30),
        });
    }
}
exports.WhiskersPanel = WhiskersPanel;


/***/ }),

/***/ 3179:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartTitlePanel = void 0;
const titlePanel_1 = __webpack_require__(9375);
class ChartTitlePanel extends titlePanel_1.TitlePanel {
    wireBeans(beans) {
        super.wireBeans(beans);
        this.chartMenuSvc = beans.chartMenuSvc;
    }
    postConstruct() {
        this.titlePlaceholder = this.chartTranslation.translate('titlePlaceholder');
        super.postConstruct();
        // edits to the title can disable it, so keep the checkbox in sync:
        this.addManagedEventListeners({
            chartTitleEdit: () => {
                this.fontPanel.setEnabled(this.hasTitle());
            },
        });
    }
    getTextInputParams() {
        const params = super.getTextInputParams();
        if (this.shouldOverrideTextWithPlaceholder(params.value)) {
            params.value = this.titlePlaceholder;
        }
        return params;
    }
    getSpacingSliderParams() {
        const params = super.getSpacingSliderParams();
        // Default title spacing is 10, but this isn't reflected in the options - this should really be fixed there.
        params.value = '10';
        return params;
    }
    onEnableChange(enabled) {
        if (this.chartMenuSvc.doesChartToolbarExist()) {
            // extra padding is only included when the toolbar is present
            const topPadding = this.chartOptions.getValue('padding.top');
            this.chartOptions.setValue('padding.top', enabled ? topPadding - 20 : topPadding + 20);
        }
        this.chartOptions.setValue(`${this.key}.enabled`, enabled);
        const currentTitleText = this.chartOptions.getValue(`${this.key}.text`);
        if (enabled && this.shouldOverrideTextWithPlaceholder(currentTitleText)) {
            this.chartOptions.setValue(`${this.key}.text`, this.titlePlaceholder);
        }
    }
    shouldOverrideTextWithPlaceholder(currentTitleText) {
        return currentTitleText === 'Title' || currentTitleText?.trim().length === 0;
    }
}
exports.ChartTitlePanel = ChartTitlePanel;


/***/ }),

/***/ 9375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TitlePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agSlider_1 = __webpack_require__(5000);
const fontPanel_1 = __webpack_require__(7730);
class TitlePanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartMenuUtils, name, key) {
        super(/* html */ `<div></div>`);
        this.chartMenuUtils = chartMenuUtils;
        this.name = name;
        this.key = key;
        this.chartOptions = chartMenuUtils.getChartOptions();
    }
    postConstruct() {
        this.initFontPanel();
    }
    hasTitle() {
        const title = this.chartOptions.getValue(this.key);
        return title && title.enabled && title.text && title.text.length > 0;
    }
    initFontPanel() {
        const hasTitle = this.hasTitle();
        const fontPanelParams = {
            name: this.chartTranslation.translate(this.name),
            enabled: hasTitle,
            suppressEnabledCheckbox: false,
            chartMenuParamsFactory: this.chartMenuUtils,
            keyMapper: (key) => `${this.key}.${key}`,
            onEnableChange: (enabled) => this.onEnableChange(enabled),
        };
        this.fontPanel = this.createManagedBean(new fontPanel_1.FontPanel(fontPanelParams));
        this.fontPanel.addItem(this.createBean(new ag_grid_community_1.AgInputTextField(this.getTextInputParams())), true);
        this.fontPanel.addItem(this.createBean(new agSlider_1.AgSlider(this.getSpacingSliderParams())));
        this.getGui().appendChild(this.fontPanel.getGui());
    }
    getTextInputParams() {
        return this.chartMenuUtils.addValueParams(`${this.key}.text`, {
            label: this.chartTranslation.translate('title'),
            labelAlignment: 'top',
        });
    }
    getSpacingSliderParams() {
        return this.chartMenuUtils.getDefaultSliderParams(`${this.key}.spacing`, 'spacing', 100);
    }
    onEnableChange(enabled) {
        this.chartOptions.setValue(`${this.key}.enabled`, enabled);
    }
}
exports.TitlePanel = TitlePanel;


/***/ }),

/***/ 5272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TitlesPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartMenuParamsFactory_1 = __webpack_require__(3786);
const chartTitlePanel_1 = __webpack_require__(3179);
const titlePanel_1 = __webpack_require__(9375);
class TitlesPanel extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(options) {
        super();
        this.options = options;
        this.titleGroup = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const { chartMenuParamsFactory, chartAxisMenuParamsFactory, chartOptionsService, seriesType, isExpandedOnInit: expanded = false, registerGroupComponent, } = this.options;
        const axisTitlePanels = [];
        if ((0, seriesTypeMapper_1.isCartesian)(seriesType)) {
            const createAxisParamsFactory = (axisType) => this.createManagedBean(new chartMenuParamsFactory_1.ChartMenuParamsFactory(chartOptionsService.getCartesianAxisThemeOverridesProxy(axisType)));
            axisTitlePanels.push(this.createManagedBean(new titlePanel_1.TitlePanel(createAxisParamsFactory('xAxis'), 'horizontalAxisTitle', 'title')));
            axisTitlePanels.push(this.createManagedBean(new titlePanel_1.TitlePanel(createAxisParamsFactory('yAxis'), 'verticalAxisTitle', 'title')));
        }
        else if ((0, seriesTypeMapper_1.isPolar)(seriesType)) {
            axisTitlePanels.push(this.createManagedBean(new titlePanel_1.TitlePanel(chartAxisMenuParamsFactory, 'polarAxisTitle', 'title')));
        }
        const titleGroupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
            title: this.chartTranslation.translate('chartTitles'),
            expanded,
            suppressEnabledCheckbox: true,
            items: [
                this.createManagedBean(new chartTitlePanel_1.ChartTitlePanel(chartMenuParamsFactory, 'chartTitle', 'title')),
                this.createManagedBean(new titlePanel_1.TitlePanel(chartMenuParamsFactory, 'chartSubtitle', 'subtitle')),
                ...axisTitlePanels,
            ],
        };
        this.setTemplate(
        /* html */ `<div>
            <ag-group-component data-ref="titleGroup"></ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector], { titleGroup: titleGroupParams });
        registerGroupComponent(this.titleGroup);
    }
}
exports.TitlesPanel = TitlesPanel;


/***/ }),

/***/ 6604:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartSettingsPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const chartTheme_1 = __webpack_require__(8987);
const miniChartsContainer_1 = __webpack_require__(6692);
class ChartSettingsPanel extends ag_grid_community_1.Component {
    constructor(chartController) {
        super(/* html */ `<div class="ag-chart-settings-wrapper">
            <div data-ref="eMiniChartsContainer" class="ag-chart-settings-mini-charts-container ag-scrollable-container"></div>
            <div data-ref="eNavBar" class="ag-chart-settings-nav-bar">
                <div data-ref="ePrevBtn" class="ag-chart-settings-prev">
                    <button type="button" class="ag-button ag-chart-settings-prev-button"></button>
                </div>
                <div data-ref="eCardSelector" class="ag-chart-settings-card-selector"></div>
                <div data-ref="eNextBtn" class="ag-chart-settings-next">
                    <button type="button" class="ag-button ag-chart-settings-next-button"></button>
                </div>
            </div>
        </div>`);
        this.chartController = chartController;
        this.eMiniChartsContainer = ag_grid_community_1.RefPlaceholder;
        this.eNavBar = ag_grid_community_1.RefPlaceholder;
        this.eCardSelector = ag_grid_community_1.RefPlaceholder;
        this.ePrevBtn = ag_grid_community_1.RefPlaceholder;
        this.eNextBtn = ag_grid_community_1.RefPlaceholder;
        this.miniChartsContainers = [];
        this.cardItems = [];
        this.activePaletteIndex = 0;
        this.palettes = [];
        this.themes = [];
    }
    postConstruct() {
        this.resetPalettes();
        this.ePrevBtn.insertAdjacentElement('afterbegin', (0, ag_grid_community_1._createIconNoSpan)('chartsThemePrevious', this.beans));
        this.eNextBtn.insertAdjacentElement('afterbegin', (0, ag_grid_community_1._createIconNoSpan)('chartsThemeNext', this.beans));
        this.addManagedElementListeners(this.ePrevBtn, { click: () => this.setActivePalette(this.getPrev(), 'left') });
        this.addManagedElementListeners(this.eNextBtn, { click: () => this.setActivePalette(this.getNext(), 'right') });
        // change the selected chart when a combo chart is modified via the data panel, i.e. the custom combo should be selected
        const reset = () => this.resetPalettes(true);
        this.addManagedListeners(this.chartController, {
            chartTypeChanged: reset,
            chartApiUpdate: reset,
        });
        this.scrollSelectedIntoView();
    }
    scrollSelectedIntoView() {
        // the panel is not immediately visible due to the slide animation, so we add a
        // setTimeout to wait until the panel animation is over and is able to scroll
        setTimeout(() => {
            const isMiniChartsContainerVisible = (miniChartsContainers) => {
                return !miniChartsContainers.getGui().classList.contains('ag-hidden');
            };
            const currentMiniChartContainer = this.miniChartsContainers.find(isMiniChartsContainerVisible);
            const currentChart = currentMiniChartContainer.getGui().querySelector('.ag-selected');
            if (currentChart) {
                const parent = currentChart.offsetParent;
                if (parent) {
                    this.eMiniChartsContainer.scrollTo(0, parent.offsetTop);
                }
            }
        }, 250);
    }
    resetPalettes(forceReset) {
        const palettes = this.chartController.getPalettes();
        const themeTemplateParameters = this.chartController.getThemeTemplateParameters();
        const chartGroups = this.gos.get('chartToolPanelsDef')?.settingsPanel?.chartGroupsDef;
        if (((0, ag_grid_community_1._areEqual)(palettes, this.palettes) && !forceReset) || this.isAnimating) {
            return;
        }
        this.palettes = palettes;
        this.themes = this.chartController.getThemeNames();
        this.activePaletteIndex = this.themes.findIndex((name) => name === this.chartController.getChartThemeName());
        this.cardItems = [];
        (0, ag_grid_community_1._clearElement)(this.eCardSelector);
        this.destroyMiniCharts();
        const { themes } = this;
        this.palettes.forEach((palette, index) => {
            const isActivePalette = this.activePaletteIndex === index;
            const { fills = [], strokes = [] } = palette;
            const themeName = themes[index];
            const isCustomTheme = !(0, chartTheme_1.isStockTheme)(themeName, this.beans.agChartsExports._Theme);
            const miniChartsContainer = this.createBean(new miniChartsContainer_1.MiniChartsContainer(this.chartController, fills, strokes, themeTemplateParameters[index], isCustomTheme, chartGroups));
            this.miniChartsContainers.push(miniChartsContainer);
            this.eMiniChartsContainer.appendChild(miniChartsContainer.getGui());
            this.addCardLink(index);
            if (isActivePalette) {
                miniChartsContainer.updateSelectedMiniChart();
            }
            else {
                miniChartsContainer.setDisplayed(false);
            }
        });
        (0, ag_grid_community_1._setDisplayed)(this.eNavBar, this.palettes.length > 1);
        (0, ag_grid_community_1._radioCssClass)(this.cardItems[this.activePaletteIndex], 'ag-selected', 'ag-not-selected');
    }
    addCardLink(index) {
        const link = document.createElement('div');
        link.classList.add('ag-chart-settings-card-item');
        this.addManagedElementListeners(link, {
            click: () => {
                this.setActivePalette(index, index < this.activePaletteIndex ? 'left' : 'right');
            },
        });
        this.eCardSelector.appendChild(link);
        this.cardItems.push(link);
    }
    getPrev() {
        let prev = this.activePaletteIndex - 1;
        if (prev < 0) {
            prev = this.palettes.length - 1;
        }
        return prev;
    }
    getNext() {
        let next = this.activePaletteIndex + 1;
        if (next >= this.palettes.length) {
            next = 0;
        }
        return next;
    }
    setActivePalette(index, animationDirection) {
        if (this.isAnimating || this.activePaletteIndex === index) {
            return;
        }
        (0, ag_grid_community_1._radioCssClass)(this.cardItems[index], 'ag-selected', 'ag-not-selected');
        const currentPalette = this.miniChartsContainers[this.activePaletteIndex];
        const currentGui = currentPalette.getGui();
        const futurePalette = this.miniChartsContainers[index];
        const nextGui = futurePalette.getGui();
        currentPalette.updateSelectedMiniChart();
        futurePalette.updateSelectedMiniChart();
        const multiplier = animationDirection === 'left' ? -1 : 1;
        const final = (nextGui.style.left = `${(0, ag_grid_community_1._getAbsoluteWidth)(this.getGui()) * multiplier}px`);
        this.activePaletteIndex = index;
        this.isAnimating = true;
        const animatingClass = 'ag-animating';
        futurePalette.setDisplayed(true);
        currentPalette.addCssClass(animatingClass);
        futurePalette.addCssClass(animatingClass);
        this.chartController.setChartThemeName(this.themes[index]);
        window.setTimeout(() => {
            currentGui.style.left = `${-parseFloat(final)}px`;
            nextGui.style.left = '0px';
        }, 0);
        window.setTimeout(() => {
            this.isAnimating = false;
            currentPalette.removeCssClass(animatingClass);
            futurePalette.removeCssClass(animatingClass);
            currentPalette.setDisplayed(false);
        }, 300);
    }
    destroyMiniCharts() {
        (0, ag_grid_community_1._clearElement)(this.eMiniChartsContainer);
        this.miniChartsContainers = this.destroyBeans(this.miniChartsContainers);
    }
    destroy() {
        this.destroyMiniCharts();
        super.destroy();
    }
}
exports.ChartSettingsPanel = ChartSettingsPanel;


/***/ }),

/***/ 3564:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniArea = void 0;
const miniLine_1 = __webpack_require__(7526);
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniArea extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniArea.data, tooltipName = 'groupedAreaTooltip', stacked = false) {
        super(container, agChartsExports, tooltipName);
        this.areas = (0, miniChartHelpers_1.createAreaPaths)(agChartsExports._Scene, this.root, data, this.size, this.padding, stacked);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
            area.strokeWidth = 1;
            area.strokeOpacity = 0.75;
            area.fillOpacity = 0.7;
        });
    }
}
exports.MiniArea = MiniArea;
MiniArea.chartType = 'area';
MiniArea.data = miniLine_1.MiniLine.data;


/***/ }),

/***/ 6249:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniNormalizedArea = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniStackedArea_1 = __webpack_require__(5133);
class MiniNormalizedArea extends miniStackedArea_1.MiniStackedArea {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, data = MiniNormalizedArea.data, tooltipName = 'normalizedAreaTooltip') {
        super(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, data, tooltipName);
    }
}
exports.MiniNormalizedArea = MiniNormalizedArea;
MiniNormalizedArea.chartType = 'normalizedArea';
MiniNormalizedArea.data = (0, miniChartHelpers_1.normalizeStackData)(miniStackedArea_1.MiniStackedArea.data);


/***/ }),

/***/ 5133:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniStackedArea = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniArea_1 = __webpack_require__(3564);
class MiniStackedArea extends miniArea_1.MiniArea {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedArea.data, tooltipName = 'stackedAreaTooltip') {
        super(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data, tooltipName, true);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
    }
}
exports.MiniStackedArea = MiniStackedArea;
MiniStackedArea.chartType = 'stackedArea';
MiniStackedArea.data = (0, miniChartHelpers_1.stackData)(miniArea_1.MiniArea.data);


/***/ }),

/***/ 702:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniBar = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniBar extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'groupedBarTooltip');
        const { _Scene } = agChartsExports;
        const padding = this.padding;
        const size = this.size;
        const data = [2, 3, 4];
        const yScale = new _Scene.BandScale();
        yScale.domain = [0, 1, 2];
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.3;
        yScale.paddingOuter = 0.3;
        const xScale = new _Scene.LinearScale();
        xScale.domain = [0, 4];
        xScale.range = [size - padding, padding];
        const bottom = xScale.convert(0);
        const height = yScale.bandwidth;
        this.bars = data.map((datum, i) => {
            const rect = new _Scene.Rect();
            rect.x = padding;
            rect.y = yScale.convert(i);
            rect.width = bottom - xScale.convert(datum);
            rect.height = height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.bars);
    }
    updateColors(fills, strokes) {
        this.bars.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
    }
}
exports.MiniBar = MiniBar;
MiniBar.chartType = 'groupedBar';


/***/ }),

/***/ 3245:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniNormalizedBar = void 0;
const miniStackedBar_1 = __webpack_require__(4161);
class MiniNormalizedBar extends miniStackedBar_1.MiniStackedBar {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, MiniNormalizedBar.data, [0, 10], 'normalizedBarTooltip');
    }
}
exports.MiniNormalizedBar = MiniNormalizedBar;
MiniNormalizedBar.chartType = 'normalizedBar';
MiniNormalizedBar.data = [
    [10, 10, 10],
    [6, 7, 8],
    [2, 4, 6],
];


/***/ }),

/***/ 4161:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniStackedBar = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniStackedBar extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedBar.data, xScaleDomain = [0, 16], tooltipName = 'stackedBarTooltip') {
        super(container, agChartsExports, tooltipName);
        const { _Scene } = agChartsExports;
        const size = this.size;
        const padding = this.padding;
        const yScale = new _Scene.BandScale();
        yScale.domain = [0, 1, 2];
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.3;
        yScale.paddingOuter = 0.3;
        const xScale = new _Scene.LinearScale();
        xScale.domain = xScaleDomain;
        xScale.range = [size - padding, padding];
        const bottom = xScale.convert(0);
        const height = yScale.bandwidth;
        this.bars = data.map((series) => series.map((datum, i) => {
            const rect = new _Scene.Rect();
            rect.x = padding;
            rect.y = yScale.convert(i);
            rect.width = bottom - xScale.convert(datum);
            rect.height = height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        }));
        this.updateColors(fills, strokes);
        this.root.append([].concat.apply([], this.bars));
    }
    updateColors(fills, strokes) {
        this.bars.forEach((series, i) => series.forEach((bar) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        }));
    }
}
exports.MiniStackedBar = MiniStackedBar;
MiniStackedBar.chartType = 'stackedBar';
MiniStackedBar.data = [
    [8, 12, 16],
    [6, 9, 12],
    [2, 3, 4],
];


/***/ }),

/***/ 1990:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniColumn = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniColumn extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'groupedColumnTooltip');
        this.columnData = [2, 3, 4];
        const { root, columnData, size, padding } = this;
        this.columns = (0, miniChartHelpers_1.createColumnRects)({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1, 2],
            yScaleDomain: [0, 4],
            xScalePadding: 0.3,
            agChartsExports,
        });
        root.append(this.columns);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((column, i) => {
            column.fill = fills[i];
            column.stroke = strokes[i];
        });
    }
}
exports.MiniColumn = MiniColumn;
MiniColumn.chartType = 'groupedColumn';


/***/ }),

/***/ 2115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniNormalizedColumn = void 0;
const miniStackedColumn_1 = __webpack_require__(2397);
class MiniNormalizedColumn extends miniStackedColumn_1.MiniStackedColumn {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, MiniNormalizedColumn.data, [0, 10], 'normalizedColumnTooltip');
    }
}
exports.MiniNormalizedColumn = MiniNormalizedColumn;
MiniNormalizedColumn.chartType = 'normalizedColumn';
MiniNormalizedColumn.data = [
    [10, 10, 10],
    [6, 7, 8],
    [2, 4, 6],
];


/***/ }),

/***/ 2397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniStackedColumn = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniStackedColumn extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedColumn.data, yScaleDomain = [0, 16], tooltipName = 'stackedColumnTooltip') {
        super(container, agChartsExports, tooltipName);
        const { root, size, padding } = this;
        this.stackedColumns = (0, miniChartHelpers_1.createColumnRects)({
            stacked: true,
            root,
            data,
            size,
            padding,
            xScaleDomain: [0, 1, 2],
            yScaleDomain,
            xScalePadding: 0.3,
            agChartsExports,
        });
        root.append([].concat.apply([], this.stackedColumns));
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.stackedColumns.forEach((series, i) => series.forEach((column) => {
            column.fill = fills[i];
            column.stroke = strokes[i];
        }));
    }
}
exports.MiniStackedColumn = MiniStackedColumn;
MiniStackedColumn.chartType = 'stackedColumn';
MiniStackedColumn.data = [
    [8, 12, 16],
    [6, 9, 12],
    [2, 3, 4],
];


/***/ }),

/***/ 539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniAreaColumnCombo = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniAreaColumnCombo extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'areaColumnComboTooltip');
        this.columnData = [3, 4.5];
        this.areaData = [[5, 4, 6, 5, 4]];
        const { root, columnData, areaData, size, padding, agChartsExports: { _Scene }, } = this;
        this.columns = (0, miniChartHelpers_1.createColumnRects)({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 6],
            xScalePadding: 0.5,
            agChartsExports,
        });
        // scale for area series
        const xScale = new _Scene.BandScale();
        xScale.range = [padding, size - padding];
        xScale.domain = [0, 1, 2, 3, 4];
        xScale.paddingInner = 1;
        xScale.paddingOuter = 0;
        const yScale = new _Scene.LinearScale();
        yScale.range = [size - padding, padding];
        yScale.domain = [0, 6];
        const pathData = [];
        const yZero = yScale.convert(0);
        const firstX = xScale.convert(0);
        areaData.forEach((series, i) => {
            const points = pathData[i] || (pathData[i] = []);
            series.forEach((data, j) => {
                const yDatum = data;
                const xDatum = j;
                const x = xScale.convert(xDatum);
                const y = yScale.convert(yDatum);
                points[j] = { x, y };
            });
            const lastX = xScale.convert(series.length - 1);
            pathData[i].push({
                x: lastX,
                y: yZero,
            }, {
                x: firstX,
                y: yZero,
            });
        });
        this.areas = pathData.map((points) => {
            const area = new _Scene.Path();
            area.strokeWidth = 0;
            area.fillOpacity = 0.8;
            const path = area.path;
            points.forEach((point, i) => path[i > 0 ? 'lineTo' : 'moveTo'](point.x, point.y));
            return area;
        });
        const areaGroup = new _Scene.Group();
        areaGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
        const columnGroup = new _Scene.Group();
        columnGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
        areaGroup.append(this.areas);
        columnGroup.append(this.columns);
        root.append(areaGroup);
        root.append(columnGroup);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i + 1];
            bar.stroke = strokes[i + 1];
        });
    }
}
exports.MiniAreaColumnCombo = MiniAreaColumnCombo;
MiniAreaColumnCombo.chartType = 'areaColumnCombo';


/***/ }),

/***/ 6042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniColumnLineCombo = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniColumnLineCombo extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'columnLineComboTooltip');
        this.columnData = [3, 4];
        this.lineData = [[5, 4, 6, 5, 4]];
        const { root, columnData, lineData, size, padding } = this;
        this.columns = (0, miniChartHelpers_1.createColumnRects)({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 4],
            xScalePadding: 0.5,
            agChartsExports,
        });
        root.append(this.columns);
        this.lines = (0, miniChartHelpers_1.createLinePaths)(agChartsExports, root, lineData, size, padding);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
        this.lines.forEach((line, i) => {
            line.stroke = fills[i + 2];
        });
    }
}
exports.MiniColumnLineCombo = MiniColumnLineCombo;
MiniColumnLineCombo.chartType = 'columnLineCombo';


/***/ }),

/***/ 1655:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniCustomCombo = void 0;
const miniChart_1 = __webpack_require__(2893);
const miniChartHelpers_1 = __webpack_require__(9004);
class MiniCustomCombo extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'customComboTooltip');
        this.columnData = [3, 4];
        this.lineData = [[5, 4, 6, 5, 4]];
        const { root, columnData, lineData, size, padding, agChartsExports: { _Scene }, } = this;
        this.columns = (0, miniChartHelpers_1.createColumnRects)({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 4],
            xScalePadding: 0.5,
            agChartsExports,
        });
        root.append(this.columns);
        this.lines = (0, miniChartHelpers_1.createLinePaths)(this.agChartsExports, root, lineData, size, padding);
        const axisStroke = 'grey';
        const axisOvershoot = 3;
        const leftAxis = new _Scene.Line();
        leftAxis.x1 = padding;
        leftAxis.y1 = padding;
        leftAxis.x2 = padding;
        leftAxis.y2 = size - padding + axisOvershoot;
        leftAxis.stroke = axisStroke;
        const bottomAxis = new _Scene.Line();
        bottomAxis.x1 = padding - axisOvershoot + 1;
        bottomAxis.y1 = size - padding;
        bottomAxis.x2 = size - padding + 1;
        bottomAxis.y2 = size - padding;
        bottomAxis.stroke = axisStroke;
        const penIcon = new _Scene.Path();
        this.buildPenIconPath(penIcon);
        penIcon.fill = 'whitesmoke';
        penIcon.stroke = 'darkslategrey';
        penIcon.strokeWidth = 1;
        root.append([bottomAxis, leftAxis, penIcon]);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
        this.lines.forEach((line, i) => {
            line.stroke = fills[i + 2];
        });
    }
    buildPenIconPath(penIcon) {
        const { path } = penIcon;
        path.moveTo(25.76, 43.46);
        path.lineTo(31.27, 48.53);
        path.moveTo(49.86, 22);
        path.lineTo(49.86, 22);
        path.cubicCurveTo(49.01994659053345, 21.317514933510974, 47.89593834348529, 21.09645997825817, 46.86, 21.41);
        path.lineTo(46.86, 21.41);
        path.cubicCurveTo(45.55460035985361, 21.77260167850787, 44.38777081121966, 22.517979360321792, 43.51, 23.55);
        path.lineTo(25.51, 43.8);
        path.lineTo(25.43, 43.89);
        path.lineTo(23.01, 51.89);
        path.lineTo(22.83, 52.46);
        path.lineTo(31.02, 48.86);
        path.lineTo(49.02, 28.52);
        path.lineTo(49.02, 28.52);
        path.cubicCurveTo(49.940716461596224, 27.521914221246085, 50.54302631059587, 26.2720342455763, 50.75, 24.93);
        path.lineTo(50.75, 24.93);
        path.cubicCurveTo(50.95363374988308, 23.866379846512814, 50.62080640232334, 22.77066734274871, 49.86, 22.0);
        path.closePath();
        path.moveTo(41.76, 25.5);
        path.lineTo(47.34, 30.5);
        path.moveTo(40.74, 26.65);
        path.lineTo(46.25, 31.71);
    }
}
exports.MiniCustomCombo = MiniCustomCombo;
MiniCustomCombo.chartType = 'customCombo';


/***/ }),

/***/ 5717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniSunburst = void 0;
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniSunburst extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'sunburstTooltip');
        // Hierarchical data using multidimensional array
        this.data = [
            [[], []],
            [[], []],
            [[], []],
        ];
        // Rotate the chart by the given angle (-90 degrees)
        this.angleOffset = -Math.PI / 2;
        this.innerRadiusRatio = 0;
        this.showRadiusAxisLine = false;
        this.showAngleAxisLines = false;
        const { data, size, padding, angleOffset, innerRadiusRatio, agChartsExports: { _Scene }, } = this;
        const radius = (size - padding * 2) / 2;
        const angleRange = [angleOffset + 0, angleOffset + 2 * Math.PI];
        const angleExtent = Math.abs(angleRange[1] - angleRange[0]);
        const radiusRange = [radius * innerRadiusRatio, radius];
        const radiusExtent = Math.abs(radiusRange[1] - radiusRange[0]);
        let maxDepth = 0;
        const findMaxDepth = (data, parentDepth) => {
            data.forEach((child) => {
                const depth = parentDepth + 1;
                maxDepth = Math.max(maxDepth, depth);
                findMaxDepth(child, depth);
            });
        };
        findMaxDepth(data, 0);
        const radiusRatio = radiusExtent / maxDepth;
        const center = this.size / 2;
        const startAngle = angleRange[0];
        this.series = [];
        const createSectors = (data, depth, startAngle, availableAngle, group) => {
            const isArray = Array.isArray(data);
            if (!isArray) {
                return;
            }
            const childDepth = depth + 1;
            let previousAngle = startAngle;
            data.forEach((child, childIndex, children) => {
                let childGroup = group;
                if (!childGroup) {
                    childGroup = new _Scene.Group();
                    this.series.push(childGroup);
                }
                const innerRadius = radiusRange[0] + depth * radiusRatio;
                const outerRadius = radiusRange[0] + childDepth * radiusRatio;
                const angleRatio = 1 / children.length;
                const start = previousAngle;
                const end = start + availableAngle * angleRatio;
                const sector = new _Scene.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = start;
                sector.endAngle = end;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                sector.inset = 0.75;
                previousAngle = end;
                childGroup.append(sector);
                createSectors(child, childDepth, start, Math.abs(end - start), childGroup);
            });
        };
        createSectors(data, 0, startAngle, angleExtent);
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            for (const sector of group.children()) {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            }
        });
    }
}
exports.MiniSunburst = MiniSunburst;
MiniSunburst.chartType = 'sunburst';


/***/ }),

/***/ 7439:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniTreemap = void 0;
const miniChart_1 = __webpack_require__(2893);
class MiniTreemap extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, fills, strokes, themeTemplate, isCustomTheme) {
        super(container, agChartsExports, 'treemapTooltip');
        const { size, padding, agChartsExports: { _Scene }, } = this;
        const data = [
            [1, 1],
            [3, 2, 1],
        ];
        const treeSize = data.length;
        const treePadding = treeSize % 2 === 0 ? 0.3 : 0.2;
        const range = [padding, size - padding];
        const columns = data.length;
        const columnParts = (columns * (columns + 1)) / 2;
        const columnPadding = treePadding / (columns - 1);
        const availableRange = range[1] - range[0];
        const availableWidth = availableRange - treePadding;
        let previousX = range[0];
        this.rects = data.reduce((rects, d, columnIndex) => {
            rects ?? (rects = []);
            const widthRatio = (columns - columnIndex) / columnParts;
            const width = availableWidth * widthRatio;
            const rows = d.length;
            const rowParts = d.reduce((parts, ratio) => (parts += ratio), 0);
            const rowPadding = treePadding / (rows - 1 || 1);
            const availableHeight = rows > 1 ? availableRange - treePadding : availableRange;
            let previousY = range[0];
            const xRects = d.map((ratio) => {
                const rect = new _Scene.Rect();
                const height = (availableHeight * ratio) / rowParts;
                rect.x = previousX;
                rect.y = previousY;
                rect.width = width;
                rect.height = height;
                rect.strokeWidth = 0.75;
                rect.crisp = true;
                previousY += height + rowPadding;
                return rect;
            });
            previousX += width + columnPadding;
            rects.push(...xRects);
            return rects;
        }, []);
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
        const rectGroup = new _Scene.Group();
        rectGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding, size - padding));
        rectGroup.append(this.rects);
        this.root.append(rectGroup);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        const defaultBackgroundColor = themeTemplate?.get(this.agChartsExports._Theme.themeSymbols.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) ?? 'white';
        this.rects.forEach((rect, i) => {
            rect.fill = fills[i % strokes.length];
            rect.stroke = isCustomTheme ? strokes[i % strokes.length] : backgroundFill;
        });
    }
}
exports.MiniTreemap = MiniTreemap;
MiniTreemap.chartType = 'treemap';


/***/ }),

/***/ 5626:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniHistogram = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniHistogram extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'histogramTooltip');
        const { padding, size, agChartsExports: { _Scene }, } = this;
        // approx normal curve
        const data = [2, 5, 11, 13, 10, 6, 1];
        const xScale = new _Scene.LinearScale();
        xScale.domain = [0, data.length];
        xScale.range = [padding, size - padding];
        const yScale = new _Scene.LinearScale();
        yScale.domain = [0, data.reduce((a, b) => Math.max(a, b), 0)];
        yScale.range = [size - padding, padding];
        const bottom = yScale.convert(0);
        this.bars = data.map((datum, i) => {
            const top = yScale.convert(datum);
            const left = xScale.convert(i);
            const right = xScale.convert(i + 1);
            const rect = new _Scene.Rect();
            rect.x = left;
            rect.y = top;
            rect.width = right - left;
            rect.height = bottom - top;
            rect.strokeWidth = 1;
            rect.strokeOpacity = 0.75;
            rect.crisp = true;
            return rect;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.bars);
    }
    updateColors([fill], [stroke]) {
        this.bars.forEach((bar) => {
            bar.fill = fill;
            bar.stroke = stroke;
        });
    }
}
exports.MiniHistogram = MiniHistogram;
MiniHistogram.chartType = 'histogram';


/***/ }),

/***/ 6544:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
tslib_1.__exportStar(__webpack_require__(1990), exports);
tslib_1.__exportStar(__webpack_require__(2397), exports);
tslib_1.__exportStar(__webpack_require__(2115), exports);
tslib_1.__exportStar(__webpack_require__(702), exports);
tslib_1.__exportStar(__webpack_require__(4161), exports);
tslib_1.__exportStar(__webpack_require__(3245), exports);
tslib_1.__exportStar(__webpack_require__(210), exports);
tslib_1.__exportStar(__webpack_require__(7716), exports);
tslib_1.__exportStar(__webpack_require__(7526), exports);
tslib_1.__exportStar(__webpack_require__(9005), exports);
tslib_1.__exportStar(__webpack_require__(8051), exports);
tslib_1.__exportStar(__webpack_require__(434), exports);
tslib_1.__exportStar(__webpack_require__(3268), exports);
tslib_1.__exportStar(__webpack_require__(3564), exports);
tslib_1.__exportStar(__webpack_require__(5133), exports);
tslib_1.__exportStar(__webpack_require__(6249), exports);
tslib_1.__exportStar(__webpack_require__(5626), exports);
tslib_1.__exportStar(__webpack_require__(781), exports);
tslib_1.__exportStar(__webpack_require__(9702), exports);
tslib_1.__exportStar(__webpack_require__(5520), exports);
tslib_1.__exportStar(__webpack_require__(8660), exports);
tslib_1.__exportStar(__webpack_require__(2036), exports);
tslib_1.__exportStar(__webpack_require__(4823), exports);
tslib_1.__exportStar(__webpack_require__(7049), exports);
tslib_1.__exportStar(__webpack_require__(1819), exports);
tslib_1.__exportStar(__webpack_require__(7439), exports);
tslib_1.__exportStar(__webpack_require__(5717), exports);
tslib_1.__exportStar(__webpack_require__(795), exports);
tslib_1.__exportStar(__webpack_require__(3209), exports);
tslib_1.__exportStar(__webpack_require__(6042), exports);
tslib_1.__exportStar(__webpack_require__(539), exports);
tslib_1.__exportStar(__webpack_require__(1655), exports);


/***/ }),

/***/ 7526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniLine = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniLine extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniLine.data, tooltipName = 'lineTooltip') {
        super(container, agChartsExports, tooltipName);
        const { size, padding, root } = this;
        this.lines = (0, miniChartHelpers_1.createLinePaths)(agChartsExports, root, data, size, padding);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, _strokes) {
        this.lines.forEach((line, i) => {
            line.stroke = fills[i];
        });
    }
}
exports.MiniLine = MiniLine;
MiniLine.chartType = 'line';
MiniLine.data = [
    [1, 3, 5],
    [2, 6, 4],
    [5, 3, 1],
];


/***/ }),

/***/ 8051:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniNormalizedLine = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniLine_1 = __webpack_require__(7526);
const miniStackedLine_1 = __webpack_require__(9005);
class MiniNormalizedLine extends miniLine_1.MiniLine {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, data = MiniNormalizedLine.data, tooltipName = 'normalizedLineTooltip') {
        super(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, data, tooltipName);
    }
}
exports.MiniNormalizedLine = MiniNormalizedLine;
MiniNormalizedLine.chartType = 'normalizedLine';
MiniNormalizedLine.data = (0, miniChartHelpers_1.normalizeStackData)(miniStackedLine_1.MiniStackedLine.data);


/***/ }),

/***/ 9005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniStackedLine = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniLine_1 = __webpack_require__(7526);
class MiniStackedLine extends miniLine_1.MiniLine {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedLine.data, tooltipName = 'stackedLineTooltip') {
        super(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, data, tooltipName);
    }
}
exports.MiniStackedLine = MiniStackedLine;
MiniStackedLine.chartType = 'stackedLine';
MiniStackedLine.data = (0, miniChartHelpers_1.stackData)(miniLine_1.MiniLine.data);


/***/ }),

/***/ 2893:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniChart = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const CANVAS_CLASS = 'ag-chart-mini-thumbnail-canvas';
class MiniChart extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(container, agChartsExports, tooltipName) {
        super();
        this.agChartsExports = agChartsExports;
        this.tooltipName = tooltipName;
        this.size = 58;
        this.padding = 5;
        const { _Scene } = agChartsExports;
        this.root = new _Scene.Group();
        const scene = new _Scene.Scene({
            width: this.size,
            height: this.size,
        });
        scene.canvas.element.classList.add(CANVAS_CLASS);
        scene.setRoot(this.root);
        scene.setContainer(container);
        this.scene = scene;
    }
    postConstruct() {
        this.scene.canvas.element.title = this.chartTranslation.translate(this.tooltipName);
        // Necessary to force scene graph render as we are not using the standalone factory.
        try {
            this.scene.render();
        }
        catch (e) {
            (0, ag_grid_community_1._error)(108, { e });
        }
    }
}
exports.MiniChart = MiniChart;


/***/ }),

/***/ 9004:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.accumulateData = exports.createPolarPaths = exports.normalizeStackData = exports.stackData = exports.createAreaPaths = exports.createLinePaths = exports.closePathViaOrigin = exports.closePathViaPreviousSeries = exports.createAreaPathCommands = exports.createPath = exports.createPathCommands = exports.prepareLinearScene = exports.createColumnRects = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function createColumnRects(params) {
    const { stacked, size, padding, xScalePadding, xScaleDomain, yScaleDomain, agChartsExports: { _Scene }, } = params;
    const xScale = new _Scene.BandScale();
    xScale.domain = xScaleDomain;
    xScale.range = [padding, size - padding];
    xScale.paddingInner = xScalePadding;
    xScale.paddingOuter = xScalePadding;
    const yScale = new _Scene.LinearScale();
    yScale.domain = yScaleDomain;
    yScale.range = [size - padding, padding];
    const createBars = (series, xScale, yScale) => {
        return series.map((datum, i) => {
            const top = yScale.convert(datum);
            const rect = new _Scene.Rect();
            rect.x = xScale.convert(i);
            rect.y = top;
            rect.width = xScale.bandwidth;
            rect.height = yScale.convert(0) - top;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
    };
    if (stacked) {
        return params.data.map((d) => createBars(d, xScale, yScale));
    }
    return createBars(params.data, xScale, yScale);
}
exports.createColumnRects = createColumnRects;
function prepareLinearScene(_Scene, data, size, padding) {
    const xDomain = [0, data[0].length - 1];
    const yDomain = data.reduce((acc, curr) => {
        curr.forEach((datum) => {
            if (datum < acc[0]) {
                acc[0] = datum;
            }
            if (datum > acc[1]) {
                acc[1] = datum;
            }
        });
        return acc;
    }, [Infinity, -Infinity]);
    yDomain[0]--;
    yDomain[yDomain.length - 1]++;
    const xScale = new _Scene.LinearScale();
    xScale.domain = xDomain;
    xScale.range = [padding, size - padding];
    const yScale = new _Scene.LinearScale();
    yScale.domain = yDomain;
    yScale.range = [size - padding, padding];
    return { xScale, yScale };
}
exports.prepareLinearScene = prepareLinearScene;
function createPathCommands(data, xScale, yScale) {
    return data.map((series) => series.map((datum, i) => [
        i > 0 ? 'lineTo' : 'moveTo',
        xScale.convert(i),
        yScale.convert(datum),
    ]));
}
exports.createPathCommands = createPathCommands;
function createPath(_Scene, commands) {
    const path = new _Scene.Path();
    commands.forEach(([command, x, y]) => path.path[command](x, y));
    return path;
}
exports.createPath = createPath;
function createAreaPathCommands(commands, yScale, stacked) {
    return commands.map((pathCommands, index, all) => {
        const closingPath = stacked
            ? closePathViaPreviousSeries(all, index, yScale)
            : closePathViaOrigin(pathCommands, yScale);
        // reverse path to maintain CW winding order
        const closingPathCommands = [...closingPath]
            .reverse()
            .map(([_, x, y]) => ['lineTo', x, y]);
        const first = pathCommands[0];
        const last = (0, ag_grid_community_1._last)(closingPathCommands);
        // close the path if needed
        if (first[1] !== last[1] || first[2] !== last[2]) {
            closingPathCommands.push(['lineTo', first[1], first[2]]);
        }
        return [...pathCommands, ...closingPathCommands];
    });
}
exports.createAreaPathCommands = createAreaPathCommands;
function closePathViaPreviousSeries(all, index, yScale) {
    if (index === 0) {
        return closePathViaOrigin(all[index], yScale);
    }
    return [...all[index - 1]];
}
exports.closePathViaPreviousSeries = closePathViaPreviousSeries;
function closePathViaOrigin(pathCommands, yScale) {
    return pathCommands.map(([c, x]) => [c, x, yScale.convert(0)]);
}
exports.closePathViaOrigin = closePathViaOrigin;
function createLinePaths({ _Scene }, root, data, size, padding) {
    const { xScale, yScale } = prepareLinearScene(_Scene, data, size, padding);
    const pathCommands = createPathCommands(data, xScale, yScale);
    const paths = pathCommands.map((commands) => {
        const path = createPath(_Scene, commands);
        path.strokeWidth = 3;
        path.lineCap = 'round';
        path.fill = undefined;
        return path;
    });
    const pathsGroup = new _Scene.Group();
    pathsGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
    pathsGroup.append(paths);
    root.append(pathsGroup);
    return paths;
}
exports.createLinePaths = createLinePaths;
function createAreaPaths(_Scene, root, data, size, padding, stacked = false) {
    const { xScale, yScale } = prepareLinearScene(_Scene, data, size, padding);
    const pathCommands = createAreaPathCommands(createPathCommands(data, xScale, yScale), yScale, stacked);
    const areasGroup = new _Scene.Group();
    areasGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
    const paths = pathCommands.map((commands) => createPath(_Scene, commands));
    areasGroup.append(paths);
    root.append(areasGroup);
    return paths;
}
exports.createAreaPaths = createAreaPaths;
function stackData(data) {
    return data.map((stack, sindex, array) => stack.map((_y, i) => array.slice(0, sindex + 1).reduce((p, c) => p + c[i], 0)));
}
exports.stackData = stackData;
function normalizeStackData(data) {
    const colSum = data.map((_, index) => data.reduce((acc, cur) => Math.max(acc, cur[index]), 0));
    return data.map((stack) => stack.map((y, index) => (y / colSum[index]) * 19));
}
exports.normalizeStackData = normalizeStackData;
function createPolarPaths(agChartsExports, root, data, size, radius, innerRadius, markerSize = 0) {
    const { _Scene } = agChartsExports;
    const angleScale = new _Scene.LinearScale();
    angleScale.domain = [0, 7];
    angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    const radiusScale = new _Scene.LinearScale();
    radiusScale.domain = [0, 10];
    radiusScale.range = [radius, innerRadius];
    const markers = [];
    const center = size / 2;
    const paths = data.map((series) => {
        const path = new _Scene.Path();
        path.strokeWidth = 1;
        path.strokeOpacity = 0.5;
        path.lineCap = 'round';
        path.fill = undefined;
        path.fillOpacity = 0.8;
        series.forEach((datum, i) => {
            const angle = angleScale.convert(i);
            const r = radius + innerRadius - radiusScale.convert(datum);
            const x = r * Math.cos(angle) + center;
            const y = r * Math.sin(angle) + center;
            path.path[i > 0 ? 'lineTo' : 'moveTo'](x, y);
            if (markerSize > 0) {
                const marker = new _Scene.Circle();
                marker.x = x;
                marker.y = y;
                marker.size = markerSize;
                markers.push(marker);
            }
        });
        path.path.closePath();
        return path;
    });
    const group = new _Scene.Group();
    group.append([...paths, ...markers]);
    root.append(group);
    return { paths, markers };
}
exports.createPolarPaths = createPolarPaths;
function accumulateData(data) {
    let [min, max] = [Infinity, -Infinity];
    const processedData = data.reduce((acc, curr, currIndex) => {
        const previous = currIndex > 0 ? acc[currIndex - 1] : undefined;
        acc[currIndex] ?? (acc[currIndex] = []);
        const current = acc[currIndex];
        curr.forEach((datum, datumIndex) => {
            if (previous) {
                datum += previous[datumIndex];
            }
            current[datumIndex] = datum;
            if (current[datumIndex] < min) {
                min = current[datumIndex];
            }
            if (current[datumIndex] > max) {
                max = current[datumIndex];
            }
        });
        return acc;
    }, []);
    return { processedData, min, max };
}
exports.accumulateData = accumulateData;


/***/ }),

/***/ 1408:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniChartWithAxes = void 0;
const miniChart_1 = __webpack_require__(2893);
class MiniChartWithAxes extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, tooltipName) {
        super(container, agChartsExports, tooltipName);
        this.stroke = 'gray';
        this.axisOvershoot = 3;
    }
    postConstruct() {
        const { _Scene } = this.agChartsExports;
        const size = this.size;
        const padding = this.padding;
        const leftAxis = new _Scene.Line();
        leftAxis.x1 = padding;
        leftAxis.y1 = padding;
        leftAxis.x2 = padding;
        leftAxis.y2 = size - padding + this.axisOvershoot;
        leftAxis.stroke = this.stroke;
        const bottomAxis = new _Scene.Line();
        bottomAxis.x1 = padding - this.axisOvershoot + 1;
        bottomAxis.y1 = size - padding;
        bottomAxis.x2 = size - padding + 1;
        bottomAxis.y2 = size - padding;
        bottomAxis.stroke = this.stroke;
        const root = this.root;
        root.append(leftAxis);
        root.append(bottomAxis);
        super.postConstruct();
    }
}
exports.MiniChartWithAxes = MiniChartWithAxes;


/***/ }),

/***/ 2220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniChartWithPolarAxes = void 0;
const miniChart_1 = __webpack_require__(2893);
class MiniChartWithPolarAxes extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, tooltipName) {
        super(container, agChartsExports, tooltipName);
        this.stroke = 'gray';
        this.showRadiusAxisLine = true;
        this.showAngleAxisLines = true;
    }
    postConstruct() {
        const { _Scene } = this.agChartsExports;
        const size = this.size;
        const padding = this.padding;
        const combinedPadding = padding * 2;
        const axisLineRadius = (size - combinedPadding) / 2;
        const gridRadii = this.showAngleAxisLines
            ? [axisLineRadius, axisLineRadius * 0.8, axisLineRadius * 0.6, axisLineRadius * 0.4]
            : [];
        const radiusAxisLine = new _Scene.Line();
        radiusAxisLine.x1 = size / 2;
        radiusAxisLine.y1 = padding;
        radiusAxisLine.x2 = size / 2;
        radiusAxisLine.y2 = size - padding - axisLineRadius - gridRadii[gridRadii.length - 1];
        radiusAxisLine.stroke = this.stroke;
        radiusAxisLine.strokeOpacity = 0.5;
        radiusAxisLine.fill = undefined;
        radiusAxisLine.visible = this.showRadiusAxisLine;
        const x = padding + axisLineRadius;
        this.gridLines = gridRadii.map((radius, index) => {
            const gridLine = new _Scene.Path();
            gridLine.path.arc(x, x, radius, 0, 2 * Math.PI);
            gridLine.strokeWidth = 1;
            gridLine.stroke = this.stroke;
            gridLine.strokeOpacity = index === 0 ? 0.5 : 0.2;
            gridLine.fill = undefined;
            return gridLine;
        });
        const root = this.root;
        root.append(radiusAxisLine);
        if (this.gridLines.length > 0)
            root.append(this.gridLines);
        super.postConstruct();
    }
}
exports.MiniChartWithPolarAxes = MiniChartWithPolarAxes;


/***/ }),

/***/ 7716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniDonut = void 0;
const miniChart_1 = __webpack_require__(2893);
class MiniDonut extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, fills, strokes, _themeTemplateParameters, _isCustomTheme, centerRadiusScaler = 0.6, tooltipName = 'donutTooltip') {
        super(container, agChartsExports, tooltipName);
        const { size, padding, agChartsExports: { _Scene }, } = this;
        const radius = (size - padding * 2) / 2;
        const center = radius + padding;
        const toRadians = _Scene.toRadians;
        const angles = [
            [toRadians(-90), toRadians(30)],
            [toRadians(30), toRadians(120)],
            [toRadians(120), toRadians(180)],
            [toRadians(180), toRadians(210)],
            [toRadians(210), toRadians(240)],
            [toRadians(240), toRadians(270)],
        ];
        this.sectors = angles.map(([startAngle, endAngle]) => {
            const sector = new _Scene.Sector();
            sector.centerX = center;
            sector.centerY = center;
            sector.innerRadius = radius * centerRadiusScaler;
            sector.outerRadius = radius;
            sector.startAngle = startAngle;
            sector.endAngle = endAngle;
            sector.stroke = undefined;
            sector.strokeWidth = 0;
            sector.inset = 0.75;
            return sector;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.sectors);
    }
    updateColors(fills, strokes) {
        this.sectors.forEach((sector, i) => {
            sector.fill = fills[i % fills.length];
            sector.stroke = strokes[i % strokes.length];
        });
    }
}
exports.MiniDonut = MiniDonut;
MiniDonut.chartType = 'donut';


/***/ }),

/***/ 210:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniPie = void 0;
const miniDonut_1 = __webpack_require__(7716);
class MiniPie extends miniDonut_1.MiniDonut {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme, 0, 'pieTooltip');
    }
}
exports.MiniPie = MiniPie;
MiniPie.chartType = 'pie';


/***/ }),

/***/ 2036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniNightingale = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniNightingale extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'nightingaleTooltip');
        this.data = [
            [6, 10, 9, 8, 7, 8],
            [4, 6, 5, 4, 5, 5],
            [3, 5, 4, 3, 4, 7],
        ];
        this.showRadiusAxisLine = false;
        const { size, padding, data, agChartsExports: { _Scene }, } = this;
        const radius = (size - padding * 2) / 2;
        const angleScale = new _Scene.BandScale();
        angleScale.domain = data[0].map((_, index) => index);
        angleScale.range = [-Math.PI, Math.PI];
        angleScale.paddingInner = 0;
        angleScale.paddingOuter = 0;
        const bandwidth = angleScale.bandwidth * 0.7;
        const { processedData, max } = (0, miniChartHelpers_1.accumulateData)(data);
        const radiusScale = new _Scene.LinearScale();
        radiusScale.domain = [0, max];
        radiusScale.range = [0, radius];
        const center = size / 2;
        this.series = processedData.map((series, index) => {
            const previousSeries = index < 0 ? undefined : processedData[index - 1];
            const seriesGroup = new _Scene.Group({ zIndex: 1000000 });
            const seriesSectors = series.map((datum, i) => {
                const previousDatum = previousSeries?.[i];
                const outerRadius = radiusScale.convert(datum);
                const innerRadius = radiusScale.convert(previousDatum ?? 0);
                const startAngle = angleScale.convert(i);
                const endAngle = startAngle + bandwidth;
                const sector = new _Scene.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = startAngle;
                sector.endAngle = endAngle;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                return sector;
            });
            seriesGroup.append(seriesSectors);
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            for (const sector of group.children()) {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            }
        });
    }
}
exports.MiniNightingale = MiniNightingale;
MiniNightingale.chartType = 'nightingale';


/***/ }),

/***/ 8660:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRadarArea = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniRadarArea extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'radarAreaTooltip');
        this.data = [
            [8, 10, 5, 7, 4, 1, 5, 8],
            [1, 1, 2, 7, 7, 8, 10, 1],
            [4, 5, 9, 9, 4, 2, 3, 4],
        ];
        const { size, padding, root, data } = this;
        this.showRadiusAxisLine = false;
        const radius = (size - padding * 2) / 2;
        const innerRadius = radius - size * 0.3;
        this.areas = (0, miniChartHelpers_1.createPolarPaths)(agChartsExports, root, data, size, radius, innerRadius).paths;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
    }
}
exports.MiniRadarArea = MiniRadarArea;
MiniRadarArea.chartType = 'radarArea';


/***/ }),

/***/ 5520:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRadarLine = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniRadarLine extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'radarLineTooltip');
        this.markerSize = 4;
        this.data = [
            [8, 7, 8, 7, 8, 8, 7, 8],
            [6, 8, 5, 10, 6, 7, 4, 6],
            [0, 3, 3, 5, 4, 4, 2, 0],
        ];
        this.showRadiusAxisLine = false;
        const { size, padding, root, data } = this;
        const radius = (size - padding * 2) / 2;
        const innerRadius = 0;
        const { paths, markers } = (0, miniChartHelpers_1.createPolarPaths)(agChartsExports, root, data, size, radius, innerRadius, this.markerSize);
        this.lines = paths;
        this.markers = markers;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.lines.forEach((line, i) => {
            const n = this.data[i].length;
            line.stroke = fills[i];
            const startIdx = i * n;
            const endIdx = startIdx + n;
            const markers = this.markers.slice(startIdx, endIdx);
            markers.forEach((marker) => {
                marker.stroke = strokes[i];
                marker.fill = fills[i];
            });
        });
    }
}
exports.MiniRadarLine = MiniRadarLine;
MiniRadarLine.chartType = 'radarLine';


/***/ }),

/***/ 9702:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRadialBar = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniRadialBar extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'radialBarTooltip');
        this.data = [
            [6, 8, 10],
            [4, 4, 3],
            [5, 4, 2],
        ];
        this.showRadiusAxisLine = false;
        const { size, padding, data, agChartsExports: { _Scene }, } = this;
        const radius = (size - padding) / 2;
        const innerRadiusRatio = 0.4;
        const innerRadius = radius * innerRadiusRatio;
        const radiusScale = new _Scene.BandScale();
        radiusScale.domain = data[0].map((_, index) => index);
        radiusScale.range = [innerRadius, radius];
        radiusScale.paddingInner = 0.5;
        radiusScale.paddingOuter = 0;
        const bandwidth = radiusScale.bandwidth;
        const { processedData, max } = (0, miniChartHelpers_1.accumulateData)(data);
        const angleScale = new _Scene.LinearScale();
        angleScale.domain = [0, Math.ceil(max * 1.5)];
        const start = (3 / 2) * Math.PI;
        const end = start + 2 * Math.PI;
        angleScale.range = [start, end];
        const center = size / 2;
        this.series = processedData.map((series, index) => {
            const previousSeries = index < 0 ? undefined : processedData[index - 1];
            const seriesGroup = new _Scene.Group({ zIndex: 1000000 });
            const seriesSectors = series.map((datum, i) => {
                const previousDatum = previousSeries?.[i] ?? 0;
                const outerRadius = radiusScale.convert(i);
                const innerRadius = outerRadius - bandwidth;
                const startAngle = angleScale.convert(previousDatum);
                const endAngle = angleScale.convert(datum);
                const sector = new _Scene.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = startAngle;
                sector.endAngle = endAngle;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                return sector;
            });
            seriesGroup.append(seriesSectors);
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            for (const sector of group.children()) {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            }
        });
    }
}
exports.MiniRadialBar = MiniRadialBar;
MiniRadialBar.chartType = 'radialBar';


/***/ }),

/***/ 781:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRadialColumn = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithPolarAxes_1 = __webpack_require__(2220);
class MiniRadialColumn extends miniChartWithPolarAxes_1.MiniChartWithPolarAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'radialColumnTooltip');
        this.data = [
            [6, 8, 10, 2, 6, 5],
            [4, 4, 3, 6, 4, 4],
            [5, 4, 2, 9, 8, 9],
        ];
        this.showRadiusAxisLine = false;
        const { padding, size, data, agChartsExports: { _Scene }, } = this;
        const radius = (size - padding * 2) / 2;
        const innerRadiusRatio = 0.4;
        const axisInnerRadius = radius * innerRadiusRatio;
        const angleScale = new _Scene.BandScale();
        angleScale.domain = data[0].map((_, index) => index);
        angleScale.range = [0, 2 * Math.PI];
        angleScale.paddingInner = 0;
        angleScale.paddingOuter = 0;
        const bandwidth = angleScale.bandwidth * 0.7;
        const { processedData, max } = (0, miniChartHelpers_1.accumulateData)(data);
        const radiusScale = new _Scene.LinearScale();
        radiusScale.domain = [0, max];
        radiusScale.range = [axisInnerRadius, radius];
        const center = this.size / 2;
        this.series = processedData.map((series, seriesIndex) => {
            const firstSeries = seriesIndex === 0;
            const previousSeries = firstSeries ? undefined : processedData[seriesIndex - 1];
            const seriesGroup = new _Scene.TranslatableGroup({ zIndex: 1000000 });
            const seriesColumns = series.map((datum, i) => {
                const previousDatum = previousSeries?.[i];
                const outerRadius = radiusScale.convert(datum);
                const innerRadius = radiusScale.convert(previousDatum ?? 0);
                const startAngle = angleScale.convert(i);
                const endAngle = startAngle + bandwidth;
                const columnWidth = _Scene.getRadialColumnWidth(startAngle, endAngle, radius, 0.5, 0.5);
                const column = new _Scene.RadialColumnShape();
                column.columnWidth = columnWidth;
                column.innerRadius = innerRadius;
                column.outerRadius = outerRadius;
                column.startAngle = startAngle;
                column.endAngle = endAngle;
                column.isBeveled = true;
                column.axisInnerRadius = axisInnerRadius;
                column.axisOuterRadius = radius;
                column.stroke = undefined;
                column.strokeWidth = 0;
                return column;
            });
            seriesGroup.append(seriesColumns);
            seriesGroup.translationX = center;
            seriesGroup.translationY = center;
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            for (const sector of group.children()) {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            }
        });
    }
}
exports.MiniRadialColumn = MiniRadialColumn;
MiniRadialColumn.chartType = 'radialColumn';


/***/ }),

/***/ 3268:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniBubble = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniBubble extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'bubbleTooltip');
        const { size, padding, agChartsExports: { _Scene }, } = this;
        // [x, y, radius] triples
        const data = [
            [
                [0.1, 0.3, 5],
                [0.5, 0.4, 7],
                [0.2, 0.8, 7],
            ],
            [
                [0.8, 0.7, 5],
                [0.7, 0.3, 9],
            ],
        ];
        const xScale = new _Scene.LinearScale();
        xScale.domain = [0, 1];
        xScale.range = [padding * 2, size - padding];
        const yScale = new _Scene.LinearScale();
        yScale.domain = [0, 1];
        yScale.range = [size - padding, padding];
        const points = [];
        data.forEach((series) => {
            series.forEach(([x, y, radius]) => {
                const arc = new _Scene.Arc();
                arc.strokeWidth = 0;
                arc.centerX = xScale.convert(x);
                arc.centerY = yScale.convert(y);
                arc.radius = radius;
                arc.fillOpacity = 0.7;
                points.push(arc);
            });
        });
        this.points = points;
        this.updateColors(fills, strokes);
        const pointsGroup = new _Scene.Group();
        pointsGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
        pointsGroup.append(this.points);
        this.root.append(pointsGroup);
    }
    updateColors(fills, strokes) {
        this.points.forEach((line, i) => {
            line.stroke = strokes[i % strokes.length];
            line.fill = fills[i % fills.length];
        });
    }
}
exports.MiniBubble = MiniBubble;
MiniBubble.chartType = 'bubble';


/***/ }),

/***/ 434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniScatter = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniScatter extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'scatterTooltip');
        const { size, padding, agChartsExports: { _Scene }, } = this;
        // [x, y] pairs
        const data = [
            [
                [0.3, 3],
                [1.1, 0.9],
                [2, 0.4],
                [3.4, 2.4],
            ],
            [
                [0, 0.3],
                [1, 2],
                [2.4, 1.4],
                [3, 0],
            ],
        ];
        const xScale = new _Scene.LinearScale();
        xScale.domain = [-0.5, 4];
        xScale.range = [padding * 2, size - padding];
        const yScale = new _Scene.LinearScale();
        yScale.domain = [-0.5, 3.5];
        yScale.range = [size - padding, padding];
        const points = [];
        data.forEach((series) => {
            series.forEach(([x, y]) => {
                const arc = new _Scene.Arc();
                arc.strokeWidth = 0;
                arc.centerX = xScale.convert(x);
                arc.centerY = yScale.convert(y);
                arc.radius = 2.5;
                points.push(arc);
            });
        });
        this.points = points;
        this.updateColors(fills, strokes);
        const pointsGroup = new _Scene.Group();
        pointsGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding * 2, size - padding * 2));
        pointsGroup.append(this.points);
        this.root.append(pointsGroup);
    }
    updateColors(fills, strokes) {
        this.points.forEach((line, i) => {
            line.stroke = strokes[i % strokes.length];
            line.fill = fills[i % fills.length];
        });
    }
}
exports.MiniScatter = MiniScatter;
MiniScatter.chartType = 'scatter';


/***/ }),

/***/ 795:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniHeatmap = void 0;
const miniChart_1 = __webpack_require__(2893);
class MiniHeatmap extends miniChart_1.MiniChart {
    constructor(container, agChartsExports, fills, strokes, themeTemplate, isCustomTheme) {
        super(container, agChartsExports, 'heatmapTooltip');
        const { size, padding, agChartsExports: { _Scene }, } = this;
        const heatmapSize = 3;
        const data = Array.from({ length: heatmapSize }, (_, __) => Array.from({ length: heatmapSize }, (_, yIndex) => yIndex));
        const domain = data.map((_, index) => index);
        const xScale = new _Scene.BandScale();
        xScale.domain = domain;
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.01;
        xScale.paddingOuter = 0.1;
        const yScale = new _Scene.BandScale();
        yScale.domain = domain;
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.01;
        yScale.paddingOuter = 0.1;
        const width = xScale.bandwidth ?? 0;
        const height = yScale.bandwidth ?? 0;
        this.rects = data.reduce((rects, d, index) => {
            rects ?? (rects = []);
            const xRects = d.map((_, yIndex) => {
                const rect = new _Scene.Rect();
                rect.x = xScale.convert(index);
                rect.y = yScale.convert(yIndex);
                rect.width = width;
                rect.height = height;
                rect.strokeWidth = 0;
                rect.crisp = true;
                return rect;
            });
            rects.push(...xRects);
            return rects;
        }, []);
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
        const rectGroup = new _Scene.Group();
        rectGroup.setClipRect(new _Scene.BBox(padding, padding, size - padding, size - padding));
        rectGroup.append(this.rects);
        this.root.append(rectGroup);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        const { _Theme, _Util } = this.agChartsExports;
        const defaultColorRange = themeTemplate?.get(_Theme.themeSymbols.DEFAULT_DIVERGING_SERIES_COLOR_RANGE);
        const defaultBackgroundColor = themeTemplate?.get(_Theme.themeSymbols.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) ?? 'white';
        const colorRange = isCustomTheme ? [fills[0], fills[1]] : defaultColorRange;
        const stroke = isCustomTheme ? strokes[0] : backgroundFill;
        const fillFn = _Util.interpolateColor(colorRange[0], colorRange[1]);
        this.rects.forEach((rect, i) => {
            rect.fill = fillFn(i * 0.2);
            rect.stroke = stroke;
        });
    }
}
exports.MiniHeatmap = MiniHeatmap;
MiniHeatmap.chartType = 'heatmap';


/***/ }),

/***/ 3209:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniWaterfall = void 0;
const miniChartHelpers_1 = __webpack_require__(9004);
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniWaterfall extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, themeTemplate, isCustomTheme) {
        super(container, agChartsExports, 'waterfallTooltip');
        this.data = [4, 3, -3, 6, -3];
        this.bars = this.createWaterfall(this.root, this.data, this.size, this.padding, 'vertical').bars;
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        const { data, agChartsExports: { _Theme: { themeSymbols }, }, } = this;
        const positive = {
            fill: isCustomTheme ? fills[0] : themeTemplate?.get(themeSymbols.PALETTE_ALT_UP_FILL),
            stroke: isCustomTheme ? strokes[0] : themeTemplate?.get(themeSymbols.PALETTE_ALT_UP_STROKE),
        };
        const negative = {
            fill: isCustomTheme ? fills[1] : themeTemplate?.get(themeSymbols.PALETTE_ALT_DOWN_FILL),
            stroke: isCustomTheme ? strokes[1] : themeTemplate?.get(themeSymbols.PALETTE_ALT_DOWN_STROKE),
        };
        this.bars.forEach((bar, i) => {
            const isPositive = data[i] >= 0;
            bar.fill = isPositive ? positive.fill : negative.fill;
            bar.stroke = isPositive ? positive.stroke : negative.stroke;
        });
    }
    createWaterfall(root, data, size, padding, direction) {
        const scalePadding = 2 * padding;
        const { processedData, min, max } = (0, miniChartHelpers_1.accumulateData)(data.map((d) => [d]));
        const flatData = processedData.reduce((flat, d) => flat.concat(d), []);
        const { _Scene } = this.agChartsExports;
        const yScale = new _Scene.LinearScale();
        yScale.domain = [Math.min(min, 0), max];
        yScale.range = [size - scalePadding, scalePadding];
        const xScale = new _Scene.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.2;
        xScale.paddingOuter = 0.3;
        const width = xScale.bandwidth;
        const connectorLine = new _Scene.Path();
        connectorLine.stroke = '#575757';
        connectorLine.strokeWidth = 0;
        const pixelAlignmentOffset = (Math.floor(connectorLine.strokeWidth) % 2) / 2;
        const connectorPath = connectorLine.path;
        connectorPath.clear();
        const barAlongX = direction === 'horizontal';
        const bars = flatData.map((datum, i) => {
            const previousDatum = i > 0 ? flatData[i - 1] : 0;
            const rawValue = data[i];
            const isPositive = rawValue > 0;
            const currY = Math.round(yScale.convert(datum));
            const trailY = Math.round(yScale.convert(previousDatum));
            const y = (isPositive ? currY : trailY) - pixelAlignmentOffset;
            const bottomY = (isPositive ? trailY : currY) + pixelAlignmentOffset;
            const height = Math.abs(bottomY - y);
            const x = xScale.convert(i);
            const rect = new _Scene.Rect();
            rect.x = barAlongX ? y : x;
            rect.y = barAlongX ? x : y;
            rect.width = barAlongX ? height : width;
            rect.height = barAlongX ? width : height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            const moveTo = currY + pixelAlignmentOffset;
            const lineTo = trailY + pixelAlignmentOffset;
            if (i > 0) {
                const lineToX = barAlongX ? lineTo : rect.x;
                const lineToY = barAlongX ? rect.y : lineTo;
                connectorPath.lineTo(lineToX, lineToY);
            }
            const moveToX = barAlongX ? moveTo : rect.x;
            const moveToY = barAlongX ? rect.y : moveTo;
            connectorPath.moveTo(moveToX, moveToY);
            return rect;
        });
        root.append([connectorLine, ...bars]);
        return { bars };
    }
}
exports.MiniWaterfall = MiniWaterfall;
MiniWaterfall.chartType = 'waterfall';


/***/ }),

/***/ 1819:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniBoxPlot = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniBoxPlot extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, agChartsExports, 'boxPlotTooltip');
        const { size, padding, agChartsExports: { _Scene }, } = this;
        const data = [11, 11.5, 10.5];
        const maxRatio = 1.2;
        const q3Ratio = 1.1;
        const q1Ratio = 0.9;
        const minRatio = 0.8;
        const yScale = new _Scene.LinearScale();
        yScale.domain = [
            data.reduce((a, b) => Math.min(a, b), Infinity) * minRatio,
            data.reduce((a, b) => Math.max(a, b), 0) * maxRatio,
        ];
        yScale.range = [size - 1.5 * padding, padding];
        const xScale = new _Scene.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.4;
        xScale.paddingOuter = 0.2;
        const bandwidth = Math.round(xScale.bandwidth);
        const halfBandWidth = Math.round(xScale.bandwidth / 2);
        this.boxPlotGroups = data.map((datum, i) => {
            const [minValue, q1Value, q3Value, maxValue] = [
                datum * minRatio,
                datum * q1Ratio,
                datum * q3Ratio,
                datum * maxRatio,
            ];
            const top = Math.round(yScale.convert(q3Value));
            const left = Math.round(xScale.convert(i));
            const right = Math.round(left + bandwidth);
            const bottom = Math.round(yScale.convert(q1Value));
            const min = Math.round(yScale.convert(minValue));
            const mid = Math.round(yScale.convert(datum));
            const max = Math.round(yScale.convert(maxValue));
            const whiskerX = left + halfBandWidth;
            const boxPlotGroup = new _Scene.Group();
            const box = new _Scene.Rect();
            const median = new _Scene.Line();
            const topWhisker = new _Scene.Line();
            const bottomWhisker = new _Scene.Line();
            const topCap = new _Scene.Line();
            const bottomCap = new _Scene.Line();
            box.x = left;
            box.y = top;
            box.width = bandwidth;
            box.height = bottom - top;
            box.strokeWidth = 1;
            box.strokeOpacity = 0.75;
            box.crisp = true;
            this.setLineProperties(median, left, right, mid, mid);
            this.setLineProperties(topWhisker, whiskerX, whiskerX, max, top);
            this.setLineProperties(bottomWhisker, whiskerX, whiskerX, min, bottom);
            this.setLineProperties(topCap, left, right, max, max);
            this.setLineProperties(bottomCap, left, right, min, min);
            boxPlotGroup.append([box, median, topWhisker, bottomWhisker, topCap, bottomCap]);
            return boxPlotGroup;
        });
        this.updateColors(fills, strokes, themeTemplateParameters, isCustomTheme);
        this.root.append(this.boxPlotGroups);
    }
    updateColors(fills, strokes, themeTemplateParameters, isCustomTheme) {
        const { agChartsExports: { _Util, _Theme }, } = this;
        const themeBackgroundColor = themeTemplateParameters?.get(_Theme.themeSymbols.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) ?? 'white';
        this.boxPlotGroups.forEach((group, i) => {
            for (const node of group.children()) {
                const fill = fills[i % fills.length];
                node.fill = isCustomTheme ? fill : _Util.interpolateColor(fill, backgroundFill)(0.7);
                node.stroke = strokes[i % strokes.length];
            }
        });
    }
    setLineProperties(line, x1, x2, y1, y2) {
        line.x1 = x1;
        line.x2 = x2;
        line.y1 = y1;
        line.y2 = y2;
        line.strokeOpacity = 0.75;
    }
}
exports.MiniBoxPlot = MiniBoxPlot;
MiniBoxPlot.chartType = 'boxPlot';


/***/ }),

/***/ 7049:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRangeArea = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniRangeArea extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'rangeAreaTooltip');
        // Create a set of repeating zigzag-shaped data series to use as the chart data
        const period = 4;
        const dataSeriesMidpoints = [
            zigzag({ offset: 0.375 * period, length: period, pattern: { low: 3, high: 5, period } }),
            zigzag({ offset: 0.375 * period, length: period, pattern: { low: 2.25, high: 4.25, period } }),
            zigzag({ offset: 0.75 * period, length: period, pattern: { low: 2.5, high: 4.5, period } }),
        ];
        const dataSeriesWidth = 1.75;
        const data = dataSeriesMidpoints.map((series) => series.map(([x, y]) => ({
            x,
            low: y - 0.5 * dataSeriesWidth,
            high: y + 0.5 * dataSeriesWidth,
        })));
        const { lines, areas } = this.createRangeArea(this.root, data, this.size, this.padding);
        this.lines = lines;
        this.areas = areas;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        // Swap the secondary and tertiary colors to match the designs
        fills = swapArrayItems(fills, 1, 2);
        strokes = swapArrayItems(strokes, 1, 2);
        this.lines.forEach(([highLine, lowLine], i) => {
            highLine.fill = undefined;
            highLine.stroke = strokes[i];
            lowLine.fill = undefined;
            lowLine.stroke = strokes[i];
        });
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
        });
    }
    createRangeArea(root, data, size, padding) {
        const xMin = data.reduce((acc, series) => series.reduce((acc, { x }) => Math.min(acc, x), acc), Infinity);
        const xMax = data.reduce((acc, series) => series.reduce((acc, { x }) => Math.max(acc, x), acc), -Infinity);
        const yMin = data.reduce((acc, series) => series.reduce((acc, { low }) => Math.min(acc, low), acc), Infinity);
        const yMax = data.reduce((acc, series) => series.reduce((acc, { high }) => Math.max(acc, high), acc), -Infinity);
        const { _Scene } = this.agChartsExports;
        const xScale = new _Scene.LinearScale();
        xScale.domain = [xMin, xMax];
        xScale.range = [padding, size - padding];
        const scalePadding = 2 * padding;
        const yScale = new _Scene.LinearScale();
        yScale.domain = [yMin, yMax];
        yScale.range = [size - scalePadding, scalePadding];
        const lines = [];
        const areas = [];
        const lowPoints = data.map((series) => {
            const highLine = new _Scene.Path();
            const lowLine = new _Scene.Path();
            const area = new _Scene.Path();
            lines.push([highLine, lowLine]);
            areas.push(area);
            highLine.strokeWidth = 0;
            lowLine.strokeWidth = 0;
            area.strokeWidth = 0;
            area.fillOpacity = 0.8;
            highLine.path.clear();
            lowLine.path.clear();
            area.path.clear();
            return series.map((datum, datumIndex) => {
                const { x, low, high } = datum;
                const scaledX = xScale.convert(x);
                const yLow = yScale.convert(low);
                const yHigh = yScale.convert(high);
                const command = datumIndex > 0 ? 'lineTo' : 'moveTo';
                highLine.path[command](scaledX, yHigh);
                lowLine.path[command](scaledX, yLow);
                area.path[command](scaledX, yHigh);
                return [scaledX, yLow];
            });
        });
        lowPoints.forEach((seriesLowPoints, seriesIndex) => {
            const n = seriesLowPoints.length - 1;
            const area = areas[seriesIndex];
            for (let datumIndex = n; datumIndex >= 0; datumIndex--) {
                const [x, y] = seriesLowPoints[datumIndex];
                area.path['lineTo'](x, y);
            }
        });
        root.append(areas.concat(...lines));
        return { lines, areas };
    }
}
exports.MiniRangeArea = MiniRangeArea;
MiniRangeArea.chartType = 'rangeArea';
function zigzag(options) {
    const { offset, length, pattern } = options;
    // Generate [x, y] points for all inflection points of the zigzag pattern that fall within the range
    const points = getZigzagInflectionPoints(offset, length, pattern);
    // Ensure the first and last points are clamped to the start and end of the range
    const xMin = 0;
    const xMax = length;
    if (points.length === 0 || points[0][0] !== xMin)
        points.unshift(getZigzagPoint(xMin, offset, pattern));
    if (points[points.length - 1][0] !== xMax)
        points.push(getZigzagPoint(xMax, offset, pattern));
    return points;
    function getZigzagInflectionPoints(offset, length, pattern) {
        const { period } = pattern;
        const scaledOffset = offset / period;
        const patternInflectionPoints = [0, 0.5];
        const inflectionPoints = patternInflectionPoints
            .map((x) => x - scaledOffset)
            // Clamp offset points to the unit range [0, 1)
            .map(getRemainderAbs)
            .sort((a, b) => a - b);
        const repeatedPoints = Array.from({ length: Math.floor(inflectionPoints.length * (period / length)) }, (_, i) => inflectionPoints[i % inflectionPoints.length] + Math.floor(i / inflectionPoints.length));
        return repeatedPoints.map((x) => x * period).map((x) => getZigzagPoint(x, offset, pattern));
    }
    function getZigzagPoint(x, offset, pattern) {
        return [x, getZigzagValue(offset + x, pattern)];
    }
    function getZigzagValue(x, pattern) {
        const { low, high, period } = pattern;
        const scaledX = getRemainderAbs(x / period);
        const y = scaledX > 0.5 ? 1 - 2 * (scaledX - 0.5) : 2 * scaledX;
        return low + (high - low) * y;
    }
}
function getRemainderAbs(value) {
    const remainder = value % 1;
    return remainder < 0 ? remainder + 1 : remainder;
}
function swapArrayItems(items, leftIndex, rightIndex) {
    const results = [...items];
    const temp = results[leftIndex];
    results[leftIndex] = results[rightIndex];
    results[rightIndex] = temp;
    return results;
}


/***/ }),

/***/ 4823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniRangeBar = void 0;
const miniChartWithAxes_1 = __webpack_require__(1408);
class MiniRangeBar extends miniChartWithAxes_1.MiniChartWithAxes {
    constructor(container, agChartsExports, fills, strokes) {
        super(container, agChartsExports, 'rangeBarTooltip');
        const data = [3, 3.5, 3];
        this.bars = this.createRangeBar(this.root, data, this.size, this.padding, 'vertical');
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.bars.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
    }
    createRangeBar(root, data, size, padding, direction) {
        const barAlongX = direction === 'horizontal';
        const scalePadding = 2 * padding;
        const { _Scene } = this.agChartsExports;
        const xScale = new _Scene.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.3;
        xScale.paddingOuter = 0.3;
        const lowRatio = 0.7;
        const highRatio = 1.3;
        const yScale = new _Scene.LinearScale();
        yScale.domain = [
            data.reduce((a, b) => Math.min(a, b), Infinity) * lowRatio,
            data.reduce((a, b) => Math.max(a, b), 0) * highRatio,
        ];
        yScale.range = [scalePadding, size - scalePadding];
        const width = xScale.bandwidth;
        const bars = data.map((datum, i) => {
            const [low, high] = [datum * lowRatio, datum * highRatio];
            const x = xScale.convert(i);
            const y = yScale.convert(low);
            const height = yScale.convert(high) - y;
            const rect = new _Scene.Rect();
            rect.x = barAlongX ? y : x;
            rect.y = barAlongX ? x : y;
            rect.width = barAlongX ? height : width;
            rect.height = barAlongX ? width : height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
        root.append(bars);
        return bars;
    }
}
exports.MiniRangeBar = MiniRangeBar;
MiniRangeBar.chartType = 'rangeBar';


/***/ }),

/***/ 6692:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniChartsContainer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const seriesTypeMapper_1 = __webpack_require__(4237);
const index_1 = __webpack_require__(6544);
const miniChartMapping = {
    columnGroup: {
        column: { range: true, pivot: true, enterprise: false, icon: index_1.MiniColumn },
        stackedColumn: { range: true, pivot: true, enterprise: false, icon: index_1.MiniStackedColumn },
        normalizedColumn: { range: true, pivot: true, enterprise: false, icon: index_1.MiniNormalizedColumn },
    },
    barGroup: {
        bar: { range: true, pivot: true, enterprise: false, icon: index_1.MiniBar },
        stackedBar: { range: true, pivot: true, enterprise: false, icon: index_1.MiniStackedBar },
        normalizedBar: { range: true, pivot: true, enterprise: false, icon: index_1.MiniNormalizedBar },
    },
    pieGroup: {
        pie: { range: true, pivot: true, enterprise: false, icon: index_1.MiniPie },
        donut: { range: true, pivot: true, enterprise: false, icon: index_1.MiniDonut },
        doughnut: { range: true, pivot: true, enterprise: false, icon: index_1.MiniDonut },
    },
    lineGroup: {
        line: { range: true, pivot: true, enterprise: false, icon: index_1.MiniLine },
        stackedLine: { range: true, pivot: true, enterprise: false, icon: index_1.MiniStackedLine },
        normalizedLine: { range: true, pivot: true, enterprise: false, icon: index_1.MiniNormalizedLine },
    },
    scatterGroup: {
        scatter: { range: true, pivot: true, enterprise: false, icon: index_1.MiniScatter },
        bubble: { range: true, pivot: true, enterprise: false, icon: index_1.MiniBubble },
    },
    areaGroup: {
        area: { range: true, pivot: true, enterprise: false, icon: index_1.MiniArea },
        stackedArea: { range: true, pivot: true, enterprise: false, icon: index_1.MiniStackedArea },
        normalizedArea: { range: true, pivot: true, enterprise: false, icon: index_1.MiniNormalizedArea },
    },
    polarGroup: {
        radarLine: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRadarLine },
        radarArea: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRadarArea },
        nightingale: { range: true, pivot: false, enterprise: true, icon: index_1.MiniNightingale },
        radialColumn: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRadialColumn },
        radialBar: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRadialBar },
    },
    statisticalGroup: {
        boxPlot: { range: true, pivot: false, enterprise: true, icon: index_1.MiniBoxPlot },
        histogram: { range: true, pivot: false, enterprise: false, icon: index_1.MiniHistogram },
        rangeBar: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRangeBar },
        rangeArea: { range: true, pivot: false, enterprise: true, icon: index_1.MiniRangeArea },
    },
    hierarchicalGroup: {
        treemap: { range: true, pivot: true, enterprise: true, icon: index_1.MiniTreemap },
        sunburst: { range: true, pivot: true, enterprise: true, icon: index_1.MiniSunburst },
    },
    specializedGroup: {
        heatmap: { range: true, pivot: false, enterprise: true, icon: index_1.MiniHeatmap },
        waterfall: { range: true, pivot: false, enterprise: true, icon: index_1.MiniWaterfall },
    },
    combinationGroup: {
        columnLineCombo: { range: true, pivot: true, enterprise: false, icon: index_1.MiniColumnLineCombo },
        areaColumnCombo: { range: true, pivot: true, enterprise: false, icon: index_1.MiniAreaColumnCombo },
        customCombo: { range: true, pivot: true, enterprise: false, icon: index_1.MiniCustomCombo },
    },
};
const DEFAULT_CHART_GROUPS = {
    columnGroup: ['column', 'stackedColumn', 'normalizedColumn'],
    barGroup: ['bar', 'stackedBar', 'normalizedBar'],
    pieGroup: ['pie', 'donut'],
    lineGroup: ['line', 'stackedLine', 'normalizedLine'],
    areaGroup: ['area', 'stackedArea', 'normalizedArea'],
    scatterGroup: ['scatter', 'bubble'],
    polarGroup: ['radarLine', 'radarArea', 'nightingale', 'radialColumn', 'radialBar'],
    statisticalGroup: ['boxPlot', 'histogram', 'rangeBar', 'rangeArea'],
    hierarchicalGroup: ['treemap', 'sunburst'],
    specializedGroup: ['heatmap', 'waterfall'],
    combinationGroup: ['columnLineCombo', 'areaColumnCombo', 'customCombo'],
};
class MiniChartsContainer extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(chartController, fills, strokes, themeTemplateParameters, isCustomTheme, chartGroups = DEFAULT_CHART_GROUPS) {
        super(/* html */ `<div class="ag-chart-settings-mini-wrapper"></div>`);
        this.wrappers = new Map();
        this.chartController = chartController;
        this.fills = fills;
        this.strokes = strokes;
        this.themeTemplateParameters = themeTemplateParameters;
        this.isCustomTheme = isCustomTheme;
        this.chartGroups = { ...chartGroups };
    }
    postConstruct() {
        // hide MiniCustomCombo if no custom combo exists
        if (!this.chartController.customComboExists() && this.chartGroups.combinationGroup) {
            this.chartGroups.combinationGroup = this.chartGroups.combinationGroup.filter((chartType) => chartType !== 'customCombo');
        }
        const eGui = this.getGui();
        const isEnterprise = this.chartController.isEnterprise();
        const isPivotChart = this.chartController.isPivotChart();
        const isRangeChart = !isPivotChart;
        // Determine the set of chart types that are specified by the chartGroupsDef config, filtering out any entries
        // that are invalid for the current chart configuration (pivot/range) and license type
        const displayedMenuGroups = Object.keys(this.chartGroups)
            .map((group) => {
            const menuGroup = group in miniChartMapping ? miniChartMapping[group] : undefined;
            if (!menuGroup) {
                // User has specified an invalid chart group in the chartGroupsDef config
                (0, ag_grid_community_1._warn)(148, { group });
                return null;
            }
            // Determine the valid chart types within this group, based on the chartGroupsDef config
            const chartGroupValues = this.chartGroups[group] ?? [];
            const menuItems = chartGroupValues
                .map((chartType) => {
                const menuItem = chartType in menuGroup
                    ? menuGroup[chartType]
                    : undefined;
                if (!menuItem) {
                    // User has specified an invalid chart type in the chartGroupsDef config
                    (0, ag_grid_community_1._warn)(149, { group, chartType });
                    return null;
                }
                if (!isEnterprise && menuItem.enterprise) {
                    return null; // skip enterprise charts if community
                }
                // Only show the chart if it is valid for the current chart configuration (pivot/range)
                if (isRangeChart && menuItem.range)
                    return menuItem;
                if (isPivotChart && menuItem.pivot)
                    return menuItem;
                return null;
            })
                .filter((menuItem) => menuItem != null);
            if (menuItems.length === 0)
                return null; // don't render empty chart groups
            return {
                label: this.chartTranslation.translate(group),
                items: menuItems,
            };
        })
            .filter((menuGroup) => menuGroup != null);
        // Render the filtered menu items
        for (const { label, items } of displayedMenuGroups) {
            const groupComponent = this.createBean(new agGroupComponent_1.AgGroupComponent({
                title: label,
                suppressEnabledCheckbox: true,
                enabled: true,
                suppressOpenCloseIcons: true,
                cssIdentifier: 'charts-settings',
                direction: 'horizontal',
                suppressKeyboardNavigation: true,
            }));
            for (const menuItem of items) {
                const MiniClass = menuItem.icon;
                const miniWrapper = document.createElement('div');
                miniWrapper.classList.add('ag-chart-mini-thumbnail');
                miniWrapper.setAttribute('tabindex', '0');
                miniWrapper.setAttribute('role', 'button');
                const miniClassChartType = MiniClass.chartType;
                const listener = () => {
                    this.chartController.setChartType(miniClassChartType);
                    this.updateSelectedMiniChart();
                };
                this.addManagedListeners(miniWrapper, {
                    click: listener,
                    keydown: (event) => {
                        if (event.key == ag_grid_community_1.KeyCode.ENTER || event.key === ag_grid_community_1.KeyCode.SPACE) {
                            event.preventDefault();
                            listener();
                        }
                    },
                });
                this.wrappers.set(miniClassChartType, miniWrapper);
                this.createBean(new MiniClass(miniWrapper, this.beans.agChartsExports, this.fills, this.strokes, this.themeTemplateParameters, this.isCustomTheme));
                groupComponent.addItem(miniWrapper);
            }
            eGui.appendChild(groupComponent.getGui());
        }
        this.updateSelectedMiniChart();
    }
    updateSelectedMiniChart() {
        const selectedChartType = this.chartController.getChartType();
        this.wrappers.forEach((miniChart, miniChartType) => {
            const selected = miniChartType === selectedChartType;
            miniChart.classList.toggle('ag-selected', selected);
            const chartName = this.chartTranslation.translate((0, seriesTypeMapper_1.getFullChartNameTranslationKey)(miniChartType));
            const ariaLabel = selected
                ? `${chartName}. ${this.chartTranslation.translate('ariaChartSelected')}`
                : chartName;
            (0, ag_grid_community_1._setAriaLabel)(miniChart, ariaLabel);
        });
    }
    destroy() {
        this.wrappers.clear();
        super.destroy();
    }
}
exports.MiniChartsContainer = MiniChartsContainer;


/***/ }),

/***/ 5518:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabbedChartMenu = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const tabbedLayout_1 = __webpack_require__(5875);
const chartDataPanel_1 = __webpack_require__(1504);
const formatPanel_1 = __webpack_require__(3160);
const chartSettingsPanel_1 = __webpack_require__(6604);
const TAB_DATA = 'data';
const TAB_FORMAT = 'format';
class TabbedChartMenu extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(panels, chartMenuContext) {
        super();
        this.panels = panels;
        this.chartMenuContext = chartMenuContext;
        this.tabs = [];
    }
    postConstruct() {
        this.panels.forEach((panel) => {
            const panelType = panel.replace('chart', '').toLowerCase();
            const panelComp = this.createPanel(panelType);
            const tabItem = this.createTab(panel, panelType, panelComp);
            this.tabs.push(tabItem);
            this.addDestroyFunc(() => this.destroyBean(panelComp));
        });
        this.tabbedLayout = new tabbedLayout_1.TabbedLayout({
            items: this.tabs,
            cssClass: 'ag-chart-tabbed-menu',
            keepScrollPosition: true,
            suppressFocusBodyOnOpen: true,
            suppressTrapFocus: true,
            enableCloseButton: true,
            closeButtonAriaLabel: this.chartTranslation.translate('ariaChartMenuClose'),
            onCloseClicked: () => {
                this.eventSource?.focus({ preventScroll: true });
                this.dispatchLocalEvent({ type: 'closed' });
            },
        });
        this.createBean(this.tabbedLayout);
    }
    createTab(name, title, panelComp) {
        const eWrapperDiv = document.createElement('div');
        eWrapperDiv.classList.add('ag-chart-tab', `ag-chart-${title}`);
        this.createBean(panelComp);
        eWrapperDiv.appendChild(panelComp.getGui());
        const titleEl = document.createElement('div');
        const translatedTitle = this.chartTranslation.translate(title);
        titleEl.innerText = translatedTitle;
        return {
            title: titleEl,
            titleLabel: translatedTitle,
            bodyPromise: ag_grid_community_1.AgPromise.resolve(eWrapperDiv),
            getScrollableContainer: () => {
                const scrollableContainer = eWrapperDiv.querySelector('.ag-scrollable-container');
                return (scrollableContainer || eWrapperDiv);
            },
            name,
        };
    }
    showTab(tab) {
        const tabItem = this.tabs[tab];
        this.tabbedLayout.showItem(tabItem);
    }
    getGui() {
        return this.tabbedLayout && this.tabbedLayout.getGui();
    }
    showMenu(eventSource, suppressFocus) {
        this.eventSource = eventSource;
        if (!suppressFocus) {
            this.tabbedLayout?.focusHeader(true);
        }
    }
    destroy() {
        if (this.parentComponent && this.parentComponent.isAlive()) {
            this.destroyBean(this.parentComponent);
        }
        super.destroy();
    }
    createPanel(panelType) {
        switch (panelType) {
            case TAB_DATA:
                return new chartDataPanel_1.ChartDataPanel(this.chartMenuContext);
            case TAB_FORMAT:
                return new formatPanel_1.FormatPanel(this.chartMenuContext);
            default:
                return new chartSettingsPanel_1.ChartSettingsPanel(this.chartMenuContext.chartController);
        }
    }
}
exports.TabbedChartMenu = TabbedChartMenu;


/***/ }),

/***/ 8592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartDataModel = exports.DEFAULT_CHART_CATEGORY = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const chartDatasource_1 = __webpack_require__(9208);
const chartColumnService_1 = __webpack_require__(8919);
const seriesTypeMapper_1 = __webpack_require__(4237);
const comboChartModel_1 = __webpack_require__(2474);
exports.DEFAULT_CHART_CATEGORY = 'AG-GRID-DEFAULT-CATEGORY';
class ChartDataModel extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.rangeSvc = beans.rangeSvc;
        this.chartTranslation = beans.chartTranslation;
    }
    constructor(params) {
        super();
        this.unlinked = false;
        this.chartData = [];
        this.valueColState = [];
        this.dimensionColState = [];
        this.colNames = {};
        this.crossFiltering = false;
        this.grouping = false;
        this.params = params;
        this.chartId = params.chartId;
        this.setParams(params);
    }
    setParams(params) {
        const { chartType, pivotChart, chartThemeName, switchCategorySeries, aggFunc, cellRange, suppressChartRanges, unlinkChart, crossFiltering, seriesGroupType, } = params;
        this.chartType = chartType;
        this.pivotChart = pivotChart ?? false;
        this.chartThemeName = chartThemeName;
        this.switchCategorySeries = !!switchCategorySeries;
        this.aggFunc = aggFunc;
        this.referenceCellRange = cellRange;
        this.suppliedCellRange = cellRange;
        this.suppressChartRanges = suppressChartRanges ?? false;
        this.unlinked = !!unlinkChart;
        this.crossFiltering = !!crossFiltering;
        this.seriesGroupType = seriesGroupType;
    }
    postConstruct() {
        this.datasource = this.createManagedBean(new chartDatasource_1.ChartDatasource());
        this.chartColSvc = this.createManagedBean(new chartColumnService_1.ChartColumnService());
        this.comboChartModel = this.createManagedBean(new comboChartModel_1.ComboChartModel(this));
        this.updateCellRanges({ setColsFromRange: true });
        this.updateData();
    }
    updateModel(params) {
        const { cellRange, seriesChartTypes } = params;
        if (cellRange !== this.suppliedCellRange) {
            this.dimensionCellRange = undefined;
            this.valueCellRange = undefined;
        }
        this.setParams(params);
        this.updateSelectedDimensions(cellRange?.columns);
        this.updateCellRanges({ setColsFromRange: true });
        const shouldUpdateComboModel = this.isComboChart() || seriesChartTypes;
        if (shouldUpdateComboModel) {
            this.comboChartModel.update(seriesChartTypes);
        }
        if (!this.unlinked) {
            this.updateData();
        }
    }
    updateCellRanges(params) {
        const { updatedColState, resetOrder, maintainColState, setColsFromRange } = params ?? {};
        if (this.valueCellRange) {
            this.referenceCellRange = this.valueCellRange;
        }
        const { dimensionCols, valueCols } = this.chartColSvc.getChartColumns();
        const allColsFromRanges = this.getAllColumnsFromRanges();
        if (updatedColState) {
            this.updateColumnState(updatedColState, resetOrder);
        }
        this.setDimensionCellRange(dimensionCols, allColsFromRanges, updatedColState);
        this.setValueCellRange(valueCols, allColsFromRanges, setColsFromRange);
        if (!updatedColState && !maintainColState) {
            this.resetColumnState();
            // dimension / category cell range could be out of sync after resetting column state when row grouping
            this.syncDimensionCellRange();
        }
        this.comboChartModel.updateSeriesChartTypes();
    }
    updateData() {
        const { startRow, endRow } = this.getRowIndexes();
        if (this.pivotChart) {
            this.resetColumnState();
        }
        this.grouping = this.isGrouping();
        const params = {
            aggFunc: this.aggFunc,
            dimensionCols: this.getSelectedDimensions(),
            grouping: this.grouping,
            pivoting: this.isPivotActive(),
            crossFiltering: this.crossFiltering,
            valueCols: this.getSelectedValueCols(),
            startRow,
            endRow,
            isScatter: ['scatter', 'bubble'].includes(this.chartType),
        };
        const { chartData, colNames, groupChartData } = this.datasource.getData(params);
        this.chartData = chartData;
        this.groupChartData = groupChartData;
        this.colNames = colNames;
        this.categoryAxisType = undefined;
    }
    isGrouping() {
        const usingTreeData = this.gos.get('treeData');
        const groupedCols = usingTreeData ? null : this.chartColSvc.getRowGroupColumns();
        const isGroupActive = usingTreeData || (groupedCols && groupedCols.length > 0);
        // charts only group when the selected category is a group column
        const colIds = this.getSelectedDimensions().map(({ colId }) => colId);
        const displayedGroupCols = this.chartColSvc.getGroupDisplayColumns();
        const groupDimensionSelected = displayedGroupCols
            .map((col) => col.getColId())
            .some((id) => colIds.includes(id));
        return !!isGroupActive && groupDimensionSelected;
    }
    getSelectedValueCols() {
        return this.valueColState.filter((cs) => cs.selected).map((cs) => cs.column);
    }
    getSelectedDimensions() {
        return this.dimensionColState.filter((cs) => cs.selected);
    }
    getColDisplayName(col, includePath) {
        return this.chartColSvc.getColDisplayName(col, includePath);
    }
    isPivotMode() {
        return this.chartColSvc.isPivotMode();
    }
    getChartDataType(colId) {
        const column = this.chartColSvc.getColumn(colId);
        return column ? column.getColDef().chartDataType : undefined;
    }
    isPivotActive() {
        return this.chartColSvc.isPivotActive();
    }
    createCellRange(type, ...columns) {
        return {
            id: this.chartId,
            startRow: this.referenceCellRange.startRow,
            endRow: this.referenceCellRange.endRow,
            columns,
            startColumn: type === ag_grid_community_1.CellRangeType.DIMENSION || this.referenceCellRange.startColumn == null
                ? columns[0]
                : this.referenceCellRange.startColumn,
            type,
        };
    }
    getAllColumnsFromRanges() {
        if (this.pivotChart) {
            return new Set(this.chartColSvc.getAllDisplayedColumns());
        }
        const columns = this.dimensionCellRange || this.valueCellRange ? [] : this.referenceCellRange.columns;
        if (this.dimensionCellRange) {
            columns.push(...this.dimensionCellRange.columns);
        }
        if (this.valueCellRange) {
            columns.push(...this.valueCellRange.columns);
        }
        return new Set(columns);
    }
    getRowIndexes() {
        let startRow = 0, endRow = 0;
        const { rangeSvc, valueCellRange, dimensionCellRange } = this;
        // Not all chart types require a value series (e.g. hierarchical charts),
        // so fall back to using the dimension cell range for inferring row indices
        const cellRange = valueCellRange || dimensionCellRange;
        if (rangeSvc && cellRange) {
            startRow = rangeSvc.getRangeStartRow(cellRange).rowIndex;
            // when the last row the cell range is a pinned 'bottom' row, the `endRow` index is set to -1 which results
            // in the ChartDatasource processing all non pinned rows from the `startRow` index.
            const endRowPosition = rangeSvc.getRangeEndRow(cellRange);
            endRow = endRowPosition.rowPinned === 'bottom' ? -1 : endRowPosition.rowIndex;
        }
        return { startRow, endRow };
    }
    resetColumnState() {
        const { dimensionCols, valueCols } = this.chartColSvc.getChartColumns();
        const allCols = this.getAllColumnsFromRanges();
        const isInitialising = this.valueColState.length < 1;
        this.dimensionColState = [];
        this.valueColState = [];
        const supportsMultipleDimensions = (0, seriesTypeMapper_1.isHierarchical)((0, seriesTypeMapper_1.getSeriesType)(this.chartType));
        let hasSelectedDimension = false;
        let order = 1;
        const aggFuncDimension = this.suppliedCellRange.columns[0]; //TODO
        dimensionCols.forEach((column) => {
            const isAutoGroupCol = column.getColId() === 'ag-Grid-AutoColumn';
            let selected = false;
            if (this.crossFiltering && this.aggFunc) {
                if (aggFuncDimension.getColId() === column.getColId()) {
                    selected = true;
                }
            }
            else {
                selected = isAutoGroupCol
                    ? true
                    : (!hasSelectedDimension || supportsMultipleDimensions) && allCols.has(column);
            }
            this.dimensionColState.push({
                column,
                colId: column.getColId(),
                displayName: this.getColDisplayName(column),
                selected,
                order: order++,
            });
            if (selected) {
                hasSelectedDimension = true;
            }
        });
        const defaultCategory = {
            colId: exports.DEFAULT_CHART_CATEGORY,
            displayName: this.chartTranslation.translate('defaultCategory'),
            selected: !hasSelectedDimension,
            order: 0,
        };
        this.dimensionColState.unshift(defaultCategory);
        const valueColumnsFromReferenceRange = this.referenceCellRange.columns.filter((c) => valueCols.has(c));
        valueCols.forEach((column) => {
            // first time the value cell range is set, preserve the column order from the supplied range
            if (isInitialising && this.referenceCellRange.columns.includes(column)) {
                column = valueColumnsFromReferenceRange.shift();
            }
            this.valueColState.push({
                column,
                colId: column.getColId(),
                displayName: this.getColDisplayName(column),
                selected: allCols.has(column),
                order: order++,
            });
        });
    }
    updateColumnState(updatedCol, resetOrder) {
        const idsMatch = (cs) => cs.colId === updatedCol.colId;
        const { dimensionColState, valueColState } = this;
        // Determine whether the specified column is a dimension or value column
        const matchedDimensionColState = dimensionColState.find(idsMatch);
        const matchedValueColState = valueColState.find(idsMatch);
        if (matchedDimensionColState) {
            // For non-hierarchical chart types, only one dimension can be selected
            const supportsMultipleDimensions = (0, seriesTypeMapper_1.isHierarchical)((0, seriesTypeMapper_1.getSeriesType)(this.chartType));
            if (!supportsMultipleDimensions) {
                // Determine which column should end up selected, if any
                const selectedColumnState = updatedCol.selected
                    ? matchedDimensionColState
                    : dimensionColState
                        .filter((cs) => cs !== matchedDimensionColState)
                        .find(({ selected }) => selected);
                // Update the selection state of all dimension columns
                dimensionColState.forEach((cs) => (cs.selected = cs === selectedColumnState));
            }
            else {
                // Update the selection state of the specified dimension column
                matchedDimensionColState.selected = updatedCol.selected;
            }
        }
        else if (matchedValueColState) {
            // Update the selection state of the specified value column
            matchedValueColState.selected = updatedCol.selected;
        }
        const allColumns = [...dimensionColState, ...valueColState];
        const orderedColIds = [];
        if (!resetOrder) {
            // calculate new order
            allColumns.forEach((col, i) => {
                if (i === updatedCol.order) {
                    orderedColIds.push(updatedCol.colId);
                }
                if (col.colId !== updatedCol.colId) {
                    orderedColIds.push(col.colId);
                }
            });
            // update col state with new order
            allColumns.forEach((col) => {
                const order = orderedColIds.indexOf(col.colId);
                col.order = order >= 0 ? orderedColIds.indexOf(col.colId) : allColumns.length - 1;
            });
        }
        this.reorderColState();
    }
    reorderColState() {
        const ascColStateOrder = (a, b) => a.order - b.order;
        this.dimensionColState.sort(ascColStateOrder);
        this.valueColState.sort(ascColStateOrder);
    }
    setDimensionCellRange(dimensionCols, colsInRange, updatedColState) {
        this.dimensionCellRange = undefined;
        const supportsMultipleDimensions = (0, seriesTypeMapper_1.isHierarchical)((0, seriesTypeMapper_1.getSeriesType)(this.chartType));
        if (!updatedColState && !this.dimensionColState.length) {
            const selectedCols = new Array();
            // use first dimension column in range by default, or all dimension columns for hierarchical charts
            dimensionCols.forEach((col) => {
                if ((selectedCols.length > 0 && !supportsMultipleDimensions) || !colsInRange.has(col)) {
                    return;
                }
                selectedCols.push(col);
            });
            if (selectedCols.length > 0) {
                this.dimensionCellRange = this.createCellRange(ag_grid_community_1.CellRangeType.DIMENSION, ...selectedCols);
            }
            return;
        }
        let selectedDimensionColStates = updatedColState ? [updatedColState] : [];
        if (this.crossFiltering && this.aggFunc) {
            const aggFuncDimension = this.suppliedCellRange.columns[0]; //TODO
            selectedDimensionColStates = this.dimensionColState.filter((cs) => cs.colId === aggFuncDimension.getColId());
        }
        else if (supportsMultipleDimensions ||
            selectedDimensionColStates.length === 0 ||
            selectedDimensionColStates.some(({ column }) => !column || !dimensionCols.has(column))) {
            selectedDimensionColStates = this.dimensionColState.filter((cs) => cs.selected);
        }
        const isDefaultCategory = selectedDimensionColStates.length === 1
            ? selectedDimensionColStates[0].colId === exports.DEFAULT_CHART_CATEGORY
            : false;
        const selectedColumns = selectedDimensionColStates
            .map(({ column }) => column)
            .filter((value) => value != null);
        if (selectedColumns.length > 0 && !isDefaultCategory) {
            this.dimensionCellRange = this.createCellRange(ag_grid_community_1.CellRangeType.DIMENSION, ...selectedColumns);
        }
    }
    setValueCellRange(valueCols, colsInRange, setColsFromRange) {
        this.valueCellRange = undefined;
        const selectedValueCols = [];
        const maxSelection = (0, seriesTypeMapper_1.getMaxNumSeries)(this.chartType);
        let numSelected = 0;
        valueCols.forEach((col) => {
            if (setColsFromRange) {
                if ((maxSelection == null || numSelected < maxSelection) && colsInRange.has(col)) {
                    selectedValueCols.push(col);
                    numSelected++;
                }
            }
            else {
                if (this.valueColState.some((colState) => colState.selected && colState.colId === col.getColId())) {
                    selectedValueCols.push(col);
                }
            }
        });
        if (selectedValueCols.length > 0) {
            let orderedColIds = [];
            if (this.valueColState.length > 0) {
                orderedColIds = this.valueColState.map((c) => c.colId);
            }
            else {
                colsInRange.forEach((c) => orderedColIds.push(c.getColId()));
            }
            selectedValueCols.sort((a, b) => orderedColIds.indexOf(a.getColId()) - orderedColIds.indexOf(b.getColId()));
            this.valueCellRange = this.createCellRange(ag_grid_community_1.CellRangeType.VALUE, ...selectedValueCols);
        }
    }
    resetCellRanges(dimension, value) {
        if (!dimension && !value) {
            return;
        }
        const { dimensionCols, valueCols } = this.chartColSvc.getChartColumns();
        const allColsFromRanges = this.getAllColumnsFromRanges();
        if (dimension) {
            this.setDimensionCellRange(dimensionCols, allColsFromRanges);
        }
        if (value) {
            this.setValueCellRange(valueCols, allColsFromRanges);
        }
    }
    updateSelectedDimensions(columns) {
        const colIdSet = new Set(columns.map((column) => column.getColId()));
        // For non-hierarchical chart types, only one dimension can be selected
        const supportsMultipleDimensions = (0, seriesTypeMapper_1.isHierarchical)((0, seriesTypeMapper_1.getSeriesType)(this.chartType));
        if (!supportsMultipleDimensions) {
            // Determine which column should end up selected, if any
            // if no dimension found in supplied columns use the default category (always index = 0)
            const foundColState = this.dimensionColState.find((colState) => colIdSet.has(colState.colId)) || this.dimensionColState[0];
            const selectedColumnId = foundColState.colId;
            // Update the selection state of all dimension columns
            this.dimensionColState = this.dimensionColState.map((colState) => ({
                ...colState,
                selected: colState.colId === selectedColumnId,
            }));
        }
        else {
            // Update the selection state of all dimension columns, selecting only the provided columns from the chart model
            const foundColStates = this.dimensionColState.filter((colState) => colIdSet.has(colState.colId));
            const selectedColumnIds = new Set(foundColStates.map((colState) => colState.colId));
            this.dimensionColState = this.dimensionColState.map((colState) => ({
                ...colState,
                selected: selectedColumnIds.has(colState.colId),
            }));
        }
    }
    syncDimensionCellRange() {
        const selectedDimensions = this.getSelectedDimensions();
        if (selectedDimensions.length === 0)
            return;
        const selectedCols = selectedDimensions
            .map(({ column }) => column)
            .filter((value) => value != null);
        if (selectedCols.length > 0) {
            this.dimensionCellRange = this.createCellRange(ag_grid_community_1.CellRangeType.DIMENSION, ...selectedCols);
        }
    }
    isComboChart(chartType) {
        return (0, seriesTypeMapper_1.isComboChart)(chartType ?? this.chartType);
    }
}
exports.ChartDataModel = ChartDataModel;


/***/ }),

/***/ 2474:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComboChartModel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const SUPPORTED_COMBO_CHART_TYPES = new Set(['line', 'groupedColumn', 'stackedColumn', 'area', 'stackedArea']);
class ComboChartModel extends ag_grid_community_1.BeanStub {
    constructor(chartDataModel) {
        super();
        // this control flag is used to only log warning for the initial user config
        this.suppressComboChartWarnings = false;
        this.chartDataModel = chartDataModel;
        this.seriesChartTypes = chartDataModel.params.seriesChartTypes ?? [];
    }
    postConstruct() {
        this.initComboCharts();
    }
    update(seriesChartTypes) {
        this.seriesChartTypes = seriesChartTypes ?? this.seriesChartTypes;
        this.initComboCharts();
        this.updateSeriesChartTypes();
    }
    initComboCharts() {
        const seriesChartTypesExist = this.seriesChartTypes && this.seriesChartTypes.length > 0;
        const customCombo = this.chartDataModel.chartType === 'customCombo' || seriesChartTypesExist;
        if (customCombo) {
            // it is not necessary to supply a chart type for combo charts when `seriesChartTypes` is supplied
            this.chartDataModel.chartType = 'customCombo';
            // cache supplied `seriesChartTypes` to allow switching between different chart types in the settings panel
            this.savedCustomSeriesChartTypes = this.seriesChartTypes || [];
        }
    }
    updateSeriesChartTypes() {
        if (!this.chartDataModel.isComboChart()) {
            return;
        }
        // ensure primary only chart types are not placed on secondary axis
        this.seriesChartTypes = this.seriesChartTypes.map((seriesChartType) => {
            const primaryOnly = ['groupedColumn', 'stackedColumn', 'stackedArea'].includes(seriesChartType.chartType);
            seriesChartType.secondaryAxis = primaryOnly ? false : seriesChartType.secondaryAxis;
            return seriesChartType;
        });
        // note that when seriesChartTypes are supplied the chart type is also changed to 'customCombo'
        if (this.chartDataModel.chartType === 'customCombo') {
            this.updateSeriesChartTypesForCustomCombo();
            return;
        }
        this.updateChartSeriesTypesForBuiltInCombos();
    }
    updateSeriesChartTypesForCustomCombo() {
        const seriesChartTypesSupplied = this.seriesChartTypes && this.seriesChartTypes.length > 0;
        if (!seriesChartTypesSupplied && !this.suppressComboChartWarnings) {
            (0, ag_grid_community_1._warn)(150);
        }
        // ensure correct chartTypes are supplied
        this.seriesChartTypes = this.seriesChartTypes.map((s) => {
            if (!SUPPORTED_COMBO_CHART_TYPES.has(s.chartType)) {
                (0, ag_grid_community_1._warn)(151, { chartType: s.chartType });
                s.chartType = 'line';
            }
            return s;
        });
        const getSeriesChartType = (valueCol) => {
            if (!this.savedCustomSeriesChartTypes || this.savedCustomSeriesChartTypes.length === 0) {
                this.savedCustomSeriesChartTypes = this.seriesChartTypes;
            }
            const providedSeriesChartType = this.savedCustomSeriesChartTypes.find((s) => s.colId === valueCol.colId);
            if (!providedSeriesChartType) {
                if (valueCol.selected && !this.suppressComboChartWarnings) {
                    (0, ag_grid_community_1._warn)(152, { colId: valueCol.colId });
                }
                return {
                    colId: valueCol.colId,
                    chartType: 'line',
                    secondaryAxis: false,
                };
            }
            return providedSeriesChartType;
        };
        const updatedSeriesChartTypes = this.chartDataModel.valueColState.map(getSeriesChartType);
        this.seriesChartTypes = updatedSeriesChartTypes;
        // also cache custom `seriesChartTypes` to allow for switching between different chart types
        this.savedCustomSeriesChartTypes = updatedSeriesChartTypes;
        // turn off warnings as first combo chart attempt has completed
        this.suppressComboChartWarnings = true;
    }
    updateChartSeriesTypesForBuiltInCombos() {
        const { chartType, valueColState } = this.chartDataModel;
        const primaryChartType = chartType === 'columnLineCombo' ? 'groupedColumn' : 'stackedArea';
        const secondaryChartType = chartType === 'columnLineCombo' ? 'line' : 'groupedColumn';
        const selectedCols = valueColState.filter((cs) => cs.selected);
        const lineIndex = Math.ceil(selectedCols.length / 2);
        this.seriesChartTypes = selectedCols.map((valueCol, i) => {
            const seriesType = i >= lineIndex ? secondaryChartType : primaryChartType;
            return { colId: valueCol.colId, chartType: seriesType, secondaryAxis: false };
        });
    }
}
exports.ComboChartModel = ComboChartModel;


/***/ }),

/***/ 8919:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartColumnService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ChartColumnService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartColSvc';
        this.valueColsWithoutSeriesType = new Set();
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.colNames = beans.colNames;
        this.valueSvc = beans.valueSvc;
    }
    postConstruct() {
        const clearValueCols = () => this.valueColsWithoutSeriesType.clear();
        this.addManagedEventListeners({
            newColumnsLoaded: clearValueCols,
            rowDataUpdated: clearValueCols,
        });
    }
    getColumn(colId) {
        return this.colModel.getColDefCol(colId);
    }
    getAllDisplayedColumns() {
        return this.beans.visibleCols.allCols;
    }
    getColDisplayName(col, includePath) {
        const headerLocation = 'chart';
        const columnDisplayName = this.colNames.getDisplayNameForColumn(col, headerLocation);
        if (includePath) {
            const displayNames = [columnDisplayName];
            const getDisplayName = (colGroup) => {
                if (!colGroup) {
                    return;
                }
                const colGroupName = this.colNames.getDisplayNameForColumnGroup(colGroup, headerLocation);
                if (colGroupName?.length) {
                    displayNames.unshift(colGroupName);
                    getDisplayName(colGroup.getParent());
                }
            };
            getDisplayName(col.getParent());
            return displayNames.join(' - ');
        }
        return columnDisplayName;
    }
    getRowGroupColumns() {
        return this.beans.rowGroupColsSvc?.columns ?? [];
    }
    getGroupDisplayColumns() {
        return this.beans.showRowGroupCols?.getShowRowGroupCols() ?? [];
    }
    isPivotMode() {
        return this.colModel.isPivotMode();
    }
    isPivotActive() {
        return this.colModel.isPivotActive();
    }
    getChartColumns() {
        const gridCols = this.colModel.getCols();
        const dimensionCols = new Set();
        const valueCols = new Set();
        gridCols.forEach((col) => {
            const colDef = col.getColDef();
            const chartDataType = colDef.chartDataType;
            if (chartDataType) {
                // chart data type was specified explicitly
                switch (chartDataType) {
                    case 'category':
                    case 'time':
                        dimensionCols.add(col);
                        return;
                    case 'series':
                        valueCols.add(col);
                        return;
                    case 'excluded':
                        return;
                    default:
                        (0, ag_grid_community_1._warn)(153, { chartDataType });
                        break;
                }
            }
            if (colDef.colId === 'ag-Grid-AutoColumn') {
                dimensionCols.add(col);
                return;
            }
            if (!col.isPrimary()) {
                valueCols.add(col);
                return;
            }
            // if 'chartDataType' is not provided then infer type based data contained in first row
            (this.isInferredValueCol(col) ? valueCols : dimensionCols).add(col);
        });
        return { dimensionCols, valueCols };
    }
    isInferredValueCol(col) {
        const colId = col.getColId();
        if (colId === 'ag-Grid-AutoColumn') {
            return false;
        }
        const row = (0, ag_grid_community_1._getRowNode)(this.beans, { rowIndex: 0, rowPinned: null });
        if (!row) {
            return this.valueColsWithoutSeriesType.has(colId);
        }
        let cellValue = this.valueSvc.getValue(col, row);
        if (cellValue == null) {
            cellValue = this.extractLeafData(row, col);
        }
        if (cellValue != null && typeof cellValue.toNumber === 'function') {
            cellValue = cellValue.toNumber();
        }
        const isNumber = typeof cellValue === 'number';
        if (isNumber) {
            this.valueColsWithoutSeriesType.add(colId);
        }
        return isNumber;
    }
    extractLeafData(row, col) {
        if (!row.allLeafChildren) {
            return null;
        }
        for (let i = 0; i < row.allLeafChildren.length; i++) {
            const childRow = row.allLeafChildren[i];
            const value = this.valueSvc.getValue(col, childRow);
            if (value != null) {
                return value;
            }
        }
        return null;
    }
    destroy() {
        this.valueColsWithoutSeriesType.clear();
        super.destroy();
    }
}
exports.ChartColumnService = ChartColumnService;


/***/ }),

/***/ 8769:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartCrossFilterService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ChartCrossFilterService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartCrossFilterSvc';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.valueSvc = beans.valueSvc;
        this.filterManager = beans.filterManager;
        if ((0, ag_grid_community_1._isClientSideRowModel)(this.gos, beans.rowModel)) {
            this.clientSideRowModel = beans.rowModel;
        }
    }
    filter(event, reset = false) {
        const filterModel = this.filterManager?.getFilterModel() ?? {};
        // filters should be reset when user clicks on canvas background
        if (reset) {
            this.resetFilters(filterModel);
            return;
        }
        const colId = this.extractFilterColId(event);
        if (this.isValidColumnFilter(colId)) {
            // update filters based on current chart selections
            this.updateFilters(filterModel, event, colId);
        }
        else {
            (0, ag_grid_community_1._warn)(154, { colId });
        }
    }
    resetFilters(filterModel) {
        const filtersExist = Object.keys(filterModel).length > 0;
        if (filtersExist) {
            // only reset filters / charts when necessary to prevent undesirable flickering effect
            this.filterManager?.setFilterModel(null);
            this.filterManager?.onFilterChanged({ source: 'api' });
        }
    }
    updateFilters(filterModel, event, colId) {
        const dataKey = this.extractFilterColId(event);
        const rawValue = event.datum[dataKey];
        if (rawValue === undefined) {
            return;
        }
        const selectedValue = rawValue.toString();
        if (event.event.metaKey || event.event.ctrlKey) {
            const existingGridValues = this.getCurrentGridValuesForCategory(colId);
            const valueAlreadyExists = existingGridValues.includes(selectedValue);
            let updatedValues;
            if (valueAlreadyExists) {
                updatedValues = existingGridValues.filter((v) => v !== selectedValue);
            }
            else {
                updatedValues = existingGridValues;
                updatedValues.push(selectedValue);
            }
            filterModel[colId] = this.getUpdatedFilterModel(colId, updatedValues);
        }
        else {
            const updatedValues = [selectedValue];
            filterModel = { [colId]: this.getUpdatedFilterModel(colId, updatedValues) };
        }
        this.filterManager?.setFilterModel(filterModel);
    }
    getUpdatedFilterModel(colId, updatedValues) {
        const columnFilterType = this.getColumnFilterType(colId);
        if (columnFilterType === 'agMultiColumnFilter') {
            return { filterType: 'multi', filterModels: [null, { filterType: 'set', values: updatedValues }] };
        }
        return { filterType: 'set', values: updatedValues };
    }
    getCurrentGridValuesForCategory(colId) {
        const filteredValues = [];
        const column = this.getColumnById(colId);
        this.clientSideRowModel?.forEachNodeAfterFilter((rowNode) => {
            if (column && !rowNode.group) {
                const value = this.valueSvc.getValue(column, rowNode) + '';
                if (!filteredValues.includes(value)) {
                    filteredValues.push(value);
                }
            }
        });
        return filteredValues;
    }
    extractFilterColId(event) {
        return event.xKey || event.calloutLabelKey;
    }
    isValidColumnFilter(colId) {
        if (colId.indexOf('-filtered-out')) {
            colId = colId.replace('-filtered-out', '');
        }
        const filterType = this.getColumnFilterType(colId);
        if (typeof filterType === 'boolean') {
            return filterType;
        }
        return ['agSetColumnFilter', 'agMultiColumnFilter'].includes(filterType);
    }
    getColumnFilterType(colId) {
        const gridColumn = this.getColumnById(colId);
        if (gridColumn) {
            const colDef = gridColumn.getColDef();
            return colDef.filter;
        }
    }
    getColumnById(colId) {
        return this.colModel.getCol(colId);
    }
}
exports.ChartCrossFilterService = ChartCrossFilterService;


/***/ }),

/***/ 7492:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartMenuService = exports.CHART_TOOL_PANEL_MENU_OPTIONS = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const CHART_TOOLBAR_ALLOW_LIST = [
    'chartUnlink',
    'chartLink',
    'chartDownload',
    'chartMenu',
];
exports.CHART_TOOL_PANEL_MENU_OPTIONS = {
    settings: 'chartSettings',
    data: 'chartData',
    format: 'chartFormat',
};
class ChartMenuService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartMenuSvc';
    }
    wireBeans(beans) {
        this.advSettingsMenuFactory = beans.advSettingsMenuFactory;
    }
    downloadChart(chartMenuContext, dimensions, fileName, fileFormat) {
        chartMenuContext.chartController.getChartProxy().downloadChart(dimensions, fileName, fileFormat);
    }
    toggleLinked(chartMenuContext) {
        chartMenuContext.chartController.detachChartRange();
    }
    openAdvancedSettings(chartMenuContext, eventSource) {
        this.advSettingsMenuFactory?.showMenu(chartMenuContext, eventSource);
    }
    hideAdvancedSettings() {
        this.advSettingsMenuFactory?.hideMenu();
    }
    getChartToolbarOptions() {
        const defaultChartToolbarOptions = ['chartMenu'];
        const toolbarItemsFunc = this.gos.getCallback('getChartToolbarItems');
        const params = {
            defaultItems: defaultChartToolbarOptions,
        };
        return toolbarItemsFunc
            ? toolbarItemsFunc(params).filter((option) => {
                if (!CHART_TOOLBAR_ALLOW_LIST.includes(option)) {
                    (0, ag_grid_community_1._warn)(155, { option });
                    return false;
                }
                return true;
            })
            : defaultChartToolbarOptions;
    }
    getChartToolPanels(chartController) {
        const chartToolPanelsDef = this.gos.get('chartToolPanelsDef');
        const panelsOverride = chartToolPanelsDef?.panels
            ?.map((panel) => {
            const menuOption = exports.CHART_TOOL_PANEL_MENU_OPTIONS[panel];
            if (!menuOption) {
                (0, ag_grid_community_1._warn)(156, { panel });
            }
            return menuOption;
        })
            .filter((panel) => Boolean(panel));
        let panels = panelsOverride ?? Object.values(exports.CHART_TOOL_PANEL_MENU_OPTIONS);
        // pivot charts use the column tool panel instead of the data panel
        if (chartController.isPivotChart()) {
            panels = panels.filter((panel) => panel !== 'chartData');
        }
        const defaultToolPanel = chartToolPanelsDef?.defaultToolPanel;
        const defaultPanel = (defaultToolPanel && exports.CHART_TOOL_PANEL_MENU_OPTIONS[defaultToolPanel]) || panels[0];
        return {
            panels,
            defaultPanel,
        };
    }
    doesChartToolbarExist() {
        const chartToolbarOptions = this.getChartToolbarOptions();
        return chartToolbarOptions.length > 0;
    }
    doChartToolPanelsExist(chartController) {
        const { panels } = this.getChartToolPanels(chartController);
        return panels.length > 0;
    }
}
exports.ChartMenuService = ChartMenuService;


/***/ }),

/***/ 6297:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartOptionsService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const object_1 = __webpack_require__(2210);
const seriesTypeMapper_1 = __webpack_require__(4237);
const CARTESIAN_AXIS_TYPES = ['number', 'category', 'time', 'grouped-category'];
const POLAR_AXIS_TYPES = ['angle-category', 'angle-number', 'radius-category', 'radius-number'];
const VALID_AXIS_TYPES = [...CARTESIAN_AXIS_TYPES, ...POLAR_AXIS_TYPES];
class ChartOptionsService extends ag_grid_community_1.BeanStub {
    constructor(chartController) {
        super();
        this.chartController = chartController;
    }
    getChartThemeOverridesProxy() {
        return {
            getValue: (expression) => this.getChartOption(expression),
            setValue: (expression, value) => this.setChartThemeOverrides([{ expression, value }]),
            setValues: (properties) => this.setChartThemeOverrides(properties),
        };
    }
    getAxisThemeOverridesProxy() {
        return {
            getValue: (expression) => this.getAxisProperty(expression),
            setValue: (expression, value) => this.setAxisThemeOverrides([{ expression, value }]),
            setValues: (properties) => this.setAxisThemeOverrides(properties),
        };
    }
    getCartesianAxisOptionsProxy(axisType) {
        return {
            getValue: (expression) => this.getCartesianAxisProperty(axisType, expression),
            setValue: (expression, value) => this.setCartesianAxisOptions(axisType, [{ expression, value }]),
            setValues: (properties) => this.setCartesianAxisOptions(axisType, properties),
        };
    }
    getCartesianAxisThemeOverridesProxy(axisType) {
        return {
            getValue: (expression) => this.getCartesianAxisProperty(axisType, expression),
            setValue: (expression, value) => this.setCartesianAxisThemeOverrides(axisType, [{ expression, value }]),
            setValues: (properties) => this.setCartesianAxisThemeOverrides(axisType, properties),
        };
    }
    getCartesianAxisAppliedThemeOverridesProxy(axisType) {
        return {
            getValue: (expression) => this.getCartesianAxisThemeOverride(axisType, 
            // Allow the caller to specify a wildcard expression to retrieve the whole set of overrides
            expression === '*' ? null : expression),
            setValue: (expression, value) => this.setCartesianAxisThemeOverrides(axisType, 
            // Allow the caller to specify a wildcard expression to set the whole set of overrides
            [{ expression: expression === '*' ? null : expression, value }]),
            setValues: (properties) => this.setCartesianAxisThemeOverrides(axisType, properties),
        };
    }
    getSeriesOptionsProxy(getSelectedSeries) {
        return {
            getValue: (expression, calculated) => this.getSeriesOption(getSelectedSeries(), expression, calculated),
            setValue: (expression, value) => this.setSeriesOptions(getSelectedSeries(), [{ expression, value }]),
            setValues: (properties) => this.setSeriesOptions(getSelectedSeries(), properties),
        };
    }
    /**
     * Determine the set of theme overrides that should be retained when transitioning from one chart type to another.
     */
    getPersistedChartThemeOverrides(existingChartOptions, existingAxes, existingChartType, targetChartType) {
        // Determine the set of theme override keys that should be retained when transitioning from one chart type to another
        const retainedThemeOverrideKeys = this.getRetainedChartThemeOverrideKeys(existingChartType, targetChartType);
        const retainedChartAxisThemeOverrideKeys = this.getRetainedChartAxisThemeOverrideKeys(null, existingChartType, targetChartType);
        // combine the options into a single merged object
        const targetChartOptions = this.createChartOptions();
        // copy the retained theme overrides from the existing chart options to the target chart options
        for (const expression of retainedThemeOverrideKeys) {
            // Locate the value in the existing chart series theme overrides
            const value = this.retrieveChartOptionsThemeOverride(existingChartOptions, existingChartType, expression);
            if (value !== undefined) {
                // Update the value in the target chart series theme overrides
                this.assignChartOptionsThemeOverride(targetChartOptions, targetChartType, expression, value);
            }
        }
        // axis theme overrides are copied to all potential target axis types
        // (this is necessary because certain chart types auto-instantiate different axis types given the same data)
        if (existingAxes) {
            this.assignPersistedAxisOverrides({
                existingAxes,
                retainedChartAxisThemeOverrideKeys,
                existingChartOptions,
                targetChartOptions,
                existingChartType,
                targetChartType,
            });
        }
        return targetChartOptions.theme.overrides;
    }
    assignPersistedAxisOverrides(params) {
        const { existingAxes, retainedChartAxisThemeOverrideKeys, existingChartOptions, targetChartOptions, existingChartType, targetChartType, } = params;
        for (const { expression, targetAxisTypes } of retainedChartAxisThemeOverrideKeys) {
            // Locate the value in the existing chart series theme overrides
            for (const existingAxisType of existingAxes.map((axis) => axis.type)) {
                const value = this.retrieveChartOptionsThemeOverride(existingChartOptions, existingChartType, ['axes', existingAxisType, expression].join('.'));
                if (value !== undefined) {
                    // Copy the value to all potential target chart axis theme overrides
                    // (axis theme overrides are currently only persisted across cartesian chart types)
                    for (const targetAxisType of targetAxisTypes) {
                        this.assignChartOptionsThemeOverride(targetChartOptions, targetChartType, ['axes', targetAxisType, expression].join('.'), value);
                    }
                }
            }
        }
    }
    getRetainedChartThemeOverrideKeys(existingChartType, targetChartType) {
        // these theme overrides are persisted across all chart types
        const UNIVERSAL_PERSISTED_THEME_OVERRIDES = ['animation'];
        // these theme overrides are persisted across all cartesian chart types
        const PERSISTED_CARTESIAN_CHART_THEME_OVERRIDES = ['zoom', 'navigator'];
        // other chart options will be retained depending on the specifics of the chart type from/to transition
        const chartSpecificThemeOverrideKeys = ((previousChartType, updatedChartType) => {
            const expressions = new Array();
            if ((0, seriesTypeMapper_1.isCartesian)((0, seriesTypeMapper_1.getSeriesType)(previousChartType)) && (0, seriesTypeMapper_1.isCartesian)((0, seriesTypeMapper_1.getSeriesType)(updatedChartType))) {
                expressions.push(...PERSISTED_CARTESIAN_CHART_THEME_OVERRIDES);
            }
            return expressions;
        })(existingChartType, targetChartType);
        return [...UNIVERSAL_PERSISTED_THEME_OVERRIDES, ...chartSpecificThemeOverrideKeys];
    }
    getRetainedChartAxisThemeOverrideKeys(axisType, existingChartType, targetChartType) {
        // different axis types have different theme overrides
        if ((0, seriesTypeMapper_1.isCartesian)((0, seriesTypeMapper_1.getSeriesType)(existingChartType)) && (0, seriesTypeMapper_1.isCartesian)((0, seriesTypeMapper_1.getSeriesType)(targetChartType))) {
            const retainedKeys = this.getRetainedCartesianAxisThemeOverrideKeys(axisType);
            return retainedKeys.map((expression) => ({ expression, targetAxisTypes: CARTESIAN_AXIS_TYPES }));
        }
        return [];
    }
    getRetainedCartesianAxisThemeOverrideKeys(axisType) {
        const axisPositionSuffixes = axisType === 'xAxis'
            ? ['', '.top', '.bottom']
            : axisType === 'yAxis'
                ? ['', '.left', '.right']
                : ['', '.left', '.right', '.top', '.bottom'];
        // these axis theme overrides are persisted across all cartesian chart axis types
        const PERSISTED_CARTESIAN_AXIS_THEME_OVERRIDES = ['crosshair'];
        const expressions = new Array();
        for (const expression of PERSISTED_CARTESIAN_AXIS_THEME_OVERRIDES) {
            for (const axisPositionSuffix of axisPositionSuffixes) {
                expressions.push(`${expression}${axisPositionSuffix}`);
            }
        }
        return expressions;
    }
    getChartOption(expression) {
        return (0, object_1.get)(this.getChart(), expression, undefined);
    }
    setChartThemeOverrides(properties) {
        const chartType = this.getChartType();
        // combine the options into a single merged object
        const chartOptions = this.createChartOptions();
        for (const { expression, value } of properties) {
            this.assignChartOptionsThemeOverride(chartOptions, chartType, expression, value);
        }
        this.applyChartOptions(chartOptions);
    }
    applyChartOptions(chartOptions, options) {
        if (Object.keys(chartOptions).length === 0)
            return;
        this.updateChart(chartOptions);
        const shouldRaiseEvent = !options?.silent;
        if (shouldRaiseEvent)
            this.raiseChartOptionsChangedEvent();
    }
    awaitChartOptionUpdate(func) {
        const chart = this.chartController.getChartProxy().getChart();
        chart
            .waitForUpdate()
            .then(() => func())
            .catch((e) => (0, ag_grid_community_1._error)(108, { e }));
    }
    getAxisProperty(expression) {
        // Assume the property exists on the first axis
        return (0, object_1.get)(this.getChart().axes?.[0], expression, undefined);
    }
    setAxisThemeOverrides(properties) {
        const chart = this.getChart();
        const chartType = this.getChartType();
        // combine the options into a single merged object
        const chartOptions = this.createChartOptions();
        for (const { expression, value } of properties) {
            // Only apply the property to axes that declare the property on their prototype chain
            const relevantAxes = chart.axes?.filter((axis) => {
                const parts = expression.split('.');
                let current = axis;
                for (const part of parts) {
                    if (!(part in current)) {
                        return false;
                    }
                    current = current[part];
                }
                return true;
            });
            if (!relevantAxes)
                continue;
            for (const axis of relevantAxes) {
                if (!this.isValidAxisType(axis))
                    continue;
                this.assignChartAxisThemeOverride(chartOptions, chartType, axis.type, null, expression, value);
            }
        }
        this.applyChartOptions(chartOptions);
    }
    getCartesianAxisProperty(axisType, expression) {
        const axes = this.getChartAxes();
        const axis = this.getCartesianAxis(axes, axisType);
        return (0, object_1.get)(axis, expression, undefined);
    }
    getCartesianAxisThemeOverride(axisType, expression) {
        const axes = this.getChartAxes();
        const chartAxis = this.getCartesianAxis(axes, axisType);
        if (!chartAxis || !this.isValidAxisType(chartAxis))
            return undefined;
        const chartType = this.getChartType();
        const chartOptions = this.getChart().getOptions();
        return this.retrieveChartAxisThemeOverride(chartOptions, chartType, chartAxis.type, axisType === 'yAxis' ? ['left', 'right'] : ['bottom', 'top'], expression);
    }
    setCartesianAxisThemeOverrides(axisType, properties) {
        const axes = this.getChartAxes();
        const chartAxis = this.getCartesianAxis(axes, axisType);
        if (!chartAxis || !this.isValidAxisType(chartAxis))
            return;
        const chartType = this.getChartType();
        // combine the axis options into a single merged object
        const chartOptions = this.createChartOptions();
        for (const { expression, value } of properties) {
            this.assignChartAxisThemeOverride(chartOptions, chartType, chartAxis.type, axisType === 'yAxis' ? ['left', 'right'] : ['bottom', 'top'], expression, value);
        }
        this.applyChartOptions(chartOptions);
    }
    setCartesianAxisOptions(axisType, properties) {
        this.updateCartesianAxisOptions(axisType, (chartOptions, axes, chartAxis) => {
            // assign the provided axis options onto the combined chart options object
            const axisIndex = axes.indexOf(chartAxis);
            for (const { expression, value } of properties) {
                this.assignChartOption(chartOptions, `axes.${axisIndex}.${expression}`, value);
            }
        });
    }
    updateCartesianAxisOptions(axisType, updateFunc) {
        // get a snapshot of all existing axis options from the chart instance
        const existingChartOptions = this.getChart().getOptions();
        const axisOptions = 'axes' in existingChartOptions ? existingChartOptions.axes : undefined;
        if (!existingChartOptions || !axisOptions)
            return;
        const axes = this.getChartAxes();
        const chartAxis = this.getCartesianAxis(axes, axisType);
        if (!chartAxis)
            return;
        // combine the axis options into a single merged object
        const chartOptions = this.createChartOptions();
        chartOptions.axes = axisOptions;
        updateFunc(chartOptions, axes, chartAxis, existingChartOptions);
        this.applyChartOptions(chartOptions);
    }
    setCartesianCategoryAxisType(axisType, value) {
        this.updateCartesianAxisOptions(axisType, (chartOptions, _axes, chartAxis, existingChartOptions) => {
            const chartType = this.getChartType();
            this.assignPersistedAxisOverrides({
                existingAxes: [chartAxis],
                retainedChartAxisThemeOverrideKeys: this.getRetainedChartAxisThemeOverrideKeys(axisType, chartType, chartType),
                existingChartOptions,
                targetChartOptions: chartOptions,
                existingChartType: chartType,
                targetChartType: chartType,
            });
            this.assignChartOption(chartOptions, `axes.0.type`, value);
            this.chartController.setCategoryAxisType(value);
        });
    }
    getCartesianAxis(axes, axisType) {
        if (axes.length < 2) {
            return undefined;
        }
        switch (axisType) {
            case 'xAxis':
                return axes[0].direction === 'x' ? axes[0] : axes[1];
            case 'yAxis':
                return axes[1].direction === 'y' ? axes[1] : axes[0];
        }
    }
    getSeriesOption(seriesType, expression, calculated) {
        // N.B. 'calculated' here refers to the fact that the property exists on the internal series object itself,
        // rather than the properties object. This is due to us needing to reach inside the chart itself to retrieve
        // the value, and will likely be cleaned up in a future release
        const series = this.getChart().series.find((s) => isMatchingSeries(seriesType, s));
        return (0, object_1.get)(calculated ? series : series?.properties.toJson(), expression, undefined);
    }
    setSeriesOptions(seriesType, properties) {
        // combine the series options into a single merged object
        const chartOptions = this.createChartOptions();
        for (const { expression, value } of properties) {
            this.assignChartOptionsSeriesThemeOverride(chartOptions, seriesType, `series.${expression}`, value);
        }
        this.applyChartOptions(chartOptions);
    }
    getPairedMode() {
        return this.chartController.getChartProxy().isPaired();
    }
    setPairedMode(paired) {
        this.chartController.getChartProxy().setPaired(paired);
    }
    getChartAxes() {
        const chart = this.getChart();
        return chart.axes ?? [];
    }
    retrieveChartAxisThemeOverride(chartOptions, chartType, axisType, axisPositions, expression) {
        // Theme overrides can be applied either to all axes simultaneously, or only to axes in a certain orientation
        // (this allows more fine-grained control for e.g. styling horizontal / vertical axes separately)
        if (axisPositions) {
            for (const axisPosition of axisPositions) {
                const value = this.retrieveChartOptionsThemeOverride(chartOptions, chartType, ['axes', axisType, axisPosition, ...(expression ? [expression] : [])].join('.'));
                if (value === undefined)
                    continue;
                return value;
            }
        }
        else {
            return this.retrieveChartOptionsThemeOverride(chartOptions, chartType, ['axes', axisType, ...(expression ? [expression] : [])].join('.'));
        }
    }
    assignChartAxisThemeOverride(chartOptions, chartType, axisType, axisPositions, expression, value) {
        // Theme overrides can be applied either to all axes simultaneously, or only to axes in a certain orientation
        // (this allows more fine-grained control for e.g. styling horizontal / vertical axes separately)
        if (axisPositions) {
            for (const axisPosition of axisPositions) {
                this.assignChartOptionsThemeOverride(chartOptions, chartType, ['axes', axisType, axisPosition, ...(expression ? [expression] : [])].join('.'), value);
            }
        }
        else {
            this.assignChartOptionsThemeOverride(chartOptions, chartType, ['axes', axisType, ...(expression ? [expression] : [])].join('.'), value);
        }
    }
    isValidAxisType(chartAxis) {
        return VALID_AXIS_TYPES.includes(chartAxis.type);
    }
    getChartType() {
        return this.chartController.getChartType();
    }
    getChart() {
        return this.chartController.getChartProxy().getChart();
    }
    updateChart(chartOptions) {
        const chartRef = this.chartController.getChartProxy().getChartRef();
        chartRef.skipAnimations();
        chartRef.updateDelta(chartOptions);
    }
    createChartOptions() {
        const chartOptions = {
            theme: {
                overrides: {},
            },
        };
        return chartOptions;
    }
    retrieveChartOptionsThemeOverride(chartOptions, chartType, expression) {
        // Determine the relevant series type theme override series keys for the current chart
        const chartSeriesTypes = this.getChartThemeOverridesSeriesTypeKeys(chartType);
        // Retrieve the first matching value
        for (const seriesType of chartSeriesTypes) {
            const value = this.retrieveChartOptionsSeriesThemeOverride(chartOptions, seriesType, expression);
            if (value === undefined)
                continue;
            return value;
        }
        return undefined;
    }
    assignChartOptionsThemeOverride(chartOptions, chartType, expression, value) {
        // Determine the relevant series type theme override series keys for the current chart
        const chartSeriesTypes = this.getChartThemeOverridesSeriesTypeKeys(chartType);
        // assign the relevant theme overrides for each series type
        for (const seriesType of chartSeriesTypes) {
            this.assignChartOptionsSeriesThemeOverride(chartOptions, seriesType, expression, value);
        }
    }
    retrieveChartOptionsSeriesThemeOverride(chartOptions, seriesType, expression) {
        return this.retrieveChartOption(chartOptions, ['theme', 'overrides', seriesType, ...(expression ? [expression] : [])].join('.'));
    }
    assignChartOptionsSeriesThemeOverride(chartOptions, seriesType, expression, value) {
        this.assignChartOption(chartOptions, ['theme', 'overrides', seriesType, ...(expression ? [expression] : [])].join('.'), value);
    }
    getChartThemeOverridesSeriesTypeKeys(chartType) {
        // In the chart options API, theme overrides are categorized according to series type.
        // Depending on the chart type, theme overrides may need to be applied to multiple series types.
        const chartSeriesTypes = this.chartController.getChartSeriesTypes(chartType);
        if (this.chartController.isComboChart()) {
            chartSeriesTypes.push('common');
        }
        return chartSeriesTypes;
    }
    retrieveChartOption(chartOptions, expression) {
        return (0, object_1.get)(chartOptions, expression, undefined);
    }
    assignChartOption(chartOptions, expression, value) {
        (0, object_1.set)(chartOptions, expression, value);
    }
    raiseChartOptionsChangedEvent() {
        const chartModel = this.chartController.getChartModel();
        this.eventSvc.dispatchEvent({
            type: 'chartOptionsChanged',
            chartId: chartModel.chartId,
            chartType: chartModel.chartType,
            chartThemeName: this.chartController.getChartThemeName(),
            chartOptions: chartModel.chartOptions,
        });
    }
    destroy() {
        super.destroy();
    }
}
exports.ChartOptionsService = ChartOptionsService;
function isMatchingSeries(seriesType, series) {
    return (0, seriesTypeMapper_1.isSeriesType)(seriesType) && series.type === seriesType;
}


/***/ }),

/***/ 93:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartTranslationService = exports.DEFAULT_CHART_TRANSLATIONS = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
exports.DEFAULT_CHART_TRANSLATIONS = {
    pivotChartTitle: 'Pivot Chart',
    rangeChartTitle: 'Range Chart',
    settings: 'Chart',
    data: 'Set Up',
    format: 'Customize',
    categories: 'Categories',
    defaultCategory: '(None)',
    series: 'Series',
    switchCategorySeries: 'Switch Category / Series',
    categoryValues: 'Category Values',
    seriesLabels: 'Series Labels',
    aggregate: 'Aggregate',
    xyValues: 'X Y Values',
    paired: 'Paired Mode',
    axis: 'Axis',
    xAxis: 'Horizontal Axis',
    yAxis: 'Vertical Axis',
    polarAxis: 'Polar Axis',
    radiusAxis: 'Radius Axis',
    navigator: 'Navigator',
    zoom: 'Zoom',
    animation: 'Animation',
    crosshair: 'Crosshair',
    color: 'Color',
    thickness: 'Thickness',
    preferredLength: 'Preferred Length',
    xType: 'X Type',
    axisType: 'Axis Type',
    automatic: 'Automatic',
    category: 'Category',
    number: 'Number',
    time: 'Time',
    timeFormat: 'Time Format',
    autoRotate: 'Auto Rotate',
    labelRotation: 'Rotation',
    circle: 'Circle',
    polygon: 'Polygon',
    square: 'Square',
    cross: 'Cross',
    diamond: 'Diamond',
    plus: 'Plus',
    triangle: 'Triangle',
    heart: 'Heart',
    orientation: 'Orientation',
    fixed: 'Fixed',
    parallel: 'Parallel',
    perpendicular: 'Perpendicular',
    radiusAxisPosition: 'Position',
    ticks: 'Ticks',
    gridLines: 'Grid Lines',
    width: 'Width',
    height: 'Height',
    length: 'Length',
    padding: 'Padding',
    spacing: 'Spacing',
    chartStyle: 'Chart Style',
    title: 'Title',
    chartTitles: 'Titles',
    chartTitle: 'Chart Title',
    chartSubtitle: 'Subtitle',
    horizontalAxisTitle: 'Horizontal Axis Title',
    verticalAxisTitle: 'Vertical Axis Title',
    polarAxisTitle: 'Polar Axis Title',
    titlePlaceholder: 'Chart Title',
    background: 'Background',
    font: 'Font',
    weight: 'Weight',
    top: 'Top',
    right: 'Right',
    bottom: 'Bottom',
    left: 'Left',
    labels: 'Labels',
    calloutLabels: 'Callout Labels',
    sectorLabels: 'Sector Labels',
    positionRatio: 'Position Ratio',
    size: 'Size',
    shape: 'Shape',
    minSize: 'Minimum Size',
    maxSize: 'Maximum Size',
    legend: 'Legend',
    position: 'Position',
    markerSize: 'Marker Size',
    markerStroke: 'Marker Stroke',
    markerPadding: 'Marker Padding',
    itemSpacing: 'Item Spacing',
    itemPaddingX: 'Item Padding X',
    itemPaddingY: 'Item Padding Y',
    layoutHorizontalSpacing: 'Horizontal Spacing',
    layoutVerticalSpacing: 'Vertical Spacing',
    strokeWidth: 'Stroke Width',
    offset: 'Offset',
    offsets: 'Offsets',
    tooltips: 'Tooltips',
    callout: 'Callout',
    markers: 'Markers',
    shadow: 'Shadow',
    blur: 'Blur',
    xOffset: 'X Offset',
    yOffset: 'Y Offset',
    lineWidth: 'Line Width',
    lineDash: 'Line Dash',
    lineDashOffset: 'Dash Offset',
    scrollingZoom: 'Scrolling',
    scrollingStep: 'Scrolling Step',
    selectingZoom: 'Selecting',
    durationMillis: 'Duration (ms)',
    crosshairLabel: 'Label',
    crosshairSnap: 'Snap to Node',
    normal: 'Normal',
    bold: 'Bold',
    italic: 'Italic',
    boldItalic: 'Bold Italic',
    predefined: 'Predefined',
    fillOpacity: 'Fill Opacity',
    strokeColor: 'Line Color',
    strokeOpacity: 'Line Opacity',
    miniChart: 'Mini-Chart',
    histogramBinCount: 'Bin count',
    connectorLine: 'Connector Line',
    seriesItems: 'Series Items',
    seriesItemType: 'Item Type',
    seriesItemPositive: 'Positive',
    seriesItemNegative: 'Negative',
    seriesItemLabels: 'Item Labels',
    columnGroup: 'Column',
    barGroup: 'Bar',
    pieGroup: 'Pie',
    lineGroup: 'Line',
    scatterGroup: 'X Y (Scatter)',
    areaGroup: 'Area',
    polarGroup: 'Polar',
    statisticalGroup: 'Statistical',
    hierarchicalGroup: 'Hierarchical',
    specializedGroup: 'Specialized',
    combinationGroup: 'Combination',
    groupedColumnTooltip: 'Grouped',
    stackedColumnTooltip: 'Stacked',
    normalizedColumnTooltip: '100% Stacked',
    groupedBarTooltip: 'Grouped',
    stackedBarTooltip: 'Stacked',
    normalizedBarTooltip: '100% Stacked',
    pieTooltip: 'Pie',
    donutTooltip: 'Donut',
    lineTooltip: 'Line',
    stackedLineTooltip: 'Stacked',
    normalizedLineTooltip: '100% Stacked',
    groupedAreaTooltip: 'Area',
    stackedAreaTooltip: 'Stacked',
    normalizedAreaTooltip: '100% Stacked',
    scatterTooltip: 'Scatter',
    bubbleTooltip: 'Bubble',
    histogramTooltip: 'Histogram',
    radialColumnTooltip: 'Radial Column',
    radialBarTooltip: 'Radial Bar',
    radarLineTooltip: 'Radar Line',
    radarAreaTooltip: 'Radar Area',
    nightingaleTooltip: 'Nightingale',
    rangeBarTooltip: 'Range Bar',
    rangeAreaTooltip: 'Range Area',
    boxPlotTooltip: 'Box Plot',
    treemapTooltip: 'Treemap',
    sunburstTooltip: 'Sunburst',
    waterfallTooltip: 'Waterfall',
    heatmapTooltip: 'Heatmap',
    columnLineComboTooltip: 'Column & Line',
    areaColumnComboTooltip: 'Area & Column',
    customComboTooltip: 'Custom Combination',
    innerRadius: 'Inner Radius',
    startAngle: 'Start Angle',
    endAngle: 'End Angle',
    reverseDirection: 'Reverse Direction',
    groupPadding: 'Group Padding',
    seriesPadding: 'Series Padding',
    tile: 'Tile',
    whisker: 'Whisker',
    cap: 'Cap',
    capLengthRatio: 'Length Ratio',
    labelPlacement: 'Placement',
    inside: 'Inside',
    outside: 'Outside',
    noDataToChart: 'No data available to be charted.',
    pivotChartRequiresPivotMode: 'Pivot Chart requires Pivot Mode enabled.',
    chartSettingsToolbarTooltip: 'Menu',
    chartLinkToolbarTooltip: 'Linked to Grid',
    chartUnlinkToolbarTooltip: 'Unlinked from Grid',
    chartDownloadToolbarTooltip: 'Download Chart',
    chartMenuToolbarTooltip: 'Menu',
    chartEdit: 'Edit Chart',
    chartAdvancedSettings: 'Advanced Settings',
    chartLink: 'Link to Grid',
    chartUnlink: 'Unlink from Grid',
    chartDownload: 'Download Chart',
    histogramFrequency: 'Frequency',
    seriesChartType: 'Series Chart Type',
    seriesType: 'Series Type',
    secondaryAxis: 'Secondary Axis',
    seriesAdd: 'Add a series',
    categoryAdd: 'Add a category',
    bar: 'Bar',
    column: 'Column',
    histogram: 'Histogram',
    advancedSettings: 'Advanced Settings',
    direction: 'Direction',
    horizontal: 'Horizontal',
    vertical: 'Vertical',
    seriesGroupType: 'Group Type',
    groupedSeriesGroupType: 'Grouped',
    stackedSeriesGroupType: 'Stacked',
    normalizedSeriesGroupType: '100% Stacked',
    legendEnabled: 'Enabled',
    invalidColor: 'Color value is invalid',
    groupedColumnFull: 'Grouped Column',
    stackedColumnFull: 'Stacked Column',
    normalizedColumnFull: '100% Stacked Column',
    groupedBarFull: 'Grouped Bar',
    stackedBarFull: 'Stacked Bar',
    normalizedBarFull: '100% Stacked Bar',
    stackedAreaFull: 'Stacked Area',
    normalizedAreaFull: '100% Stacked Area',
    stackedLineFull: 'Stacked Line',
    normalizedLineFull: '100% Stacked Line',
    customCombo: 'Custom Combination',
    // menu items
    groupedColumn: 'Grouped',
    stackedColumn: 'Stacked',
    pie: 'Pie',
    donut: 'Donut',
    line: 'Line',
    scatter: 'Scatter',
    bubble: 'Bubble',
    area: 'Area',
    stackedArea: 'Stacked',
    radarLine: 'Radar Line',
    radarArea: 'Radar Area',
    nightingale: 'Nightingale',
    radialColumn: 'Radial Column',
    radialBar: 'Radial Bar',
    boxPlot: 'Box Plot',
    rangeBar: 'Range Bar',
    rangeArea: 'Range Area',
    treemap: 'Treemap',
    sunburst: 'Sunburst',
    waterfall: 'Waterfall',
    heatmap: 'Heatmap',
    columnLineCombo: 'Column & Line',
    AreaColumnCombo: 'Area & Column',
    // aria
    ariaChartMenuClose: 'Close Chart Edit Menu',
    ariaChartSelected: 'Selected',
    // group
    group: 'Group',
    // time formats
    timeFormatSlashesDDMMYYYY: 'DD/MM/YYYY',
    timeFormatSlashesMMDDYYYY: 'MM/DD/YYYY',
    timeFormatSlashesDDMMYY: 'DD/MM/YY',
    timeFormatSlashesMMDDYY: 'MM/DD/YY',
    timeFormatDotsDDMYY: 'DD.M.YY',
    timeFormatDotsMDDYY: 'M.DD.YY',
    timeFormatDashesYYYYMMDD: 'YYYY-MM-DD',
    timeFormatSpacesDDMMMMYYYY: 'DD MMMM YYYY',
    timeFormatHHMMSS: 'HH:MM:SS',
    timeFormatHHMMSSAmPm: 'HH:MM:SS AM/PM',
    // agg funcs
    sum: 'Sum',
    first: 'First',
    last: 'Last',
    min: 'Min',
    max: 'Max',
    count: 'Count',
    avg: 'Average',
};
class ChartTranslationService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartTranslation';
    }
    translate(toTranslate) {
        const translate = this.getLocaleTextFunc();
        const defaultTranslation = exports.DEFAULT_CHART_TRANSLATIONS[toTranslate];
        return translate(toTranslate, defaultTranslation);
    }
}
exports.ChartTranslationService = ChartTranslationService;


/***/ }),

/***/ 1480:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flatMap = exports.partition = void 0;
function partition(items, selector) {
    return items.reduce((groupedItems, item) => {
        const key = selector(item);
        const existingItems = groupedItems.get(key);
        return groupedItems.set(key, existingItems ? [...existingItems, item] : [item]);
    }, new Map());
}
exports.partition = partition;
function flatMap(items, iteratee) {
    return items.reduce((acc, item, index, array) => acc.concat(iteratee(item, index, array)), new Array());
}
exports.flatMap = flatMap;


/***/ }),

/***/ 2753:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLegacyAxisType = exports.ALL_AXIS_TYPES = void 0;
exports.ALL_AXIS_TYPES = ['number', 'category', 'grouped-category', 'log', 'time'];
function getLegacyAxisType(chartType) {
    switch (chartType) {
        case 'bar':
        case 'stackedBar':
        case 'normalizedBar':
            return ['number', 'category'];
        case 'groupedBar':
            return ['number', 'grouped-category'];
        case 'column':
        case 'stackedColumn':
        case 'normalizedColumn':
        case 'line':
        case 'stackedLine':
        case 'normalizedLine':
        case 'area':
        case 'stackedArea':
        case 'normalizedArea':
        case 'histogram':
            return ['category', 'number'];
        case 'groupedColumn':
            return ['grouped-category', 'number'];
        case 'scatter':
        case 'bubble':
            return ['number', 'number'];
        default:
            return undefined;
    }
}
exports.getLegacyAxisType = getLegacyAxisType;


/***/ }),

/***/ 8889:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCreateParams = exports.validateUpdateParams = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const seriesTypeMapper_1 = __webpack_require__(4237);
const validateIfDefined = (validationFn) => {
    return (value) => {
        if (value == undefined)
            return true;
        return validationFn(value);
    };
};
const isString = (value) => typeof value === 'string';
const isBoolean = (value) => typeof value === 'boolean';
const isValidSeriesChartType = (value) => typeof value === 'object';
const createWarnMessage = (property, expectedType) => (value) => `AG Grid - unable to update chart as invalid params supplied:  \`${property}: ${value}\`, expected ${expectedType}.`;
const createEnterpriseMessage = (feature) => {
    const url = 'https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/';
    return `${feature} is not supported in AG Charts Community ('ag-charts-enterprise' hasn't been loaded). See ${url} for more details.`;
};
const legacyChartTypes = ['doughnut'];
const baseUpdateChartParams = [
    'type',
    'chartId',
    'chartType',
    'chartThemeName',
    'chartThemeOverrides',
    'unlinkChart',
];
function isValidChartType(value) {
    return !!(0, seriesTypeMapper_1.getSeriesTypeIfExists)(value) || (0, seriesTypeMapper_1.isComboChart)(value);
}
function isLegacyChartType(value) {
    return legacyChartTypes.includes(value);
}
const validateChartType = validateIfDefined((chartType) => {
    if (isValidChartType(chartType))
        return true;
    if (isLegacyChartType(chartType)) {
        const renamedChartType = (0, seriesTypeMapper_1.getCanonicalChartType)(chartType);
        (0, ag_grid_community_1._warnOnce)(`The chart type '${chartType}' has been deprecated. Please use '${renamedChartType}' instead.`);
        return renamedChartType;
    }
    return false;
});
const validateAgChartThemeOverrides = validateIfDefined((themeOverrides) => {
    // ensure supplied AgChartThemeOverrides is an object - can be improved if necessary?
    return typeof themeOverrides === 'object';
});
const validateChartParamsCellRange = validateIfDefined((cellRange) => {
    // ensure supplied ChartParamsCellRange is an object - can be improved if necessary?
    return typeof cellRange === 'object';
});
const validateAggFunc = validateIfDefined((aggFunc) => {
    // ensure supplied aggFunc is a `string` or `function` - can be improved if necessary?
    return typeof aggFunc === 'string' || typeof aggFunc === 'function';
});
const enterpriseChartTypeValidation = (isEnterprise) => ({
    property: 'chartType',
    validationFn: validateIfDefined((chartType) => isEnterprise || !chartType || !(0, seriesTypeMapper_1.isEnterpriseChartType)(chartType)),
    warnMessage: (chartType) => createEnterpriseMessage(`The '${chartType}' chart type`),
});
const switchCategorySeriesValidation = (isEnterprise) => ({
    property: 'switchCategorySeries',
    validationFn: validateIfDefined((switchCategorySeries) => {
        if (!switchCategorySeries || isEnterprise) {
            return true;
        }
        return undefined;
    }),
    warnMessage: () => createEnterpriseMessage(`'switchCategorySeries' has been ignored as it`),
    warnIfFixed: true,
});
const commonUpdateValidations = () => [
    { property: 'chartId', validationFn: isString, warnMessage: createWarnMessage('chartId', 'string') },
    {
        property: 'chartType',
        validationFn: validateChartType,
        warnMessage: createWarnMessage('chartType', 'ChartType'),
    },
    {
        property: 'chartThemeName',
        validationFn: isString,
        warnMessage: createWarnMessage('chartThemeName', 'string'),
    },
    {
        property: 'chartThemeOverrides',
        validationFn: validateAgChartThemeOverrides,
        warnMessage: createWarnMessage('chartThemeOverrides', 'AgChartThemeOverrides'),
    },
    { property: 'unlinkChart', validationFn: isBoolean, warnMessage: createWarnMessage('unlinkChart', 'boolean') },
];
const cellRangeValidations = (isEnterprise) => [
    {
        property: 'cellRange',
        validationFn: validateChartParamsCellRange,
        warnMessage: createWarnMessage('cellRange', 'ChartParamsCellRange'),
    },
    {
        property: 'suppressChartRanges',
        validationFn: isBoolean,
        warnMessage: createWarnMessage('suppressChartRanges', 'boolean'),
    },
    {
        property: 'aggFunc',
        validationFn: validateAggFunc,
        warnMessage: createWarnMessage('aggFunc', 'string or IAggFunc'),
    },
    switchCategorySeriesValidation(isEnterprise),
];
function validateUpdateParams(params, isEnterprise) {
    const paramsToValidate = params;
    switch (paramsToValidate.type) {
        case 'rangeChartUpdate':
            return validateUpdateRangeChartParams(params, isEnterprise);
        case 'pivotChartUpdate':
            return validateUpdatePivotChartParams(params);
        case 'crossFilterChartUpdate':
            return validateUpdateCrossFilterChartParams(params, isEnterprise);
        default:
            (0, ag_grid_community_1._warnOnce)(`Invalid value supplied for 'type': ${params.type}. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`);
            return false;
    }
}
exports.validateUpdateParams = validateUpdateParams;
function validateCreateParams(params, isEnterprise) {
    return validateProperties(params, [
        enterpriseChartTypeValidation(isEnterprise),
        switchCategorySeriesValidation(isEnterprise),
    ]);
}
exports.validateCreateParams = validateCreateParams;
function validateUpdateRangeChartParams(params, isEnterprise) {
    const validations = [
        ...commonUpdateValidations(),
        enterpriseChartTypeValidation(isEnterprise),
        ...cellRangeValidations(isEnterprise),
        {
            property: 'seriesChartTypes',
            validationFn: (value) => value === undefined || (Array.isArray(value) && value.every(isValidSeriesChartType)),
            warnMessage: createWarnMessage('seriesChartTypes', 'Array of SeriesChartType'),
        },
    ];
    return validateProperties(params, validations, [
        ...baseUpdateChartParams,
        'cellRange',
        'suppressChartRanges',
        'switchCategorySeries',
        'aggFunc',
        'seriesChartTypes',
        'seriesGroupType',
    ], 'UpdateRangeChartParams');
}
function validateUpdatePivotChartParams(params) {
    const validations = [...commonUpdateValidations()];
    return validateProperties(params, validations, [...baseUpdateChartParams], 'UpdatePivotChartParams');
}
function validateUpdateCrossFilterChartParams(params, isEnterprise) {
    const validations = [
        ...commonUpdateValidations(),
        ...cellRangeValidations(isEnterprise),
    ];
    return validateProperties(params, validations, [...baseUpdateChartParams, 'cellRange', 'suppressChartRanges', 'aggFunc'], 'UpdateCrossFilterChartParams');
}
function validateProperties(params, validations, validPropertyNames, paramsType) {
    let validatedProperties = undefined;
    for (const validation of validations) {
        const { property, validationFn, warnMessage, warnIfFixed } = validation;
        if (property in params) {
            const value = params[property];
            const validationResult = validationFn(value);
            if (validationResult === true)
                continue;
            if (validationResult === false) {
                (0, ag_grid_community_1._warnOnce)(warnMessage(value));
                return false;
            }
            // If the validation function returned a 'fix' value, we need to return an updated property set.
            // First we clone the input set if there has not been a 'fix' encountered in a previous iteration:
            validatedProperties = validatedProperties || { ...params };
            /// Then we update the cloned object with the 'fixed' value
            validatedProperties[property] = validationResult;
            if (warnIfFixed) {
                (0, ag_grid_community_1._warnOnce)(warnMessage(value));
            }
        }
    }
    if (validPropertyNames) {
        // Check for unexpected properties
        for (const property of Object.keys(params)) {
            if (!validPropertyNames.includes(property)) {
                (0, ag_grid_community_1._warnOnce)(`Unexpected property supplied. ${paramsType} does not contain: \`${property}\`.`);
                return false;
            }
        }
    }
    // If one or more 'fixed' values were encountered, return the updated property set
    if (validatedProperties)
        return validatedProperties;
    return true;
}


/***/ }),

/***/ 3610:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToRGBA = void 0;
function hexToRGBA(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return alpha ? `rgba(${r}, ${g}, ${b}, ${alpha})` : `rgba(${r}, ${g}, ${b})`;
}
exports.hexToRGBA = hexToRGBA;


/***/ }),

/***/ 9687:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deproxy = void 0;
function deproxy(chartOrProxy) {
    if (chartOrProxy.chart != null) {
        return chartOrProxy.chart;
    }
    return chartOrProxy;
}
exports.deproxy = deproxy;


/***/ }),

/***/ 2210:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.set = exports.get = void 0;
function get(source, expression, defaultValue) {
    if (source == null) {
        return defaultValue;
    }
    const keys = expression.split('.');
    let objectToRead = source;
    while (keys.length > 1) {
        objectToRead = objectToRead[keys.shift()];
        if (objectToRead == null) {
            return defaultValue;
        }
    }
    const value = objectToRead[keys[0]];
    return value != null ? value : defaultValue;
}
exports.get = get;
function set(target, expression, value) {
    if (target == null) {
        return;
    }
    const keys = expression.split('.');
    let objectToUpdate = target;
    // Create empty objects
    keys.forEach((key, i) => {
        if (!objectToUpdate[key]) {
            objectToUpdate[key] = {};
        }
        if (i < keys.length - 1) {
            objectToUpdate = objectToUpdate[key];
        }
    });
    objectToUpdate[keys[keys.length - 1]] = value;
}
exports.set = set;


/***/ }),

/***/ 4237:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFullChartNameTranslationKey = exports.canSwitchDirection = exports.supportsInvertedCategorySeries = exports.getMaxNumSeries = exports.getMaxNumCategories = exports.isPieChartSeries = exports.getSeriesType = exports.getSeriesTypeIfExists = exports.getCanonicalChartType = exports.isHierarchical = exports.isRadial = exports.isPolar = exports.isCartesian = exports.isStacked = exports.isEnterpriseChartType = exports.isComboChart = exports.isSeriesType = exports.SERIES_GROUP_TYPES = void 0;
const CHART_TYPE_TO_SERIES_TYPE = {
    column: 'bar',
    groupedColumn: 'bar',
    stackedColumn: 'bar',
    normalizedColumn: 'bar',
    bar: 'bar',
    groupedBar: 'bar',
    stackedBar: 'bar',
    normalizedBar: 'bar',
    line: 'line',
    stackedLine: 'line',
    normalizedLine: 'line',
    scatter: 'scatter',
    bubble: 'bubble',
    pie: 'pie',
    donut: 'donut',
    doughnut: 'donut',
    area: 'area',
    stackedArea: 'area',
    normalizedArea: 'area',
    histogram: 'histogram',
    radarLine: 'radar-line',
    radarArea: 'radar-area',
    nightingale: 'nightingale',
    radialColumn: 'radial-column',
    radialBar: 'radial-bar',
    sunburst: 'sunburst',
    rangeBar: 'range-bar',
    rangeArea: 'range-area',
    boxPlot: 'box-plot',
    treemap: 'treemap',
    heatmap: 'heatmap',
    waterfall: 'waterfall',
};
const COMBO_CHART_TYPES = new Set(['columnLineCombo', 'areaColumnCombo', 'customCombo']);
exports.SERIES_GROUP_TYPES = ['grouped', 'stacked', 'normalized'];
const SERIES_TYPES = {
    area: {
        isCartesian: true,
        canInvert: true,
    },
    bar: {
        isCartesian: true,
        canInvert: true,
    },
    histogram: {
        isCartesian: true,
    },
    line: {
        isCartesian: true,
        canInvert: true,
    },
    pie: {
        isPie: true,
    },
    donut: {
        isPie: true,
        canInvert: true,
    },
    scatter: {
        isCartesian: true,
    },
    bubble: {
        isCartesian: true,
    },
    'radial-column': {
        isPolar: true,
        isEnterprise: true,
        isRadial: true,
        canInvert: true,
    },
    'radial-bar': {
        isPolar: true,
        isEnterprise: true,
        isRadial: true,
        canInvert: true,
    },
    'radar-line': {
        isPolar: true,
        isEnterprise: true,
        canInvert: true,
    },
    'radar-area': {
        isPolar: true,
        isEnterprise: true,
        canInvert: true,
    },
    nightingale: {
        isPolar: true,
        isEnterprise: true,
        canInvert: true,
    },
    'range-bar': {
        isCartesian: true,
        isEnterprise: true,
        canSwitchDirection: true,
    },
    'range-area': {
        isCartesian: true,
        isEnterprise: true,
    },
    'box-plot': {
        isCartesian: true,
        isEnterprise: true,
        canSwitchDirection: true,
    },
    treemap: {
        isEnterprise: true,
        isHierarchical: true,
    },
    sunburst: {
        isEnterprise: true,
        isHierarchical: true,
    },
    heatmap: {
        isCartesian: true,
        isEnterprise: true,
    },
    waterfall: {
        isCartesian: true,
        isEnterprise: true,
        canSwitchDirection: true,
    },
};
function isSeriesType(seriesType) {
    return !!SERIES_TYPES[seriesType];
}
exports.isSeriesType = isSeriesType;
function isComboChart(chartType) {
    return COMBO_CHART_TYPES.has(chartType);
}
exports.isComboChart = isComboChart;
function doesSeriesHaveProperty(seriesType, prop) {
    return !!SERIES_TYPES[seriesType]?.[prop];
}
function isEnterpriseChartType(chartType) {
    return doesSeriesHaveProperty(getSeriesType(chartType), 'isEnterprise');
}
exports.isEnterpriseChartType = isEnterpriseChartType;
const stackedChartTypes = new Set(['stackedColumn', 'normalizedColumn', 'stackedBar', 'normalizedBar']);
function isStacked(chartType) {
    return stackedChartTypes.has(chartType);
}
exports.isStacked = isStacked;
function isCartesian(seriesType) {
    return doesSeriesHaveProperty(seriesType, 'isCartesian');
}
exports.isCartesian = isCartesian;
function isPolar(seriesType) {
    return doesSeriesHaveProperty(seriesType, 'isPolar');
}
exports.isPolar = isPolar;
function isRadial(seriesType) {
    return doesSeriesHaveProperty(seriesType, 'isRadial');
}
exports.isRadial = isRadial;
function isHierarchical(seriesType) {
    return doesSeriesHaveProperty(seriesType, 'isHierarchical');
}
exports.isHierarchical = isHierarchical;
function getCanonicalChartType(chartType) {
    return chartType === 'doughnut' ? 'donut' : chartType;
}
exports.getCanonicalChartType = getCanonicalChartType;
function getSeriesTypeIfExists(chartType) {
    return CHART_TYPE_TO_SERIES_TYPE[chartType];
}
exports.getSeriesTypeIfExists = getSeriesTypeIfExists;
function getSeriesType(chartType) {
    return getSeriesTypeIfExists(chartType) ?? 'line';
}
exports.getSeriesType = getSeriesType;
function isPieChartSeries(seriesType) {
    return doesSeriesHaveProperty(seriesType, 'isPie');
}
exports.isPieChartSeries = isPieChartSeries;
function canOnlyHaveSingleSeries(chartType) {
    return chartType === 'pie' || chartType === 'waterfall' || chartType === 'histogram';
}
function getMaxNumCategories(chartType) {
    return isHierarchical(getSeriesType(chartType)) ? undefined : 1;
}
exports.getMaxNumCategories = getMaxNumCategories;
function getMaxNumSeries(chartType) {
    if (isHierarchical(getSeriesType(chartType))) {
        return 2;
    }
    else if (canOnlyHaveSingleSeries(chartType)) {
        return 1;
    }
    else {
        return undefined;
    }
}
exports.getMaxNumSeries = getMaxNumSeries;
function supportsInvertedCategorySeries(chartType) {
    return !isComboChart(chartType) && doesSeriesHaveProperty(getSeriesType(chartType), 'canInvert');
}
exports.supportsInvertedCategorySeries = supportsInvertedCategorySeries;
function canSwitchDirection(chartType) {
    return doesSeriesHaveProperty(getSeriesType(chartType), 'canSwitchDirection');
}
exports.canSwitchDirection = canSwitchDirection;
function getFullChartNameTranslationKey(chartType) {
    switch (chartType) {
        case 'groupedColumn':
        case 'stackedColumn':
        case 'normalizedColumn':
        case 'groupedBar':
        case 'stackedBar':
        case 'normalizedBar':
        case 'stackedLine':
        case 'normalizedLine':
        case 'stackedArea':
        case 'normalizedArea':
            return `${chartType}Full`;
        case 'doughnut':
            return 'donut';
        case 'areaColumnCombo':
            return 'AreaColumnCombo';
        default:
            return chartType;
    }
}
exports.getFullChartNameTranslationKey = getFullChartNameTranslationKey;


/***/ }),

/***/ 6476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.heuristicVersionDetection = exports.upgradeChartModel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const version_1 = __webpack_require__(7205);
const axisTypeMapper_1 = __webpack_require__(2753);
const seriesTypeMapper_1 = __webpack_require__(4237);
const DEBUG = false;
function upgradeChartModel(model) {
    const originalVersion = model.version;
    if (model.version == null) {
        // Try to guess the version so we can apply the right subset of migrations.
        model.version = heuristicVersionDetection(model);
    }
    model = migrateIfBefore('23.0.0', model, migrateV23);
    model = migrateIfBefore('24.0.0', model, migrateV24);
    model = migrateIfBefore('25.1.0', model, migrateV25_1);
    model = migrateIfBefore('26.0.0', model, migrateV26);
    model = migrateIfBefore('26.1.0', model, migrateV26_1);
    // Switch from iChartOptions to iAgChartOptions....
    model = migrateIfBefore('26.2.0', model, migrateV26_2);
    model = migrateIfBefore('28.0.0', model, migrateV28);
    model = migrateIfBefore('28.2.0', model, migrateV28_2);
    model = migrateIfBefore('29.0.0', model, migrateV29);
    model = migrateIfBefore('29.1.0', model, migrateV29_1);
    model = migrateIfBefore('29.2.0', model, migrateV29_2);
    model = migrateIfBefore('30.0.0', model, migrateV30);
    model = migrateIfBefore('31.0.0', model, migrateV31);
    model = migrateIfBefore('32.0.0', model, migrateV32);
    model = migrateIfBefore('33.0.0', model, migrateV33);
    model = cleanup(model);
    // Bump version to latest.
    model = migrateIfBefore(version_1.VERSION, model, (m) => m);
    if (DEBUG && originalVersion !== model.version) {
        // eslint-disable-next-line no-console
        console.log('AG Grid: ChartModel migration complete', { model });
    }
    return model;
}
exports.upgradeChartModel = upgradeChartModel;
function migrateV23(model) {
    // https://github.com/ag-grid/ag-grid/commit/76c6744ff2b732d298d1ade73c122188854b5bac
    model = jsonRename('chartOptions.legend.item.marker.type', 'shape', model);
    model = jsonRename('chartOptions.seriesDefaults.marker.type', 'shape', model);
    // https://github.com/ag-grid/ag-grid/commit/7bdf2cfd666acda758a818733a9f9cb35ac1d7a7
    model = jsonRename('chartOptions.legend.padding', 'spacing', model);
    return model;
}
function migrateV24(model) {
    // https://github.com/ag-grid/ag-grid/commit/f4e854e3dc459400fa00e6da2873cb8e9cfff6fe#
    model = jsonDelete('chartOptions.seriesDefaults.marker.minSize', model);
    const { chartType, chartPalette, // Migrate.
    chartOptions: { xAxis, yAxis, ...chartOptions }, ...chartModel } = model;
    const axesTypes = (0, axisTypeMapper_1.getLegacyAxisType)(chartType);
    const axes = axesTypes?.map((type, i) => ({
        type,
        ...(i === 0 ? xAxis : yAxis),
    }));
    // Precise legacy palette fills/strokes can be found here for future reference:
    // https://github.com/ag-grid/ag-grid/blob/b22.1.0/grid-enterprise-modules/charts/src/charts/chart/palettes.ts
    const LEGACY_PALETTES = {
        borneo: 'ag-default',
        material: 'ag-material',
        bright: 'ag-vivid',
    };
    return {
        chartType,
        chartThemeName: LEGACY_PALETTES[chartPalette] ?? 'ag-default',
        chartOptions: {
            ...chartOptions,
            axes,
            xAxis,
            yAxis,
        },
        ...chartModel,
    };
}
function migrateV25_1(model) {
    // https://github.com/ag-grid/ag-grid/commit/61943f9fecbfb5ac1b9a1fd93788f9fdd8687181
    model = jsonRename('chartOptions.seriesDefaults.label.minRequiredAngle', 'minAngle', model);
    return model;
}
function migrateV26(model) {
    // https://github.com/ag-grid/ag-grid/commit/df2445d88e64cb4e831d6163104a0fa60ccde3b5
    const highlightOptUpdate = ({ dimOpacity, ...opts }) => ({
        ...opts,
        ...(dimOpacity != null ? { series: { dimOpacity } } : {}),
    });
    model = jsonMutate('chartOptions.seriesDefaults.highlightStyle', model, highlightOptUpdate);
    // https://github.com/ag-grid/ag-grid/commit/f4e854e3dc459400fa00e6da2873cb8e9cfff6fe#
    model = jsonDelete('chart', model);
    model = jsonDelete('chartOptions.seriesDefaults.tooltipClass', model);
    model = jsonDelete('chartOptions.seriesDefaults.tooltipTracking', model);
    // Cleanup label.rotation === 0, which was treated as 'use the default' on reload prior to 26.
    model = jsonDeleteDefault('chartOptions.axes[].label.rotation', 0, model);
    model = jsonDeleteDefault('chartOptions.axes[].label.rotation', 335, model);
    return model;
}
function migrateV26_1(model) {
    // https://github.com/ag-grid/ag-grid/commit/df2445d88e64cb4e831d6163104a0fa60ccde3b5
    const highlightOptUpdate = ({ item, series, ...opts }) => ({
        item: { ...opts, ...item },
        ...(series ? { series } : {}),
    });
    model = jsonMutate('chartOptions.seriesDefaults.highlightStyle', model, highlightOptUpdate);
    model = jsonMutate('chartOptions.series[].highlightStyle', model, highlightOptUpdate);
    return model;
}
function migrateV26_2(model) {
    // https://github.com/ag-grid/ag-grid/commit/8b2e223cb1a687cb6c1d70b9f75f52fa29d00341
    model = jsonMove('chartOptions.seriesDefaults.fill.opacity', 'chartOptions.seriesDefaults.fillOpacity', model);
    model = jsonMove('chartOptions.seriesDefaults.stroke.opacity', 'chartOptions.seriesDefaults.strokeOpacity', model);
    model = jsonMove('chartOptions.seriesDefaults.stroke.width', 'chartOptions.seriesDefaults.strokeWidth', model);
    model = jsonDelete('chartOptions.seriesDefaults.fill', model);
    model = jsonDelete('chartOptions.seriesDefaults.stroke', model);
    model = jsonDelete('chartOptions.seriesDefaults.callout.colors', model);
    model = jsonDelete('chartOptions.xAxis', model);
    model = jsonDelete('chartOptions.yAxis', model);
    const { chartType: providedChartType, 
    // disable no-unused-vars because `series` is required here, even though
    // unused, because it serves to take the `series` key out of otherChartOptions
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    chartOptions: { axes, series, seriesDefaults, ...otherChartOptions }, ...otherModelProps } = model;
    // At 26.2.0 combination charts weren't supported, so we can safely assume a single series type.
    // We can't rely on the `series.type` field as it was incorrect (in v25.0.0 line chart has an
    // `area` series).
    // Note that in v31.1.0, the canonical name for the 'doughnut' chart type changed to 'donut'.
    const chartType = (0, seriesTypeMapper_1.getCanonicalChartType)(providedChartType);
    const seriesType = (0, seriesTypeMapper_1.getSeriesType)(chartType);
    const seriesTypes = [seriesType];
    const chartTypeMixin = {};
    if (!(0, seriesTypeMapper_1.isPieChartSeries)(seriesType)) {
        const minimalAxis = { top: {}, bottom: {}, left: {}, right: {} };
        const updatedAxes = axes
            .map(({ type, ...axisProps }) => ({
            [type]: { ...minimalAxis, ...axisProps },
        }))
            .reduce(merge, {});
        axisTypeMapper_1.ALL_AXIS_TYPES.filter((v) => updatedAxes[v] == null).forEach((v) => {
            updatedAxes[v] = { ...minimalAxis };
        });
        chartTypeMixin.axes = updatedAxes;
    }
    const updatedChartOptions = seriesTypes
        .map((t) => ({
        [t]: {
            ...chartTypeMixin,
            series: seriesDefaults,
            ...otherChartOptions,
        },
    }))
        .reduce(merge, {});
    model = {
        ...otherModelProps,
        chartType,
        chartOptions: updatedChartOptions,
    };
    return model;
}
function migrateV28(model) {
    model = jsonDelete('chartOptions.*.title.padding', model);
    model = jsonDelete('chartOptions.*.subtitle.padding', model);
    model = jsonDelete('chartOptions.*.axes.*.title.padding', model);
    model = jsonBackfill('chartOptions.*.axes.*.title.enabled', false, model);
    return model;
}
function migrateV28_2(model) {
    model = jsonRename('chartOptions.pie.series.callout', 'calloutLine', model);
    model = jsonRename('chartOptions.pie.series.label', 'calloutLabel', model);
    model = jsonRename('chartOptions.pie.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.pie.series.labelName', 'sectorLabelName', model);
    model = jsonRename('chartOptions.donut.series.callout', 'calloutLine', model);
    model = jsonRename('chartOptions.donut.series.label', 'calloutLabel', model);
    model = jsonRename('chartOptions.donut.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.donut.series.labelName', 'sectorLabelName', model);
    // series.yKeys => yKey ?
    // series.yNames => yName ?
    return model;
}
function migrateV29(model) {
    model = jsonMoveIfMissing('chartOptions.scatter.series.fill', 'chartOptions.scatter.series.marker.fill', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.fillOpacity', 'chartOptions.scatter.series.marker.fillOpacity', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.stroke', 'chartOptions.scatter.series.marker.stroke', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.strokeOpacity', 'chartOptions.scatter.series.marker.strokeOpacity', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.strokeWidth', 'chartOptions.scatter.series.marker.strokeWidth', model);
    model = jsonMove('chartOptions.scatter.series.paired', 'chartOptions.scatter.paired', model);
    return model;
}
function migrateV29_1(model) {
    model = jsonDelete('chartOptions.axes[].tick.count', model);
    return model;
}
function migrateV29_2(model) {
    // https://github.com/ag-grid/ag-grid/commit/ce11956492e42e845932edb4e05d7b0b21db5c61
    const tooltipOptUpdate = ({ tracking, ...opts }) => {
        const output = { ...opts };
        if (tracking === false) {
            output.position ?? (output.position = { type: 'pointer' });
            output.range ?? (output.range = 'nearest');
        }
        else if (tracking === true) {
            output.position ?? (output.position = { type: 'node' });
            output.range ?? (output.range = 'nearest');
        }
        return output;
    };
    model = jsonMutate('chartOptions.*.tooltip', model, tooltipOptUpdate);
    return model;
}
function migrateV30(model) {
    // Repeated from migrateV28_2() as they were applied retrospectively for the v30 release.
    model = jsonRename('chartOptions.pie.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.pie.series.labelName', 'sectorLabelName', model);
    // Late-applied migrations for deprecations in the 29.x.y range.
    model = migrateV29_1(model);
    model = migrateV29_2(model);
    // Actual v30 changes.
    model = jsonDelete('chartOptions.*.series.flipXY', model);
    model = jsonAdd('chartOptions.common.legend.enabled', true, model);
    model = jsonBackfill('chartOptions.common.legend.position', 'right', model);
    return model;
}
function migrateV31(model) {
    const V30_LEGACY_PALETTES = {
        'ag-pastel': 'ag-sheets',
        'ag-solar': 'ag-polychroma',
    };
    const updatedModel = jsonRename('chartOptions.column', 'bar', model);
    const chartThemeName = V30_LEGACY_PALETTES[updatedModel.chartThemeName] || updatedModel.chartThemeName;
    return {
        ...updatedModel,
        chartThemeName,
    };
}
function migrateV32(model) {
    model = jsonMutateProperty('chartOptions.*.autoSize', true, model, (parent, targetProp) => {
        if (parent[targetProp] === true) {
            // autoSize: true was the OOB default, so just use the new OOB default baked-in.
        }
        else if (parent[targetProp] === false) {
            // Fallback to legacy Charts defaults for autoSize: false.
            parent['minHeight'] = 600;
            parent['minWidth'] = 300;
        }
        delete parent[targetProp];
    });
    return model;
}
function migrateV33(model) {
    model = jsonDelete('chartOptions.*.axes.category.label.format', model);
    model = jsonDelete('chartOptions.*.axes.category.crosshair.label.format', model);
    model = jsonDelete('chartOptions.*.axes.angle-category.label.format', model);
    model = jsonDelete('chartOptions.*.axes.radius-category.label.format', model);
    model = jsonRename('chartOptions.*.axes.*.label.padding', 'spacing', model);
    model = jsonRename('chartOptions.*.navigator.miniChart.label.padding', 'spacing', model);
    model = jsonDelete('chartOptions.*.axes.*.crossLines.label.className', model);
    model = jsonMutateProperty('chartOptions.*.axes.*.crossLines.label.position', true, model, (parent, targetProp) => {
        if (typeof parent[targetProp] === 'string') {
            parent[targetProp] = parent[targetProp].replace(/([A-Z])/, '-$1').toLowerCase();
        }
    });
    model = jsonDelete('chartOptions.bullet', model);
    model = jsonRenameEnumValues('chartOptions.bar.series.label.placement', model, {
        inside: 'inside-center',
        outside: 'inside-end',
    });
    model = jsonRenameEnumValues('chartOptions.waterfall.series.item.*.label.placement', model, {
        inside: 'inside-center',
        start: 'outside-start',
        end: 'outside-end',
    });
    model = jsonDelete('chartOptions.*.navigator.min', model);
    model = jsonDelete('chartOptions.*.navigator.max', model);
    model = jsonDelete('chartOptions.*.zoom.ratioX', model);
    model = jsonDelete('chartOptions.*.zoom.ratioY', model);
    model = jsonDelete('chartOptions.*.zoom.rangeX', model);
    model = jsonDelete('chartOptions.*.zoom.rangeY', model);
    return model;
}
function cleanup(model) {
    // Remove fixed width/height - this has never been supported via UI configuration.
    model = jsonDelete('chartOptions.*.width', model);
    model = jsonDelete('chartOptions.*.height', model);
    model = jsonBackfill('chartOptions.*.axes.category.label.autoRotate', true, model);
    return model;
}
function heuristicVersionDetection(model) {
    const modelAny = model;
    if (model.version != null) {
        return model.version;
    }
    const hasKey = (obj, ...keys) => {
        return Object.keys(obj || {}).some((k) => keys.includes(k));
    };
    const chartOptions = modelAny.chartOptions;
    const seriesOptions = hasKey(chartOptions, 'seriesDefaults')
        ? chartOptions?.seriesDefaults
        : chartOptions?.[Object.keys(chartOptions)[0]];
    const hints = {
        '27.0.0': hasKey(modelAny, 'seriesChartTypes'),
        '26.2.0': !hasKey(chartOptions, 'seriesDefaults'),
        '26.1.0': hasKey(seriesOptions?.highlightStyle, 'item'),
        '26.0.0': hasKey(seriesOptions?.highlightStyle, 'series'),
        // '26.0.0': modelAny.chart === undefined,
        '25.1.0': hasKey(seriesOptions?.label, 'minAngle'),
        '25.0.0': hasKey(modelAny, 'modelType', 'aggFunc', 'unlinkChart', 'suppressChartRanges') ||
            hasKey(seriesOptions, 'lineDash', 'lineDashOffset'),
        '24.0.0': hasKey(modelAny, 'chartThemeName', 'chart') || hasKey(chartOptions, 'series'),
        '23.2.0': hasKey(chartOptions, 'navigator'),
        '23.0.0': hasKey(chartOptions?.legend?.item?.marker, 'shape'),
        '22.1.0': hasKey(modelAny, 'chartPalette', 'chartType'),
    };
    // Default to 27.1.0, the last version before we added `version`.
    const defaultVersion = '27.1.0';
    const matchingHints = Object.entries(hints).filter(([_, match]) => match);
    // eslint-disable-next-line no-console
    if (DEBUG)
        console.log('AG Grid: ChartModel migration', { heuristicVersionCandidates: matchingHints });
    const [heuristicVersion = defaultVersion] = matchingHints[0];
    // eslint-disable-next-line no-console
    if (DEBUG)
        console.log('AG Grid: ChartModel migration', { heuristicVersion });
    return heuristicVersion;
}
exports.heuristicVersionDetection = heuristicVersionDetection;
function migrateIfBefore(maxVersion, model, migration) {
    if (versionNumber(maxVersion) > versionNumber(model.version)) {
        // eslint-disable-next-line no-console
        if (DEBUG)
            console.log('AG Grid: ChartModel migration', { migratingTo: maxVersion });
        const result = migration(model);
        result.version = maxVersion;
        // eslint-disable-next-line no-console
        if (DEBUG)
            console.log('AG Grid: ChartModel migration', { migratedTo: maxVersion, result });
        return result;
    }
    return model;
}
function versionParts(versionRaw) {
    const version = versionRaw.includes('-beta') ? versionRaw.replace(/-beta.*/, '') : versionRaw;
    const split = typeof version === 'string' ? version.split('.').map((v) => Number(v)) : [];
    if (split.length !== 3 || split.some((v) => isNaN(v))) {
        throw new Error((0, ag_grid_community_1._errMsg)(253, { version }));
    }
    return {
        major: split[0],
        minor: split[1],
        patch: split[2],
    };
}
function versionNumber(version) {
    const { major, minor, patch } = versionParts(version);
    // Return a number of the form MMmmPP.
    return major * 10000 + minor * 100 + patch;
}
function jsonDeleteDefault(path, defaultValue, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => {
        if (parent[prop] === defaultValue) {
            delete parent[prop];
        }
    });
}
function jsonBackfill(path, defaultValue, json) {
    return jsonMutateProperty(path, false, json, (parent, prop) => {
        if (parent[prop] == null) {
            parent[prop] = defaultValue;
        }
    });
}
function jsonAdd(path, value, json) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    const nextPath = path[0];
    if (path.length > 1) {
        json[nextPath] = jsonAdd(path.slice(1), value, json[nextPath] ?? {});
    }
    const hasProperty = Object.keys(json).includes(nextPath);
    if (!hasProperty) {
        json[nextPath] = value;
    }
    return json;
}
function jsonMove(from, to, json) {
    let valueToMove = undefined;
    let valueFound = false;
    json = jsonMutateProperty(from, true, json, (parent, prop) => {
        valueFound = true;
        valueToMove = parent[prop];
        delete parent[prop];
    });
    if (!valueFound) {
        return json;
    }
    return jsonMutateProperty(to, false, json, (parent, prop) => {
        parent[prop] = valueToMove;
    });
}
function jsonMoveIfMissing(from, to, json) {
    let valueToMove = undefined;
    let valueFound = false;
    json = jsonMutateProperty(from, true, json, (parent, prop) => {
        valueFound = true;
        valueToMove = parent[prop];
        delete parent[prop];
    });
    if (!valueFound) {
        return json;
    }
    return jsonMutateProperty(to, false, json, (parent, prop) => {
        if (parent[prop] === undefined) {
            parent[prop] = valueToMove;
        }
    });
}
function jsonRename(path, renameTo, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => {
        parent[renameTo] = parent[prop];
        delete parent[prop];
    });
}
function jsonDelete(path, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => delete parent[prop]);
}
function jsonMutateProperty(path, skipMissing, json, mutator) {
    const pathElements = path instanceof Array ? path : path.split('.');
    const parentPathElements = pathElements.slice(0, pathElements.length - 1);
    const targetName = pathElements[pathElements.length - 1];
    return jsonMutate(parentPathElements, json, (parent) => {
        const hasProperty = Object.keys(parent).includes(targetName);
        if (skipMissing && !hasProperty) {
            return parent;
        }
        const result = { ...parent };
        mutator(result, targetName);
        return result;
    });
}
function jsonMutate(path, json, mutator) {
    const pathElements = path instanceof Array ? path : path.split('.');
    // Clone to avoid mutating original input.
    json = { ...json };
    if (pathElements.length === 0) {
        return mutator(json);
    }
    else if (pathElements[0].startsWith('{')) {
        const pathOptions = pathElements[0].substring(1, pathElements[0].lastIndexOf('}')).split(',');
        for (const pathOption of pathOptions) {
            if (json[pathOption] != null) {
                json[pathOption] = jsonMutate(pathElements.slice(1), json[pathOption], mutator);
            }
        }
    }
    else if (pathElements[0].endsWith('[]')) {
        const arrayName = pathElements[0].substring(0, path[0].indexOf('['));
        if (json[arrayName] instanceof Array) {
            json[arrayName] = json[arrayName].map((v) => jsonMutate(pathElements.slice(1), v, mutator));
        }
    }
    else if (pathElements[0] === '*') {
        for (const jsonProp of Object.keys(json)) {
            json[jsonProp] = jsonMutate(pathElements.slice(1), json[jsonProp], mutator);
        }
    }
    else if (json[pathElements[0]] != null) {
        json[pathElements[0]] = jsonMutate(pathElements.slice(1), json[pathElements[0]], mutator);
    }
    return json;
}
function jsonRenameEnumValues(path, json, values) {
    return jsonMutateProperty(path, true, json, (parent, targetProp) => {
        if (typeof parent[targetProp] === 'string') {
            parent[targetProp] = values[targetProp] ?? targetProp;
        }
    });
}
const merge = (r, n) => ({ ...r, ...n });


/***/ }),

/***/ 100:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const version_1 = __webpack_require__(7205);
const gridChartComp_1 = __webpack_require__(7760);
const chartParamsValidator_1 = __webpack_require__(8889);
const seriesTypeMapper_1 = __webpack_require__(4237);
const chartModelMigration_1 = __webpack_require__(6476);
class ChartService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartSvc';
        // we destroy all charts bound to this grid when grid is destroyed. activeCharts contains all charts, including
        // those in developer provided containers.
        this.activeCharts = new Set();
        this.activeChartComps = new Set();
        // this shared (singleton) context is used by cross filtering in line and area charts
        this.crossFilteringContext = {
            lastSelectedChartId: '',
        };
        this.isEnterprise = () => this.agChartsExports.isEnterprise;
    }
    wireBeans(beans) {
        this.visibleCols = beans.visibleCols;
        this.rangeSvc = beans.rangeSvc;
        this.agChartsExports = beans.agChartsExports;
    }
    updateChart(params) {
        if (this.activeChartComps.size === 0) {
            (0, ag_grid_community_1._warn)(124);
            return;
        }
        const chartComp = [...this.activeChartComps].find((chartComp) => chartComp.getChartId() === params.chartId);
        if (!chartComp) {
            (0, ag_grid_community_1._warn)(125, { chartId: params.chartId });
            return;
        }
        chartComp.update(params);
    }
    getChartModels() {
        const models = [];
        const versionedModel = (c) => {
            return { ...c, version: version_1.VERSION };
        };
        this.activeChartComps.forEach((c) => models.push(versionedModel(c.getChartModel())));
        return models;
    }
    getChartRef(chartId) {
        let chartRef;
        this.activeCharts.forEach((cr) => {
            if (cr.chartId === chartId) {
                chartRef = cr;
            }
        });
        return chartRef;
    }
    getChartComp(chartId) {
        let chartComp;
        this.activeChartComps.forEach((comp) => {
            if (comp.getChartId() === chartId) {
                chartComp = comp;
            }
        });
        return chartComp;
    }
    getChartImageDataURL(params) {
        let url;
        this.activeChartComps.forEach((c) => {
            if (c.getChartId() === params.chartId) {
                url = c.getChartImageDataURL(params.fileFormat);
            }
        });
        return url;
    }
    downloadChart(params) {
        const chartComp = Array.from(this.activeChartComps).find((c) => c.getChartId() === params.chartId);
        chartComp?.downloadChart(params.dimensions, params.fileName, params.fileFormat);
    }
    openChartToolPanel(params) {
        const chartComp = Array.from(this.activeChartComps).find((c) => c.getChartId() === params.chartId);
        chartComp?.openChartToolPanel(params.panel);
    }
    closeChartToolPanel(chartId) {
        const chartComp = Array.from(this.activeChartComps).find((c) => c.getChartId() === chartId);
        chartComp?.closeChartToolPanel();
    }
    createChartFromCurrentRange(chartType = 'groupedColumn', fromApi) {
        const cellRange = this.getSelectedRange();
        return this.createChart({ cellRange, chartType, focusDialogOnOpen: !fromApi });
    }
    restoreChart(model, chartContainer) {
        if (!model) {
            (0, ag_grid_community_1._warn)(126);
            return;
        }
        if (model.version !== version_1.VERSION) {
            model = (0, chartModelMigration_1.upgradeChartModel)(model);
        }
        let cellRange;
        let pivotChart;
        let suppressChartRanges;
        let chartPaletteToRestore;
        if (model.modelType === 'pivot') {
            // if required enter pivot mode
            this.gos.updateGridOptions({ options: { pivotMode: true }, source: 'pivotChart' });
            cellRange = this.createCellRange(undefined, true);
            pivotChart = true;
            suppressChartRanges = true;
        }
        else {
            cellRange = this.createCellRange(model.cellRange);
            chartPaletteToRestore = model.chartPalette;
            suppressChartRanges = model.suppressChartRanges;
        }
        if (!cellRange) {
            return;
        }
        return this.createChart({
            ...model,
            cellRange,
            pivotChart,
            suppressChartRanges,
            chartContainer,
            chartOptionsToRestore: model.chartOptions,
            chartPaletteToRestore,
        });
    }
    createRangeChart(params, fromApi) {
        const cellRange = this.createCellRange(params.cellRange);
        if (!cellRange) {
            return;
        }
        return this.createChart({
            ...params,
            cellRange,
            focusDialogOnOpen: !fromApi,
        });
    }
    createPivotChart(params, fromApi) {
        // if required enter pivot mode
        this.gos.updateGridOptions({ options: { pivotMode: true }, source: 'pivotChart' });
        const cellRange = this.createCellRange(undefined, true);
        if (!cellRange) {
            return;
        }
        return this.createChart({
            ...params,
            cellRange,
            pivotChart: true,
            suppressChartRanges: true,
            focusDialogOnOpen: !fromApi,
        });
    }
    createCrossFilterChart(params, fromApi) {
        const cellRange = this.createCellRange(params.cellRange);
        if (!cellRange) {
            return;
        }
        const suppressChartRangesSupplied = typeof params.suppressChartRanges !== 'undefined' && params.suppressChartRanges !== null;
        const suppressChartRanges = suppressChartRangesSupplied ? params.suppressChartRanges : true;
        return this.createChart({
            ...params,
            cellRange,
            suppressChartRanges,
            crossFiltering: true,
            focusDialogOnOpen: !fromApi,
        });
    }
    createChart(params) {
        const validationResult = (0, chartParamsValidator_1.validateCreateParams)(params, this.agChartsExports.isEnterprise);
        if (!validationResult) {
            return undefined;
        }
        params = validationResult === true ? params : validationResult;
        const { chartType, chartContainer } = params;
        const createChartContainerFunc = this.gos.getCallback('createChartContainer');
        const gridChartParams = {
            ...params,
            chartId: this.generateId(),
            chartType: (0, seriesTypeMapper_1.getCanonicalChartType)(chartType),
            insideDialog: !(chartContainer || createChartContainerFunc),
            crossFilteringContext: this.crossFilteringContext,
            crossFilteringResetCallback: () => this.activeChartComps.forEach((c) => c.crossFilteringReset()),
        };
        const chartComp = new gridChartComp_1.GridChartComp(gridChartParams);
        this.createBean(chartComp);
        const chartRef = this.createChartRef(chartComp);
        if (chartContainer) {
            // if container exists, means developer initiated chart create via API, so place in provided container
            chartContainer.appendChild(chartRef.chartElement);
        }
        else if (createChartContainerFunc) {
            // otherwise, user created chart via grid UI, check if developer provides containers (e.g. if the application
            // is using its own dialogs rather than the grid provided dialogs)
            createChartContainerFunc(chartRef);
        }
        else {
            // add listener to remove from active charts list when charts are destroyed, e.g. closing chart dialog
            chartComp.addEventListener('destroyed', () => {
                this.activeChartComps.delete(chartComp);
                this.activeCharts.delete(chartRef);
            });
        }
        return chartRef;
    }
    createChartRef(chartComp) {
        const chartRef = {
            destroyChart: () => {
                if (this.activeCharts.has(chartRef)) {
                    this.destroyBean(chartComp);
                    this.activeChartComps.delete(chartComp);
                    this.activeCharts.delete(chartRef);
                }
            },
            focusChart: () => {
                (0, ag_grid_community_1._focusInto)(chartComp.getGui());
            },
            chartElement: chartComp.getGui(),
            chart: chartComp.getUnderlyingChart(),
            chartId: chartComp.getChartModel().chartId,
        };
        this.activeCharts.add(chartRef);
        this.activeChartComps.add(chartComp);
        return chartRef;
    }
    getSelectedRange() {
        const ranges = this.rangeSvc?.getCellRanges() ?? [];
        return ranges.length > 0 ? ranges[0] : { columns: [] };
    }
    generateId() {
        return `id-${Math.random().toString(36).substring(2, 18)}`;
    }
    createCellRange(cellRangeParams, allRange) {
        const rangeParams = allRange
            ? {
                rowStartIndex: null,
                rowStartPinned: undefined,
                rowEndIndex: null,
                rowEndPinned: undefined,
                columns: this.visibleCols.allCols.map((col) => col.getColId()),
            }
            : cellRangeParams;
        const cellRange = rangeParams && this.rangeSvc?.createPartialCellRangeFromRangeParams(rangeParams, true);
        if (!cellRange) {
            (0, ag_grid_community_1._warn)(127, { allRange });
        }
        return cellRange;
    }
    destroy() {
        this.activeCharts.forEach((chart) => chart.destroyChart());
        super.destroy();
    }
}
exports.ChartService = ChartService;


/***/ }),

/***/ 4604:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.restoreChart = exports.updateChart = exports.createCrossFilterChart = exports.createPivotChart = exports.createRangeChart = exports.closeChartToolPanel = exports.openChartToolPanel = exports.downloadChart = exports.getChartImageDataURL = exports.getChartRef = exports.getChartModels = void 0;
function getChartModels(beans) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.getChartModels());
}
exports.getChartModels = getChartModels;
function getChartRef(beans, chartId) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.getChartRef(chartId));
}
exports.getChartRef = getChartRef;
function getChartImageDataURL(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.getChartImageDataURL(params));
}
exports.getChartImageDataURL = getChartImageDataURL;
function downloadChart(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.downloadChart(params));
}
exports.downloadChart = downloadChart;
function openChartToolPanel(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.openChartToolPanel(params));
}
exports.openChartToolPanel = openChartToolPanel;
function closeChartToolPanel(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.closeChartToolPanel(params.chartId));
}
exports.closeChartToolPanel = closeChartToolPanel;
function createRangeChart(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.createRangeChart(params, true));
}
exports.createRangeChart = createRangeChart;
function createPivotChart(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.createPivotChart(params, true));
}
exports.createPivotChart = createPivotChart;
function createCrossFilterChart(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.createCrossFilterChart(params, true));
}
exports.createCrossFilterChart = createCrossFilterChart;
function updateChart(beans, params) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.updateChart(params));
}
exports.updateChart = updateChart;
function restoreChart(beans, chartModel, chartContainer) {
    return beans.frameworkOverrides.wrapIncoming(() => beans.chartSvc?.restoreChart(chartModel, chartContainer));
}
exports.restoreChart = restoreChart;


/***/ }),

/***/ 4806:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integratedChartsModuleCSS = void 0;
exports.integratedChartsModuleCSS = `.ag-chart{display:flex;height:100%;position:relative;width:100%}.ag-chart-components-wrapper{display:flex}.ag-chart-canvas-wrapper,.ag-chart-components-wrapper{flex:1 1 auto;position:relative}.ag-chart-menu{background:var(--ag-background-color);background-color:color-mix(in srgb,transparent,var(--ag-background-color) 30%);border-radius:var(--ag-border-radius);display:flex;flex-direction:row;gap:20px;padding:4px 2px;position:absolute;top:8px;width:auto;--ag-icon-size:20px}:where(.ag-ltr) .ag-chart-menu{justify-content:right;right:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}:where(.ag-rtl) .ag-chart-menu{justify-content:left;left:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}:where(.ag-chart) .ag-chart-menu{display:none}:where(.ag-chart-menu-hidden:hover) .ag-chart-menu{display:block}.ag-chart-docked-container{min-width:var(--ag-chart-menu-panel-width);position:relative}:where(.ag-chart-menu-hidden)~.ag-chart-docked-container{display:none}.ag-chart-tabbed-menu{display:flex;flex-direction:column;height:100%;overflow:hidden;width:100%}.ag-chart-tabbed-menu-header{cursor:default;flex:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-tabbed-menu-body{align-items:stretch;display:flex;flex:1 1 auto;overflow:hidden;position:relative;&:after{background:linear-gradient(var(--ag-background-color),transparent);content:"";display:block;height:16px;left:0;position:absolute;right:0;top:0}}.ag-chart-tab{overflow:hidden;overflow-y:auto;width:100%}.ag-chart-settings{overflow-x:hidden}.ag-chart-settings-wrapper{display:flex;flex-direction:column;height:100%;overflow:hidden;position:relative;width:100%}.ag-chart-settings-nav-bar{align-items:center;border-top:1px solid var(--ag-border-color);display:flex;height:30px;padding:0 10px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-chart-settings-card-selector{align-items:center;display:flex;flex:1 1 auto;height:100%;justify-content:space-around;padding:0 10px}.ag-chart-settings-card-item{background-color:var(--ag-foreground-color);border-radius:4px;cursor:pointer;height:8px;position:relative;width:8px;&.ag-not-selected{opacity:.2}&:before{background-color:transparent;content:" ";display:block;height:20px;left:50%;margin-left:-10px;margin-top:-10px;position:absolute;top:50%;width:20px}&.ag-selected{background-color:var(--ag-accent-color)}}.ag-chart-settings-next,.ag-chart-settings-prev{flex:none;position:relative;&:focus-within{border-radius:1px;box-shadow:var(--ag-focus-shadow)}}.ag-chart-settings-next-button,.ag-chart-settings-prev-button{cursor:pointer;height:100%;left:0;opacity:0;position:absolute;top:0;width:100%}.ag-chart-settings-mini-charts-container{flex:1 1 auto;overflow:hidden auto;position:relative}.ag-chart-settings-mini-wrapper{display:flex;flex-direction:column;left:0;min-height:100%;overflow:hidden;padding-bottom:var(--ag-widget-container-vertical-padding);position:absolute;top:0;width:100%;&.ag-animating{transition:left .3s;transition-timing-function:ease-in-out}}.ag-chart-mini-thumbnail{border:1px solid var(--ag-border-color);border-radius:5px;cursor:pointer;&.ag-selected{border-color:var(--ag-accent-color);border-width:2px}&:focus-visible{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}}.ag-chart-mini-thumbnail-canvas{display:block}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper,.ag-chart-format-wrapper{display:flex;flex-direction:column;padding-bottom:16px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper{height:100%;overflow-y:auto}.ag-chart-advanced-settings{background-color:var(--ag-chrome-background-color)}.ag-chart-advanced-settings,.ag-chart-advanced-settings-wrapper{width:100%}.ag-chart-advanced-settings-wrapper{padding-bottom:0}.ag-chart-advanced-settings-section{border-bottom:1px solid var(--ag-border-color);display:flex;margin:0;padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding)}.ag-chart-empty-text{align-items:center;background-color:var(--ag-background-color);display:flex;height:100%;justify-content:center;top:0;width:100%}.ag-charts-font-size-color{align-self:stretch;display:flex;justify-content:space-between}.ag-charts-data-group-item{padding-bottom:var(--ag-widget-container-vertical-padding);position:relative}.ag-charts-data-group-item:where(:not(:last-child)){margin-bottom:var(--ag-spacing)}.ag-chart-menu-icon{border-radius:var(--ag-border-radius);cursor:pointer;margin:2px 0;opacity:.8;&:hover{opacity:1}}.ag-chart-menu-toolbar-button{background-color:unset;border:0;border-radius:1px;padding:0 2px}.ag-chart-data-column-drag-handle{margin-left:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-title-bar{background-color:unset;position:relative}.ag-charts-data-group-container{padding:calc(var(--ag-widget-container-vertical-padding)*.5) var(--ag-widget-container-horizontal-padding)}.ag-charts-data-group-item:where(:not(.ag-charts-format-sub-level-group,.ag-pill-select,.ag-select)){height:var(--ag-list-item-height)}.ag-charts-data-group-item:where(.ag-picker-field){margin-top:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-container,.ag-charts-format-top-level-group-container{margin-left:calc(var(--ag-spacing)*2);padding:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-item,.ag-charts-format-top-level-group-item{margin:var(--ag-spacing) 0}.ag-charts-format-sub-level-group-container{display:flex;flex-direction:column;padding:var(--ag-widget-vertical-spacing) 0}.ag-charts-settings-group-container{display:grid;grid-template-columns:60px 1fr 60px 1fr 60px;padding:var(--ag-spacing);row-gap:8px;:where(.ag-chart-mini-thumbnail:nth-child(3n+1)){grid-column:1}:where(.ag-chart-mini-thumbnail:nth-child(3n+2)){grid-column:3}:where(.ag-chart-mini-thumbnail:nth-child(3n+3)){grid-column:5}}.ag-chart-data-section,.ag-chart-format-section{display:flex;margin:0;:where(.ag-label:not(.ag-group-title-bar)){color:var(--ag-chart-menu-label-color)}:where(.ag-label-align-top .ag-label){margin-bottom:var(--ag-widget-vertical-spacing);margin-top:calc(var(--ag-widget-vertical-spacing)*.5)}:where(.ag-slider.ag-label-align-top .ag-label){margin-bottom:0}:where(label){display:inline-block}}.ag-chart-menu-panel{--ag-panel-background-color:var(--ag-chrome-background-color)}:where(.ag-ltr) .ag-chart-menu-panel{border-left:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-chart-menu-panel{border-right:1px solid var(--ag-border-color)}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar{border-top:none;font-weight:500;padding:0 calc(var(--ag-spacing)*1.5)}.ag-charts-format-sub-level-group-title-bar{background:none;font-weight:500;padding:var(--ag-widget-vertical-spacing) 0}.ag-chart-data-wrapper,.ag-chart-format-wrapper,.ag-charts-data-group-container,.ag-charts-data-group-title-bar,.ag-charts-format-sub-level-group,.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-group-item:last-child,.ag-charts-format-top-level-group,.ag-charts-format-top-level-group-item,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar,:where(.ag-charts-format-top-level-group) .ag-charts-format-top-level-group-container{margin:0;padding:0}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-title-bar{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:relative}.ag-charts-data-group,.ag-charts-format-top-level-group{border-top:1px solid var(--ag-border-color)}:where(.ag-charts-data-group) .ag-charts-data-group-container,:where(.ag-charts-format-top-level-group) .ag-charts-format-top-level-group-container,:where(.ag-charts-settings-group) .ag-charts-settings-group-container{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-no-header-group-container>*,.ag-charts-format-top-level-group-container>*{margin-bottom:var(--ag-widget-vertical-spacing)}.ag-charts-advanced-settings-top-level-group-container{margin:0}:where(.ag-charts-advanced-settings-top-level-group){.ag-charts-advanced-settings-top-level-group-container,.ag-charts-advanced-settings-top-level-group-title-bar{padding:0 var(--ag-widget-container-horizontal-padding)}}.ag-charts-advanced-settings-top-level-group-item{margin-bottom:0;margin-top:calc(var(--ag-widget-vertical-spacing)*2)}.ag-chart-settings-card-item.ag-not-selected:hover{opacity:.35}.ag-angle-select{align-items:center;display:flex}.ag-angle-select-wrapper{display:flex}.ag-angle-select-parent-circle{background-color:var(--ag-background-color);border:1px solid;border-color:var(--ag-border-color);border-radius:12px;display:block;height:24px;position:relative;width:24px}.ag-angle-select-child-circle{background-color:var(--ag-foreground-color);border-radius:3px;height:6px;left:12px;margin-left:-3px;margin-top:-4px;position:absolute;top:4px;width:6px}.ag-slider-wrapper{display:flex;:where(.ag-input-field){flex:1 1 auto}}.ag-color-panel{display:flex;flex-direction:column;padding:var(--ag-spacing);text-align:center;width:100%}.ag-spectrum-color{cursor:default;flex:1 1 auto;overflow:visible;position:relative}.ag-spectrum-fill{inset:0;position:absolute}.ag-spectrum-val{background-image:linear-gradient(0deg,#000,hsla(20,42%,65%,0));cursor:pointer}.ag-spectrum-dragger{background:#000;border:3px solid #fff;border-radius:18px;box-shadow:0 0 2px 0 rgba(0,0,0,.24);cursor:pointer;height:18px;pointer-events:none;position:absolute;width:18px}.ag-spectrum-alpha,.ag-spectrum-hue{cursor:default}.ag-spectrum-hue-background{background:linear-gradient(270deg,red 3%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);height:100%;width:100%}.ag-spectrum-alpha-background{background:linear-gradient(to right,var(--ag-internal-spectrum-alpha-color-from),var(--ag-internal-spectrum-alpha-color-to)),url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><path d="M0 0H2V4H4V2H0Z" fill="%23b2b2b2"/></svg>') 0 0 /4px 4px;height:100%;width:100%}.ag-spectrum-tool{border-radius:2px;cursor:pointer;height:11px;margin-bottom:10px;position:relative}.ag-spectrum-slider{border:2px solid #fff;border-radius:13px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:13px;margin-top:-12px;pointer-events:none;position:absolute;width:13px}:where(.ag-spectrum-alpha) .ag-spectrum-slider{background:linear-gradient(to bottom,var(--ag-internal-spectrum-alpha-color),var(--ag-internal-spectrum-alpha-color)) var(--ag-background-color)}.ag-recent-colors{display:flex;gap:6px;margin-bottom:2px;margin-left:var(--ag-spacing);margin-right:var(--ag-spacing)}.ag-recent-color{border:1px solid var(--ag-border-color);cursor:pointer}.ag-angle-select[disabled]{opacity:.5;pointer-events:none}:where(.ag-ltr) .ag-angle-select-field,:where(.ag-ltr) .ag-slider-field{margin-right:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-angle-select-field,:where(.ag-rtl) .ag-slider-field{margin-left:calc(var(--ag-spacing)*2)}.ag-color-dialog{border-radius:5px}:where(.ag-color-picker){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:var(--ag-spacing)}.ag-picker-field-display{align-items:center;display:flex;flex-direction:row;min-height:var(--ag-list-item-height)}}:where(.ag-ltr) .ag-color-picker-color,:where(.ag-ltr) .ag-color-picker-value{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-color-picker-color,:where(.ag-rtl) .ag-color-picker-value{margin-left:var(--ag-spacing)}.ag-spectrum-tools{padding-bottom:0;padding-left:0;padding-right:0}.ag-spectrum-alpha-background,.ag-spectrum-hue-background{border-radius:2px}.ag-color-input-color,.ag-color-picker-color,.ag-recent-color{border-radius:4px}.ag-spectrum-sat{background-image:linear-gradient(90deg,#fff,hsla(20,42%,65%,0))}.ag-recent-color,.ag-spectrum-color,.ag-spectrum-slider{&:where(:not(:disabled,[readonly])):focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-color-input-color,.ag-color-picker-color{border:1px solid var(--ag-border-color);border-radius:2px;height:var(--ag-icon-size);width:var(--ag-icon-size)}:where(.ag-color-input){.ag-color-input-color{position:absolute}}:where(.ag-ltr) :where(.ag-color-input){.ag-input-field-input{padding-left:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-color-input){.ag-input-field-input{padding-right:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-right:var(--ag-spacing)}}.ag-range-field{align-items:center;display:flex;:where(.ag-input-wrapper){height:100%}}.ag-range-field-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:none;height:100%;overflow:visible;padding:0;width:100%;&:disabled{opacity:.5}}.ag-range-field-input{&::-webkit-slider-runnable-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&:focus::-webkit-slider-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}&:active::-webkit-slider-runnable-track{background-color:var(--ag-accent-color)}}.ag-range-field-input{&::-moz-range-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-moz-ag-range-thumb{-moz-appearance:none;appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&:focus::-moz-ag-range-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}&:active::-moz-ag-range-track{background-color:var(--ag-accent-color)}}`;


/***/ }),

/***/ 1527:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegratedChartsModule = exports.GridChartsModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const licenseManager_1 = __webpack_require__(6565);
const rangeSelectionModule_1 = __webpack_require__(266);
const version_1 = __webpack_require__(7205);
const menuItemModule_1 = __webpack_require__(3375);
const agChartsExports_1 = __webpack_require__(2459);
const enterpriseChartProxyFactory_1 = __webpack_require__(7879);
const advancedSettingsMenuFactory_1 = __webpack_require__(6353);
const chartMenuList_1 = __webpack_require__(6292);
const chartCrossFilterService_1 = __webpack_require__(8769);
const chartMenuService_1 = __webpack_require__(7492);
const chartTranslationService_1 = __webpack_require__(93);
const chartService_1 = __webpack_require__(100);
const chartsApi_1 = __webpack_require__(4604);
const integratedChartsModule_css_GENERATED_1 = __webpack_require__(4806);
const validGridChartsVersion_1 = __webpack_require__(3504);
const icons = {
    // shown on top right of chart when chart is linked to range data (click to unlink)
    linked: 'linked',
    // shown on top right of chart when chart is not linked to range data (click to link)
    unlinked: 'unlinked',
    // icon to open charts menu
    chartsMenu: 'menu-alt',
    // download chart
    chartsDownload: 'save',
    // Edit Chart menu item shown in Integrated Charts menu
    chartsMenuEdit: 'chart',
    // Advanced Settings menu item shown in Integrated Charts menu
    chartsMenuAdvancedSettings: 'settings',
    // shown in Integrated Charts menu add fields
    chartsMenuAdd: 'plus',
    // shown in Integrated Charts tool panel color picker
    chartsColorPicker: 'small-down',
    // previous in Integrated Charts settings tool panel theme switcher
    chartsThemePrevious: 'previous',
    // next in Integrated Charts settings tool panel theme switcher
    chartsThemeNext: 'next',
};
const apiFunctions = {
    getChartModels: chartsApi_1.getChartModels,
    getChartRef: chartsApi_1.getChartRef,
    getChartImageDataURL: chartsApi_1.getChartImageDataURL,
    downloadChart: chartsApi_1.downloadChart,
    openChartToolPanel: chartsApi_1.openChartToolPanel,
    closeChartToolPanel: chartsApi_1.closeChartToolPanel,
    createRangeChart: chartsApi_1.createRangeChart,
    createPivotChart: chartsApi_1.createPivotChart,
    createCrossFilterChart: chartsApi_1.createCrossFilterChart,
    updateChart: chartsApi_1.updateChart,
    restoreChart: chartsApi_1.restoreChart,
};
const dependsOn = [
    rangeSelectionModule_1.CellSelectionModule,
    agGridEnterpriseModule_1.EnterpriseCoreModule,
    ag_grid_community_1._SharedDragAndDropModule,
    ag_grid_community_1._PopupModule,
    menuItemModule_1.MenuItemModule,
];
const moduleName = 'IntegratedCharts';
/**
 * @deprecated v33 Deprecated as of v33, please use `IntegratedChartsModule` instead.
 */
exports.GridChartsModule = {
    moduleName: 'GridCharts',
    version: version_1.VERSION,
    dependsOn,
    validate: () => {
        return {
            isValid: false,
            message: `AG Grid: As of v33, the "GridChartsModule" has been deprecated. Please use "IntegratedChartsModule.with(...)" instead.\n ${(0, ag_grid_community_1._preInitErrMsg)(257)}`,
        };
    },
};
/**
 * @feature Integrated Charts
 * Requires the AG Charts library to be provided to this module via the `with` method.
 * The AG Charts module can be imported from either `ag-charts-community` or `ag-charts-enterprise`.
 * @example
 * import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
 * import { ModuleRegistry } from 'ag-grid-community';
 * import { IntegratedChartsModule } from 'ag-grid-enterprise';
 *
 * ModuleRegistry.registerModules([ IntegratedChartsModule.with(AgChartsEnterpriseModule) ]);
 */
exports.IntegratedChartsModule = {
    moduleName,
    version: version_1.VERSION,
    dependsOn,
    validate: () => {
        return {
            isValid: false,
            message: (0, ag_grid_community_1._preInitErrMsg)(257),
        };
    },
    with: (params) => {
        params.setup();
        params.setGridContext?.(true);
        if (params.isEnterprise && params.setLicenseKey) {
            const chartsManager = {
                setLicenseKey: params.setLicenseKey,
            };
            licenseManager_1.LicenseManager.setChartsLicenseManager(chartsManager);
        }
        return {
            moduleName,
            version: version_1.VERSION,
            icons,
            apiFunctions,
            dependsOn,
            css: [integratedChartsModule_css_GENERATED_1.integratedChartsModuleCSS],
            validate: () => {
                return (0, validGridChartsVersion_1.validGridChartsVersion)({
                    gridVersion: version_1.VERSION,
                    chartsVersion: params.VERSION,
                });
            },
            beans: [
                // bind the params to the constructor to avoid the need for static properties
                agChartsExports_1.AgChartsExports.bind(null, params),
                chartService_1.ChartService,
                chartTranslationService_1.ChartTranslationService,
                chartCrossFilterService_1.ChartCrossFilterService,
                chartMenuList_1.ChartMenuListFactory,
                chartMenuService_1.ChartMenuService,
                // Include enterprise beans for now for all users as tiny compared to charts bundle size
                enterpriseChartProxyFactory_1.EnterpriseChartProxyFactory,
                advancedSettingsMenuFactory_1.AdvancedSettingsMenuFactory,
            ],
        };
    },
};


/***/ }),

/***/ 3504:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validGridChartsVersion = exports.validGridChartsVersionErrorMessage = exports.gridChartVersion = void 0;
const VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION = 28;
const VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION = 6;
function isValidVersion(version) {
    return version && version.match(/\d+\.\d+\.\d+/);
}
function isValidMajorVersion({ gridMajorVersion, chartsMajorVersion, }) {
    const gridMajor = parseInt(gridMajorVersion, 10);
    const chartsMajor = parseInt(chartsMajorVersion, 10);
    const gridMajorDifference = gridMajor - VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION;
    const chartsMajorDifference = chartsMajor - VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION;
    const isFirstOrAfterVersion = gridMajorDifference >= 0;
    return gridMajorDifference === chartsMajorDifference && isFirstOrAfterVersion;
}
function gridChartVersion(gridVersion) {
    if (!gridVersion || !isValidVersion(gridVersion)) {
        return undefined;
    }
    const [gridMajor, gridMinor] = gridVersion.split('.') || [];
    const gridMajorMinor = `${gridMajor}.${gridMinor}.x`;
    const gridMajorNumber = parseInt(gridMajor, 10);
    const chartsMajor = gridMajorNumber - VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION + VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION;
    if (chartsMajor < 0) {
        return undefined;
    }
    const chartsMinor = gridMinor;
    const chartsMajorMinor = `${chartsMajor}.${chartsMinor}.x`;
    return {
        gridMajorMinor,
        chartsMajorMinor,
    };
}
exports.gridChartVersion = gridChartVersion;
function validGridChartsVersionErrorMessage({ type, gridVersion, chartsVersion, }) {
    const invalidMessage = 'AG Grid: AG Grid version is incompatible. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.';
    if (!gridVersion) {
        return invalidMessage;
    }
    const version = gridChartVersion(gridVersion);
    if (!version) {
        return invalidMessage;
    }
    const { gridMajorMinor, chartsMajorMinor } = version;
    if (type === 'incompatible') {
        return `AG Grid version ${gridVersion} and AG Charts version ${chartsVersion} is not supported. AG Grid version ${gridMajorMinor} should be used with AG Chart ${chartsMajorMinor}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.`;
    }
    else if (type === 'invalidCharts') {
        return `AG Grid version ${gridMajorMinor} should be used with AG Chart ${chartsMajorMinor} not ${chartsVersion}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.`;
    }
    return invalidMessage;
}
exports.validGridChartsVersionErrorMessage = validGridChartsVersionErrorMessage;
function validGridChartsVersion({ gridVersion, chartsVersion, }) {
    if (!isValidVersion(chartsVersion)) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'invalidCharts', gridVersion, chartsVersion }),
        };
    }
    if (!isValidVersion(gridVersion)) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'invalidGrid', gridVersion, chartsVersion }),
        };
    }
    const [gridMajor, gridMinor] = gridVersion.split('.') || [];
    const [chartsMajor, chartsMinor, chartsPatch] = chartsVersion.split('.') || [];
    const isValidMajor = isValidMajorVersion({
        gridMajorVersion: gridMajor,
        chartsMajorVersion: chartsMajor,
    });
    if ((isValidMajor && gridMinor === chartsMinor) || chartsPatch.includes('beta')) {
        return {
            isValid: true,
        };
    }
    else if (!isValidMajor || gridMinor !== chartsMinor) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'incompatible', gridVersion, chartsVersion }),
        };
    }
    return {
        isValid: false,
        message: validGridChartsVersionErrorMessage({ type: 'invalid', gridVersion, chartsVersion }),
    };
}
exports.validGridChartsVersion = validGridChartsVersion;


/***/ }),

/***/ 1750:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAngleSelect = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgAngleSelect extends ag_grid_community_1.AgAbstractLabel {
    wireBeans(beans) {
        this.dragSvc = beans.dragSvc;
    }
    constructor(config) {
        super(config, 
        /* html */ `<div class="ag-angle-select">
            <div data-ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div class="ag-angle-select-field">
                    <div data-ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div data-ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field data-ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`, [ag_grid_community_1.AgInputNumberFieldSelector]);
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        this.eParentCircle = ag_grid_community_1.RefPlaceholder;
        this.eChildCircle = ag_grid_community_1.RefPlaceholder;
        this.eAngleValue = ag_grid_community_1.RefPlaceholder;
        this.radius = 0;
        this.offsetX = 0;
        this.offsetY = 0;
    }
    postConstruct() {
        super.postConstruct();
        const { value, onValueChange } = this.config;
        if (value != null) {
            this.setValue(value, undefined, true);
        }
        if (onValueChange != null) {
            this.onValueChange(onValueChange);
        }
        this.dragListener = {
            eElement: this.eParentCircle,
            dragStartPixels: 0,
            onDragStart: () => {
                this.parentCircleRect = this.eParentCircle.getBoundingClientRect();
            },
            onDragging: (e) => this.calculateAngleDrag(e),
            onDragStop: () => { },
        };
        this.dragSvc?.addDragSource(this.dragListener);
        this.eAngleValue
            .setLabel('')
            .setLabelWidth(5)
            .setInputWidth(45)
            .setMin(0)
            .setMax(360)
            .setValue(`${this.degrees}`)
            .onValueChange((value) => {
            if (value == null || value === '') {
                value = '0';
            }
            value = this.eAngleValue.normalizeValue(value);
            let floatValue = parseFloat(value);
            if (floatValue > 180) {
                floatValue = floatValue - 360;
            }
            this.setValue(floatValue);
        });
        this.updateNumberInput();
        if ((0, ag_grid_community_1._exists)(this.getValue())) {
            this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString());
        }
        this.addManagedListeners(this, {
            fieldValueChanged: () => {
                if (this.eAngleValue.getInputElement().contains((0, ag_grid_community_1._getActiveDomElement)(this.beans))) {
                    return;
                }
                this.updateNumberInput();
            },
        });
    }
    updateNumberInput() {
        const normalizedValue = this.normalizeNegativeValue(this.getValue());
        this.eAngleValue.setValue(normalizedValue.toString());
    }
    positionChildCircle(radians) {
        const rect = this.parentCircleRect || { width: 24, height: 24 };
        const eChildCircle = this.eChildCircle;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        eChildCircle.style.left = `${centerX + Math.cos(radians) * 8}px`;
        eChildCircle.style.top = `${centerY + Math.sin(radians) * 8}px`;
    }
    calculatePolar() {
        const x = this.offsetX;
        const y = this.offsetY;
        const radians = Math.atan2(y, x);
        this.degrees = this.toDegrees(radians);
        this.radius = Math.sqrt(x * x + y * y);
        this.positionChildCircle(radians);
    }
    calculateCartesian() {
        const radians = this.toRadians(this.getValue());
        const radius = this.getRadius();
        this.setOffsetX(Math.cos(radians) * radius).setOffsetY(Math.sin(radians) * radius);
    }
    setOffsetX(offset) {
        if (this.offsetX !== offset) {
            this.offsetX = offset;
            this.calculatePolar();
        }
        return this;
    }
    setOffsetY(offset) {
        if (this.offsetY !== offset) {
            this.offsetY = offset;
            this.calculatePolar();
        }
        return this;
    }
    calculateAngleDrag(e) {
        const rect = this.parentCircleRect;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - centerX;
        const dy = y - centerY;
        const radians = Math.atan2(dy, dx);
        this.setValue(radians, true);
    }
    toDegrees(radians) {
        return (radians / Math.PI) * 180;
    }
    toRadians(degrees) {
        return (degrees / 180) * Math.PI;
    }
    normalizeNegativeValue(degrees) {
        return degrees < 0 ? 360 + degrees : degrees;
    }
    normalizeAngle180(radians) {
        radians %= Math.PI * 2;
        if (radians < -Math.PI) {
            radians += Math.PI * 2;
        }
        else if (radians >= Math.PI) {
            radians -= Math.PI * 2;
        }
        return radians;
    }
    getRadius() {
        return this.radius;
    }
    setRadius(r) {
        if (this.radius === r) {
            return this;
        }
        this.radius = r;
        this.calculateCartesian();
        return this;
    }
    onValueChange(callbackFn) {
        this.addManagedListeners(this, {
            fieldValueChanged: () => {
                callbackFn(this.degrees);
            },
        });
        return this;
    }
    getValue(radians) {
        return radians ? this.toRadians(this.degrees) : this.degrees;
    }
    setValue(degrees, radians, silent) {
        let radiansValue;
        if (!radians) {
            radiansValue = this.normalizeAngle180(this.toRadians(degrees));
        }
        else {
            radiansValue = degrees;
        }
        degrees = this.toDegrees(radiansValue);
        if (this.degrees !== degrees) {
            this.degrees = Math.floor(degrees);
            this.calculateCartesian();
            this.positionChildCircle(radiansValue);
            if (!silent) {
                this.dispatchLocalEvent({ type: 'fieldValueChanged' });
            }
        }
        return this;
    }
    setWidth(width) {
        (0, ag_grid_community_1._setFixedWidth)(this.getGui(), width);
        return this;
    }
    setDisabled(disabled) {
        super.setDisabled(disabled);
        this.eAngleValue.setDisabled(disabled);
        return this;
    }
    destroy() {
        this.dragSvc?.removeDragSource(this.dragListener);
        super.destroy();
    }
}
exports.AgAngleSelect = AgAngleSelect;


/***/ }),

/***/ 7699:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgColorInputSelector = exports.AgColorInput = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgColorInput extends ag_grid_community_1.AgInputTextField {
    wireBeans(beans) {
        this.chartTranslation = beans.chartTranslation;
        this.color = beans.agChartsExports._Util.Color;
    }
    constructor() {
        super({
            template: /* html */ `
            <div role="presentation" class="ag-color-input">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <input data-ref="eInput" class="ag-input-field-input">
                    <div data-ref="eColor" class="ag-color-input-color"></div>
                </div>
            </div>`,
        });
        this.eColor = ag_grid_community_1.RefPlaceholder;
    }
    setColor(color) {
        const rgbaColor = color.toRgbaString();
        this.setValue(this.color.fromString(rgbaColor).toHexString().toUpperCase(), true);
        this.eColor.style.backgroundColor = rgbaColor;
    }
    setValue(value, silent) {
        const isValid = this.color.validColorString(value ?? '');
        this.eInput.setCustomValidity(isValid ? '' : this.chartTranslation.translate('invalidColor'));
        super.setValue(value, silent);
        if (isValid && !silent) {
            this.dispatchLocalEvent({ type: 'colorChanged' });
        }
        return this;
    }
    onColorChanged(callback) {
        this.addManagedListeners(this, { colorChanged: () => callback(this.color.fromString(this.value)) });
    }
}
exports.AgColorInput = AgColorInput;
exports.AgColorInputSelector = {
    selector: 'AG-COLOR-INPUT',
    component: AgColorInput,
};


/***/ }),

/***/ 7434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgColorPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agColorInput_1 = __webpack_require__(7699);
const maxRecentColors = 8;
let sharedRecentColors = [];
class AgColorPanel extends ag_grid_community_1.Component {
    constructor(config) {
        super(
        /* html */ `<div class="ag-color-panel" tabindex="-1">
            <div data-ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div data-ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div data-ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div data-ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div data-ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div data-ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div data-ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <ag-color-input data-ref="colorInput"></ag-color-input>
                <div data-ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`, [agColorInput_1.AgColorInputSelector]);
        this.H = 1; // in the [0, 1] range
        this.S = 1; // in the [0, 1] range
        this.B = 1; // in the [0, 1] range
        this.A = 1; // in the [0, 1] range
        this.isSpectrumDragging = false;
        this.isSpectrumHueDragging = false;
        this.isSpectrumAlphaDragging = false;
        this.colorChanged = false;
        this.spectrumColor = ag_grid_community_1.RefPlaceholder;
        this.spectrumVal = ag_grid_community_1.RefPlaceholder;
        this.spectrumDragger = ag_grid_community_1.RefPlaceholder;
        this.spectrumHue = ag_grid_community_1.RefPlaceholder;
        this.spectrumHueSlider = ag_grid_community_1.RefPlaceholder;
        this.spectrumAlpha = ag_grid_community_1.RefPlaceholder;
        this.spectrumAlphaSlider = ag_grid_community_1.RefPlaceholder;
        this.colorInput = ag_grid_community_1.RefPlaceholder;
        this.recentColors = ag_grid_community_1.RefPlaceholder;
        this.picker = config.picker;
    }
    wireBeans(beans) {
        this._Color = beans.agChartsExports._Util.Color;
    }
    postConstruct() {
        this.initTabIndex();
        this.initRecentColors();
        this.addGuiEventListener('focus', () => this.spectrumColor.focus());
        this.addGuiEventListener('keydown', (e) => {
            if (e.key === ag_grid_community_1.KeyCode.ENTER && !e.defaultPrevented) {
                this.destroy();
            }
        });
        this.addManagedListeners(this.spectrumColor, { keydown: (e) => this.moveDragger(e) });
        this.addManagedListeners(this.spectrumAlphaSlider, { keydown: (e) => this.moveAlphaSlider(e) });
        this.addManagedListeners(this.spectrumHueSlider, { keydown: (e) => this.moveHueSlider(e) });
        this.addManagedListeners(this.spectrumVal, { mousedown: this.onSpectrumDraggerDown.bind(this) });
        this.addManagedListeners(this.spectrumHue, { mousedown: this.onSpectrumHueDown.bind(this) });
        this.addManagedListeners(this.spectrumAlpha, { mousedown: this.onSpectrumAlphaDown.bind(this) });
        this.addGuiEventListener('mousemove', (e) => {
            this.onSpectrumDraggerMove(e);
            this.onSpectrumHueMove(e);
            this.onSpectrumAlphaMove(e);
        });
        // Listening to `mouseup` on the document on purpose. The user might release the mouse button
        // outside the UI control. When the mouse returns back to the control's area, the dragging
        // of the thumb is not expected and seen as a bug.
        this.addManagedListeners(document, { mouseup: this.onMouseUp.bind(this) });
        this.colorInput.onColorChanged(this.setColor.bind(this));
        this.addManagedListeners(this.recentColors, {
            click: this.onRecentColorClick.bind(this),
            keydown: (e) => {
                if (e.key === ag_grid_community_1.KeyCode.ENTER || e.key === ag_grid_community_1.KeyCode.SPACE) {
                    e.preventDefault();
                    this.onRecentColorClick(e);
                }
            },
        });
    }
    initTabIndex() {
        const tabIndex = (this.tabIndex = this.gos.get('tabIndex').toString());
        this.spectrumColor.setAttribute('tabindex', tabIndex);
        this.spectrumHueSlider.setAttribute('tabindex', tabIndex);
        this.spectrumAlphaSlider.setAttribute('tabindex', tabIndex);
    }
    refreshSpectrumRect() {
        return (this.spectrumValRect = this.spectrumVal.getBoundingClientRect());
    }
    refreshHueRect() {
        return (this.spectrumHueRect = this.spectrumHue.getBoundingClientRect());
    }
    refreshAlphaRect() {
        return (this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect());
    }
    onSpectrumDraggerDown(e) {
        e.preventDefault();
        this.refreshSpectrumRect();
        this.isSpectrumDragging = true;
        this.moveDragger(e);
    }
    onSpectrumDraggerMove(e) {
        if (this.isSpectrumDragging) {
            this.moveDragger(e);
        }
    }
    onSpectrumHueDown(e) {
        this.refreshHueRect();
        this.isSpectrumHueDragging = true;
        this.moveHueSlider(e);
    }
    onSpectrumHueMove(e) {
        if (this.isSpectrumHueDragging) {
            this.moveHueSlider(e);
        }
    }
    onSpectrumAlphaDown(e) {
        this.refreshAlphaRect();
        this.isSpectrumAlphaDragging = true;
        this.moveAlphaSlider(e);
    }
    onSpectrumAlphaMove(e) {
        if (this.isSpectrumAlphaDragging) {
            this.moveAlphaSlider(e);
        }
    }
    onMouseUp() {
        this.isSpectrumDragging = false;
        this.isSpectrumHueDragging = false;
        this.isSpectrumAlphaDragging = false;
    }
    moveDragger(e) {
        const valRect = this.spectrumValRect;
        if (!valRect) {
            return;
        }
        let x;
        let y;
        if (e instanceof MouseEvent) {
            x = e.clientX - valRect.left;
            y = e.clientY - valRect.top;
        }
        else {
            const isLeft = e.key === ag_grid_community_1.KeyCode.LEFT;
            const isRight = e.key === ag_grid_community_1.KeyCode.RIGHT;
            const isUp = e.key === ag_grid_community_1.KeyCode.UP;
            const isDown = e.key === ag_grid_community_1.KeyCode.DOWN;
            const isVertical = isUp || isDown;
            const isHorizontal = isLeft || isRight;
            if (!isVertical && !isHorizontal) {
                return;
            }
            e.preventDefault();
            const { x: currentX, y: currentY } = this.getSpectrumValue();
            x = currentX + (isHorizontal ? (isLeft ? -5 : 5) : 0);
            y = currentY + (isVertical ? (isUp ? -5 : 5) : 0);
        }
        x = Math.max(x, 0);
        x = Math.min(x, valRect.width);
        y = Math.max(y, 0);
        y = Math.min(y, valRect.height);
        this.setSpectrumValue(x / valRect.width, 1 - y / valRect.height);
    }
    moveHueSlider(e) {
        const rect = this.spectrumHueRect;
        if (!rect) {
            return;
        }
        const x = this.moveSlider(this.spectrumHueSlider, e);
        if (x == null) {
            return;
        }
        this.H = 1 - x / rect.width;
        this.update();
    }
    moveAlphaSlider(e) {
        const rect = this.spectrumAlphaRect;
        if (!rect) {
            return;
        }
        const x = this.moveSlider(this.spectrumAlphaSlider, e);
        if (x == null) {
            return;
        }
        this.A = x / rect.width;
        this.update();
    }
    moveSlider(slider, e) {
        const sliderRect = slider.getBoundingClientRect();
        const parentRect = slider.parentElement?.getBoundingClientRect();
        if (!slider || !parentRect) {
            return null;
        }
        const offset = sliderRect.width / 2;
        let x;
        if (e instanceof MouseEvent) {
            x = Math.floor(e.clientX - parentRect.left);
        }
        else {
            const isLeft = e.key === ag_grid_community_1.KeyCode.LEFT;
            const isRight = e.key === ag_grid_community_1.KeyCode.RIGHT;
            if (!isLeft && !isRight) {
                return null;
            }
            e.preventDefault();
            const diff = isLeft ? -5 : 5;
            x = parseFloat(slider.style.left) + offset + diff;
        }
        x = Math.max(x, 0);
        x = Math.min(x, parentRect.width);
        slider.style.left = x - offset + 'px';
        return x;
    }
    update(suppressColorInputUpdate) {
        const { A, S, B, H, _Color } = this;
        const hue = H * 360;
        const color = _Color.fromHSB(hue, S, B, A);
        const rgbaColor = color.toRgbaString();
        const colorWithoutAlpha = _Color.fromHSB(hue, S, B);
        const rgbaColorWithoutAlpha = colorWithoutAlpha.toRgbaString();
        const spectrumColor = _Color.fromHSB(hue, 1, 1);
        const spectrumRgbaColor = spectrumColor.toRgbaString();
        // the recent color list needs to know color has actually changed
        const colorPicker = this.picker;
        const existingColor = _Color.fromString(colorPicker.getValue());
        if (existingColor.toRgbaString() !== rgbaColor) {
            this.colorChanged = true;
        }
        colorPicker.setValue(rgbaColor);
        this.spectrumColor.style.backgroundColor = spectrumRgbaColor;
        this.spectrumDragger.style.backgroundColor = rgbaColorWithoutAlpha;
        this.spectrumHueSlider.style.backgroundColor = spectrumRgbaColor;
        this.spectrumAlpha.style.setProperty('--ag-internal-spectrum-alpha-color-from', _Color.fromHSB(hue, S, B, 0).toRgbaString());
        this.spectrumAlpha.style.setProperty('--ag-internal-spectrum-alpha-color-to', rgbaColorWithoutAlpha);
        this.spectrumAlpha.style.setProperty('--ag-internal-spectrum-alpha-color', rgbaColor);
        if (!suppressColorInputUpdate) {
            this.colorInput.setColor(color);
        }
    }
    /**
     * @param saturation In the [0, 1] interval.
     * @param brightness In the [0, 1] interval.
     */
    setSpectrumValue(saturation, brightness, suppressColorInputUpdate) {
        const valRect = this.spectrumValRect || this.refreshSpectrumRect();
        if (valRect == null) {
            return;
        }
        const dragger = this.spectrumDragger;
        const draggerRect = dragger.getBoundingClientRect();
        saturation = Math.max(0, saturation);
        saturation = Math.min(1, saturation);
        brightness = Math.max(0, brightness);
        brightness = Math.min(1, brightness);
        this.S = saturation;
        this.B = brightness;
        dragger.style.left = saturation * valRect.width - draggerRect.width / 2 + 'px';
        dragger.style.top = (1 - brightness) * valRect.height - draggerRect.height / 2 + 'px';
        this.update(suppressColorInputUpdate);
    }
    getSpectrumValue() {
        const dragger = this.spectrumDragger;
        const draggerRect = dragger.getBoundingClientRect();
        const x = parseFloat(dragger.style.left) + draggerRect.width / 2;
        const y = parseFloat(dragger.style.top) + draggerRect.height / 2;
        return { x, y };
    }
    initRecentColors() {
        const recentColors = sharedRecentColors;
        const innerHtml = recentColors.map((color, index) => {
            return /* html */ `<div class="ag-recent-color" id=${index} style="background-color: ${color}; width: 15px; height: 15px;" recent-color="${color}" tabIndex="${this.tabIndex}"></div>`;
        });
        this.recentColors.innerHTML = innerHtml.join('');
        (0, ag_grid_community_1._setDisplayed)(this.recentColors, !!recentColors.length);
    }
    setValue(val) {
        const color = this._Color.fromString(val);
        this.setColor(color, true);
    }
    setColor(color, updateColorInput) {
        const [h, s, b] = color.toHSB();
        this.H = (isNaN(h) ? 0 : h) / 360;
        this.A = color.a;
        const spectrumHueRect = this.spectrumHueRect || this.refreshHueRect();
        const spectrumAlphaRect = this.spectrumAlphaRect || this.refreshAlphaRect();
        this.spectrumHueSlider.style.left = `${(this.H - 1) * -spectrumHueRect.width - this.spectrumHueSlider.getBoundingClientRect().width / 2}px`;
        this.spectrumAlphaSlider.style.left = `${this.A * spectrumAlphaRect.width - this.spectrumAlphaSlider.getBoundingClientRect().width / 2}px`;
        this.setSpectrumValue(s, b, !updateColorInput);
    }
    onRecentColorClick(e) {
        const target = e.target;
        if (!(0, ag_grid_community_1._exists)(target.id)) {
            return;
        }
        const id = parseInt(target.id, 10);
        this.setValue(sharedRecentColors[id]);
        this.destroy();
    }
    addRecentColor() {
        const color = this._Color.fromHSB(this.H * 360, this.S, this.B, this.A);
        const rgbaColor = color.toRgbaString();
        let recentColors = sharedRecentColors;
        if (!this.colorChanged || recentColors[0] === rgbaColor) {
            return;
        }
        // remove duplicate color
        recentColors = recentColors.filter((currentColor) => currentColor != rgbaColor);
        // add color to head
        recentColors = [rgbaColor].concat(recentColors);
        // ensure we don't exceed max number of recent colors
        if (recentColors.length > maxRecentColors) {
            recentColors = recentColors.slice(0, maxRecentColors);
        }
        sharedRecentColors = recentColors;
    }
    destroy() {
        this.addRecentColor();
        super.destroy();
    }
}
exports.AgColorPanel = AgColorPanel;


/***/ }),

/***/ 1296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgColorPickerSelector = exports.AgColorPicker = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agDialog_1 = __webpack_require__(8775);
const agColorPanel_1 = __webpack_require__(7434);
class AgColorPicker extends ag_grid_community_1.AgPickerField {
    constructor(config) {
        super({
            pickerAriaLabelKey: 'ariaLabelColorPicker',
            pickerAriaLabelValue: 'Color Picker',
            pickerType: 'ag-list',
            className: 'ag-color-picker',
            pickerIcon: 'chartsColorPicker',
            ...config,
        });
    }
    postConstruct() {
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        this.eDisplayFieldColor = eDocument.createElement('span');
        this.eDisplayFieldColor.classList.add('ag-color-picker-color');
        this.eDisplayFieldText = eDocument.createElement('span');
        this.eDisplayFieldText.classList.add('ag-color-picker-value');
        this.eDisplayField.appendChild(this.eDisplayFieldColor);
        this.eDisplayField.appendChild(this.eDisplayFieldText);
        super.postConstruct();
        if (this.value) {
            this.setValue(this.value);
        }
    }
    createPickerComponent() {
        const eGuiRect = this.eWrapper.getBoundingClientRect();
        const parentRect = this.beans.popupSvc.getParentRect();
        const colorDialog = this.createBean(new agDialog_1.AgDialog({
            closable: false,
            modal: true,
            hideTitleBar: true,
            minWidth: 190,
            width: 190,
            height: 250,
            x: eGuiRect.right - parentRect.left - 190,
            y: eGuiRect.top - parentRect.top - 250 - (this.config.pickerGap ?? 0),
            postProcessPopupParams: {
                type: 'colorPicker',
                eventSource: this.eWrapper,
            },
        }));
        return colorDialog;
    }
    renderAndPositionPicker() {
        const pickerComponent = this.pickerComponent;
        const colorPanel = this.createBean(new agColorPanel_1.AgColorPanel({ picker: this }));
        pickerComponent.addCssClass('ag-color-dialog');
        colorPanel.addDestroyFunc(() => {
            if (pickerComponent.isAlive()) {
                this.destroyBean(pickerComponent);
            }
        });
        pickerComponent.setParentComponent(this);
        pickerComponent.setBodyComponent(colorPanel);
        colorPanel.setValue(this.getValue());
        colorPanel.getGui().focus();
        pickerComponent.addDestroyFunc(() => {
            // here we check if the picker was already being
            // destroyed to avoid a stack overflow
            if (!this.isDestroyingPicker) {
                this.beforeHidePicker();
                this.isDestroyingPicker = true;
                if (colorPanel.isAlive()) {
                    this.destroyBean(colorPanel);
                }
                if (this.isAlive()) {
                    this.getFocusableElement().focus();
                }
            }
            else {
                this.isDestroyingPicker = false;
            }
        });
        return () => this.pickerComponent?.close();
    }
    setValue(color) {
        if (this.value === color) {
            return this;
        }
        this.eDisplayFieldColor.style.backgroundColor = color;
        this.eDisplayFieldText.textContent = this.beans.agChartsExports._Util.Color.fromString(color)
            .toHexString()
            .toUpperCase();
        return super.setValue(color);
    }
    getValue() {
        return this.value;
    }
}
exports.AgColorPicker = AgColorPicker;
exports.AgColorPickerSelector = {
    selector: 'AG-COLOR-PICKER',
    component: AgColorPicker,
};


/***/ }),

/***/ 5748:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgInputRangeSelector = exports.AgInputRange = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgInputRange extends ag_grid_community_1.AgAbstractInputField {
    constructor(config) {
        super(config, 'ag-range-field', 'range');
    }
    postConstruct() {
        super.postConstruct();
        const { min, max, step } = this.config;
        if (min != null) {
            this.setMinValue(min);
        }
        if (max != null) {
            this.setMaxValue(max);
        }
        this.setStep(step || 1);
    }
    addInputListeners() {
        this.addManagedElementListeners(this.eInput, {
            input: (e) => {
                const value = e.target.value;
                this.setValue(value);
            },
        });
    }
    setMinValue(value) {
        this.min = value;
        this.eInput.setAttribute('min', value.toString());
        return this;
    }
    setMaxValue(value) {
        this.max = value;
        this.eInput.setAttribute('max', value.toString());
        return this;
    }
    setStep(value) {
        this.eInput.setAttribute('step', value.toString());
        return this;
    }
    setValue(value, silent) {
        if (this.min != null) {
            value = Math.max(parseFloat(value), this.min).toString();
        }
        if (this.max != null) {
            value = Math.min(parseFloat(value), this.max).toString();
        }
        const ret = super.setValue(value, silent);
        this.eInput.value = value;
        return ret;
    }
}
exports.AgInputRange = AgInputRange;
exports.AgInputRangeSelector = {
    selector: 'AG-INPUT-RANGE',
    component: AgInputRange,
};


/***/ }),

/***/ 8239:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agPillSelectCSS = void 0;
exports.agPillSelectCSS = `.ag-pill-select{display:flex;flex-direction:column}:where(.ag-pill-select){.ag-column-drop-list{padding:0}.ag-select{padding-top:var(--ag-spacing)}.ag-picker-field-wrapper{background-color:transparent;border:0}.ag-picker-field-display{cursor:pointer;font-weight:500}.ag-picker-field-display,.ag-picker-field-icon{color:var(--ag-chart-menu-label-color)}}`;


/***/ }),

/***/ 2406:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPillSelect = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pillDragComp_1 = __webpack_require__(3173);
const pillDropZonePanel_1 = __webpack_require__(9733);
const agPillSelect_css_GENERATED_1 = __webpack_require__(8239);
class AgPillSelect extends ag_grid_community_1.Component {
    constructor(config) {
        super(/* html */ `<div class="ag-pill-select" role="presentation"></div>`);
        this.config = config ?? {};
        const { selectedValueList, valueFormatter, valueList } = this.config;
        this.selectedValues = selectedValueList ?? [];
        this.valueList = valueList ?? [];
        this.valueFormatter = valueFormatter ?? ((value) => (0, ag_grid_community_1._escapeString)(value));
        this.registerCSS(agPillSelect_css_GENERATED_1.agPillSelectCSS);
    }
    postConstruct() {
        const { ariaLabel, onValuesChange, dragSourceId } = this.config;
        this.dropZonePanel = this.createManagedBean(new PillSelectDropZonePanel({
            getValues: () => this.selectedValues,
            setValues: (values) => this.updateValues(values),
            isDraggable: () => this.selectedValues.length > 1,
        }, (value) => this.valueFormatter(value), ariaLabel, dragSourceId));
        const eGui = this.getGui();
        eGui.appendChild(this.dropZonePanel.getGui());
        this.initSelect();
        if (onValuesChange != null) {
            this.onValuesChange = onValuesChange;
        }
    }
    setValues(valueList, selectedValues) {
        const { added, removed, updated } = this.getChanges(this.valueList, valueList);
        let refreshSelect = false;
        if (added.length || removed.length || updated.length) {
            refreshSelect = true;
        }
        this.valueList = valueList;
        this.updateValues(selectedValues, refreshSelect, true);
        return this;
    }
    setValueFormatter(valueFormatter) {
        this.valueFormatter = valueFormatter;
        return this;
    }
    initSelect() {
        const options = this.createSelectOptions();
        if (!options.length) {
            return false;
        }
        const { selectPlaceholder: placeholder } = this.config;
        this.eSelect = this.createBean(new ag_grid_community_1.AgSelect({
            options,
            placeholder,
            onValueChange: (value) => this.addValue(value),
            pickerIcon: 'chartsMenuAdd',
        }));
        this.getGui().appendChild(this.eSelect.getGui());
        return true;
    }
    createSelectOptions() {
        const options = [];
        const { maxSelection } = this.config;
        if (maxSelection && this.selectedValues.length >= maxSelection) {
            return options;
        }
        this.valueList.forEach((value) => {
            if (!this.selectedValues.includes(value)) {
                options.push({ value, text: this.valueFormatter(value) });
            }
        });
        return options;
    }
    addValue(value) {
        this.dropZonePanel.addItem(value);
    }
    updateValues(values, forceRefreshSelect, silent) {
        const previousSelectedValues = this.selectedValues;
        this.selectedValues = values;
        const changes = this.getChanges(previousSelectedValues, values);
        const refreshSelect = forceRefreshSelect || changes.added.length || changes.removed.length;
        const activeElement = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        const selectHasFocus = this.eSelect?.getGui().contains(activeElement);
        const dropZoneHasFocus = this.dropZonePanel?.getGui().contains(activeElement);
        if (!silent) {
            this.onValuesChange?.(changes);
        }
        const emptyRefreshedSelect = refreshSelect ? !this.refreshSelect() : false;
        this.dropZonePanel.refreshGui();
        if (refreshSelect && selectHasFocus) {
            if (emptyRefreshedSelect) {
                this.dropZonePanel.focusList(true);
            }
            else {
                this.eSelect?.getFocusableElement().focus();
            }
        }
        if (dropZoneHasFocus && !values.length) {
            this.eSelect?.getFocusableElement().focus();
        }
    }
    getChanges(previousSelectedValues, newSelectedValues) {
        const added = newSelectedValues.filter((value) => !previousSelectedValues.includes(value));
        const removed = previousSelectedValues.filter((value) => !newSelectedValues.includes(value));
        const updated = newSelectedValues.filter((value, index) => previousSelectedValues[index] !== value);
        return { added, removed, updated, selected: newSelectedValues };
    }
    refreshSelect() {
        if (!this.eSelect) {
            return this.initSelect();
        }
        const options = this.createSelectOptions();
        if (!options.length) {
            (0, ag_grid_community_1._removeFromParent)(this.eSelect.getGui());
            this.eSelect = this.destroyBean(this.eSelect);
            return false;
        }
        this.eSelect.clearOptions().addOptions(options).setValue(undefined, true);
        return true;
    }
    destroy() {
        this.destroyBean(this.eSelect);
        super.destroy();
    }
}
exports.AgPillSelect = AgPillSelect;
class PillSelectDragComp extends pillDragComp_1.PillDragComp {
    constructor(value, dragSourceDropTarget, ghost, valueFormatter, draggable, sourceId) {
        super(dragSourceDropTarget, ghost, false);
        this.value = value;
        this.valueFormatter = valueFormatter;
        this.draggable = draggable;
        this.sourceId = sourceId;
    }
    getItem() {
        return this.value;
    }
    getDisplayName() {
        return this.valueFormatter(this.value);
    }
    getAriaDisplayName() {
        return this.getDisplayName();
    }
    getTooltip() {
        return undefined;
    }
    createGetDragItem() {
        return () => ({
            value: this.value,
        });
    }
    getDragSourceType() {
        return ag_grid_community_1.DragSourceType.ChartPanel;
    }
    getDragSourceId() {
        return this.sourceId;
    }
    isDraggable() {
        return this.draggable;
    }
}
class PillSelectDropZonePanel extends pillDropZonePanel_1.PillDropZonePanel {
    constructor(model, valueFormatter, ariaLabel, sourceId) {
        super(false);
        this.model = model;
        this.valueFormatter = valueFormatter;
        this.ariaLabel = ariaLabel;
        this.sourceId = sourceId;
    }
    postConstruct() {
        super.init();
    }
    isItemDroppable(item, draggingEvent) {
        return (this.isSourceEventFromTarget(draggingEvent) ||
            (this.sourceId != null && this.sourceId === draggingEvent.dragSource.sourceId));
    }
    updateItems(items) {
        this.model.setValues(items);
    }
    getExistingItems() {
        return this.model.getValues();
    }
    getIconName() {
        return this.isPotentialDndItems() ? 'move' : 'notAllowed';
    }
    getAriaLabel() {
        return this.ariaLabel;
    }
    createPillComponent(item, dropTarget, ghost) {
        return new PillSelectDragComp(item, dropTarget, ghost, this.valueFormatter, this.model.isDraggable(), this.sourceId);
    }
    getItems(dragItem) {
        return [dragItem.value];
    }
    isInterestedIn(type) {
        return type === ag_grid_community_1.DragSourceType.ChartPanel;
    }
}


/***/ }),

/***/ 5000:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgSliderSelector = exports.AgSlider = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agInputRange_1 = __webpack_require__(5748);
class AgSlider extends ag_grid_community_1.AgAbstractLabel {
    constructor(config) {
        super(config, 
        /* html */ `<div class="ag-slider">
            <label data-ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range data-ref="eSlider"></ag-input-range>
                <ag-input-number-field data-ref="eText"></ag-input-number-field>
            </div>
        </div>`, [agInputRange_1.AgInputRangeSelector, ag_grid_community_1.AgInputNumberFieldSelector]);
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        this.eSlider = ag_grid_community_1.RefPlaceholder;
        this.eText = ag_grid_community_1.RefPlaceholder;
        this.labelAlignment = 'top';
    }
    postConstruct() {
        super.postConstruct();
        this.eSlider.addCssClass('ag-slider-field');
        const { minValue, maxValue, textFieldWidth, step, value, onValueChange } = this.config;
        if (minValue != null) {
            this.setMinValue(minValue);
        }
        if (maxValue != null) {
            this.setMaxValue(maxValue);
        }
        if (textFieldWidth != null) {
            this.setTextFieldWidth(textFieldWidth);
        }
        if (step != null) {
            this.setStep(step);
        }
        if (value != null) {
            this.setValue(value);
        }
        if (onValueChange != null) {
            this.onValueChange(onValueChange);
        }
    }
    onValueChange(callbackFn) {
        this.addManagedListeners(this.eText, {
            fieldValueChanged: () => {
                const textValue = parseFloat(this.eText.getValue());
                this.eSlider.setValue(textValue.toString(), true);
                callbackFn(textValue || 0);
            },
        });
        this.addManagedListeners(this.eSlider, {
            fieldValueChanged: () => {
                const sliderValue = this.eSlider.getValue();
                this.eText.setValue(sliderValue, true);
                callbackFn(parseFloat(sliderValue));
            },
        });
        return this;
    }
    setSliderWidth(width) {
        this.eSlider.setWidth(width);
        return this;
    }
    setTextFieldWidth(width) {
        this.eText.setWidth(width);
        return this;
    }
    setMinValue(minValue) {
        this.eSlider.setMinValue(minValue);
        this.eText.setMin(minValue);
        return this;
    }
    setMaxValue(maxValue) {
        this.eSlider.setMaxValue(maxValue);
        this.eText.setMax(maxValue);
        return this;
    }
    getValue() {
        return this.eText.getValue();
    }
    setValue(value, silent) {
        if (this.getValue() === value) {
            return this;
        }
        this.eText.setValue(value, true);
        this.eSlider.setValue(value, true);
        if (!silent) {
            this.dispatchLocalEvent({ type: 'fieldValueChanged' });
        }
        return this;
    }
    setStep(step) {
        this.eSlider.setStep(step);
        this.eText.setStep(step);
        return this;
    }
}
exports.AgSlider = AgSlider;
exports.AgSliderSelector = {
    selector: 'AG-SLIDER',
    component: AgSlider,
};


/***/ }),

/***/ 9112:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pasteFromClipboard = exports.copySelectedRangeDown = exports.copySelectedRangeToClipboard = exports.copySelectedRowsToClipboard = exports.cutToClipboard = exports.copyToClipboard = void 0;
function copyToClipboard(beans, params) {
    beans.clipboardSvc?.copyToClipboard(params);
}
exports.copyToClipboard = copyToClipboard;
function cutToClipboard(beans, params) {
    beans.clipboardSvc?.cutToClipboard(params);
}
exports.cutToClipboard = cutToClipboard;
function copySelectedRowsToClipboard(beans, params) {
    beans.clipboardSvc?.copySelectedRowsToClipboard(params);
}
exports.copySelectedRowsToClipboard = copySelectedRowsToClipboard;
function copySelectedRangeToClipboard(beans, params) {
    beans.clipboardSvc?.copySelectedRangeToClipboard(params);
}
exports.copySelectedRangeToClipboard = copySelectedRangeToClipboard;
function copySelectedRangeDown(beans) {
    beans.clipboardSvc?.copyRangeDown();
}
exports.copySelectedRangeDown = copySelectedRangeDown;
function pasteFromClipboard(beans) {
    beans.clipboardSvc?.pasteFromClipboard();
}
exports.pasteFromClipboard = pasteFromClipboard;


/***/ }),

/***/ 3766:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipboardModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const clipboardApi_1 = __webpack_require__(9112);
const clipboardService_1 = __webpack_require__(5519);
/**
 * @feature Import & Export -> Clipboard
 */
exports.ClipboardModule = {
    moduleName: 'Clipboard',
    version: version_1.VERSION,
    beans: [clipboardService_1.ClipboardService],
    apiFunctions: {
        copyToClipboard: clipboardApi_1.copyToClipboard,
        cutToClipboard: clipboardApi_1.cutToClipboard,
        copySelectedRowsToClipboard: clipboardApi_1.copySelectedRowsToClipboard,
        copySelectedRangeToClipboard: clipboardApi_1.copySelectedRangeToClipboard,
        copySelectedRangeDown: clipboardApi_1.copySelectedRangeDown,
        pasteFromClipboard: clipboardApi_1.pasteFromClipboard,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1.CsvExportModule, ag_grid_community_1._KeyboardNavigationModule, ag_grid_community_1.HighlightChangesModule],
};


/***/ }),

/***/ 5519:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipboardService = exports.stringToArray = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
// Matches value in changeDetectionService
const SOURCE_PASTE = 'paste';
const EXPORT_TYPE_DRAG_COPY = 'dragCopy';
const EXPORT_TYPE_CLIPBOARD = 'clipboard';
var CellClearType;
(function (CellClearType) {
    CellClearType[CellClearType["CellRange"] = 0] = "CellRange";
    CellClearType[CellClearType["SelectedRows"] = 1] = "SelectedRows";
    CellClearType[CellClearType["FocusedCell"] = 2] = "FocusedCell";
})(CellClearType || (CellClearType = {}));
// This will parse a delimited string into an array of arrays.
function stringToArray(strData, delimiter = ',') {
    const data = [];
    const isNewline = (char) => char === '\r' || char === '\n';
    let insideQuotedField = false;
    if (strData === '') {
        return [['']];
    }
    // iterate over each character, keep track of current row and column (of the returned array)
    for (let row = 0, column = 0, position = 0; position < strData.length; position++) {
        const previousChar = strData[position - 1];
        const currentChar = strData[position];
        const nextChar = strData[position + 1];
        const ensureDataExists = () => {
            if (!data[row]) {
                // create row if it doesn't exist
                data[row] = [];
            }
            if (!data[row][column]) {
                // create column if it doesn't exist
                data[row][column] = '';
            }
        };
        ensureDataExists();
        if (currentChar === '"') {
            if (insideQuotedField) {
                if (nextChar === '"') {
                    // unescape double quote
                    data[row][column] += '"';
                    position++;
                }
                else {
                    // exit quoted field
                    insideQuotedField = false;
                }
                // continue;
            }
            else if (previousChar === undefined || previousChar === delimiter || isNewline(previousChar)) {
                // enter quoted field
                insideQuotedField = true;
                // continue;
            }
        }
        if (!insideQuotedField && currentChar !== '"') {
            if (currentChar === delimiter) {
                // move to next column
                column++;
                ensureDataExists();
                continue;
            }
            else if (isNewline(currentChar)) {
                // move to next row
                column = 0;
                row++;
                ensureDataExists();
                if (currentChar === '\r' && nextChar === '\n') {
                    // skip over second newline character if it exists
                    position++;
                }
                continue;
            }
        }
        // add current character to current column
        data[row][column] += currentChar;
    }
    return data;
}
exports.stringToArray = stringToArray;
class ClipboardService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'clipboardSvc';
        this.clientSideRowModel = null;
        this.gridCtrl = null;
        this.lastPasteOperationTime = 0;
        this.navigatorApiFailed = false;
    }
    postConstruct() {
        const { gos, rowModel, ctrlsSvc } = this.beans;
        if ((0, ag_grid_community_1._isClientSideRowModel)(gos, rowModel)) {
            this.clientSideRowModel = rowModel;
        }
        ctrlsSvc.whenReady(this, (p) => {
            this.gridCtrl = p.gridCtrl;
        });
    }
    destroy() {
        super.destroy();
        this.clientSideRowModel = null;
        this.gridCtrl = null;
    }
    pasteFromClipboard() {
        // Method 1 - native clipboard API, available in modern chrome browsers
        const allowNavigator = !this.gos.get('suppressClipboardApi');
        // Some browsers (Firefox) do not allow Web Applications to read from
        // the clipboard so verify if not only the ClipboardAPI is available,
        // but also if the `readText` method is public.
        if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {
            navigator.clipboard
                .readText()
                .then(this.processClipboardData.bind(this))
                .catch((e) => {
                (0, ag_grid_community_1._warn)(40, { e, method: 'readText' });
                this.navigatorApiFailed = true;
                this.pasteFromClipboardLegacy();
            });
        }
        else {
            this.pasteFromClipboardLegacy();
        }
    }
    pasteFromClipboardLegacy() {
        // Method 2 - if modern API fails, the old school hack
        let defaultPrevented = false;
        const handlePasteEvent = (e) => {
            const currentPastOperationTime = new Date().getTime();
            if (currentPastOperationTime - this.lastPasteOperationTime < 50) {
                defaultPrevented = true;
                e.preventDefault();
            }
            this.lastPasteOperationTime = currentPastOperationTime;
        };
        this.executeOnTempElement((textArea) => {
            textArea.addEventListener('paste', handlePasteEvent);
            textArea.focus({ preventScroll: true });
        }, (element) => {
            const data = element.value;
            if (!defaultPrevented) {
                this.processClipboardData(data);
            }
            else {
                this.refocusLastFocusedCell();
            }
            element.removeEventListener('paste', handlePasteEvent);
        });
    }
    refocusLastFocusedCell() {
        const { focusSvc } = this.beans;
        const focusedCell = focusSvc.getFocusedCell();
        if (focusedCell) {
            focusSvc.setFocusedCell({
                rowIndex: focusedCell.rowIndex,
                column: focusedCell.column,
                rowPinned: focusedCell.rowPinned,
                forceBrowserFocus: true,
            });
        }
    }
    getClipboardDelimiter() {
        const delimiter = this.gos.get('clipboardDelimiter');
        return (0, ag_grid_community_1._exists)(delimiter) ? delimiter : '\t';
    }
    processClipboardData(data) {
        if (data == null) {
            return;
        }
        let parsedData = stringToArray(data, this.getClipboardDelimiter());
        const userFunc = this.gos.getCallback('processDataFromClipboard');
        if (userFunc) {
            parsedData = userFunc({ data: parsedData });
        }
        if (parsedData == null) {
            return;
        }
        if (this.gos.get('suppressLastEmptyLineOnPaste')) {
            this.removeLastLineIfBlank(parsedData);
        }
        const { rangeSvc } = this.beans;
        const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {
            const rangeActive = rangeSvc?.isMoreThanOneCell();
            const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData);
            if (pasteIntoRange) {
                this.pasteIntoActiveRange(rangeSvc, parsedData, cellsToFlash, updatedRowNodes, changedPath);
            }
            else {
                this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);
            }
        };
        this.doPasteOperation(pasteOperation);
    }
    // common code to paste operations, e.g. paste to cell, paste to range, and copy range down
    doPasteOperation(pasteOperationFunc) {
        const source = 'clipboard';
        const { eventSvc, focusSvc, rowRenderer, gos } = this.beans;
        eventSvc.dispatchEvent({
            type: 'pasteStart',
            source,
        });
        const { clientSideRowModel } = this;
        const rootNode = clientSideRowModel?.rootNode;
        const changedPath = rootNode && new ag_grid_community_1.ChangedPath(gos.get('aggregateOnlyChangedColumns'), rootNode);
        const cellsToFlash = {};
        const updatedRowNodes = [];
        const focusedCell = focusSvc.getFocusedCell();
        pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);
        const nodesToRefresh = [...updatedRowNodes];
        if (changedPath) {
            clientSideRowModel.doAggregate(changedPath);
            // add all nodes impacted by aggregation, as they need refreshed also.
            changedPath.forEachChangedNodeDepthFirst((rowNode) => {
                nodesToRefresh.push(rowNode);
            });
        }
        // clipboardSvc has to do changeDetection itself, to prevent repeat logic in favour of batching.
        // changeDetectionSvc is disabled for this action.
        rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
        this.dispatchFlashCells(cellsToFlash);
        this.fireRowChanged(updatedRowNodes);
        // if using the clipboard hack with a temp element, then the focus has been lost,
        // so need to put it back. otherwise paste operation loosed focus on cell and keyboard
        // navigation stops.
        this.refocusLastFocusedCell();
        eventSvc.dispatchEvent({
            type: 'pasteEnd',
            source,
        });
    }
    pasteIntoActiveRange(rangeSvc, clipboardData, cellsToFlash, updatedRowNodes, changedPath) {
        // true if clipboard data can be evenly pasted into range, otherwise false
        const abortRepeatingPasteIntoRows = this.getRangeSize(rangeSvc) % clipboardData.length != 0;
        let indexOffset = 0;
        let dataRowIndex = 0;
        const rowCallback = (currentRow, rowNode, columns, index) => {
            const atEndOfClipboardData = index - indexOffset >= clipboardData.length;
            if (atEndOfClipboardData) {
                if (abortRepeatingPasteIntoRows) {
                    return;
                }
                // increment offset and reset data index to repeat paste of data
                indexOffset += dataRowIndex;
                dataRowIndex = 0;
            }
            const currentRowData = clipboardData[index - indexOffset];
            // otherwise we are not the first row, so copy
            updatedRowNodes.push(rowNode);
            const processCellFromClipboardFunc = this.gos.getCallback('processCellFromClipboard');
            columns.forEach((column, idx) => {
                if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {
                    return;
                }
                // repeat data for columns we don't have data for - happens when to range is bigger than copied data range
                if (idx >= currentRowData.length) {
                    idx = idx % currentRowData.length;
                }
                const newValue = this.processCell(rowNode, column, currentRowData[idx], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);
                rowNode.setDataValue(column, newValue, SOURCE_PASTE);
                if (changedPath) {
                    changedPath.addParentNode(rowNode.parent, [column]);
                }
                const { rowIndex, rowPinned } = currentRow;
                const cellId = (0, ag_grid_community_1._createCellId)({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            });
            dataRowIndex++;
        };
        this.iterateActiveRanges(false, rowCallback);
    }
    getDisplayedColumnsStartingAt(column) {
        let currentColumn = column;
        const columns = [];
        const visibleCols = this.beans.visibleCols;
        while (currentColumn != null) {
            columns.push(currentColumn);
            currentColumn = visibleCols.getColAfter(currentColumn);
        }
        return columns;
    }
    pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {
        if (!focusedCell) {
            return;
        }
        const currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };
        const columnsToPasteInto = this.getDisplayedColumnsStartingAt(focusedCell.column);
        if (this.isPasteSingleValueIntoRange(parsedData)) {
            this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);
        }
        else {
            this.pasteMultipleValues(parsedData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath);
        }
    }
    // if range is active, and only one cell, then we paste this cell into all cells in the active range.
    isPasteSingleValueIntoRange(parsedData) {
        const rangeSvc = this.beans.rangeSvc;
        return this.hasOnlyOneValueToPaste(parsedData) && !!rangeSvc && !rangeSvc.isEmpty();
    }
    pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath) {
        const value = parsedData[0][0];
        const rowCallback = (currentRow, rowNode, columns) => {
            updatedRowNodes.push(rowNode);
            columns.forEach((column) => this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath));
        };
        this.iterateActiveRanges(false, rowCallback);
    }
    hasOnlyOneValueToPaste(parsedData) {
        return parsedData.length === 1 && parsedData[0].length === 1;
    }
    copyRangeDown() {
        const { rangeSvc, gos, valueSvc } = this.beans;
        if (!rangeSvc || rangeSvc.isEmpty()) {
            return;
        }
        const firstRowValues = [];
        const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {
            const processCellForClipboardFunc = gos.getCallback('processCellForClipboard');
            const processCellFromClipboardFunc = gos.getCallback('processCellFromClipboard');
            const rowCallback = (currentRow, rowNode, columns) => {
                // take reference of first row, this is the one we will be using to copy from
                if (!firstRowValues.length) {
                    // two reasons for looping through columns
                    columns.forEach((column) => {
                        // get the initial values to copy down
                        const value = this.processCell(rowNode, column, valueSvc.getValue(column, rowNode), EXPORT_TYPE_DRAG_COPY, processCellForClipboardFunc, false, true);
                        firstRowValues.push(value);
                    });
                }
                else {
                    // otherwise we are not the first row, so copy
                    updatedRowNodes.push(rowNode);
                    columns.forEach((column, index) => {
                        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {
                            return;
                        }
                        const firstRowValue = this.processCell(rowNode, column, firstRowValues[index], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);
                        rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);
                        if (changedPath) {
                            changedPath.addParentNode(rowNode.parent, [column]);
                        }
                        const { rowIndex, rowPinned } = currentRow;
                        const cellId = (0, ag_grid_community_1._createCellId)({ rowIndex, column, rowPinned });
                        cellsToFlash[cellId] = true;
                    });
                }
            };
            this.iterateActiveRanges(true, rowCallback);
        };
        this.doPasteOperation(pasteOperation);
    }
    removeLastLineIfBlank(parsedData) {
        // remove last row if empty, excel puts empty last row in
        const lastLine = (0, ag_grid_community_1._last)(parsedData);
        const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === '';
        if (lastLineIsBlank) {
            // do not remove the last empty line when that is the only line pasted
            if (parsedData.length === 1) {
                return;
            }
            (0, ag_grid_community_1._removeFromArray)(parsedData, lastLine);
        }
    }
    fireRowChanged(rowNodes) {
        if (this.gos.get('editType') !== 'fullRow') {
            return;
        }
        rowNodes.forEach((rowNode) => {
            this.eventSvc.dispatchEvent({
                type: 'rowValueChanged',
                node: rowNode,
                data: rowNode.data,
                rowIndex: rowNode.rowIndex,
                rowPinned: rowNode.rowPinned,
            });
        });
    }
    pasteMultipleValues(clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {
        let rowPointer = currentRow;
        const beans = this.beans;
        const { gos, cellNavigation } = beans;
        // if doing CSRM and NOT tree data, then it means groups are aggregates, which are read only,
        // so we should skip them when doing paste operations.
        const skipGroupRows = this.clientSideRowModel != null && !gos.get('enableGroupEdit') && !gos.get('treeData');
        const getNextGoodRowNode = () => {
            while (true) {
                if (!rowPointer) {
                    return null;
                }
                const res = (0, ag_grid_community_1._getRowNode)(beans, rowPointer);
                // move to next row down for next set of values
                rowPointer = cellNavigation.getRowBelow({
                    rowPinned: rowPointer.rowPinned,
                    rowIndex: rowPointer.rowIndex,
                });
                // if no more rows, return null
                if (res == null) {
                    return null;
                }
                // skip details rows and footer rows, never paste into them as they don't hold data
                const skipRow = res.detail || res.footer || (skipGroupRows && res.group);
                // skipping row means we go into the next iteration of the while loop
                if (!skipRow) {
                    return res;
                }
            }
        };
        clipboardGridData.forEach((clipboardRowData) => {
            const rowNode = getNextGoodRowNode();
            // if we have come to end of rows in grid, then skip
            if (!rowNode) {
                return;
            }
            clipboardRowData.forEach((value, index) => this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath));
            updatedRowNodes.push(rowNode);
        });
    }
    updateCellValue(rowNode, column, value, cellsToFlash, type, changedPath) {
        if (!rowNode || !column || !column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {
            return;
        }
        const processedValue = this.processCell(rowNode, column, value, type, this.gos.getCallback('processCellFromClipboard'), true);
        rowNode.setDataValue(column, processedValue, SOURCE_PASTE);
        const { rowIndex, rowPinned } = rowNode;
        const cellId = (0, ag_grid_community_1._createCellId)({ rowIndex: rowIndex, column, rowPinned });
        cellsToFlash[cellId] = true;
        if (changedPath) {
            changedPath.addParentNode(rowNode.parent, [column]);
        }
    }
    copyToClipboard(params = {}) {
        this.copyOrCutToClipboard(params);
    }
    cutToClipboard(params = {}, source = 'api') {
        if (this.gos.get('suppressCutToClipboard')) {
            return;
        }
        this.eventSvc.dispatchEvent({
            type: 'cutStart',
            source,
        });
        this.copyOrCutToClipboard(params, true);
        this.eventSvc.dispatchEvent({
            type: 'cutEnd',
            source,
        });
    }
    copyOrCutToClipboard(params, cut) {
        let { includeHeaders, includeGroupHeaders } = params;
        const { gos, focusSvc } = this.beans;
        // don't override 'includeHeaders' if it has been explicitly set to 'false'
        if (includeHeaders == null) {
            includeHeaders = gos.get('copyHeadersToClipboard');
        }
        if (includeGroupHeaders == null) {
            includeGroupHeaders = gos.get('copyGroupHeadersToClipboard');
        }
        const copyParams = { includeHeaders, includeGroupHeaders };
        const rowSelection = gos.get('rowSelection');
        const cellSelection = gos.get('cellSelection');
        let cellClearType = null;
        // Copy priority is Range > Row > Focus
        if (this.shouldCopyCells(cellSelection, rowSelection)) {
            this.copySelectedRangeToClipboard(copyParams);
            cellClearType = CellClearType.CellRange;
        }
        else if (this.shouldCopyRows(rowSelection)) {
            this.copySelectedRowsToClipboard(copyParams);
            cellClearType = CellClearType.SelectedRows;
        }
        else if (focusSvc.isAnyCellFocused()) {
            this.copyFocusedCellToClipboard(copyParams);
            cellClearType = CellClearType.FocusedCell;
        }
        if (cut && cellClearType !== null) {
            this.clearCellsAfterCopy(cellClearType);
        }
    }
    shouldCopyCells(cellSelection, rowSelection) {
        const { rangeSvc, selectionSvc, gos } = this.beans;
        if (!rangeSvc || rangeSvc.isEmpty()) {
            return false;
        }
        if (cellSelection) {
            // If `cellSelection` is defined, user is using the new cell selection API, so we only copy
            // cells by default.
            const shouldCopyRowsInstead = typeof rowSelection === 'object' && rowSelection.copySelectedRows && !selectionSvc?.isEmpty();
            return !shouldCopyRowsInstead;
        }
        else {
            // If user is using the deprecated API, we preserve the previous behaviour
            const suppressCopySingleCellRanges = gos.get('suppressCopySingleCellRanges');
            const shouldSkip = !rangeSvc.isMoreThanOneCell() && suppressCopySingleCellRanges;
            return !shouldSkip;
        }
    }
    shouldCopyRows(rowSelection) {
        const { selectionSvc, gos } = this.beans;
        if (selectionSvc?.isEmpty() ?? true) {
            return false;
        }
        if (rowSelection && typeof rowSelection !== 'string') {
            // If `rowSelection` is defined as an object, user is using the new selection API, so we determine
            // behaviour based on `copySelectedRows`
            return rowSelection.copySelectedRows ?? false;
        }
        else {
            // If user is using the deprecated API, we preserve the previous behaviour
            return !gos.get('suppressCopyRowsToClipboard');
        }
    }
    clearCellsAfterCopy(type) {
        const beans = this.beans;
        const { rangeSvc, focusSvc, eventSvc } = beans;
        eventSvc.dispatchEvent({ type: 'keyShortcutChangedCellStart' });
        if (type === CellClearType.CellRange) {
            rangeSvc.clearCellRangeCellValues({ cellEventSource: 'clipboardSvc' });
        }
        else if (type === CellClearType.SelectedRows) {
            this.clearSelectedRows();
        }
        else {
            const focusedCell = focusSvc.getFocusedCell();
            if (focusedCell == null) {
                return;
            }
            const rowNode = (0, ag_grid_community_1._getRowNode)(beans, focusedCell);
            if (rowNode) {
                this.clearCellValue(rowNode, focusedCell.column);
            }
        }
        eventSvc.dispatchEvent({ type: 'keyShortcutChangedCellEnd' });
    }
    clearSelectedRows() {
        const { selectionSvc, visibleCols } = this.beans;
        const selected = selectionSvc?.getSelectedNodes() ?? [];
        const columns = visibleCols.allCols;
        for (const row of selected) {
            for (const col of columns) {
                this.clearCellValue(row, col);
            }
        }
    }
    clearCellValue(rowNode, column) {
        if (!column.isCellEditable(rowNode)) {
            return;
        }
        const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
        rowNode.setDataValue(column, emptyValue, 'clipboardSvc');
    }
    iterateActiveRanges(onlyFirst, rowCallback, columnCallback) {
        const rangeSvc = this.beans.rangeSvc;
        if (!rangeSvc || rangeSvc.isEmpty()) {
            return;
        }
        const cellRanges = rangeSvc.getCellRanges();
        if (onlyFirst) {
            this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);
        }
        else {
            cellRanges.forEach((range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1));
        }
    }
    iterateActiveRange(range, rowCallback, columnCallback, isLastRange) {
        const { rangeSvc, cellNavigation } = this.beans;
        if (!rangeSvc) {
            return;
        }
        let currentRow = rangeSvc.getRangeStartRow(range);
        const lastRow = rangeSvc.getRangeEndRow(range);
        if (columnCallback && range.columns) {
            columnCallback(range.columns);
        }
        let rangeIndex = 0;
        let isLastRow = false;
        // the currentRow could be missing if the user sets the active range manually, and sets a range
        // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).
        while (!isLastRow && currentRow != null) {
            const rowNode = (0, ag_grid_community_1._getRowNode)(this.beans, currentRow);
            isLastRow = (0, ag_grid_community_1._isSameRow)(currentRow, lastRow);
            rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);
            currentRow = cellNavigation.getRowBelow(currentRow);
        }
    }
    copySelectedRangeToClipboard(params = {}) {
        const rangeSvc = this.beans.rangeSvc;
        if (!rangeSvc || rangeSvc.isEmpty()) {
            return;
        }
        const allRangesMerge = rangeSvc.areAllRangesAbleToMerge();
        const { data, cellsToFlash } = allRangesMerge
            ? this.buildDataFromMergedRanges(rangeSvc, params)
            : this.buildDataFromRanges(rangeSvc, params);
        this.copyDataToClipboard(data);
        this.dispatchFlashCells(cellsToFlash);
    }
    buildDataFromMergedRanges(rangeSvc, params) {
        const columnsSet = new Set();
        const ranges = rangeSvc.getCellRanges();
        const rowPositionsMap = new Map();
        const allRowPositions = [];
        const allCellsToFlash = {};
        ranges.forEach((range) => {
            range.columns.forEach((col) => columnsSet.add(col));
            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeSvc, range);
            rowPositions.forEach((rowPosition) => {
                const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || 'null'}`;
                if (!rowPositionsMap.get(rowPositionAsString)) {
                    rowPositionsMap.set(rowPositionAsString, true);
                    allRowPositions.push(rowPosition);
                }
            });
            Object.assign(allCellsToFlash, cellsToFlash);
        });
        const allColumns = this.beans.visibleCols.allCols;
        const exportedColumns = Array.from(columnsSet);
        exportedColumns.sort((a, b) => {
            const posA = allColumns.indexOf(a);
            const posB = allColumns.indexOf(b);
            return posA - posB;
        });
        const data = this.buildExportParams({
            columns: exportedColumns,
            rowPositions: allRowPositions,
            includeHeaders: params.includeHeaders,
            includeGroupHeaders: params.includeGroupHeaders,
        });
        return { data, cellsToFlash: allCellsToFlash };
    }
    buildDataFromRanges(rangeSvc, params) {
        const ranges = rangeSvc.getCellRanges();
        const data = [];
        const allCellsToFlash = {};
        ranges.forEach((range) => {
            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeSvc, range);
            Object.assign(allCellsToFlash, cellsToFlash);
            data.push(this.buildExportParams({
                columns: range.columns,
                rowPositions: rowPositions,
                includeHeaders: params.includeHeaders,
                includeGroupHeaders: params.includeGroupHeaders,
            }));
        });
        return { data: data.join('\n'), cellsToFlash: allCellsToFlash };
    }
    getRangeRowPositionsAndCellsToFlash(rangeSvc, range) {
        const rowPositions = [];
        const cellsToFlash = {};
        const startRow = rangeSvc.getRangeStartRow(range);
        const lastRow = rangeSvc.getRangeEndRow(range);
        let node = startRow;
        while (node) {
            rowPositions.push(node);
            range.columns.forEach((column) => {
                const { rowIndex, rowPinned } = node;
                const cellId = (0, ag_grid_community_1._createCellId)({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            });
            if ((0, ag_grid_community_1._isSameRow)(node, lastRow)) {
                break;
            }
            node = this.beans.cellNavigation.getRowBelow(node);
        }
        return { rowPositions, cellsToFlash };
    }
    getCellsToFlashFromRowNodes(rowNodes) {
        const allDisplayedColumns = this.beans.visibleCols.allCols;
        const cellsToFlash = {};
        for (let i = 0; i < rowNodes.length; i++) {
            const { level, rowIndex: index, rowPinned, sibling } = rowNodes[i];
            // Account for the grand total row (sibling of root node)
            const rowIndex = level === -1 ? sibling.rowIndex : index;
            if (rowIndex == null) {
                continue;
            }
            for (let j = 0; j < allDisplayedColumns.length; j++) {
                const column = allDisplayedColumns[j];
                const cellId = (0, ag_grid_community_1._createCellId)({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            }
        }
        return cellsToFlash;
    }
    copyFocusedCellToClipboard(params = {}) {
        const focusedCell = this.beans.focusSvc.getFocusedCell();
        if (focusedCell == null) {
            return;
        }
        const cellId = (0, ag_grid_community_1._createCellId)(focusedCell);
        const currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };
        const column = focusedCell.column;
        const data = this.buildExportParams({
            columns: [column],
            rowPositions: [currentRow],
            includeHeaders: params.includeHeaders,
            includeGroupHeaders: params.includeGroupHeaders,
        });
        this.copyDataToClipboard(data);
        this.dispatchFlashCells({ [cellId]: true });
    }
    copySelectedRowsToClipboard(params = {}) {
        const { columnKeys, includeHeaders, includeGroupHeaders } = params;
        const data = this.buildExportParams({
            columns: columnKeys,
            includeHeaders,
            includeGroupHeaders,
        });
        this.copyDataToClipboard(data);
        const rowNodes = this.beans.selectionSvc?.getSelectedNodes() || [];
        this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));
    }
    buildExportParams(params) {
        const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;
        const { gos, csvCreator } = this.beans;
        const exportParams = {
            columnKeys: columns,
            rowPositions,
            skipColumnHeaders: !includeHeaders,
            skipColumnGroupHeaders: !includeGroupHeaders,
            suppressQuotes: true,
            columnSeparator: this.getClipboardDelimiter(),
            onlySelected: !rowPositions,
            processCellCallback: gos.getCallback('processCellForClipboard'),
            processRowGroupCallback: (params) => this.processRowGroupCallback(params),
            processHeaderCallback: gos.getCallback('processHeaderForClipboard'),
            processGroupHeaderCallback: gos.getCallback('processGroupHeaderForClipboard'),
        };
        return csvCreator.getDataAsCsv(exportParams, true);
    }
    processRowGroupCallback({ node, column }) {
        const { gos, valueSvc, rowGroupColsSvc } = this.beans;
        const isTreeData = gos.get('treeData');
        // if not tree datathen we get the value from the group data
        const getValueFromNode = () => {
            if (isTreeData || !column) {
                return node.key;
            }
            const value = node.groupData?.[column.getId()];
            if (!value ||
                !node.rowGroupColumn ||
                node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {
                return value;
            }
            return valueSvc.formatValue(node.rowGroupColumn, node, value) ?? value;
        };
        let value = getValueFromNode();
        if (node.footer) {
            let suffix = '';
            if (value && value.length) {
                suffix = ` ${value}`;
            }
            value = `Total${suffix}`;
        }
        const processCellForClipboard = gos.getCallback('processCellForClipboard');
        if (processCellForClipboard) {
            let column = node.rowGroupColumn;
            if (!column && node.footer && node.level === -1 && rowGroupColsSvc) {
                column = rowGroupColsSvc.columns[0];
            }
            return processCellForClipboard({
                value,
                node,
                column,
                type: 'clipboard',
                formatValue: (valueToFormat) => valueSvc.formatValue(column, node, valueToFormat) ?? valueToFormat,
                parseValue: (valueToParse) => valueSvc.parseValue(column, node, valueToParse, valueSvc.getValue(column, node)),
            });
        }
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    dispatchFlashCells(cellsToFlash) {
        window.setTimeout(() => {
            this.eventSvc.dispatchEvent({
                type: 'flashCells',
                cells: cellsToFlash,
            });
        }, 0);
    }
    processCell(rowNode, column, value, type, func, canParse, canFormat) {
        const valueSvc = this.beans.valueSvc;
        if (func) {
            const params = {
                column,
                node: rowNode,
                value,
                type,
                formatValue: (valueToFormat) => valueSvc.formatValue(column, rowNode ?? null, valueToFormat) ?? valueToFormat,
                parseValue: (valueToParse) => valueSvc.parseValue(column, rowNode ?? null, valueToParse, valueSvc.getValue(column, rowNode)),
            };
            return func(params);
        }
        if (canParse && column.getColDef().useValueParserForImport !== false) {
            return valueSvc.parseValue(column, rowNode ?? null, value, valueSvc.getValue(column, rowNode));
        }
        if (canFormat && column.getColDef().useValueFormatterForExport !== false) {
            return valueSvc.formatValue(column, rowNode ?? null, value) ?? value;
        }
        return value;
    }
    copyDataToClipboard(data) {
        const userProvidedFunc = this.gos.getCallback('sendToClipboard');
        // method 1 - user provided func
        if (userProvidedFunc) {
            userProvidedFunc({ data });
            return;
        }
        // method 2 - native clipboard API, available in modern chrome browsers
        const allowNavigator = !this.gos.get('suppressClipboardApi');
        if (allowNavigator && navigator.clipboard) {
            navigator.clipboard.writeText(data).catch((e) => {
                (0, ag_grid_community_1._warn)(40, { e, method: 'writeText' });
                this.copyDataToClipboardLegacy(data);
            });
            return;
        }
        this.copyDataToClipboardLegacy(data);
    }
    copyDataToClipboardLegacy(data) {
        // method 3 - if all else fails, the old school hack
        this.executeOnTempElement((element) => {
            const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
            const focusedElementBefore = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
            element.value = data || ' '; // has to be non-empty value or execCommand will not do anything
            element.select();
            element.focus({ preventScroll: true });
            const result = eDocument.execCommand('copy');
            if (!result) {
                (0, ag_grid_community_1._warn)(41);
            }
            if (focusedElementBefore != null && focusedElementBefore.focus != null) {
                focusedElementBefore.focus({ preventScroll: true });
            }
        });
    }
    executeOnTempElement(callbackNow, callbackAfter) {
        if (!this.gridCtrl) {
            return;
        }
        const eDoc = (0, ag_grid_community_1._getDocument)(this.beans);
        const eTempInput = eDoc.createElement('textarea');
        const style = eTempInput.style;
        style.width = '1px';
        style.height = '1px';
        // removing items from the DOM causes the document element to scroll to the
        // position where the element was positioned. Here we set scrollTop / scrollLeft
        // to prevent the document element from scrolling when we remove it from the DOM.
        const documentElement = eDoc.documentElement;
        style.top = documentElement.scrollTop + 'px';
        style.left = documentElement.scrollLeft + 'px';
        style.position = 'absolute';
        style.opacity = '0';
        const guiRoot = this.gridCtrl.getGui();
        guiRoot.appendChild(eTempInput);
        try {
            callbackNow(eTempInput);
        }
        catch (err) {
            (0, ag_grid_community_1._warn)(42);
        }
        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...
        if (callbackAfter) {
            window.setTimeout(() => {
                callbackAfter(eTempInput);
                guiRoot.removeChild(eTempInput);
            }, 100);
        }
        else {
            guiRoot.removeChild(eTempInput);
        }
    }
    getRangeSize(rangeSvc) {
        const ranges = rangeSvc.getCellRanges();
        let startRangeIndex = 0;
        let endRangeIndex = 0;
        if (ranges.length > 0) {
            startRangeIndex = rangeSvc.getRangeStartRow(ranges[0]).rowIndex;
            endRangeIndex = rangeSvc.getRangeEndRow(ranges[0]).rowIndex;
        }
        return startRangeIndex - endRangeIndex + 1;
    }
}
exports.ClipboardService = ClipboardService;


/***/ }),

/***/ 2664:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agPrimaryColsCSS = void 0;
exports.agPrimaryColsCSS = `.ag-column-select{display:flex;flex:3 1 0px;flex-direction:column;overflow:hidden;position:relative}.ag-column-select-header{align-items:center;display:flex;flex:none;gap:var(--ag-widget-horizontal-spacing);height:var(--ag-header-height);padding-left:var(--ag-widget-container-horizontal-padding);padding-right:var(--ag-widget-container-horizontal-padding);position:relative}.ag-column-select-column,.ag-column-select-column-group{align-items:center;display:flex;gap:var(--ag-widget-horizontal-spacing);height:100%;position:relative;&:where(:not(:last-child)){margin-bottom:var(--ag-widget-vertical-spacing)}}:where(.ag-ltr) .ag-column-select-column,:where(.ag-ltr) .ag-column-select-column-group{padding-left:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}:where(.ag-rtl) .ag-column-select-column,:where(.ag-rtl) .ag-column-select-column-group{padding-right:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}.ag-column-select-header-icon{border-radius:var(--ag-border-radius);cursor:pointer;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-column-select-header-filter-wrapper{flex:1 1 auto}.ag-column-select-header-filter{width:100%}.ag-column-select-list{flex:1 1 0px;overflow:hidden}:where(.ag-ltr) .ag-column-select-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}:where(.ag-rtl) .ag-column-select-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly{opacity:.5;pointer-events:none}.ag-column-select-virtual-list-viewport{padding:calc(var(--ag-widget-container-vertical-padding)*.5) 0}.ag-column-select-virtual-list-item{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-column-select-column-label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-select-checkbox{display:flex}`;


/***/ }),

/***/ 1269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPrimaryColsSelector = exports.AgPrimaryCols = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPrimaryCols_css_GENERATED_1 = __webpack_require__(2664);
const agPrimaryColsHeader_1 = __webpack_require__(4312);
const agPrimaryColsList_1 = __webpack_require__(5853);
class AgPrimaryCols extends ag_grid_community_1.Component {
    constructor() {
        super(
        /* html */ `<div class="ag-column-select">
            <ag-primary-cols-header data-ref="primaryColsHeaderPanel"></ag-primary-cols-header>
            <ag-primary-cols-list data-ref="primaryColsListPanel"></ag-primary-cols-list>
        </div>`, [agPrimaryColsHeader_1.AgPrimaryColsHeaderSelector, agPrimaryColsList_1.AgPrimaryColsListSelector]);
        this.primaryColsHeaderPanel = ag_grid_community_1.RefPlaceholder;
        this.primaryColsListPanel = ag_grid_community_1.RefPlaceholder;
        this.registerCSS(agPrimaryCols_css_GENERATED_1.agPrimaryColsCSS);
    }
    // we allow dragging in the toolPanel, but not when this component appears in the column menu
    init(allowDragging, params, eventType) {
        const { primaryColsHeaderPanel, primaryColsListPanel } = this;
        primaryColsHeaderPanel.init(params);
        const hideFilter = params.suppressColumnFilter;
        const hideSelect = params.suppressColumnSelectAll;
        const hideExpand = params.suppressColumnExpandAll;
        if (hideExpand && hideFilter && hideSelect) {
            primaryColsHeaderPanel.setDisplayed(false);
        }
        this.addManagedListeners(primaryColsListPanel, {
            groupExpanded: (event) => {
                primaryColsHeaderPanel.setExpandState(event.state);
                params.onStateUpdated();
            },
            selectionChanged: (event) => primaryColsHeaderPanel.setSelectionState(event.state),
        });
        primaryColsListPanel.init(params, allowDragging, eventType);
        this.addManagedListeners(primaryColsHeaderPanel, {
            expandAll: primaryColsListPanel.doSetExpandedAll.bind(primaryColsListPanel, true),
            collapseAll: primaryColsListPanel.doSetExpandedAll.bind(primaryColsListPanel, false),
            selectAll: primaryColsListPanel.doSetSelectedAll.bind(primaryColsListPanel, true),
            unselectAll: primaryColsListPanel.doSetSelectedAll.bind(primaryColsListPanel, false),
            filterChanged: (event) => primaryColsListPanel.setFilterText(event.filterText),
        });
        this.positionableFeature = this.createManagedBean(new ag_grid_community_1.PositionableFeature(this.getGui(), { minHeight: 100 }));
    }
    toggleResizable(resizable) {
        this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
    }
    expandGroups(groupIds) {
        this.primaryColsListPanel.setGroupsExpanded(true, groupIds);
    }
    collapseGroups(groupIds) {
        this.primaryColsListPanel.setGroupsExpanded(false, groupIds);
    }
    setColumnLayout(colDefs) {
        this.primaryColsListPanel.setColumnLayout(colDefs);
    }
    syncLayoutWithGrid() {
        this.primaryColsListPanel.onColumnsChanged();
    }
    getExpandedGroups() {
        return this.primaryColsListPanel.getExpandedGroups();
    }
}
exports.AgPrimaryCols = AgPrimaryCols;
exports.AgPrimaryColsSelector = {
    selector: 'AG-PRIMARY-COLS',
    component: AgPrimaryCols,
};


/***/ }),

/***/ 4312:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPrimaryColsHeaderSelector = exports.AgPrimaryColsHeader = exports.ExpandState = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
var ExpandState;
(function (ExpandState) {
    ExpandState[ExpandState["EXPANDED"] = 0] = "EXPANDED";
    ExpandState[ExpandState["COLLAPSED"] = 1] = "COLLAPSED";
    ExpandState[ExpandState["INDETERMINATE"] = 2] = "INDETERMINATE";
})(ExpandState || (exports.ExpandState = ExpandState = {}));
const DEBOUNCE_DELAY = 300;
class AgPrimaryColsHeader extends ag_grid_community_1.Component {
    constructor() {
        super(
        /* html */ `<div class="ag-column-select-header" role="presentation">
            <div data-ref="eExpand" class="ag-column-select-header-icon"></div>
            <ag-checkbox data-ref="eSelect" class="ag-column-select-header-checkbox"></ag-checkbox>
            <ag-input-text-field class="ag-column-select-header-filter-wrapper" data-ref="eFilterTextField"></ag-input-text-field>
        </div>`, [ag_grid_community_1.AgCheckboxSelector, ag_grid_community_1.AgInputTextFieldSelector]);
        this.eExpand = ag_grid_community_1.RefPlaceholder;
        this.eSelect = ag_grid_community_1.RefPlaceholder;
        this.eFilterTextField = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.createExpandIcons();
        this.addManagedListeners(this.eExpand, {
            click: this.onExpandClicked.bind(this),
            keydown: (e) => {
                if (e.key === ag_grid_community_1.KeyCode.SPACE) {
                    e.preventDefault();
                    this.onExpandClicked();
                }
            },
        });
        this.addManagedElementListeners(this.eSelect.getInputElement(), { click: this.onSelectClicked.bind(this) });
        this.addManagedPropertyListener('functionsReadOnly', () => this.onFunctionsReadOnlyPropChanged());
        this.eFilterTextField.setAutoComplete(false).onValueChange(() => this.onFilterTextChanged());
        this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
        const translate = this.getLocaleTextFunc();
        this.eSelect.setInputAriaLabel(translate('ariaColumnSelectAll', 'Toggle All Columns Visibility'));
        this.eFilterTextField.setInputAriaLabel(translate('ariaFilterColumnsInput', 'Filter Columns Input'));
        this.activateTabIndex([this.eExpand]);
    }
    onFunctionsReadOnlyPropChanged() {
        const readOnly = this.gos.get('functionsReadOnly');
        this.eSelect.setReadOnly(readOnly);
        this.eSelect.addOrRemoveCssClass('ag-column-select-column-readonly', readOnly);
    }
    init(params) {
        this.params = params;
        const readOnly = this.gos.get('functionsReadOnly');
        this.eSelect.setReadOnly(readOnly);
        this.eSelect.addOrRemoveCssClass('ag-column-select-column-readonly', readOnly);
        if (this.beans.colModel.ready) {
            this.showOrHideOptions();
        }
    }
    createExpandIcons() {
        const beans = this.beans;
        this.eExpand.appendChild((this.eExpandChecked = (0, ag_grid_community_1._createIconNoSpan)('columnSelectOpen', beans)));
        this.eExpand.appendChild((this.eExpandUnchecked = (0, ag_grid_community_1._createIconNoSpan)('columnSelectClosed', beans)));
        this.eExpand.appendChild((this.eExpandIndeterminate = (0, ag_grid_community_1._createIconNoSpan)('columnSelectIndeterminate', beans)));
        this.setExpandState(ExpandState.EXPANDED);
    }
    // we only show expand / collapse if we are showing columns
    showOrHideOptions() {
        const params = this.params;
        const showFilter = !params.suppressColumnFilter;
        const showSelect = !params.suppressColumnSelectAll;
        const showExpand = !params.suppressColumnExpandAll;
        const groupsPresent = !!this.beans.colModel.colDefCols?.treeDepth;
        const translate = this.getLocaleTextFunc();
        this.eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));
        (0, ag_grid_community_1._setDisplayed)(this.eFilterTextField.getGui(), showFilter);
        (0, ag_grid_community_1._setDisplayed)(this.eSelect.getGui(), showSelect);
        (0, ag_grid_community_1._setDisplayed)(this.eExpand, showExpand && groupsPresent);
    }
    onFilterTextChanged() {
        if (!this.onFilterTextChangedDebounced) {
            this.onFilterTextChangedDebounced = (0, ag_grid_community_1._debounce)(this, () => {
                const filterText = this.eFilterTextField.getValue();
                this.dispatchLocalEvent({ type: 'filterChanged', filterText: filterText });
            }, DEBOUNCE_DELAY);
        }
        this.onFilterTextChangedDebounced();
    }
    onSelectClicked() {
        this.dispatchLocalEvent({ type: this.selectState ? 'unselectAll' : 'selectAll' });
    }
    onExpandClicked() {
        this.dispatchLocalEvent({ type: this.expandState === ExpandState.EXPANDED ? 'collapseAll' : 'expandAll' });
    }
    setExpandState(state) {
        this.expandState = state;
        (0, ag_grid_community_1._setDisplayed)(this.eExpandChecked, state === ExpandState.EXPANDED);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandUnchecked, state === ExpandState.COLLAPSED);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandIndeterminate, state === ExpandState.INDETERMINATE);
    }
    setSelectionState(state) {
        this.selectState = state;
        this.eSelect.setValue(this.selectState);
    }
}
exports.AgPrimaryColsHeader = AgPrimaryColsHeader;
exports.AgPrimaryColsHeaderSelector = {
    selector: 'AG-PRIMARY-COLS-HEADER',
    component: AgPrimaryColsHeader,
};


/***/ }),

/***/ 5853:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPrimaryColsListSelector = exports.AgPrimaryColsList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const toolPanelColDefService_1 = __webpack_require__(6092);
const virtualList_1 = __webpack_require__(7904);
const agPrimaryColsHeader_1 = __webpack_require__(4312);
const columnModelItem_1 = __webpack_require__(2176);
const modelItemUtils_1 = __webpack_require__(4781);
const primaryColsListPanelItemDragFeature_1 = __webpack_require__(3234);
const toolPanelColumnComp_1 = __webpack_require__(4545);
const toolPanelColumnGroupComp_1 = __webpack_require__(4224);
class UIColumnModel {
    constructor(items) {
        this.items = items;
    }
    getRowCount() {
        return this.items.length;
    }
    getRow(index) {
        return this.items[index];
    }
}
const PRIMARY_COLS_LIST_PANEL_CLASS = 'ag-column-select-list';
class AgPrimaryColsList extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.colModel = beans.colModel;
    }
    constructor() {
        super(/* html */ `<div class="${PRIMARY_COLS_LIST_PANEL_CLASS}" role="presentation"></div>`);
        this.destroyColumnItemFuncs = [];
        this.hasLoadedInitialState = false;
        this.isInitialState = false;
    }
    destroy() {
        this.destroyColumnTree();
        super.destroy();
    }
    destroyColumnTree() {
        this.allColsTree = [];
        this.destroyColumnItemFuncs.forEach((f) => f());
        this.destroyColumnItemFuncs = [];
    }
    init(params, allowDragging, eventType) {
        this.params = params;
        this.allowDragging = allowDragging;
        this.eventType = eventType;
        if (!params.suppressSyncLayoutWithGrid) {
            this.addManagedEventListeners({ columnMoved: this.onColumnsChanged.bind(this) });
        }
        this.addManagedEventListeners({
            newColumnsLoaded: this.onColumnsChanged.bind(this),
        });
        const listener = this.fireSelectionChangedEvent.bind(this);
        this.addManagedEventListeners({
            columnPivotChanged: listener,
            columnPivotModeChanged: listener,
            columnRowGroupChanged: listener,
            columnValueChanged: listener,
            columnVisible: listener,
            newColumnsLoaded: listener,
        });
        this.expandGroupsByDefault = !params.contractColumnSelection;
        const virtualList = this.createManagedBean(new virtualList_1.VirtualList({
            cssIdentifier: 'column-select',
            ariaRole: 'tree',
        }));
        this.virtualList = virtualList;
        this.appendChild(virtualList.getGui());
        virtualList.setComponentCreator((item, listItemElement) => {
            (0, ag_grid_community_1._setAriaLevel)(listItemElement, item.depth + 1);
            return this.createComponentFromItem(item, listItemElement);
        });
        if (this.colModel.ready) {
            this.onColumnsChanged();
        }
        if (params.suppressColumnMove) {
            return;
        }
        this.createManagedBean(new primaryColsListPanelItemDragFeature_1.PrimaryColsListPanelItemDragFeature(this, virtualList));
    }
    createComponentFromItem(item, listItemElement) {
        const allowDragging = this.allowDragging;
        if (item.group) {
            const renderedGroup = new toolPanelColumnGroupComp_1.ToolPanelColumnGroupComp(item, allowDragging, this.eventType, listItemElement);
            this.createBean(renderedGroup);
            return renderedGroup;
        }
        const columnComp = new toolPanelColumnComp_1.ToolPanelColumnComp(item, allowDragging, this.groupsExist, listItemElement);
        this.createBean(columnComp);
        return columnComp;
    }
    onColumnsChanged() {
        const params = this.params;
        if (!this.hasLoadedInitialState) {
            this.hasLoadedInitialState = true;
            this.isInitialState = !!params.initialState;
        }
        const expandedStates = this.getExpandedStates();
        const pivotModeActive = this.colModel.isPivotMode();
        const shouldSyncColumnLayoutWithGrid = !params.suppressSyncLayoutWithGrid && !pivotModeActive;
        if (shouldSyncColumnLayoutWithGrid) {
            this.buildTreeFromWhatGridIsDisplaying();
        }
        else {
            this.buildTreeFromProvidedColumnDefs();
        }
        this.setExpandedStates(expandedStates);
        this.markFilteredColumns();
        this.flattenAndFilterModel();
        this.isInitialState = false;
    }
    getDisplayedColsList() {
        return this.displayedColsList;
    }
    getExpandedStates() {
        const res = {};
        if (this.isInitialState) {
            const { expandedGroupIds } = this.params.initialState;
            expandedGroupIds.forEach((id) => {
                res[id] = true;
            });
            return res;
        }
        if (!this.allColsTree) {
            return {};
        }
        this.forEachItem((item) => {
            if (!item.group) {
                return;
            }
            const colGroup = item.columnGroup;
            if (colGroup) {
                // group should always exist, this is defensive
                res[colGroup.getId()] = item.expanded;
            }
        });
        return res;
    }
    setExpandedStates(states) {
        if (!this.allColsTree) {
            return;
        }
        const { isInitialState } = this;
        this.forEachItem((item) => {
            if (!item.group) {
                return;
            }
            const colGroup = item.columnGroup;
            if (colGroup) {
                // group should always exist, this is defensive
                const expanded = states[colGroup.getId()];
                const groupExistedLastTime = expanded != null;
                if (groupExistedLastTime || isInitialState) {
                    item.expanded = !!expanded;
                }
            }
        });
    }
    buildTreeFromWhatGridIsDisplaying() {
        (0, toolPanelColDefService_1.syncLayoutWithGrid)(this.colModel, this.setColumnLayout.bind(this));
    }
    setColumnLayout(colDefs) {
        const columnTree = (0, toolPanelColDefService_1.toolPanelCreateColumnTree)(this.colModel, colDefs);
        this.buildListModel(columnTree);
        // using col defs to check if groups exist as it could be a custom layout
        this.groupsExist = colDefs.some((colDef) => {
            return colDef && typeof colDef.children !== 'undefined';
        });
        this.markFilteredColumns();
        this.flattenAndFilterModel();
    }
    buildTreeFromProvidedColumnDefs() {
        const colModel = this.colModel;
        // add column / group comps to tool panel
        this.buildListModel(colModel.getColDefColTree());
        this.groupsExist = !!colModel.colDefCols?.treeDepth;
    }
    buildListModel(columnTree) {
        const columnExpandedListener = this.onColumnExpanded.bind(this);
        const addListeners = (item) => {
            item.addEventListener('expandedChanged', columnExpandedListener);
            const removeFunc = item.removeEventListener.bind(item, 'expandedChanged', columnExpandedListener);
            this.destroyColumnItemFuncs.push(removeFunc);
        };
        const colNames = this.beans.colNames;
        const recursivelyBuild = (tree, dept, parentList) => {
            tree.forEach((child) => {
                if ((0, ag_grid_community_1.isProvidedColumnGroup)(child)) {
                    createGroupItem(child, dept, parentList);
                }
                else {
                    createColumnItem(child, dept, parentList);
                }
            });
        };
        const createGroupItem = (columnGroup, dept, parentList) => {
            const columnGroupDef = columnGroup.getColGroupDef();
            const skipThisGroup = columnGroupDef && columnGroupDef.suppressColumnsToolPanel;
            if (skipThisGroup) {
                return;
            }
            if (columnGroup.isPadding()) {
                recursivelyBuild(columnGroup.getChildren(), dept, parentList);
                return;
            }
            const displayName = colNames.getDisplayNameForProvidedColumnGroup(null, columnGroup, 'columnToolPanel');
            const item = new columnModelItem_1.ColumnModelItem(displayName, columnGroup, dept, true, this.expandGroupsByDefault);
            parentList.push(item);
            addListeners(item);
            recursivelyBuild(columnGroup.getChildren(), dept + 1, item.children);
        };
        const createColumnItem = (column, dept, parentList) => {
            const skipThisColumn = column.getColDef() && column.getColDef().suppressColumnsToolPanel;
            if (skipThisColumn) {
                return;
            }
            const displayName = colNames.getDisplayNameForColumn(column, 'columnToolPanel');
            parentList.push(new columnModelItem_1.ColumnModelItem(displayName, column, dept));
        };
        this.destroyColumnTree();
        recursivelyBuild(columnTree, 0, this.allColsTree);
    }
    onColumnExpanded() {
        this.flattenAndFilterModel();
    }
    flattenAndFilterModel() {
        this.displayedColsList = [];
        const recursiveFunc = (item) => {
            if (!item.passesFilter) {
                return;
            }
            this.displayedColsList.push(item);
            if (item.group && item.expanded) {
                item.children.forEach(recursiveFunc);
            }
        };
        const virtualList = this.virtualList;
        this.allColsTree.forEach(recursiveFunc);
        virtualList.setModel(new UIColumnModel(this.displayedColsList));
        const focusedRow = virtualList.getLastFocusedRow();
        virtualList.refresh();
        if (focusedRow != null) {
            this.focusRowIfAlive(focusedRow);
        }
        this.notifyListeners();
        this.refreshAriaLabel();
    }
    refreshAriaLabel() {
        const translate = this.getLocaleTextFunc();
        const columnListName = translate('ariaColumnPanelList', 'Column List');
        const localeColumns = translate('columns', 'Columns');
        const items = this.displayedColsList.length;
        (0, ag_grid_community_1._setAriaLabel)(this.virtualList.getAriaElement(), `${columnListName} ${items} ${localeColumns}`);
    }
    focusRowIfAlive(rowIndex) {
        window.setTimeout(() => {
            if (this.isAlive()) {
                this.virtualList.focusRow(rowIndex);
            }
        }, 0);
    }
    forEachItem(callback) {
        const recursiveFunc = (items) => {
            items.forEach((item) => {
                callback(item);
                if (item.group) {
                    recursiveFunc(item.children);
                }
            });
        };
        const allColsTree = this.allColsTree;
        if (!allColsTree) {
            return;
        }
        recursiveFunc(allColsTree);
    }
    doSetExpandedAll(value) {
        this.forEachItem((item) => {
            if (item.group) {
                item.expanded = value;
            }
        });
    }
    setGroupsExpanded(expand, groupIds) {
        if (!groupIds) {
            this.doSetExpandedAll(expand);
            return;
        }
        const expandedGroupIds = [];
        this.forEachItem((item) => {
            if (!item.group) {
                return;
            }
            const groupId = item.columnGroup.getId();
            if (groupIds.indexOf(groupId) >= 0) {
                item.expanded = expand;
                expandedGroupIds.push(groupId);
            }
        });
        const unrecognisedGroupIds = groupIds.filter((groupId) => !expandedGroupIds.includes(groupId));
        if (unrecognisedGroupIds.length > 0) {
            (0, ag_grid_community_1._warn)(157, { unrecognisedGroupIds });
        }
    }
    getExpandState() {
        let expandedCount = 0;
        let notExpandedCount = 0;
        this.forEachItem((item) => {
            if (!item.group) {
                return;
            }
            if (item.expanded) {
                expandedCount++;
            }
            else {
                notExpandedCount++;
            }
        });
        if (expandedCount > 0 && notExpandedCount > 0) {
            return agPrimaryColsHeader_1.ExpandState.INDETERMINATE;
        }
        if (notExpandedCount > 0) {
            return agPrimaryColsHeader_1.ExpandState.COLLAPSED;
        }
        return agPrimaryColsHeader_1.ExpandState.EXPANDED;
    }
    doSetSelectedAll(selectAllChecked) {
        (0, modelItemUtils_1.selectAllChildren)(this.beans, this.allColsTree, selectAllChecked, this.eventType);
    }
    getSelectionState() {
        let checkedCount = 0;
        let uncheckedCount = 0;
        const pivotMode = this.colModel.isPivotMode();
        this.forEachItem((item) => {
            if (item.group) {
                return;
            }
            if (!item.passesFilter) {
                return;
            }
            const column = item.column;
            const colDef = column.getColDef();
            let checked;
            if (pivotMode) {
                const noPivotModeOptionsAllowed = !column.isAllowPivot() && !column.isAllowRowGroup() && !column.isAllowValue();
                if (noPivotModeOptionsAllowed) {
                    return;
                }
                checked = column.isValueActive() || column.isPivotActive() || column.isRowGroupActive();
            }
            else {
                if (colDef.lockVisible) {
                    return;
                }
                checked = column.isVisible();
            }
            checked ? checkedCount++ : uncheckedCount++;
        });
        if (checkedCount > 0 && uncheckedCount > 0) {
            return undefined;
        }
        return !(checkedCount === 0 || uncheckedCount > 0);
    }
    setFilterText(filterText) {
        this.filterText = (0, ag_grid_community_1._exists)(filterText) ? filterText.toLowerCase() : null;
        this.markFilteredColumns();
        this.flattenAndFilterModel();
    }
    markFilteredColumns() {
        const passesFilter = (item) => {
            if (!(0, ag_grid_community_1._exists)(this.filterText)) {
                return true;
            }
            const displayName = item.displayName;
            return displayName == null || displayName.toLowerCase().indexOf(this.filterText) !== -1;
        };
        const recursivelyCheckFilter = (item, parentPasses) => {
            let atLeastOneChildPassed = false;
            if (item.group) {
                const groupPasses = passesFilter(item);
                item.children.forEach((child) => {
                    const childPasses = recursivelyCheckFilter(child, groupPasses || parentPasses);
                    if (childPasses) {
                        atLeastOneChildPassed = childPasses;
                    }
                });
            }
            const filterPasses = parentPasses || atLeastOneChildPassed ? true : passesFilter(item);
            item.passesFilter = filterPasses;
            return filterPasses;
        };
        this.allColsTree.forEach((item) => recursivelyCheckFilter(item, false));
    }
    notifyListeners() {
        this.fireGroupExpandedEvent();
        this.fireSelectionChangedEvent();
    }
    fireGroupExpandedEvent() {
        const expandState = this.getExpandState();
        this.dispatchLocalEvent({ type: 'groupExpanded', state: expandState });
    }
    fireSelectionChangedEvent() {
        if (!this.allColsTree) {
            return;
        }
        const selectionState = this.getSelectionState();
        this.dispatchLocalEvent({ type: 'selectionChanged', state: selectionState });
    }
    getExpandedGroups() {
        const expandedGroupIds = [];
        if (!this.allColsTree) {
            return expandedGroupIds;
        }
        this.forEachItem((item) => {
            if (item.group && item.expanded) {
                expandedGroupIds.push(item.columnGroup.getId());
            }
        });
        return expandedGroupIds;
    }
}
exports.AgPrimaryColsList = AgPrimaryColsList;
exports.AgPrimaryColsListSelector = {
    selector: 'AG-PRIMARY-COLS-LIST',
    component: AgPrimaryColsList,
};


/***/ }),

/***/ 2176:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnModelItem = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ColumnModelItem {
    constructor(displayName, columnOrGroup, depth, group = false, expanded) {
        this.displayName = displayName;
        this.depth = depth;
        this.group = group;
        this.localEventService = new ag_grid_community_1.LocalEventService();
        if (group) {
            this.columnGroup = columnOrGroup;
            this._expanded = expanded;
            this.children = [];
        }
        else {
            this.column = columnOrGroup;
        }
    }
    get expanded() {
        return !!this._expanded;
    }
    set expanded(expanded) {
        if (expanded === this._expanded) {
            return;
        }
        this._expanded = expanded;
        this.localEventService.dispatchEvent({ type: 'expandedChanged' });
    }
    addEventListener(eventType, listener) {
        this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
        this.localEventService.removeEventListener(eventType, listener);
    }
}
exports.ColumnModelItem = ColumnModelItem;


/***/ }),

/***/ 7367:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnToolPanelCSS = void 0;
exports.columnToolPanelCSS = `.ag-column-panel{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.ag-pivot-mode-panel{display:flex;height:var(--ag-header-height)}.ag-pivot-mode-select{align-items:center;display:flex}:where(.ag-ltr) .ag-pivot-mode-select{margin-left:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-pivot-mode-select{margin-right:var(--ag-widget-container-horizontal-padding)}.ag-column-panel-column-select{border-bottom:var(--ag-tool-panel-separator-border)}.ag-column-panel-column-select:where(:nth-child(n+2 of :not(.ag-hidden))){border-top:var(--ag-tool-panel-separator-border)}:where(.ag-column-panel) .ag-column-drop-vertical{flex:1 1 0px;min-height:50px;&:where(:not(.ag-last-column-drop)){border-bottom:var(--ag-tool-panel-separator-border)}}`;


/***/ }),

/***/ 4142:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnToolPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPrimaryCols_1 = __webpack_require__(1269);
const columnToolPanel_css_GENERATED_1 = __webpack_require__(7367);
class ColumnToolPanel extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-column-panel"></div>`);
        this.initialised = false;
        this.childDestroyFuncs = [];
        this.registerCSS(columnToolPanel_css_GENERATED_1.columnToolPanelCSS);
    }
    wireBeans(beans) {
        this.colToolPanelFactory = beans.colToolPanelFactory;
    }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    init(params) {
        const defaultParams = this.gos.addGridCommonParams({
            suppressColumnMove: false,
            suppressColumnSelectAll: false,
            suppressColumnFilter: false,
            suppressColumnExpandAll: false,
            contractColumnSelection: false,
            suppressPivotMode: false,
            suppressRowGroups: false,
            suppressValues: false,
            suppressPivots: false,
            suppressSyncLayoutWithGrid: false,
        });
        const mergedParams = {
            ...defaultParams,
            ...params,
        };
        this.params = mergedParams;
        const { childDestroyFuncs, colToolPanelFactory, gos } = this;
        const hasPivotModule = gos.isModuleRegistered('SharedPivot');
        const hasRowGroupingModule = hasPivotModule || gos.isModuleRegistered('SharedRowGrouping');
        if (!mergedParams.suppressPivotMode && colToolPanelFactory && hasPivotModule) {
            this.pivotModePanel = colToolPanelFactory.createPivotModePanel(this, childDestroyFuncs);
        }
        // DO NOT CHANGE TO createManagedBean
        const primaryColsPanel = this.createBean(new agPrimaryCols_1.AgPrimaryCols());
        this.primaryColsPanel = primaryColsPanel;
        childDestroyFuncs.push(() => this.destroyBean(this.primaryColsPanel));
        primaryColsPanel.init(true, mergedParams, 'toolPanelUi');
        primaryColsPanel.addCssClass('ag-column-panel-column-select');
        this.appendChild(primaryColsPanel);
        if (colToolPanelFactory) {
            if (!mergedParams.suppressRowGroups && hasRowGroupingModule) {
                this.rowGroupDropZonePanel = colToolPanelFactory.createRowGroupPanel(this, childDestroyFuncs);
            }
            if (!mergedParams.suppressValues && hasRowGroupingModule) {
                this.valuesDropZonePanel = colToolPanelFactory.createValuesPanel(this, childDestroyFuncs);
            }
            if (!mergedParams.suppressPivots && hasPivotModule) {
                this.pivotDropZonePanel = colToolPanelFactory.createPivotPanel(this, childDestroyFuncs);
            }
            this.setLastVisible();
            const [pivotModeListener] = this.addManagedEventListeners({
                columnPivotModeChanged: () => {
                    this.resetChildrenHeight();
                    this.setLastVisible();
                },
            });
            childDestroyFuncs.push(() => pivotModeListener());
        }
        this.initialised = true;
    }
    setPivotModeSectionVisible(visible) {
        const colToolPanelFactory = this.colToolPanelFactory;
        if (!colToolPanelFactory) {
            return;
        }
        this.pivotModePanel = colToolPanelFactory.setPanelVisible(this.pivotModePanel, visible, colToolPanelFactory.createPivotModePanel.bind(colToolPanelFactory, this, this.childDestroyFuncs, true));
        this.setLastVisible();
    }
    setRowGroupsSectionVisible(visible) {
        const colToolPanelFactory = this.colToolPanelFactory;
        if (!colToolPanelFactory) {
            return;
        }
        this.rowGroupDropZonePanel = colToolPanelFactory.setPanelVisible(this.rowGroupDropZonePanel, visible, colToolPanelFactory.createRowGroupPanel.bind(colToolPanelFactory, this, this.childDestroyFuncs));
        this.setLastVisible();
    }
    setValuesSectionVisible(visible) {
        const colToolPanelFactory = this.colToolPanelFactory;
        if (!colToolPanelFactory) {
            return;
        }
        this.valuesDropZonePanel = colToolPanelFactory.setPanelVisible(this.valuesDropZonePanel, visible, colToolPanelFactory.createValuesPanel.bind(colToolPanelFactory, this, this.childDestroyFuncs));
        this.setLastVisible();
    }
    setPivotSectionVisible(visible) {
        const colToolPanelFactory = this.colToolPanelFactory;
        if (!colToolPanelFactory) {
            return;
        }
        this.pivotDropZonePanel = colToolPanelFactory.setPanelVisible(this.pivotDropZonePanel, visible, colToolPanelFactory.createPivotPanel.bind(colToolPanelFactory, this, this.childDestroyFuncs));
        this.pivotDropZonePanel?.setDisplayed(visible);
        this.setLastVisible();
    }
    setResizers() {
        [this.primaryColsPanel, this.rowGroupDropZonePanel, this.valuesDropZonePanel, this.pivotDropZonePanel].forEach((panel) => {
            if (!panel) {
                return;
            }
            const eGui = panel.getGui();
            panel.toggleResizable(!eGui.classList.contains('ag-last-column-drop') && !eGui.classList.contains('ag-hidden'));
        });
    }
    setLastVisible() {
        const eGui = this.getGui();
        const columnDrops = Array.prototype.slice.call(eGui.querySelectorAll('.ag-column-drop'));
        columnDrops.forEach((columnDrop) => columnDrop.classList.remove('ag-last-column-drop'));
        const columnDropEls = eGui.querySelectorAll('.ag-column-drop:not(.ag-hidden)');
        const lastVisible = (0, ag_grid_community_1._last)(columnDropEls);
        if (lastVisible) {
            lastVisible.classList.add('ag-last-column-drop');
        }
        this.setResizers();
    }
    resetChildrenHeight() {
        const eGui = this.getGui();
        const children = eGui.children;
        for (let i = 0; i < children.length; i++) {
            const { style } = children[i];
            style.removeProperty('height');
            style.removeProperty('flex');
        }
    }
    expandColumnGroups(groupIds) {
        this.primaryColsPanel.expandGroups(groupIds);
    }
    collapseColumnGroups(groupIds) {
        this.primaryColsPanel.collapseGroups(groupIds);
    }
    setColumnLayout(colDefs) {
        this.primaryColsPanel.setColumnLayout(colDefs);
    }
    syncLayoutWithGrid() {
        this.primaryColsPanel.syncLayoutWithGrid();
    }
    destroyChildren() {
        const childDestroyFuncs = this.childDestroyFuncs;
        childDestroyFuncs.forEach((func) => func());
        childDestroyFuncs.length = 0;
        (0, ag_grid_community_1._clearElement)(this.getGui());
    }
    refresh(params) {
        this.destroyChildren();
        this.init(params);
        return true;
    }
    getState() {
        return {
            expandedGroupIds: this.primaryColsPanel.getExpandedGroups(),
        };
    }
    destroy() {
        this.destroyChildren();
        super.destroy();
    }
}
exports.ColumnToolPanel = ColumnToolPanel;


/***/ }),

/***/ 8698:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnToolPanelFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pivotDropZonePanel_1 = __webpack_require__(6491);
const rowGroupDropZonePanel_1 = __webpack_require__(4552);
const valueDropZonePanel_1 = __webpack_require__(3392);
const pivotModePanel_1 = __webpack_require__(4465);
class ColumnToolPanelFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colToolPanelFactory';
    }
    setPanelVisible(existingPanel, visible, createFunc) {
        if (existingPanel) {
            existingPanel.setDisplayed(visible);
        }
        else if (visible) {
            existingPanel = createFunc();
        }
        return existingPanel;
    }
    createRowGroupPanel(parent, destroyFuncs) {
        return this.createPanel(parent, destroyFuncs, new rowGroupDropZonePanel_1.RowGroupDropZonePanel(false));
    }
    createValuesPanel(parent, destroyFuncs) {
        return this.createPanel(parent, destroyFuncs, new valueDropZonePanel_1.ValuesDropZonePanel(false));
    }
    createPivotPanel(parent, destroyFuncs) {
        return this.createPanel(parent, destroyFuncs, new pivotDropZonePanel_1.PivotDropZonePanel(false));
    }
    createPivotModePanel(parent, destroyFuncs, prepend) {
        return this.createPanel(parent, destroyFuncs, new pivotModePanel_1.PivotModePanel(), prepend);
    }
    createPanel(parent, destroyFuncs, panel, prepend) {
        panel = parent.createBean(panel);
        destroyFuncs.push(() => parent.destroyBean(panel));
        if (prepend) {
            parent.prependChild(panel);
        }
        else {
            parent.appendChild(panel);
        }
        return panel;
    }
}
exports.ColumnToolPanelFactory = ColumnToolPanelFactory;


/***/ }),

/***/ 6455:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnsToolPanelModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const sideBarModule_1 = __webpack_require__(6358);
const version_1 = __webpack_require__(7205);
const menuItemModule_1 = __webpack_require__(3375);
const columnToolPanel_1 = __webpack_require__(4142);
const columnToolPanelFactory_1 = __webpack_require__(8698);
/**
 * @feature Accessories -> Columns Tool Panel
 */
exports.ColumnsToolPanelModule = {
    moduleName: 'ColumnsToolPanel',
    version: version_1.VERSION,
    beans: [columnToolPanelFactory_1.ColumnToolPanelFactory],
    userComponents: { agColumnsToolPanel: columnToolPanel_1.ColumnToolPanel },
    icons: {
        // column tool panel tab
        columnsToolPanel: 'columns',
        // "Group by {column-name}" item in column header menu
        menuAddRowGroup: 'group',
        // "Un-Group by {column-name}" item in column header menu
        menuRemoveRowGroup: 'group',
        // identifies the pivot drop zone
        pivotPanel: 'pivot',
        // "Row groups" drop zone in column tool panel
        rowGroupPanel: 'group',
        // columns tool panel Values drop zone
        valuePanel: 'aggregation',
        // column tool panel column group contracted (click to expand)
        columnSelectClosed: 'tree-closed',
        // column tool panel column group expanded (click to contract)
        columnSelectOpen: 'tree-open',
        // column tool panel header expand/collapse all button, shown when some children are expanded and
        //     others are collapsed
        columnSelectIndeterminate: 'tree-indeterminate',
    },
    dependsOn: [
        agGridEnterpriseModule_1.EnterpriseCoreModule,
        sideBarModule_1.SideBarModule,
        ag_grid_community_1._ColumnMoveModule,
        ag_grid_community_1._SharedDragAndDropModule,
        ag_grid_community_1._PopupModule,
        menuItemModule_1.MenuItemModule,
    ],
};


/***/ }),

/***/ 4781:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPivotState = exports.updateColumns = exports.setAllColumns = exports.selectAllChildren = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function selectAllChildren(beans, colTree, selectAllChecked, eventType) {
    const cols = extractAllLeafColumns(colTree);
    setAllColumns(beans, cols, selectAllChecked, eventType);
}
exports.selectAllChildren = selectAllChildren;
function setAllColumns(beans, cols, selectAllChecked, eventType) {
    if (beans.colModel.isPivotMode()) {
        setAllPivot(beans, cols, selectAllChecked, eventType);
    }
    else {
        setAllVisible(beans, cols, selectAllChecked, eventType);
    }
}
exports.setAllColumns = setAllColumns;
function extractAllLeafColumns(allItems) {
    const res = [];
    const recursiveFunc = (items) => {
        items.forEach((item) => {
            if (!item.passesFilter) {
                return;
            }
            if (item.group) {
                recursiveFunc(item.children);
            }
            else {
                res.push(item.column);
            }
        });
    };
    recursiveFunc(allItems);
    return res;
}
function setAllVisible(beans, columns, visible, eventType) {
    const colStateItems = [];
    columns.forEach((col) => {
        if (col.getColDef().lockVisible) {
            return;
        }
        if (col.isVisible() != visible) {
            colStateItems.push({
                colId: col.getId(),
                hide: !visible,
            });
        }
    });
    if (colStateItems.length > 0) {
        (0, ag_grid_community_1._applyColumnState)(beans, { state: colStateItems }, eventType);
    }
    beans.selectionColSvc?.refreshVisibility(eventType);
}
function setAllPivot(beans, columns, value, eventType) {
    setAllPivotActive(beans, columns, value, eventType);
}
function setAllPivotActive(beans, columns, value, eventType) {
    const colStateItems = [];
    const turnOnAction = (col) => {
        // don't change any column that's already got a function active
        if (col.isAnyFunctionActive()) {
            return;
        }
        if (col.isAllowValue()) {
            const aggFunc = typeof col.getAggFunc() === 'string' ? col.getAggFunc() : beans.aggFuncSvc?.getDefaultAggFunc(col);
            colStateItems.push({
                colId: col.getId(),
                aggFunc: aggFunc,
            });
        }
        else if (col.isAllowRowGroup()) {
            colStateItems.push({
                colId: col.getId(),
                rowGroup: true,
            });
        }
        else if (col.isAllowPivot()) {
            colStateItems.push({
                colId: col.getId(),
                pivot: true,
            });
        }
    };
    const turnOffAction = (col) => {
        const isActive = col.isPivotActive() || col.isRowGroupActive() || col.isValueActive();
        if (isActive) {
            colStateItems.push({
                colId: col.getId(),
                pivot: false,
                rowGroup: false,
                aggFunc: null,
            });
        }
    };
    const action = value ? turnOnAction : turnOffAction;
    columns.forEach(action);
    if (colStateItems.length > 0) {
        (0, ag_grid_community_1._applyColumnState)(beans, { state: colStateItems }, eventType);
    }
}
function updateColumns(beans, params) {
    const { columns, visibleState, pivotState, eventType } = params;
    const state = columns.map((column) => {
        const colId = column.getColId();
        if (beans.colModel.isPivotMode()) {
            const pivotStateForColumn = pivotState?.[colId];
            return {
                colId,
                pivot: pivotStateForColumn?.pivot,
                rowGroup: pivotStateForColumn?.rowGroup,
                aggFunc: pivotStateForColumn?.aggFunc,
            };
        }
        else {
            return {
                colId,
                hide: !visibleState?.[colId],
            };
        }
    });
    (0, ag_grid_community_1._applyColumnState)(beans, { state }, eventType);
}
exports.updateColumns = updateColumns;
function createPivotState(column) {
    return {
        pivot: column.isPivotActive(),
        rowGroup: column.isRowGroupActive(),
        aggFunc: column.isValueActive() ? column.getAggFunc() : undefined,
    };
}
exports.createPivotState = createPivotState;


/***/ }),

/***/ 4465:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotModePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class PivotModePanel extends ag_grid_community_1.Component {
    constructor() {
        super(...arguments);
        this.cbPivotMode = ag_grid_community_1.RefPlaceholder;
    }
    createTemplate() {
        return /* html */ `<div class="ag-pivot-mode-panel">
                <ag-toggle-button data-ref="cbPivotMode" class="ag-pivot-mode-select"></ag-toggle-button>
            </div>`;
    }
    postConstruct() {
        this.setTemplate(this.createTemplate(), [ag_grid_community_1.AgToggleButtonSelector]);
        const cbPivotMode = this.cbPivotMode;
        const { colModel, ctrlsSvc, gos } = this.beans;
        cbPivotMode.setValue(colModel.isPivotMode());
        const localeTextFunc = this.getLocaleTextFunc();
        cbPivotMode.setLabel(localeTextFunc('pivotMode', 'Pivot Mode'));
        const onBtPivotMode = () => {
            const newValue = !!cbPivotMode.getValue();
            if (newValue !== colModel.isPivotMode()) {
                gos.updateGridOptions({ options: { pivotMode: newValue }, source: 'toolPanelUi' });
                ctrlsSvc.getHeaderRowContainerCtrls().forEach((c) => c.refresh());
            }
        };
        const onPivotModeChanged = () => {
            const pivotModeActive = colModel.isPivotMode();
            cbPivotMode.setValue(pivotModeActive);
        };
        this.addManagedListeners(cbPivotMode, { fieldValueChanged: onBtPivotMode });
        this.addManagedEventListeners({
            newColumnsLoaded: onPivotModeChanged,
            columnPivotModeChanged: onPivotModeChanged,
        });
    }
}
exports.PivotModePanel = PivotModePanel;


/***/ }),

/***/ 3234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimaryColsListPanelItemDragFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const virtualListDragFeature_1 = __webpack_require__(5760);
const toolPanelColumnGroupComp_1 = __webpack_require__(4224);
class PrimaryColsListPanelItemDragFeature extends ag_grid_community_1.BeanStub {
    constructor(comp, virtualList) {
        super();
        this.comp = comp;
        this.virtualList = virtualList;
    }
    postConstruct() {
        this.createManagedBean(new virtualListDragFeature_1.VirtualListDragFeature(this.comp, this.virtualList, {
            dragSourceType: ag_grid_community_1.DragSourceType.ToolPanel,
            listItemDragStartEvent: 'columnPanelItemDragStart',
            listItemDragEndEvent: 'columnPanelItemDragEnd',
            eventSource: this.eventSvc,
            getCurrentDragValue: (listItemDragStartEvent) => this.getCurrentDragValue(listItemDragStartEvent),
            isMoveBlocked: (currentDragValue) => this.isMoveBlocked(currentDragValue),
            getNumRows: (comp) => comp.getDisplayedColsList().length,
            moveItem: (currentDragValue, lastHoveredListItem) => this.moveItem(this.getCurrentColumnsBeingMoved(currentDragValue), lastHoveredListItem),
        }));
    }
    getCurrentDragValue(listItemDragStartEvent) {
        return listItemDragStartEvent.column;
    }
    getCurrentColumnsBeingMoved(column) {
        if ((0, ag_grid_community_1.isProvidedColumnGroup)(column)) {
            return column.getLeafColumns();
        }
        return column ? [column] : [];
    }
    isMoveBlocked(currentDragValue) {
        const preventMoving = this.gos.get('suppressMovableColumns');
        if (preventMoving) {
            return true;
        }
        const currentColumns = this.getCurrentColumnsBeingMoved(currentDragValue);
        const hasNotMovable = currentColumns.find((col) => {
            const colDef = col.getColDef();
            return !!colDef.suppressMovable || !!colDef.lockPosition;
        });
        return !!hasNotMovable;
    }
    moveItem(currentColumns, lastHoveredListItem) {
        if (!lastHoveredListItem) {
            return;
        }
        const { component } = lastHoveredListItem;
        let lastHoveredColumn = null;
        let isBefore = lastHoveredListItem.position === 'top';
        if (component instanceof toolPanelColumnGroupComp_1.ToolPanelColumnGroupComp) {
            const columns = component.getColumns();
            lastHoveredColumn = columns[0];
            isBefore = true;
        }
        else if (component) {
            lastHoveredColumn = component.column;
        }
        if (!lastHoveredColumn) {
            return;
        }
        const targetIndex = this.getMoveTargetIndex({
            currentColumns,
            lastHoveredColumn,
            isBefore,
        });
        if (targetIndex != null) {
            this.beans.colMoves?.moveColumns(currentColumns, targetIndex, 'toolPanelUi');
        }
    }
    getMoveTargetIndex(params) {
        const { currentColumns, lastHoveredColumn, isBefore } = params;
        if (!lastHoveredColumn || !currentColumns) {
            return null;
        }
        const allColumns = this.beans.colModel.getCols();
        const targetColumnIndex = allColumns.indexOf(lastHoveredColumn);
        const adjustedTarget = isBefore ? targetColumnIndex : targetColumnIndex + 1;
        const diff = this.getMoveDiff(allColumns, currentColumns, adjustedTarget);
        return adjustedTarget - diff;
    }
    getMoveDiff(allColumns, currentColumns, end) {
        if (!currentColumns) {
            return 0;
        }
        const targetColumn = currentColumns[0];
        const span = currentColumns.length;
        const currentIndex = allColumns.indexOf(targetColumn);
        if (currentIndex < end) {
            return span;
        }
        return 0;
    }
}
exports.PrimaryColsListPanelItemDragFeature = PrimaryColsListPanelItemDragFeature;


/***/ }),

/***/ 4545:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelColumnComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const modelItemUtils_1 = __webpack_require__(4781);
const toolPanelContextMenu_1 = __webpack_require__(334);
class ToolPanelColumnComp extends ag_grid_community_1.Component {
    constructor(modelItem, allowDragging, groupsExist, focusWrapper) {
        super();
        this.allowDragging = allowDragging;
        this.groupsExist = groupsExist;
        this.focusWrapper = focusWrapper;
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        this.cbSelect = ag_grid_community_1.RefPlaceholder;
        this.processingColumnStateChange = false;
        const { column, depth, displayName } = modelItem;
        this.column = column;
        this.columnDept = depth;
        this.displayName = displayName;
    }
    postConstruct() {
        this.setTemplate(
        /* html */
        `<div class="ag-column-select-column">
                <ag-checkbox data-ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
                <span class="ag-column-select-column-label" data-ref="eLabel"></span>
            </div>`, [ag_grid_community_1.AgCheckboxSelector]);
        const { beans, cbSelect, displayName, eLabel, columnDept: indent, groupsExist, column, gos, focusWrapper, } = this;
        const eDragHandle = (0, ag_grid_community_1._createIconNoSpan)('columnDrag', beans);
        this.eDragHandle = eDragHandle;
        eDragHandle.classList.add('ag-drag-handle', 'ag-column-select-column-drag-handle');
        const checkboxGui = cbSelect.getGui();
        const checkboxInput = cbSelect.getInputElement();
        checkboxGui.insertAdjacentElement('afterend', eDragHandle);
        checkboxInput.setAttribute('tabindex', '-1');
        const displayNameSanitised = (0, ag_grid_community_1._escapeString)(displayName);
        eLabel.innerHTML = displayNameSanitised;
        // if grouping, we add an extra level of indent, to cater for expand/contract icons we need to indent for
        if (groupsExist) {
            this.addCssClass('ag-column-select-add-group-indent');
        }
        this.addCssClass(`ag-column-select-indent-${indent}`);
        this.getGui().style.setProperty('--ag-indentation-level', String(indent));
        this.tooltipFeature = this.createOptionalManagedBean(beans.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getLocation: () => 'columnToolPanelColumn',
            getColDef: () => column.getColDef(),
            shouldDisplayTooltip: (0, ag_grid_community_1._getShouldDisplayTooltip)(gos, () => eLabel),
        }));
        this.setupDragging();
        const onColStateChanged = this.onColumnStateChanged.bind(this);
        this.addManagedEventListeners({ columnPivotModeChanged: onColStateChanged });
        this.addManagedListeners(column, {
            columnValueChanged: onColStateChanged,
            columnPivotChanged: onColStateChanged,
            columnRowGroupChanged: onColStateChanged,
            visibleChanged: onColStateChanged,
        });
        this.addManagedListeners(focusWrapper, {
            keydown: this.handleKeyDown.bind(this),
            contextmenu: this.onContextMenu.bind(this),
        });
        this.addManagedPropertyListener('functionsReadOnly', this.onColumnStateChanged.bind(this));
        this.addManagedListeners(cbSelect, { fieldValueChanged: this.onCheckboxChanged.bind(this) });
        this.addManagedElementListeners(eLabel, { click: this.onLabelClicked.bind(this) });
        this.onColumnStateChanged();
        this.refreshAriaLabel();
        this.setupTooltip();
        const classes = (0, ag_grid_community_1._getToolPanelClassesFromColDef)(column.getColDef(), gos, column, null);
        classes.forEach((c) => this.addOrRemoveCssClass(c, true));
    }
    getColumn() {
        return this.column;
    }
    setupTooltip() {
        const refresh = () => this.tooltipFeature?.setTooltipAndRefresh(this.column.getColDef().headerTooltip);
        refresh();
        this.addManagedEventListeners({ newColumnsLoaded: refresh });
    }
    onContextMenu(e) {
        const { column, gos } = this;
        if (gos.get('functionsReadOnly')) {
            return;
        }
        const contextMenu = this.createBean(new toolPanelContextMenu_1.ToolPanelContextMenu(column, e, this.focusWrapper));
        this.addDestroyFunc(() => {
            if (contextMenu.isAlive()) {
                this.destroyBean(contextMenu);
            }
        });
    }
    handleKeyDown(e) {
        if (e.key === ag_grid_community_1.KeyCode.SPACE) {
            e.preventDefault();
            if (this.isSelectable()) {
                this.onSelectAllChanged(!this.isSelected());
            }
        }
    }
    onLabelClicked() {
        if (this.gos.get('functionsReadOnly')) {
            return;
        }
        const nextState = !this.cbSelect.getValue();
        this.onChangeCommon(nextState);
    }
    onCheckboxChanged(event) {
        this.onChangeCommon(event.selected);
    }
    onChangeCommon(nextState) {
        // ignore lock visible columns
        if (this.cbSelect.isReadOnly()) {
            return;
        }
        this.refreshAriaLabel();
        // only want to action if the user clicked the checkbox, not if we are setting the checkbox because
        // of a change in the model
        if (this.processingColumnStateChange) {
            return;
        }
        (0, modelItemUtils_1.setAllColumns)(this.beans, [this.column], nextState, 'toolPanelUi');
    }
    refreshAriaLabel() {
        const { cbSelect, focusWrapper, displayName } = this;
        const translate = this.getLocaleTextFunc();
        const columnLabel = translate('ariaColumn', 'Column');
        const state = cbSelect.getValue() ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden');
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        (0, ag_grid_community_1._setAriaLabel)(focusWrapper, `${displayName} ${columnLabel}`);
        this.cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
        (0, ag_grid_community_1._setAriaDescribedBy)(focusWrapper, cbSelect.getInputElement().id);
    }
    setupDragging() {
        const eDragHandle = this.eDragHandle;
        if (!this.allowDragging) {
            (0, ag_grid_community_1._setDisplayed)(eDragHandle, false);
            return;
        }
        const beans = this.beans;
        const { gos, eventSvc, dragAndDrop } = beans;
        let hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
        const dragSource = {
            type: ag_grid_community_1.DragSourceType.ToolPanel,
            eElement: eDragHandle,
            dragItemName: this.displayName,
            getDefaultIconName: () => (hideColumnOnExit ? 'hide' : 'notAllowed'),
            getDragItem: () => this.createDragItem(),
            onDragStarted: () => {
                hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
                eventSvc.dispatchEvent({
                    type: 'columnPanelItemDragStart',
                    column: this.column,
                });
            },
            onDragStopped: () => {
                eventSvc.dispatchEvent({
                    type: 'columnPanelItemDragEnd',
                });
            },
            onGridEnter: (dragItem) => {
                if (hideColumnOnExit) {
                    // when dragged into the grid, restore the state that was active pre-drag
                    (0, modelItemUtils_1.updateColumns)(beans, {
                        columns: [this.column],
                        visibleState: dragItem?.visibleState,
                        pivotState: dragItem?.pivotState,
                        eventType: 'toolPanelUi',
                    });
                }
            },
            onGridExit: () => {
                if (hideColumnOnExit) {
                    // when dragged outside of the grid, mimic what happens when checkbox is disabled
                    // this handles the behaviour for pivot which is different to just hiding a column.
                    this.onChangeCommon(false);
                }
            },
        };
        dragAndDrop.addDragSource(dragSource, true);
        this.addDestroyFunc(() => dragAndDrop.removeDragSource(dragSource));
    }
    createDragItem() {
        const colId = this.column.getColId();
        const visibleState = { [colId]: this.column.isVisible() };
        const pivotState = { [colId]: (0, modelItemUtils_1.createPivotState)(this.column) };
        return {
            columns: [this.column],
            visibleState,
            pivotState,
        };
    }
    onColumnStateChanged() {
        this.processingColumnStateChange = true;
        const isPivotMode = this.beans.colModel.isPivotMode();
        if (isPivotMode) {
            // if reducing, checkbox means column is one of pivot, value or group
            const anyFunctionActive = this.column.isAnyFunctionActive();
            this.cbSelect.setValue(anyFunctionActive);
        }
        else {
            // if not reducing, the checkbox tells us if column is visible or not
            this.cbSelect.setValue(this.column.isVisible());
        }
        let canBeToggled = true;
        let canBeDragged = true;
        if (isPivotMode) {
            // when in pivot mode, the item should be read only if:
            //  a) gui is not allowed make any changes
            const functionsReadOnly = this.gos.get('functionsReadOnly');
            //  b) column is not allow any functions on it
            const noFunctionsAllowed = !this.column.isAnyFunctionAllowed();
            canBeToggled = !functionsReadOnly && !noFunctionsAllowed;
            canBeDragged = canBeToggled;
        }
        else {
            const { enableRowGroup, enableValue, lockPosition, suppressMovable, lockVisible } = this.column.getColDef();
            const forceDraggable = !!enableRowGroup || !!enableValue;
            const disableDraggable = !!lockPosition || !!suppressMovable;
            canBeToggled = !lockVisible;
            canBeDragged = forceDraggable || !disableDraggable;
        }
        this.cbSelect.setReadOnly(!canBeToggled);
        this.eDragHandle.classList.toggle('ag-column-select-column-readonly', !canBeDragged);
        this.addOrRemoveCssClass('ag-column-select-column-readonly', !canBeDragged && !canBeToggled);
        this.cbSelect.setPassive(false);
        this.processingColumnStateChange = false;
    }
    getDisplayName() {
        return this.displayName;
    }
    onSelectAllChanged(value) {
        const cbSelect = this.cbSelect;
        if (value !== cbSelect.getValue()) {
            if (!cbSelect.isReadOnly()) {
                cbSelect.toggle();
            }
        }
    }
    isSelected() {
        return this.cbSelect.getValue();
    }
    isSelectable() {
        return !this.cbSelect.isReadOnly();
    }
    isExpandable() {
        return false;
    }
    setExpanded(_value) {
        (0, ag_grid_community_1._warn)(158);
    }
}
exports.ToolPanelColumnComp = ToolPanelColumnComp;


/***/ }),

/***/ 4224:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelColumnGroupComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const modelItemUtils_1 = __webpack_require__(4781);
const toolPanelContextMenu_1 = __webpack_require__(334);
class ToolPanelColumnGroupComp extends ag_grid_community_1.Component {
    constructor(modelItem, allowDragging, eventType, focusWrapper) {
        super();
        this.modelItem = modelItem;
        this.allowDragging = allowDragging;
        this.eventType = eventType;
        this.focusWrapper = focusWrapper;
        this.cbSelect = ag_grid_community_1.RefPlaceholder;
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        this.eGroupOpenedIcon = ag_grid_community_1.RefPlaceholder;
        this.eGroupClosedIcon = ag_grid_community_1.RefPlaceholder;
        this.eColumnGroupIcons = ag_grid_community_1.RefPlaceholder;
        this.processingColumnStateChange = false;
        const { columnGroup, depth, displayName } = modelItem;
        this.columnGroup = columnGroup;
        this.columnDepth = depth;
        this.displayName = displayName;
    }
    postConstruct() {
        this.setTemplate(
        /* html */
        `<div class="ag-column-select-column-group">
                <span class="ag-column-group-icons" data-ref="eColumnGroupIcons" >
                    <span class="ag-column-group-closed-icon" data-ref="eGroupClosedIcon"></span>
                    <span class="ag-column-group-opened-icon" data-ref="eGroupOpenedIcon"></span>
                </span>
                <ag-checkbox data-ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
                <span class="ag-column-select-column-label" data-ref="eLabel"></span>
            </div>`, [ag_grid_community_1.AgCheckboxSelector]);
        const { beans, cbSelect, eLabel, displayName, columnDepth: columnDept, modelItem, focusWrapper, columnGroup, } = this;
        const { registry, gos } = beans;
        const eDragHandle = (0, ag_grid_community_1._createIconNoSpan)('columnDrag', beans);
        this.eDragHandle = eDragHandle;
        eDragHandle.classList.add('ag-drag-handle', 'ag-column-select-column-group-drag-handle');
        const checkboxGui = cbSelect.getGui();
        const checkboxInput = cbSelect.getInputElement();
        checkboxGui.insertAdjacentElement('afterend', eDragHandle);
        checkboxInput.setAttribute('tabindex', '-1');
        eLabel.innerHTML = displayName ?? '';
        this.setupExpandContract();
        this.addCssClass('ag-column-select-indent-' + columnDept);
        this.getGui().style.setProperty('--ag-indentation-level', String(columnDept));
        this.tooltipFeature = this.createOptionalManagedBean(registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getLocation: () => 'columnToolPanelColumnGroup',
            shouldDisplayTooltip: (0, ag_grid_community_1._getShouldDisplayTooltip)(gos, () => eLabel),
        }));
        this.addManagedEventListeners({ columnPivotModeChanged: this.onColumnStateChanged.bind(this) });
        this.addManagedElementListeners(eLabel, { click: this.onLabelClicked.bind(this) });
        this.addManagedListeners(cbSelect, { fieldValueChanged: this.onCheckboxChanged.bind(this) });
        this.addManagedListeners(modelItem, { expandedChanged: this.onExpandChanged.bind(this) });
        this.addManagedListeners(focusWrapper, {
            keydown: this.handleKeyDown.bind(this),
            contextmenu: this.onContextMenu.bind(this),
        });
        this.setOpenClosedIcons();
        this.setupDragging();
        this.onColumnStateChanged();
        this.addVisibilityListenersToAllChildren();
        this.refreshAriaExpanded();
        this.refreshAriaLabel();
        this.setupTooltip();
        const classes = (0, ag_grid_community_1._getToolPanelClassesFromColDef)(columnGroup.getColGroupDef(), gos, null, columnGroup);
        classes.forEach((c) => this.addOrRemoveCssClass(c, true));
    }
    getColumns() {
        return this.columnGroup.getLeafColumns();
    }
    setupTooltip() {
        const colGroupDef = this.columnGroup.getColGroupDef();
        if (!colGroupDef) {
            return;
        }
        const refresh = () => this.tooltipFeature?.setTooltipAndRefresh(colGroupDef.headerTooltip);
        refresh();
        this.addManagedEventListeners({ newColumnsLoaded: refresh });
    }
    handleKeyDown(e) {
        switch (e.key) {
            case ag_grid_community_1.KeyCode.LEFT:
                e.preventDefault();
                this.modelItem.expanded = false;
                break;
            case ag_grid_community_1.KeyCode.RIGHT:
                e.preventDefault();
                this.modelItem.expanded = true;
                break;
            case ag_grid_community_1.KeyCode.SPACE:
                e.preventDefault();
                if (this.isSelectable()) {
                    this.onSelectAllChanged(!this.isSelected());
                }
                break;
        }
    }
    onContextMenu(e) {
        const { columnGroup, gos } = this;
        if (gos.get('functionsReadOnly')) {
            return;
        }
        const contextMenu = this.createBean(new toolPanelContextMenu_1.ToolPanelContextMenu(columnGroup, e, this.focusWrapper));
        this.addDestroyFunc(() => {
            if (contextMenu.isAlive()) {
                this.destroyBean(contextMenu);
            }
        });
    }
    addVisibilityListenersToAllChildren() {
        const listener = this.onColumnStateChanged.bind(this);
        this.columnGroup.getLeafColumns().forEach((column) => {
            this.addManagedListeners(column, {
                visibleChanged: listener,
                columnValueChanged: listener,
                columnPivotChanged: listener,
                columnRowGroupChanged: listener,
            });
        });
    }
    setupDragging() {
        if (!this.allowDragging) {
            (0, ag_grid_community_1._setDisplayed)(this.eDragHandle, false);
            return;
        }
        const beans = this.beans;
        const { gos, eventSvc, dragAndDrop } = beans;
        let hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
        const dragSource = {
            type: ag_grid_community_1.DragSourceType.ToolPanel,
            eElement: this.eDragHandle,
            dragItemName: this.displayName,
            getDefaultIconName: () => (hideColumnOnExit ? 'hide' : 'notAllowed'),
            getDragItem: () => this.createDragItem(),
            onDragStarted: () => {
                hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
                eventSvc.dispatchEvent({
                    type: 'columnPanelItemDragStart',
                    column: this.columnGroup,
                });
            },
            onDragStopped: () => {
                eventSvc.dispatchEvent({
                    type: 'columnPanelItemDragEnd',
                });
            },
            onGridEnter: (dragItem) => {
                if (hideColumnOnExit) {
                    // when dragged into the grid, restore the state that was active pre-drag
                    (0, modelItemUtils_1.updateColumns)(beans, {
                        columns: this.columnGroup.getLeafColumns(),
                        visibleState: dragItem?.visibleState,
                        pivotState: dragItem?.pivotState,
                        eventType: this.eventType,
                    });
                }
            },
            onGridExit: () => {
                if (hideColumnOnExit) {
                    // when dragged outside of the grid, mimic what happens when checkbox is disabled
                    // this handles the behaviour for pivot which is different to just hiding a column.
                    this.onChangeCommon(false);
                }
            },
        };
        dragAndDrop.addDragSource(dragSource, true);
        this.addDestroyFunc(() => dragAndDrop.removeDragSource(dragSource));
    }
    createDragItem() {
        const columns = this.columnGroup.getLeafColumns();
        const visibleState = {};
        const pivotState = {};
        columns.forEach((col) => {
            const colId = col.getId();
            visibleState[colId] = col.isVisible();
            pivotState[colId] = (0, modelItemUtils_1.createPivotState)(col);
        });
        return {
            columns,
            visibleState,
            pivotState,
        };
    }
    setupExpandContract() {
        const { beans, eGroupClosedIcon, eGroupOpenedIcon, eColumnGroupIcons } = this;
        eGroupClosedIcon.appendChild((0, ag_grid_community_1._createIcon)('columnSelectClosed', beans, null));
        eGroupOpenedIcon.appendChild((0, ag_grid_community_1._createIcon)('columnSelectOpen', beans, null));
        const listener = this.onExpandOrContractClicked.bind(this);
        this.addManagedElementListeners(eGroupClosedIcon, { click: listener });
        this.addManagedElementListeners(eGroupOpenedIcon, { click: listener });
        const touchListener = new ag_grid_community_1.TouchListener(eColumnGroupIcons, true);
        this.addManagedListeners(touchListener, { tap: listener });
        this.addDestroyFunc(touchListener.destroy.bind(touchListener));
    }
    onLabelClicked() {
        const nextState = !this.cbSelect.getValue();
        this.onChangeCommon(nextState);
    }
    onCheckboxChanged(event) {
        this.onChangeCommon(event.selected);
    }
    getVisibleLeafColumns() {
        const childColumns = [];
        const extractCols = (children) => {
            children.forEach((child) => {
                if (!child.passesFilter) {
                    return;
                }
                if (child.group) {
                    extractCols(child.children);
                }
                else {
                    childColumns.push(child.column);
                }
            });
        };
        extractCols(this.modelItem.children);
        return childColumns;
    }
    onChangeCommon(nextState) {
        this.refreshAriaLabel();
        if (this.processingColumnStateChange) {
            return;
        }
        (0, modelItemUtils_1.selectAllChildren)(this.beans, this.modelItem.children, nextState, this.eventType);
    }
    refreshAriaLabel() {
        const { cbSelect, focusWrapper, displayName } = this;
        const translate = this.getLocaleTextFunc();
        const columnLabel = translate('ariaColumnGroup', 'Column Group');
        const checkboxValue = cbSelect.getValue();
        const state = checkboxValue === undefined
            ? translate('ariaIndeterminate', 'indeterminate')
            : checkboxValue
                ? translate('ariaVisible', 'visible')
                : translate('ariaHidden', 'hidden');
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        (0, ag_grid_community_1._setAriaLabel)(focusWrapper, `${displayName} ${columnLabel}`);
        cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
        (0, ag_grid_community_1._setAriaDescribedBy)(focusWrapper, cbSelect.getInputElement().id);
    }
    onColumnStateChanged() {
        const selectedValue = this.workOutSelectedValue();
        const readOnlyValue = this.workOutReadOnlyValue();
        this.processingColumnStateChange = true;
        const cbSelect = this.cbSelect;
        cbSelect.setValue(selectedValue);
        cbSelect.setReadOnly(readOnlyValue);
        this.addOrRemoveCssClass('ag-column-select-column-group-readonly', readOnlyValue);
        this.processingColumnStateChange = false;
    }
    workOutSelectedValue() {
        const pivotMode = this.beans.colModel.isPivotMode();
        const visibleLeafColumns = this.getVisibleLeafColumns();
        let checkedCount = 0;
        let uncheckedCount = 0;
        visibleLeafColumns.forEach((column) => {
            if (!pivotMode && column.getColDef().lockVisible) {
                return;
            }
            if (this.isColumnChecked(column, pivotMode)) {
                checkedCount++;
            }
            else {
                uncheckedCount++;
            }
        });
        if (checkedCount > 0 && uncheckedCount > 0) {
            return undefined;
        }
        return checkedCount > 0;
    }
    workOutReadOnlyValue() {
        const pivotMode = this.beans.colModel.isPivotMode();
        let colsThatCanAction = 0;
        this.columnGroup.getLeafColumns().forEach((col) => {
            if (pivotMode) {
                if (col.isAnyFunctionAllowed()) {
                    colsThatCanAction++;
                }
            }
            else {
                if (!col.getColDef().lockVisible) {
                    colsThatCanAction++;
                }
            }
        });
        return colsThatCanAction === 0;
    }
    isColumnChecked(column, pivotMode) {
        if (pivotMode) {
            const pivoted = column.isPivotActive();
            const grouped = column.isRowGroupActive();
            const aggregated = column.isValueActive();
            return pivoted || grouped || aggregated;
        }
        return column.isVisible();
    }
    onExpandOrContractClicked() {
        const modelItem = this.modelItem;
        const oldState = modelItem.expanded;
        modelItem.expanded = !oldState;
    }
    onExpandChanged() {
        this.setOpenClosedIcons();
        this.refreshAriaExpanded();
    }
    setOpenClosedIcons() {
        const folderOpen = this.modelItem.expanded;
        (0, ag_grid_community_1._setDisplayed)(this.eGroupClosedIcon, !folderOpen);
        (0, ag_grid_community_1._setDisplayed)(this.eGroupOpenedIcon, folderOpen);
    }
    refreshAriaExpanded() {
        (0, ag_grid_community_1._setAriaExpanded)(this.focusWrapper, this.modelItem.expanded);
    }
    getDisplayName() {
        return this.displayName;
    }
    onSelectAllChanged(value) {
        const cbSelect = this.cbSelect;
        const cbValue = cbSelect.getValue();
        const readOnly = cbSelect.isReadOnly();
        if (!readOnly && ((value && !cbValue) || (!value && cbValue))) {
            cbSelect.toggle();
        }
    }
    isSelected() {
        return this.cbSelect.getValue();
    }
    isSelectable() {
        return !this.cbSelect.isReadOnly();
    }
    setSelected(selected) {
        this.cbSelect.setValue(selected, true);
    }
}
exports.ToolPanelColumnGroupComp = ToolPanelColumnGroupComp;


/***/ }),

/***/ 334:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelContextMenu = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
const agMenuList_1 = __webpack_require__(9476);
class ToolPanelContextMenu extends ag_grid_community_1.Component {
    constructor(column, mouseEvent, parentEl) {
        super(/* html */ `<div class="ag-menu"></div>`);
        this.column = column;
        this.mouseEvent = mouseEvent;
        this.parentEl = parentEl;
        this.displayName = null;
    }
    postConstruct() {
        const { column, beans: { colNames }, } = this;
        this.initializeProperties(column);
        let displayName;
        if ((0, ag_grid_community_1.isColumn)(column)) {
            displayName = colNames.getDisplayNameForColumn(column, 'columnToolPanel');
        }
        else {
            displayName = colNames.getDisplayNameForProvidedColumnGroup(null, column, 'columnToolPanel');
        }
        this.displayName = displayName;
        this.buildMenuItemMap();
        if (this.isActive()) {
            this.mouseEvent.preventDefault();
            const menuItemsMapped = this.getMappedMenuItems();
            if (menuItemsMapped.length === 0) {
                return;
            }
            this.displayContextMenu(menuItemsMapped);
        }
    }
    initializeProperties(column) {
        let columns;
        if ((0, ag_grid_community_1.isProvidedColumnGroup)(column)) {
            columns = column.getLeafColumns();
        }
        else {
            columns = [column];
        }
        this.columns = columns;
        this.allowGrouping = columns.some((col) => col.isPrimary() && col.isAllowRowGroup());
        this.allowValues = columns.some((col) => col.isPrimary() && col.isAllowValue());
        this.allowPivoting =
            this.beans.colModel.isPivotMode() && columns.some((col) => col.isPrimary() && col.isAllowPivot());
    }
    buildMenuItemMap() {
        const localeTextFunc = this.getLocaleTextFunc();
        const { beans, displayName } = this;
        const { rowGroupColsSvc, valueColsSvc, pivotColsSvc, colModel } = beans;
        const menuItemMap = new Map();
        this.menuItemMap = menuItemMap;
        menuItemMap.set('rowGroup', {
            allowedFunction: (col) => col.isPrimary() && col.isAllowRowGroup() && !(0, rowGroupingUtils_1.isRowGroupColLocked)(col, beans),
            activeFunction: (col) => col.isRowGroupActive(),
            activateLabel: () => `${localeTextFunc('groupBy', 'Group by')} ${displayName}`,
            deactivateLabel: () => `${localeTextFunc('ungroupBy', 'Un-Group by')} ${displayName}`,
            activateFunction: () => rowGroupColsSvc?.setColumns(this.addColumnsToList(rowGroupColsSvc.columns), 'toolPanelUi'),
            deActivateFunction: () => rowGroupColsSvc?.setColumns(this.removeColumnsFromList(rowGroupColsSvc.columns), 'toolPanelUi'),
            addIcon: 'menuAddRowGroup',
            removeIcon: 'menuRemoveRowGroup',
        });
        menuItemMap.set('value', {
            allowedFunction: (col) => col.isPrimary() && col.isAllowValue(),
            activeFunction: (col) => col.isValueActive(),
            activateLabel: () => localeTextFunc('addToValues', `Add ${displayName} to values`, [displayName]),
            deactivateLabel: () => localeTextFunc('removeFromValues', `Remove ${displayName} from values`, [displayName]),
            activateFunction: () => valueColsSvc?.setColumns(this.addColumnsToList(valueColsSvc.columns), 'toolPanelUi'),
            deActivateFunction: () => valueColsSvc?.setColumns(this.removeColumnsFromList(valueColsSvc.columns), 'toolPanelUi'),
            addIcon: 'valuePanel',
            removeIcon: 'valuePanel',
        });
        menuItemMap.set('pivot', {
            allowedFunction: (col) => colModel.isPivotMode() && col.isPrimary() && col.isAllowPivot(),
            activeFunction: (col) => col.isPivotActive(),
            activateLabel: () => localeTextFunc('addToLabels', `Add ${displayName} to labels`, [displayName]),
            deactivateLabel: () => localeTextFunc('removeFromLabels', `Remove ${displayName} from labels`, [displayName]),
            activateFunction: () => pivotColsSvc?.setColumns(this.addColumnsToList(pivotColsSvc.columns), 'toolPanelUi'),
            deActivateFunction: () => pivotColsSvc?.setColumns(this.removeColumnsFromList(pivotColsSvc.columns), 'toolPanelUi'),
            addIcon: 'pivotPanel',
            removeIcon: 'pivotPanel',
        });
    }
    addColumnsToList(columnList) {
        return [...columnList].concat(this.columns.filter((col) => columnList.indexOf(col) === -1));
    }
    removeColumnsFromList(columnList) {
        return columnList.filter((col) => this.columns.indexOf(col) === -1);
    }
    displayContextMenu(menuItemsMapped) {
        const eGui = this.getGui();
        const menuList = this.createBean(new agMenuList_1.AgMenuList());
        const localeTextFunc = this.getLocaleTextFunc();
        let hideFunc = () => { };
        eGui.appendChild(menuList.getGui());
        menuList.addMenuItems(menuItemsMapped);
        menuList.addManagedListeners(menuList, {
            closeMenu: () => {
                this.parentEl.focus();
                hideFunc();
            },
        });
        const popupSvc = this.beans.popupSvc;
        const addPopupRes = popupSvc.addPopup({
            modal: true,
            eChild: eGui,
            closeOnEsc: true,
            afterGuiAttached: () => (0, ag_grid_community_1._focusInto)(menuList.getGui()),
            ariaLabel: localeTextFunc('ariaLabelContextMenu', 'Context Menu'),
            closedCallback: (e) => {
                if (e instanceof KeyboardEvent) {
                    this.parentEl.focus();
                }
                this.destroyBean(menuList);
            },
        });
        if (addPopupRes) {
            hideFunc = addPopupRes.hideFunc;
        }
        popupSvc.positionPopupUnderMouseEvent({
            type: 'columnContextMenu',
            mouseEvent: this.mouseEvent,
            ePopup: eGui,
        });
    }
    isActive() {
        return this.allowGrouping || this.allowValues || this.allowPivoting;
    }
    getMappedMenuItems() {
        const ret = [];
        const { menuItemMap, columns, displayName, beans } = this;
        for (const val of menuItemMap.values()) {
            const isInactive = columns.some((col) => val.allowedFunction(col) && !val.activeFunction(col));
            const isActive = columns.some((col) => val.allowedFunction(col) && val.activeFunction(col));
            if (isInactive) {
                ret.push({
                    name: val.activateLabel(displayName),
                    icon: (0, ag_grid_community_1._createIconNoSpan)(val.addIcon, beans, null),
                    action: () => val.activateFunction(),
                });
            }
            if (isActive) {
                ret.push({
                    name: val.deactivateLabel(displayName),
                    icon: (0, ag_grid_community_1._createIconNoSpan)(val.removeIcon, beans, null),
                    action: () => val.deActivateFunction(),
                });
            }
        }
        return ret;
    }
}
exports.ToolPanelContextMenu = ToolPanelContextMenu;


/***/ }),

/***/ 2805:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numberFormatMap = exports.INCH_TO_EMU = void 0;
exports.INCH_TO_EMU = 9525;
exports.numberFormatMap = {
    '0': 1,
    '0.00': 2,
    '#,##0': 3,
    '#,##0.00': 4,
    '0%': 9,
    '0.00%': 10,
    '0.00E+00': 11,
    '# ?/?': 12,
    '# ??/??': 13,
    'mm-dd-yy': 14,
    'd-mmm-yy': 15,
    'd-mmm': 16,
    'mmm-yy': 17,
    'h:mm AM/PM': 18,
    'h:mm:ss AM/PM': 19,
    'h:mm': 20,
    'h:mm:ss': 21,
    'm/d/yy h:mm': 22,
    '#,##0 ;(#,##0)': 37,
    '#,##0 ;[Red](#,##0)': 38,
    '#,##0.00;(#,##0.00)': 39,
    '#,##0.00;[Red](#,##0.00)': 40,
    'mm:ss': 45,
    '[h]:mm:ss': 46,
    'mmss.0': 47,
    '##0.0E+0': 48,
    '@': 49,
};


/***/ }),

/***/ 1842:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertLegacyVerticalAlignment = exports.convertLegacyHorizontalAlignment = exports.convertLegacyBorder = exports.convertLegacyColor = exports.convertLegacyPattern = void 0;
const getWeightName = (value) => {
    switch (value) {
        case 1:
            return 'thin';
        case 2:
            return 'medium';
        case 3:
            return 'thick';
        default:
            return 'hair';
    }
};
const mappedBorderNames = {
    None: 'None',
    Dot: 'Dotted',
    Dash: 'Dashed',
    Double: 'Double',
    DashDot: 'DashDot',
    DashDotDot: 'DashDotDot',
    SlantDashDot: 'SlantDashDot',
    Continuous: 'Continuous',
};
const mediumBorders = ['Dashed', 'DashDot', 'DashDotDot'];
const colorMap = {
    None: 'none',
    Solid: 'solid',
    Gray50: 'mediumGray',
    Gray75: 'darkGray',
    Gray25: 'lightGray',
    HorzStripe: 'darkHorizontal',
    VertStripe: 'darkVertical',
    ReverseDiagStripe: 'darkDown',
    DiagStripe: 'darkUp',
    DiagCross: 'darkGrid',
    ThickDiagCross: 'darkTrellis',
    ThinHorzStripe: 'lightHorizontal',
    ThinVertStripe: 'lightVertical',
    ThinReverseDiagStripe: 'lightDown',
    ThinDiagStripe: 'lightUp',
    ThinHorzCross: 'lightGrid',
    ThinDiagCross: 'lightTrellis',
    Gray125: 'gray125',
    Gray0625: 'gray0625',
};
const horizontalAlignmentMap = {
    Automatic: 'general',
    Left: 'left',
    Center: 'center',
    Right: 'right',
    Fill: 'fill',
    Justify: 'justify',
    CenterAcrossSelection: 'centerContinuous',
    Distributed: 'distributed',
    JustifyDistributed: 'justify',
};
const verticalAlignmentMap = {
    Automatic: undefined,
    Top: 'top',
    Bottom: 'bottom',
    Center: 'center',
    Justify: 'justify',
    Distributed: 'distributed',
    JustifyDistributed: 'justify',
};
const convertLegacyPattern = (name) => {
    if (!name) {
        return 'none';
    }
    return colorMap[name] || name;
};
exports.convertLegacyPattern = convertLegacyPattern;
const convertLegacyColor = (color) => {
    if (color == undefined) {
        return color;
    }
    if (color.charAt(0) === '#') {
        color = color.substring(1);
    }
    return color.length === 6 ? 'FF' + color : color;
};
exports.convertLegacyColor = convertLegacyColor;
const convertLegacyBorder = (type, weight) => {
    if (!type) {
        return 'thin';
    }
    // Legacy Types are: None, Continuous, Dash, Dot, DashDot, DashDotDot, SlantDashDot, and Double
    // Weight represents: 0—Hairline, 1—Thin , 2—Medium, 3—Thick
    // New types: none, thin, medium, dashed, dotted, thick, double, hair, mediumDashed, dashDot, mediumDashDot,
    // dashDotDot, mediumDashDotDot, slantDashDot
    const namedWeight = getWeightName(weight);
    if (type === 'Continuous') {
        return namedWeight;
    }
    const mappedName = mappedBorderNames[type];
    if (namedWeight === 'medium' && mediumBorders.some((type) => type === mappedName)) {
        return `medium${mappedName}`;
    }
    return `${mappedName.charAt(0).toLowerCase()}${mappedName.substring(1)}`;
};
exports.convertLegacyBorder = convertLegacyBorder;
const convertLegacyHorizontalAlignment = (alignment) => {
    return horizontalAlignmentMap[alignment] || 'general';
};
exports.convertLegacyHorizontalAlignment = convertLegacyHorizontalAlignment;
const convertLegacyVerticalAlignment = (alignment) => {
    return verticalAlignmentMap[alignment] || undefined;
};
exports.convertLegacyVerticalAlignment = convertLegacyVerticalAlignment;


/***/ }),

/***/ 3237:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildSharedString = exports.replaceInvisibleCharacters = exports.getExcelColumnName = exports.createXmlPart = exports.setExcelImageTotalHeight = exports.setExcelImageTotalWidth = exports.getHeightFromProperty = exports.getFontFamilyId = exports.pixelsToEMU = exports.pointsToPixel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const excelConstants_1 = __webpack_require__(2805);
const xmlFactory_1 = __webpack_require__(5048);
const pointsToPixel = (points) => {
    return Math.round((points * 96) / 72);
};
exports.pointsToPixel = pointsToPixel;
const pixelsToEMU = (value) => {
    return Math.ceil(value * excelConstants_1.INCH_TO_EMU);
};
exports.pixelsToEMU = pixelsToEMU;
const getFontFamilyId = (name) => {
    if (name === undefined) {
        return;
    }
    const families = ['Automatic', 'Roman', 'Swiss', 'Modern', 'Script', 'Decorative'];
    const pos = families.indexOf(name || 'Automatic');
    return Math.max(pos, 0);
};
exports.getFontFamilyId = getFontFamilyId;
const getHeightFromProperty = (rowIndex, height) => {
    if (!height) {
        return;
    }
    let finalHeight;
    if (typeof height === 'number') {
        finalHeight = height;
    }
    else {
        // eslint-disable-next-line @typescript-eslint/ban-types
        const heightFunc = height;
        finalHeight = heightFunc({ rowIndex });
    }
    return finalHeight;
};
exports.getHeightFromProperty = getHeightFromProperty;
const setExcelImageTotalWidth = (image, columnsToExport) => {
    const { colSpan, column } = image.position;
    if (!image.width) {
        return;
    }
    if (colSpan) {
        const columnsInSpan = columnsToExport.slice(column - 1, column + colSpan - 1);
        let totalWidth = 0;
        for (let i = 0; i < columnsInSpan.length; i++) {
            const colWidth = columnsInSpan[i].getActualWidth();
            if (image.width < totalWidth + colWidth) {
                image.position.colSpan = i + 1;
                image.totalWidth = image.width;
                image.width = image.totalWidth - totalWidth;
                break;
            }
            totalWidth += colWidth;
        }
    }
    else {
        image.totalWidth = image.width;
    }
};
exports.setExcelImageTotalWidth = setExcelImageTotalWidth;
const setExcelImageTotalHeight = (image, rowHeight) => {
    const { rowSpan, row } = image.position;
    if (!image.height) {
        return;
    }
    if (rowSpan) {
        let totalHeight = 0;
        let counter = 0;
        for (let i = row; i < row + rowSpan; i++) {
            const nextRowHeight = (0, exports.pointsToPixel)((0, exports.getHeightFromProperty)(i, rowHeight) || 20);
            if (image.height < totalHeight + nextRowHeight) {
                image.position.rowSpan = counter + 1;
                image.totalHeight = image.height;
                image.height = image.totalHeight - totalHeight;
                break;
            }
            totalHeight += nextRowHeight;
            counter++;
        }
    }
    else {
        image.totalHeight = image.height;
    }
};
exports.setExcelImageTotalHeight = setExcelImageTotalHeight;
const createXmlPart = (body, skipHeader) => {
    const header = (0, xmlFactory_1.createXmlHeader)({
        encoding: 'UTF-8',
        standalone: 'yes',
    });
    const xmlBody = (0, xmlFactory_1.createXml)(body);
    if (skipHeader) {
        return xmlBody;
    }
    return `${header}${xmlBody}`;
};
exports.createXmlPart = createXmlPart;
const getExcelColumnName = (colIdx) => {
    const startCode = 65;
    const tableWidth = 26;
    const fromCharCode = String.fromCharCode;
    const pos = Math.floor(colIdx / tableWidth);
    const tableIdx = colIdx % tableWidth;
    if (!pos || colIdx === tableWidth) {
        return fromCharCode(startCode + colIdx - 1);
    }
    if (!tableIdx) {
        return (0, exports.getExcelColumnName)(pos - 1) + 'Z';
    }
    if (pos < tableWidth) {
        return fromCharCode(startCode + pos - 1) + fromCharCode(startCode + tableIdx - 1);
    }
    return (0, exports.getExcelColumnName)(pos) + fromCharCode(startCode + tableIdx - 1);
};
exports.getExcelColumnName = getExcelColumnName;
const replaceInvisibleCharacters = (str) => {
    if (str == null) {
        return null;
    }
    // Excel breaks when characters with code below 30 are exported
    // we use the loop below to wrap these characters between _x(code)_
    let newString = '';
    for (let i = 0; i < str.length; i++) {
        const point = str.charCodeAt(i);
        if (point >= 0 && point <= 31 && point !== 10) {
            const convertedCode = point.toString(16).toUpperCase();
            const paddedCode = convertedCode.padStart(4, '0');
            const newValue = `_x${paddedCode}_`;
            newString += newValue;
        }
        else {
            newString += str[i];
        }
    }
    return newString;
};
exports.replaceInvisibleCharacters = replaceInvisibleCharacters;
const buildSharedString = (strMap) => {
    const ret = [];
    for (const key of strMap.keys()) {
        const textNode = key.toString();
        const child = {
            name: 't',
            textNode: (0, ag_grid_community_1._escapeString)((0, exports.replaceInvisibleCharacters)(textNode), false),
        };
        // if we have leading or trailing spaces, instruct Excel not to trim them
        const preserveSpaces = textNode.trim().length !== textNode.length;
        if (preserveSpaces) {
            child.properties = {
                rawMap: {
                    'xml:space': 'preserve',
                },
            };
        }
        ret.push({
            name: 'si',
            children: [child],
        });
    }
    return ret;
};
exports.buildSharedString = buildSharedString;


/***/ }),

/***/ 5048:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createXml = exports.createXmlHeader = void 0;
const LINE_SEPARATOR = '\r\n';
function returnAttributeIfPopulated(key, value, booleanTransformer) {
    if (!value && value !== '' && value !== 0) {
        return '';
    }
    let xmlValue = value;
    if (typeof value === 'boolean') {
        if (booleanTransformer) {
            xmlValue = booleanTransformer(value);
        }
    }
    return ` ${key}="${xmlValue}"`;
}
function createXmlHeader(headerElement = {}) {
    const headerStart = '<?';
    const headerEnd = '?>';
    const keys = ['version'];
    if (!headerElement.version) {
        headerElement.version = '1.0';
    }
    if (headerElement.encoding) {
        keys.push('encoding');
    }
    if (headerElement.standalone) {
        keys.push('standalone');
    }
    const att = keys.map((key) => `${key}="${headerElement[key]}"`).join(' ');
    return `${headerStart}xml ${att} ${headerEnd}`;
}
exports.createXmlHeader = createXmlHeader;
function createXml(xmlElement, booleanTransformer) {
    let props = '';
    if (xmlElement.properties) {
        if (xmlElement.properties.prefixedAttributes) {
            xmlElement.properties.prefixedAttributes.forEach((prefixedSet) => {
                Object.keys(prefixedSet.map).forEach((key) => {
                    props += returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);
                });
            });
        }
        if (xmlElement.properties.rawMap) {
            Object.keys(xmlElement.properties.rawMap).forEach((key) => {
                props += returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
            });
        }
    }
    let result = '<' + xmlElement.name + props;
    if (!xmlElement.children && xmlElement.textNode == null) {
        return result + '/>' + LINE_SEPARATOR;
    }
    if (xmlElement.textNode != null) {
        return result + '>' + xmlElement.textNode + '</' + xmlElement.name + '>' + LINE_SEPARATOR;
    }
    result += '>' + LINE_SEPARATOR;
    if (xmlElement.children) {
        xmlElement.children.forEach((it) => {
            result += createXml(it, booleanTransformer);
        });
    }
    return result + '</' + xmlElement.name + '>' + LINE_SEPARATOR;
}
exports.createXml = createXml;


/***/ }),

/***/ 1790:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExcelCreator = exports.exportMultipleSheetsAsExcel = exports.getMultipleSheetsAsExcel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const excelSerializingSession_1 = __webpack_require__(5103);
const excelXlsxFactory_1 = __webpack_require__(7165);
const contentTypes_1 = __webpack_require__(541);
const zipContainer_1 = __webpack_require__(5950);
const createExcelXMLCoreFolderStructure = (zipContainer) => {
    zipContainer.addFolders(['_rels/', 'docProps/', 'xl/', 'xl/theme/', 'xl/_rels/', 'xl/worksheets/']);
    if (!excelXlsxFactory_1.XLSX_IMAGES.size) {
        return;
    }
    zipContainer.addFolders(['xl/worksheets/_rels', 'xl/drawings/', 'xl/drawings/_rels', 'xl/media/']);
    let imgCounter = 0;
    excelXlsxFactory_1.XLSX_IMAGES.forEach((value) => {
        const firstImage = value[0].image[0];
        const { base64, imageType } = firstImage;
        zipContainer.addFile(`xl/media/image${++imgCounter}.${(0, contentTypes_1._normaliseImageExtension)(imageType)}`, base64, true);
    });
};
const createExcelXmlWorksheets = (zipContainer, data) => {
    let imageRelationCounter = 0;
    let headerFooterImageCounter = 0;
    for (let i = 0; i < data.length; i++) {
        const value = data[i];
        zipContainer.addFile(`xl/worksheets/sheet${i + 1}.xml`, value, false);
        const hasImages = excelXlsxFactory_1.XLSX_IMAGES.size > 0 && excelXlsxFactory_1.XLSX_WORKSHEET_IMAGES.has(i);
        const tableData = excelXlsxFactory_1.XLSX_WORKSHEET_DATA_TABLES.size > 0 && excelXlsxFactory_1.XLSX_WORKSHEET_DATA_TABLES.get(i);
        const hasHeaderFooterImages = excelXlsxFactory_1.XLSX_IMAGES.size && excelXlsxFactory_1.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.has(i);
        if (!hasImages && !tableData && !hasHeaderFooterImages) {
            continue;
        }
        let tableName;
        let drawingIndex;
        let vmlDrawingIndex;
        if (hasImages) {
            createExcelXmlDrawings(zipContainer, i, imageRelationCounter);
            drawingIndex = imageRelationCounter;
            imageRelationCounter++;
        }
        if (hasHeaderFooterImages) {
            createExcelVmlDrawings(zipContainer, i, headerFooterImageCounter);
            vmlDrawingIndex = headerFooterImageCounter;
            headerFooterImageCounter++;
        }
        if (tableData) {
            tableName = tableData.name;
        }
        const worksheetRelFile = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;
        zipContainer.addFile(worksheetRelFile, (0, excelXlsxFactory_1.createXlsxRelationships)({
            tableName,
            drawingIndex,
            vmlDrawingIndex,
        }));
    }
};
const createExcelXmlDrawings = (zipContainer, sheetIndex, drawingIndex) => {
    const drawingFolder = 'xl/drawings';
    const drawingFileName = `${drawingFolder}/drawing${drawingIndex + 1}.xml`;
    const relFileName = `${drawingFolder}/_rels/drawing${drawingIndex + 1}.xml.rels`;
    zipContainer.addFile(relFileName, (0, excelXlsxFactory_1.createXlsxDrawingRel)(sheetIndex));
    zipContainer.addFile(drawingFileName, (0, excelXlsxFactory_1.createXlsxDrawing)(sheetIndex));
};
const createExcelVmlDrawings = (zipContainer, sheetIndex, drawingIndex) => {
    const drawingFolder = 'xl/drawings';
    const drawingFileName = `${drawingFolder}/vmlDrawing${drawingIndex + 1}.vml`;
    const relFileName = `${drawingFolder}/_rels/vmlDrawing${drawingIndex + 1}.vml.rels`;
    zipContainer.addFile(drawingFileName, (0, excelXlsxFactory_1.createXlsxVmlDrawing)(sheetIndex));
    zipContainer.addFile(relFileName, (0, excelXlsxFactory_1.createXlsxVmlDrawingRel)(sheetIndex));
};
const createExcelXmlTables = (zipContainer) => {
    const tablesDataByWorksheet = excelXlsxFactory_1.XLSX_WORKSHEET_DATA_TABLES;
    const worksheetKeys = Array.from(tablesDataByWorksheet.keys());
    for (let i = 0; i < worksheetKeys.length; i++) {
        const sheetIndex = worksheetKeys[i];
        const table = tablesDataByWorksheet.get(sheetIndex);
        if (!table) {
            continue;
        }
        zipContainer.addFile(`xl/tables/${table.name}.xml`, (0, excelXlsxFactory_1.createXlsxTable)(table, i));
    }
};
const createExcelXmlCoreSheets = (zipContainer, fontSize, author, sheetLen, activeTab) => {
    zipContainer.addFile('xl/workbook.xml', (0, excelXlsxFactory_1.createXlsxWorkbook)(activeTab));
    zipContainer.addFile('xl/styles.xml', (0, excelXlsxFactory_1.createXlsxStylesheet)(fontSize));
    zipContainer.addFile('xl/sharedStrings.xml', (0, excelXlsxFactory_1.createXlsxSharedStrings)());
    zipContainer.addFile('xl/theme/theme1.xml', (0, excelXlsxFactory_1.createXlsxTheme)());
    zipContainer.addFile('xl/_rels/workbook.xml.rels', (0, excelXlsxFactory_1.createXlsxWorkbookRels)(sheetLen));
    zipContainer.addFile('docProps/core.xml', (0, excelXlsxFactory_1.createXlsxCore)(author));
    zipContainer.addFile('[Content_Types].xml', (0, excelXlsxFactory_1.createXlsxContentTypes)(sheetLen));
    zipContainer.addFile('_rels/.rels', (0, excelXlsxFactory_1.createXlsxRels)());
};
const createExcelFileForExcel = (zipContainer, data, options = {}) => {
    if (!data || data.length === 0) {
        (0, ag_grid_community_1._warn)(159);
        (0, excelXlsxFactory_1.resetXlsxFactory)();
        return false;
    }
    const { fontSize = 11, author = 'AG Grid', activeTab = 0 } = options;
    const len = data.length;
    const activeTabWithinBounds = Math.max(Math.min(activeTab, len - 1), 0);
    createExcelXMLCoreFolderStructure(zipContainer);
    createExcelXmlTables(zipContainer);
    createExcelXmlWorksheets(zipContainer, data);
    createExcelXmlCoreSheets(zipContainer, fontSize, author, len, activeTabWithinBounds);
    (0, excelXlsxFactory_1.resetXlsxFactory)();
    return true;
};
const getMultipleSheetsAsExcelCompressed = (params) => {
    const { data, fontSize, author, activeSheetIndex } = params;
    const mimeType = params.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    const zipContainer = new zipContainer_1.ZipContainer();
    if (!createExcelFileForExcel(zipContainer, data, {
        author,
        fontSize,
        activeTab: activeSheetIndex,
    })) {
        return Promise.resolve(undefined);
    }
    return zipContainer.getZipFile(mimeType);
};
const getMultipleSheetsAsExcel = (params) => {
    const { data, fontSize, author, activeSheetIndex } = params;
    const mimeType = params.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    const zipContainer = new zipContainer_1.ZipContainer();
    if (!createExcelFileForExcel(zipContainer, data, {
        author,
        fontSize,
        activeTab: activeSheetIndex,
    })) {
        return;
    }
    return zipContainer.getUncompressedZipFile(mimeType);
};
exports.getMultipleSheetsAsExcel = getMultipleSheetsAsExcel;
const exportMultipleSheetsAsExcel = (params) => {
    const { fileName = 'export.xlsx' } = params;
    getMultipleSheetsAsExcelCompressed(params).then((contents) => {
        if (contents) {
            const downloadFileName = typeof fileName === 'function' ? fileName() : fileName;
            (0, ag_grid_community_1._downloadFile)(downloadFileName, contents);
        }
    });
};
exports.exportMultipleSheetsAsExcel = exportMultipleSheetsAsExcel;
class ExcelCreator extends ag_grid_community_1.BaseCreator {
    constructor() {
        super(...arguments);
        this.beanName = 'excelCreator';
    }
    getMergedParams(params) {
        const baseParams = this.gos.get('defaultExcelExportParams');
        return Object.assign({}, baseParams, params);
    }
    export(userParams) {
        if (this.isExportSuppressed()) {
            (0, ag_grid_community_1._warn)(160);
            return;
        }
        const mergedParams = this.getMergedParams(userParams);
        const data = this.getData(mergedParams);
        const exportParams = {
            data: [data],
            fontSize: mergedParams.fontSize,
            author: mergedParams.author,
            mimeType: mergedParams.mimeType,
        };
        this.packageCompressedFile(exportParams).then((packageFile) => {
            if (packageFile) {
                const { fileName } = mergedParams;
                const providedFileName = typeof fileName === 'function' ? fileName(this.gos.getGridCommonParams()) : fileName;
                (0, ag_grid_community_1._downloadFile)(this.getFileName(providedFileName), packageFile);
            }
        });
    }
    exportDataAsExcel(params) {
        this.export(params);
    }
    getDataAsExcel(params) {
        const mergedParams = this.getMergedParams(params);
        const data = this.getData(mergedParams);
        const exportParams = {
            data: [data],
            fontSize: mergedParams.fontSize,
            author: mergedParams.author,
            mimeType: mergedParams.mimeType,
        };
        return this.packageFile(exportParams);
    }
    setFactoryMode(factoryMode) {
        (0, excelXlsxFactory_1.setXlsxFactoryMode)(factoryMode);
    }
    getFactoryMode() {
        return (0, excelXlsxFactory_1.getXlsxFactoryMode)();
    }
    getSheetDataForExcel(params) {
        const mergedParams = this.getMergedParams(params);
        return this.getData(mergedParams);
    }
    getMultipleSheetsAsExcel(params) {
        return (0, exports.getMultipleSheetsAsExcel)(params);
    }
    exportMultipleSheetsAsExcel(params) {
        (0, exports.exportMultipleSheetsAsExcel)(params);
    }
    getDefaultFileExtension() {
        return 'xlsx';
    }
    createSerializingSession(params) {
        const { colModel, colNames, rowGroupColsSvc, valueSvc, gos } = this.beans;
        const config = {
            ...params,
            colModel,
            colNames,
            rowGroupColsSvc,
            valueSvc,
            gos,
            suppressRowOutline: params.suppressRowOutline || params.skipRowGroups,
            headerRowHeight: params.headerRowHeight || params.rowHeight,
            baseExcelStyles: gos.get('excelStyles') || [],
            rightToLeft: params.rightToLeft ?? gos.get('enableRtl'),
            styleLinker: this.styleLinker.bind(this),
        };
        return new excelSerializingSession_1.ExcelSerializingSession(config);
    }
    styleLinker(params) {
        const { rowType, rowIndex, value, column, columnGroup, node } = params;
        const isHeader = rowType === 'HEADER';
        const isGroupHeader = rowType === 'HEADER_GROUPING';
        const col = (isHeader ? column : columnGroup);
        let headerClasses = [];
        const { gos, cellStyles } = this.beans;
        if (isHeader || isGroupHeader) {
            headerClasses.push('header');
            if (isGroupHeader) {
                headerClasses.push('headerGroup');
            }
            if (col) {
                headerClasses = headerClasses.concat((0, ag_grid_community_1._getHeaderClassesFromColDef)(col.getDefinition(), gos, column || null, columnGroup || null));
            }
            return headerClasses;
        }
        const styles = gos.get('excelStyles');
        const applicableStyles = ['cell'];
        if (!styles || !styles.length) {
            return applicableStyles;
        }
        const styleIds = styles.map((it) => {
            return it.id;
        });
        const colDef = column.getDefinition();
        cellStyles?.processAllCellClasses(colDef, gos.addGridCommonParams({
            value,
            data: node.data,
            node: node,
            colDef,
            column: column,
            rowIndex: rowIndex,
        }), (className) => {
            if (styleIds.indexOf(className) > -1) {
                applicableStyles.push(className);
            }
        });
        return applicableStyles.sort((left, right) => {
            return styleIds.indexOf(left) < styleIds.indexOf(right) ? -1 : 1;
        });
    }
    isExportSuppressed() {
        return this.gos.get('suppressExcelExport');
    }
    packageCompressedFile(params) {
        return getMultipleSheetsAsExcelCompressed(params);
    }
    packageFile(params) {
        return (0, exports.getMultipleSheetsAsExcel)(params);
    }
}
exports.ExcelCreator = ExcelCreator;


/***/ }),

/***/ 4760:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.exportMultipleSheetsAsExcel = exports.getMultipleSheetsAsExcel = exports.getSheetDataForExcel = exports.exportDataAsExcel = exports.getDataAsExcel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function assertNotExcelMultiSheet(beans) {
    if (beans.excelCreator?.getFactoryMode() === 'MULTI_SHEET') {
        (0, ag_grid_community_1._warn)(161);
        return false;
    }
    return true;
}
function getDataAsExcel(beans, params) {
    if (assertNotExcelMultiSheet(beans)) {
        return beans.excelCreator?.getDataAsExcel(params);
    }
    return undefined;
}
exports.getDataAsExcel = getDataAsExcel;
function exportDataAsExcel(beans, params) {
    if (assertNotExcelMultiSheet(beans)) {
        beans.excelCreator?.exportDataAsExcel(params);
    }
}
exports.exportDataAsExcel = exportDataAsExcel;
function getSheetDataForExcel(beans, params) {
    beans.excelCreator?.setFactoryMode('MULTI_SHEET');
    return beans.excelCreator?.getSheetDataForExcel(params);
}
exports.getSheetDataForExcel = getSheetDataForExcel;
function getMultipleSheetsAsExcel(beans, params) {
    return beans.excelCreator?.getMultipleSheetsAsExcel(params);
}
exports.getMultipleSheetsAsExcel = getMultipleSheetsAsExcel;
function exportMultipleSheetsAsExcel(beans, params) {
    beans.excelCreator?.exportMultipleSheetsAsExcel(params);
}
exports.exportMultipleSheetsAsExcel = exportMultipleSheetsAsExcel;


/***/ }),

/***/ 2886:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExcelExportModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const excelCreator_1 = __webpack_require__(1790);
const excelExportApi_1 = __webpack_require__(4760);
/**
 * @feature Import & Export -> Excel
 */
exports.ExcelExportModule = {
    moduleName: 'ExcelExport',
    version: version_1.VERSION,
    beans: [excelCreator_1.ExcelCreator],
    apiFunctions: {
        getDataAsExcel: excelExportApi_1.getDataAsExcel,
        exportDataAsExcel: excelExportApi_1.exportDataAsExcel,
        getSheetDataForExcel: excelExportApi_1.getSheetDataForExcel,
        getMultipleSheetsAsExcel: excelExportApi_1.getMultipleSheetsAsExcel,
        exportMultipleSheetsAsExcel: excelExportApi_1.exportMultipleSheetsAsExcel,
    },
    dependsOn: [ag_grid_community_1._SharedExportModule, agGridEnterpriseModule_1.EnterpriseCoreModule],
};


/***/ }),

/***/ 5103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExcelSerializingSession = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const excelUtils_1 = __webpack_require__(3237);
const excelXlsxFactory_1 = __webpack_require__(7165);
class ExcelSerializingSession extends ag_grid_community_1.BaseGridSerializingSession {
    constructor(config) {
        super(config);
        this.mixedStyles = {};
        this.mixedStyleCounter = 0;
        this.rows = [];
        this.frozenRowCount = 0;
        this.skipFrozenRows = false;
        this.frozenColumnCount = 0;
        this.skipFrozenColumns = false;
        this.config = Object.assign({}, config);
        this.stylesByIds = {};
        this.config.baseExcelStyles.forEach((style) => {
            this.stylesByIds[style.id] = style;
        });
        this.excelStyles = [...this.config.baseExcelStyles, { id: '_quotePrefix', quotePrefix: 1 }];
    }
    addCustomContent(customContent) {
        customContent.forEach((row) => {
            const rowLen = this.rows.length + 1;
            let outlineLevel;
            if (!this.config.suppressRowOutline && row.outlineLevel != null) {
                outlineLevel = row.outlineLevel;
            }
            const rowObj = {
                height: (0, excelUtils_1.getHeightFromProperty)(rowLen, row.height || this.config.rowHeight),
                cells: (row.cells || []).map((cell, idx) => {
                    const image = this.addImage(rowLen, this.columnsToExport[idx], cell.data?.value);
                    let excelStyles = null;
                    if (cell.styleId) {
                        excelStyles = typeof cell.styleId === 'string' ? [cell.styleId] : cell.styleId;
                    }
                    const excelStyleId = this.getStyleId(excelStyles);
                    if (image) {
                        return this.createCell(excelStyleId, this.getDataTypeForValue(image.value), image.value == null ? '' : image.value);
                    }
                    const value = cell.data?.value ?? '';
                    const type = this.getDataTypeForValue(value);
                    if (cell.mergeAcross) {
                        return this.createMergedCell(excelStyleId, type, value, cell.mergeAcross);
                    }
                    return this.createCell(excelStyleId, type, value);
                }),
                outlineLevel,
            };
            if (row.collapsed != null) {
                rowObj.collapsed = row.collapsed;
            }
            if (row.hidden != null) {
                rowObj.hidden = row.hidden;
            }
            this.rows.push(rowObj);
        });
    }
    onNewHeaderGroupingRow() {
        const currentCells = [];
        const { freezeRows, headerRowHeight } = this.config;
        this.rows.push({
            cells: currentCells,
            height: (0, excelUtils_1.getHeightFromProperty)(this.rows.length + 1, headerRowHeight),
        });
        if (freezeRows) {
            this.frozenRowCount++;
        }
        return {
            onColumn: (columnGroup, header, index, span, collapsibleRanges) => {
                const styleIds = this.config.styleLinker({
                    rowType: 'HEADER_GROUPING',
                    rowIndex: 1,
                    value: `grouping-${header}`,
                    columnGroup,
                });
                currentCells.push({
                    ...this.createMergedCell(this.getStyleId(styleIds), this.getDataTypeForValue('string'), header, span),
                    collapsibleRanges,
                });
            },
        };
    }
    onNewHeaderRow() {
        const { freezeRows, headerRowHeight } = this.config;
        if (freezeRows) {
            this.frozenRowCount++;
        }
        return this.onNewRow(this.onNewHeaderColumn, headerRowHeight);
    }
    onNewBodyRow(node) {
        const { freezeRows, rowHeight } = this.config;
        if (!this.skipFrozenRows) {
            if (freezeRows === 'headersAndPinnedRows' && node?.rowPinned === 'top') {
                this.frozenRowCount++;
            }
            else if (typeof freezeRows === 'function') {
                if (freezeRows({ ...this.gos.getGridCommonParams(), node: node })) {
                    this.frozenRowCount++;
                }
                else {
                    this.skipFrozenRows = true;
                }
            }
            else {
                this.skipFrozenRows = true;
            }
        }
        const rowAccumulator = this.onNewRow(this.onNewBodyColumn, rowHeight);
        if (node) {
            this.addRowOutlineIfNecessary(node);
        }
        return rowAccumulator;
    }
    prepare(columnsToExport) {
        super.prepare(columnsToExport);
        this.columnsToExport = [...columnsToExport];
        this.cols = columnsToExport.map((col, i) => this.convertColumnToExcel(col, i));
    }
    parse() {
        // adding custom content might have made some rows wider than the grid, so add new columns
        const longestRow = this.rows.reduce((a, b) => Math.max(a, b.cells.length), 0);
        while (this.cols.length < longestRow) {
            this.cols.push(this.convertColumnToExcel(null, this.cols.length + 1));
        }
        const { config } = this;
        let name;
        if (config.sheetName != null) {
            const { sheetName } = config;
            const sheetNameValue = typeof sheetName === 'function' ? sheetName(this.gos.getGridCommonParams()) : sheetName;
            name = String(sheetNameValue).substring(0, 31);
        }
        else {
            name = 'ag-grid';
        }
        const data = {
            name,
            table: {
                columns: this.cols,
                rows: this.rows,
            },
        };
        return this.createExcel(data);
    }
    addRowOutlineIfNecessary(node) {
        const { gos, suppressRowOutline, rowGroupExpandState = 'expanded' } = this.config;
        const isGroupHideOpenParents = gos.get('groupHideOpenParents');
        if (isGroupHideOpenParents || suppressRowOutline || node.level == null) {
            return;
        }
        const padding = node.footer ? 1 : 0;
        const currentRow = (0, ag_grid_community_1._last)(this.rows);
        // Excel only supports up to 7 levels of outline
        const outlineLevel = Math.min(node.level + padding, 7);
        currentRow.outlineLevel = outlineLevel;
        if (rowGroupExpandState === 'expanded') {
            return;
        }
        const collapseAll = rowGroupExpandState === 'collapsed';
        if (node.isExpandable()) {
            const isExpanded = !collapseAll && node.expanded;
            currentRow.collapsed = !isExpanded;
        }
        currentRow.hidden =
            // always show the node if there is no parent to be expanded
            !!node.parent &&
                // or if it is a child of the root node
                node.parent.level !== -1 &&
                (collapseAll || this.isAnyParentCollapsed(node.parent));
    }
    isAnyParentCollapsed(node) {
        while (node && node.level !== -1) {
            if (!node.expanded) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    convertColumnToExcel(column, index) {
        const columnWidth = this.config.columnWidth;
        const headerValue = column ? this.extractHeaderValue(column) : undefined;
        const displayName = headerValue ?? '';
        const filterAllowed = column ? column.isFilterAllowed() : false;
        if (columnWidth) {
            if (typeof columnWidth === 'number') {
                return { width: columnWidth, displayName, filterAllowed };
            }
            return { width: columnWidth({ column, index }), displayName, filterAllowed };
        }
        if (column) {
            const smallestUsefulWidth = 75;
            return { width: Math.max(column.getActualWidth(), smallestUsefulWidth), displayName, filterAllowed };
        }
        return {
            displayName,
            filterAllowed,
        };
    }
    onNewHeaderColumn(rowIndex, currentCells) {
        return (column) => {
            const nameForCol = this.extractHeaderValue(column);
            const styleIds = this.config.styleLinker({
                rowType: 'HEADER',
                rowIndex,
                value: nameForCol,
                column,
            });
            currentCells.push(this.createCell(this.getStyleId(styleIds), this.getDataTypeForValue('string'), nameForCol));
        };
    }
    onNewBodyColumn(rowIndex, currentCells) {
        let skipCols = 0;
        const { freezeColumns, rightToLeft } = this.config;
        return (column, index, node) => {
            if (skipCols > 0) {
                skipCols -= 1;
                return;
            }
            if (!this.skipFrozenColumns) {
                const pinned = column.getPinned();
                const isPinnedLeft = pinned === true || pinned === 'left';
                if (freezeColumns === 'pinned' && pinned && isPinnedLeft !== rightToLeft) {
                    this.frozenColumnCount++;
                }
                else if (typeof freezeColumns === 'function' &&
                    freezeColumns({ ...this.gos.getGridCommonParams(), column })) {
                    this.frozenColumnCount++;
                }
                else {
                    this.skipFrozenColumns = true;
                }
            }
            const { value: valueForCell, valueFormatted } = this.extractRowCellValue(column, index, rowIndex, 'excel', node);
            const styleIds = this.config.styleLinker({
                rowType: 'BODY',
                rowIndex,
                value: valueForCell,
                column,
                node,
            });
            const excelStyleId = this.getStyleId(styleIds);
            const colSpan = column.getColSpan(node);
            const addedImage = this.addImage(rowIndex, column, valueForCell);
            if (addedImage) {
                currentCells.push(this.createCell(excelStyleId, this.getDataTypeForValue(addedImage.value), addedImage.value == null ? '' : addedImage.value));
            }
            else if (colSpan > 1) {
                skipCols = colSpan - 1;
                currentCells.push(this.createMergedCell(excelStyleId, this.getDataTypeForValue(valueForCell), valueForCell, colSpan - 1));
            }
            else {
                currentCells.push(this.createCell(excelStyleId, this.getDataTypeForValue(valueForCell), valueForCell, valueFormatted));
            }
        };
    }
    onNewRow(onNewColumnAccumulator, height) {
        const currentCells = [];
        this.rows.push({
            cells: currentCells,
            height: (0, excelUtils_1.getHeightFromProperty)(this.rows.length + 1, height),
        });
        return {
            onColumn: onNewColumnAccumulator.bind(this, this.rows.length, currentCells)(),
        };
    }
    createExcel(data) {
        const { excelStyles, config } = this;
        if (this.frozenColumnCount) {
            config.frozenColumnCount = this.frozenColumnCount;
        }
        if (this.frozenRowCount) {
            config.frozenRowCount = this.frozenRowCount;
        }
        return (0, excelXlsxFactory_1.createXlsxExcel)(excelStyles, data, config);
    }
    getDataTypeForValue(valueForCell) {
        if (valueForCell === undefined) {
            return 'empty';
        }
        return this.isNumerical(valueForCell) ? 'n' : 's';
    }
    getTypeFromStyle(style, value) {
        if (this.isFormula(value)) {
            return 'f';
        }
        if (style && style.dataType) {
            switch (style.dataType.toLocaleLowerCase()) {
                case 'formula':
                    return 'f';
                case 'string':
                    return 's';
                case 'number':
                    return 'n';
                case 'datetime':
                    return 'd';
                case 'error':
                    return 'e';
                case 'boolean':
                    return 'b';
                default:
                    (0, ag_grid_community_1._warn)(162, { id: style.id, dataType: style.dataType });
            }
        }
        return null;
    }
    addImage(rowIndex, column, value) {
        if (!this.config.addImageToCell) {
            return;
        }
        const addedImage = this.config.addImageToCell(rowIndex, column, value);
        if (!addedImage) {
            return;
        }
        (0, excelXlsxFactory_1.addXlsxBodyImageToMap)(addedImage.image, rowIndex, column, this.columnsToExport, this.config.rowHeight);
        return addedImage;
    }
    createCell(styleId, type, value, valueFormatted) {
        const actualStyle = this.getStyleById(styleId);
        if (!actualStyle?.dataType && type === 's' && valueFormatted) {
            value = valueFormatted;
        }
        const processedType = this.getTypeFromStyle(actualStyle, value) || type;
        const { value: processedValue, escaped } = this.getCellValue(processedType, value);
        const styles = [];
        if (actualStyle) {
            styles.push(styleId);
        }
        if (escaped) {
            styles.push('_quotePrefix');
        }
        styleId = this.getStyleId(styles) || undefined;
        return {
            styleId,
            data: {
                type: processedType,
                value: processedValue,
            },
        };
    }
    createMergedCell(styleId, type, value, numOfCells) {
        const valueToUse = value == null ? '' : value;
        return {
            styleId: this.getStyleById(styleId) ? styleId : undefined,
            data: {
                type: type,
                value: type === 's' ? (0, excelXlsxFactory_1.getXlsxStringPosition)(valueToUse).toString() : value,
            },
            mergeAcross: numOfCells,
        };
    }
    getCellValue(type, value) {
        let escaped = false;
        if (value == null || (type === 's' && value === '')) {
            return { value: '', escaped: false };
        }
        if (type === 's') {
            if (value && value[0] === "'") {
                escaped = true;
                value = value.slice(1);
            }
            value = (0, excelXlsxFactory_1.getXlsxStringPosition)(value).toString();
        }
        else if (type === 'f') {
            value = value.slice(1);
        }
        else if (type === 'n') {
            const numberValue = Number(value);
            if (isNaN(numberValue)) {
                value = '';
            }
            else if (value !== '') {
                value = numberValue.toString();
            }
        }
        return { value, escaped };
    }
    getStyleId(styleIds) {
        if (!styleIds || !styleIds.length) {
            return null;
        }
        if (styleIds.length === 1) {
            return styleIds[0];
        }
        const key = styleIds.join('-');
        if (!this.mixedStyles[key]) {
            this.addNewMixedStyle(styleIds);
        }
        return this.mixedStyles[key].excelID;
    }
    deepCloneObject(object) {
        return JSON.parse(JSON.stringify(object));
    }
    addNewMixedStyle(styleIds) {
        this.mixedStyleCounter += 1;
        const excelId = `mixedStyle${this.mixedStyleCounter}`;
        const resultantStyle = {};
        for (const styleId of styleIds) {
            for (const excelStyle of this.excelStyles) {
                if (excelStyle.id === styleId) {
                    (0, ag_grid_community_1._mergeDeep)(resultantStyle, this.deepCloneObject(excelStyle));
                }
            }
        }
        resultantStyle.id = excelId;
        const key = styleIds.join('-');
        this.mixedStyles[key] = {
            excelID: excelId,
            key: key,
            result: resultantStyle,
        };
        this.excelStyles.push(resultantStyle);
        this.stylesByIds[excelId] = resultantStyle;
    }
    isFormula(value) {
        if (value == null) {
            return false;
        }
        return this.config.autoConvertFormulas && value.toString().startsWith('=');
    }
    isNumerical(value) {
        if (typeof value === 'bigint') {
            return true;
        }
        return isFinite(value) && value !== '' && !isNaN(parseFloat(value));
    }
    getStyleById(styleId) {
        if (styleId == null) {
            return null;
        }
        return this.stylesByIds[styleId] || null;
    }
}
exports.ExcelSerializingSession = ExcelSerializingSession;


/***/ }),

/***/ 7165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createXlsxRelationships = exports.createXlsxVmlDrawingRel = exports.createXlsxVmlDrawing = exports.createXlsxDrawingRel = exports.createXlsxDrawing = exports.createXlsxWorkbookRels = exports.createXlsxTable = exports.createXlsxTheme = exports.createXlsxRels = exports.createXlsxContentTypes = exports.createXlsxCore = exports.createXlsxSharedStrings = exports.createXlsxStylesheet = exports.createXlsxWorkbook = exports.resetXlsxFactory = exports.getXlsxStringPosition = exports.addXlsxBodyImageToMap = exports.addXlsxHeaderFooterImageToMap = exports.addXlsxTableToSheet = exports.getXlsxSanitizedTableName = exports.showExcelTableNonCompatibleFeaturesWarning = exports.createXlsxExcel = exports.setXlsxFactoryMode = exports.getXlsxFactoryMode = exports.DEFAULT_TABLE_DISPLAY_NAME = exports.XLSX_WORKSHEET_DATA_TABLES = exports.XLSX_WORKSHEET_IMAGE_IDS = exports.XLSX_WORKBOOK_IMAGE_IDS = exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES = exports.XLSX_WORKSHEET_IMAGES = exports.XLSX_IMAGES = void 0;
const tslib_1 = __webpack_require__(5608);
const ag_grid_community_1 = __webpack_require__(6624);
const excelUtils_1 = __webpack_require__(3237);
const contentTypes_1 = tslib_1.__importStar(__webpack_require__(541));
const core_1 = tslib_1.__importDefault(__webpack_require__(1528));
const drawing_1 = tslib_1.__importDefault(__webpack_require__(6161));
const relationships_1 = tslib_1.__importDefault(__webpack_require__(7348));
const sharedStrings_1 = tslib_1.__importDefault(__webpack_require__(1126));
const stylesheet_1 = tslib_1.__importStar(__webpack_require__(3056));
const table_1 = tslib_1.__importDefault(__webpack_require__(859));
const office_1 = tslib_1.__importDefault(__webpack_require__(6316));
const vmlDrawing_1 = tslib_1.__importDefault(__webpack_require__(5592));
const workbook_1 = tslib_1.__importDefault(__webpack_require__(2519));
const worksheet_1 = tslib_1.__importDefault(__webpack_require__(559));
/*
 * See links for more info on the Office Open XML format being used:
 * https://www.ecma-international.org/wp-content/uploads/Office-Open-XML-White-Paper.pdf
 * https://ecma-international.org/publications-and-standards/standards/ecma-376/
 */
const XLSX_SHARED_STRINGS = new Map();
let XLSX_SHEET_NAMES = [];
/** Maps images to sheet */
exports.XLSX_IMAGES = new Map();
/** Maps sheets to images */
exports.XLSX_WORKSHEET_IMAGES = new Map();
/** Maps sheets to header/footer images */
exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES = new Map();
/** Maps all workbook images to a global Id */
exports.XLSX_WORKBOOK_IMAGE_IDS = new Map();
/** Maps all sheet images to unique Ids */
exports.XLSX_WORKSHEET_IMAGE_IDS = new Map();
/** Maps all sheet tables to unique Ids */
exports.XLSX_WORKSHEET_DATA_TABLES = new Map();
/** Default name to be used for tables when no name is provided */
exports.DEFAULT_TABLE_DISPLAY_NAME = 'AG-GRID-TABLE';
let XLSX_FACTORY_MODE = 'SINGLE_SHEET';
function getXlsxFactoryMode() {
    return XLSX_FACTORY_MODE;
}
exports.getXlsxFactoryMode = getXlsxFactoryMode;
function setXlsxFactoryMode(factoryMode) {
    XLSX_FACTORY_MODE = factoryMode;
}
exports.setXlsxFactoryMode = setXlsxFactoryMode;
function createXlsxExcel(styles, worksheet, config) {
    addSheetName(worksheet);
    (0, stylesheet_1.registerStyles)(styles, XLSX_SHEET_NAMES.length);
    const newConfig = Object.assign({}, config);
    // Table export is not compatible with pivot mode nor master/detail features
    if (config.exportAsExcelTable) {
        if (config.colModel.isPivotActive()) {
            showExcelTableNonCompatibleFeaturesWarning('pivot mode');
            newConfig.exportAsExcelTable = false;
        }
        if (config.gos.get('masterDetail')) {
            showExcelTableNonCompatibleFeaturesWarning('master/detail');
            newConfig.exportAsExcelTable = false;
        }
    }
    processTableConfig(worksheet, newConfig);
    return createWorksheet(worksheet, newConfig);
}
exports.createXlsxExcel = createXlsxExcel;
function showExcelTableNonCompatibleFeaturesWarning(featureName) {
    (0, ag_grid_community_1._warn)(163, { featureName });
}
exports.showExcelTableNonCompatibleFeaturesWarning = showExcelTableNonCompatibleFeaturesWarning;
function getXlsxSanitizedTableName(name) {
    return name
        .replace(/^[^a-zA-Z_]+/, '_')
        .replace(/\s/g, '_')
        .replace(/[^a-zA-Z0-9_]/g, '_');
}
exports.getXlsxSanitizedTableName = getXlsxSanitizedTableName;
function addXlsxTableToSheet(sheetIndex, table) {
    if (exports.XLSX_WORKSHEET_DATA_TABLES.has(sheetIndex)) {
        (0, ag_grid_community_1._warn)(164);
        return;
    }
    exports.XLSX_WORKSHEET_DATA_TABLES.set(sheetIndex, table);
}
exports.addXlsxTableToSheet = addXlsxTableToSheet;
function processTableConfig(worksheet, config) {
    const { exportAsExcelTable, prependContent, appendContent, colModel } = config;
    if (!exportAsExcelTable) {
        return;
    }
    const tableConfig = typeof exportAsExcelTable === 'boolean' ? {} : exportAsExcelTable;
    const { name: nameFromConfig, showColumnStripes, showRowStripes, showFilterButton, highlightFirstColumn, highlightLastColumn, } = tableConfig;
    const tableName = getXlsxSanitizedTableName(nameFromConfig || exports.DEFAULT_TABLE_DISPLAY_NAME);
    const sheetIndex = XLSX_SHEET_NAMES.length - 1;
    const { table } = worksheet;
    const { rows, columns } = table;
    const headerRowCount = (0, ag_grid_community_1._getHeaderRowCount)(colModel);
    const skipTopRows = prependContent ? prependContent.length : 0;
    const removeFromBottom = appendContent ? appendContent.length : 0;
    const tableRowCount = rows.length;
    const tableColCount = columns.length;
    const tableColumns = [];
    const showFilterButtons = [];
    for (let i = 0; i < tableColCount; i++) {
        const col = columns[i];
        tableColumns.push(col.displayName || '');
        showFilterButtons.push(showFilterButton === 'match' || showFilterButton === undefined
            ? col.filterAllowed ?? false // We fall back to the column's filterAllowed property on match
            : showFilterButton);
    }
    if (!tableColumns || !tableColumns.length || !tableRowCount || !tableName) {
        (0, ag_grid_community_1._warn)(165);
        return;
    }
    addXlsxTableToSheet(sheetIndex, {
        name: `table${exports.XLSX_WORKSHEET_DATA_TABLES.size + 1}`,
        displayName: tableName,
        columns: tableColumns,
        showFilterButtons: showFilterButtons,
        rowRange: [headerRowCount + skipTopRows, headerRowCount + (tableRowCount - headerRowCount) - removeFromBottom],
        showRowStripes: showRowStripes ?? true,
        showColumnStripes: showColumnStripes ?? false,
        highlightFirstColumn: highlightFirstColumn ?? false,
        highlightLastColumn: highlightLastColumn ?? false,
    });
}
function addXlsxHeaderFooterImageToMap(image, position) {
    const sheetIndex = XLSX_SHEET_NAMES.length - 1;
    const headerFooterImage = image;
    headerFooterImage.headerFooterPosition = position;
    buildImageMap({ imageToAdd: headerFooterImage, idx: sheetIndex });
    let headerFooterImagesForSheet = exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.get(sheetIndex);
    if (!headerFooterImagesForSheet) {
        headerFooterImagesForSheet = [];
        exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.set(sheetIndex, headerFooterImagesForSheet);
    }
    if (!headerFooterImagesForSheet.find((img) => img.id === image.id)) {
        headerFooterImagesForSheet.push(image);
    }
}
exports.addXlsxHeaderFooterImageToMap = addXlsxHeaderFooterImageToMap;
function addXlsxBodyImageToMap(image, rowIndex, col, columnsToExport, rowHeight) {
    const sheetIndex = XLSX_SHEET_NAMES.length;
    const { row, column } = image.position || {};
    const calculatedImage = image;
    if (columnsToExport) {
        if (rowIndex != null && col != null && (!row || !column)) {
            if (!image.position) {
                image.position = {};
            }
            image.position = Object.assign({}, image.position, {
                row: rowIndex,
                column: columnsToExport.indexOf(col) + 1,
            });
        }
        (0, excelUtils_1.setExcelImageTotalWidth)(calculatedImage, columnsToExport);
        (0, excelUtils_1.setExcelImageTotalHeight)(calculatedImage, rowHeight);
    }
    buildImageMap({ imageToAdd: calculatedImage, idx: sheetIndex });
    let worksheetImageIdMap = exports.XLSX_WORKSHEET_IMAGE_IDS.get(sheetIndex);
    if (!worksheetImageIdMap) {
        worksheetImageIdMap = new Map();
        exports.XLSX_WORKSHEET_IMAGE_IDS.set(sheetIndex, worksheetImageIdMap);
    }
    const sheetImages = exports.XLSX_WORKSHEET_IMAGES.get(sheetIndex);
    if (!sheetImages) {
        exports.XLSX_WORKSHEET_IMAGES.set(sheetIndex, [calculatedImage]);
    }
    else {
        sheetImages.push(calculatedImage);
    }
    if (!worksheetImageIdMap.get(image.id)) {
        worksheetImageIdMap.set(image.id, { index: worksheetImageIdMap.size, type: image.imageType });
    }
}
exports.addXlsxBodyImageToMap = addXlsxBodyImageToMap;
function buildImageMap(params) {
    const { imageToAdd, idx } = params;
    const mappedImagesToSheet = exports.XLSX_IMAGES.get(imageToAdd.id);
    if (mappedImagesToSheet) {
        const currentSheetImages = mappedImagesToSheet.find((currentImage) => currentImage.sheetId === idx);
        if (currentSheetImages) {
            currentSheetImages.image.push(imageToAdd);
        }
        else {
            mappedImagesToSheet.push({
                sheetId: idx,
                image: [imageToAdd],
            });
        }
    }
    else {
        exports.XLSX_IMAGES.set(imageToAdd.id, [{ sheetId: idx, image: [imageToAdd] }]);
        exports.XLSX_WORKBOOK_IMAGE_IDS.set(imageToAdd.id, {
            type: imageToAdd.imageType,
            index: exports.XLSX_WORKBOOK_IMAGE_IDS.size,
        });
    }
}
function addSheetName(worksheet) {
    const name = (0, ag_grid_community_1._escapeString)(worksheet.name) || '';
    let append = '';
    while (XLSX_SHEET_NAMES.indexOf(`${name}${append}`) !== -1) {
        if (append === '') {
            append = '_1';
        }
        else {
            const curr = parseInt(append.slice(1), 10);
            append = `_${curr + 1}`;
        }
    }
    worksheet.name = `${name}${append}`;
    XLSX_SHEET_NAMES.push(worksheet.name);
}
function getXlsxStringPosition(str) {
    if (XLSX_SHARED_STRINGS.has(str)) {
        return XLSX_SHARED_STRINGS.get(str);
    }
    XLSX_SHARED_STRINGS.set(str, XLSX_SHARED_STRINGS.size);
    return XLSX_SHARED_STRINGS.size - 1;
}
exports.getXlsxStringPosition = getXlsxStringPosition;
function resetXlsxFactory() {
    XLSX_SHARED_STRINGS.clear();
    exports.XLSX_IMAGES.clear();
    exports.XLSX_WORKSHEET_IMAGES.clear();
    exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.clear();
    exports.XLSX_WORKBOOK_IMAGE_IDS.clear();
    exports.XLSX_WORKSHEET_IMAGE_IDS.clear();
    exports.XLSX_WORKSHEET_DATA_TABLES.clear();
    XLSX_SHEET_NAMES = [];
    XLSX_FACTORY_MODE = 'SINGLE_SHEET';
}
exports.resetXlsxFactory = resetXlsxFactory;
function createXlsxWorkbook(currentSheet) {
    return (0, excelUtils_1.createXmlPart)(workbook_1.default.getTemplate(XLSX_SHEET_NAMES, currentSheet));
}
exports.createXlsxWorkbook = createXlsxWorkbook;
function createXlsxStylesheet(defaultFontSize) {
    return (0, excelUtils_1.createXmlPart)(stylesheet_1.default.getTemplate(defaultFontSize));
}
exports.createXlsxStylesheet = createXlsxStylesheet;
function createXlsxSharedStrings() {
    return (0, excelUtils_1.createXmlPart)(sharedStrings_1.default.getTemplate(XLSX_SHARED_STRINGS));
}
exports.createXlsxSharedStrings = createXlsxSharedStrings;
function createXlsxCore(author) {
    return (0, excelUtils_1.createXmlPart)(core_1.default.getTemplate(author));
}
exports.createXlsxCore = createXlsxCore;
function createXlsxContentTypes(sheetLen) {
    return (0, excelUtils_1.createXmlPart)(contentTypes_1.default.getTemplate(sheetLen));
}
exports.createXlsxContentTypes = createXlsxContentTypes;
function createXlsxRels() {
    const rs = relationships_1.default.getTemplate([
        {
            Id: 'rId1',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
            Target: 'xl/workbook.xml',
        },
        {
            Id: 'rId2',
            Type: 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
            Target: 'docProps/core.xml',
        },
    ]);
    return (0, excelUtils_1.createXmlPart)(rs);
}
exports.createXlsxRels = createXlsxRels;
function createXlsxTheme() {
    return (0, excelUtils_1.createXmlPart)(office_1.default.getTemplate());
}
exports.createXlsxTheme = createXlsxTheme;
function createXlsxTable(dataTable, index) {
    return (0, excelUtils_1.createXmlPart)(table_1.default.getTemplate(dataTable, index));
}
exports.createXlsxTable = createXlsxTable;
function createXlsxWorkbookRels(sheetLen) {
    const worksheets = new Array(sheetLen).fill(undefined).map((v, i) => ({
        Id: `rId${i + 1}`,
        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
        Target: `worksheets/sheet${i + 1}.xml`,
    }));
    const rs = relationships_1.default.getTemplate([
        ...worksheets,
        {
            Id: `rId${sheetLen + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
            Target: 'theme/theme1.xml',
        },
        {
            Id: `rId${sheetLen + 2}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
            Target: 'styles.xml',
        },
        {
            Id: `rId${sheetLen + 3}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
            Target: 'sharedStrings.xml',
        },
    ]);
    return (0, excelUtils_1.createXmlPart)(rs);
}
exports.createXlsxWorkbookRels = createXlsxWorkbookRels;
function createXlsxDrawing(sheetIndex) {
    return (0, excelUtils_1.createXmlPart)(drawing_1.default.getTemplate({ sheetIndex }));
}
exports.createXlsxDrawing = createXlsxDrawing;
function createXlsxDrawingRel(sheetIndex) {
    const worksheetImageIds = exports.XLSX_WORKSHEET_IMAGE_IDS.get(sheetIndex) || [];
    const XMLArr = [];
    for (const [key, value] of worksheetImageIds) {
        const { index, type } = value;
        XMLArr.push({
            Id: `rId${index + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
            Target: `../media/image${exports.XLSX_WORKBOOK_IMAGE_IDS.get(key).index + 1}.${(0, contentTypes_1._normaliseImageExtension)(type)}`,
        });
    }
    return (0, excelUtils_1.createXmlPart)(relationships_1.default.getTemplate(XMLArr));
}
exports.createXlsxDrawingRel = createXlsxDrawingRel;
function createXlsxVmlDrawing(sheetIndex) {
    return (0, excelUtils_1.createXmlPart)(vmlDrawing_1.default.getTemplate({ sheetIndex }), true);
}
exports.createXlsxVmlDrawing = createXlsxVmlDrawing;
function createXlsxVmlDrawingRel(sheetIndex) {
    const worksheetHeaderFooterImages = exports.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.get(sheetIndex) || [];
    const XMLArr = [];
    for (let i = 0; i < worksheetHeaderFooterImages.length; i++) {
        const headerFooterImage = worksheetHeaderFooterImages[i];
        const workbookImage = exports.XLSX_WORKBOOK_IMAGE_IDS.get(headerFooterImage.id);
        if (!workbookImage) {
            continue;
        }
        const { index, type } = workbookImage;
        XMLArr.push({
            Id: `rId${i + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
            Target: `../media/image${index + 1}.${(0, contentTypes_1._normaliseImageExtension)(type)}`,
        });
    }
    return (0, excelUtils_1.createXmlPart)(relationships_1.default.getTemplate(XMLArr));
}
exports.createXlsxVmlDrawingRel = createXlsxVmlDrawingRel;
function createXlsxRelationships({ drawingIndex, vmlDrawingIndex, tableName, } = {}) {
    if (drawingIndex === undefined && vmlDrawingIndex === undefined && tableName === undefined) {
        return '';
    }
    const config = [];
    if (drawingIndex != null) {
        config.push({
            Id: `rId${config.length + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
            Target: `../drawings/drawing${drawingIndex + 1}.xml`,
        });
    }
    if (vmlDrawingIndex != null) {
        config.push({
            Id: `rId${config.length + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
            Target: `../drawings/vmlDrawing${vmlDrawingIndex + 1}.vml`,
        });
    }
    if (tableName != null) {
        config.push({
            Id: `rId${config.length + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
            Target: `../tables/${tableName}.xml`,
        });
    }
    const rs = relationships_1.default.getTemplate(config);
    return (0, excelUtils_1.createXmlPart)(rs);
}
exports.createXlsxRelationships = createXlsxRelationships;
function createWorksheet(worksheet, config) {
    return (0, excelUtils_1.createXmlPart)(worksheet_1.default.getTemplate({
        worksheet,
        currentSheet: XLSX_SHEET_NAMES.length - 1,
        config,
    }));
}


/***/ }),

/***/ 3391:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ag_grid_community_1 = __webpack_require__(6624);
const excelUtils_1 = __webpack_require__(3237);
const stylesheet_1 = __webpack_require__(3056);
const convertLegacyType = (type) => {
    const t = type.charAt(0).toLowerCase();
    return t === 's' ? 'inlineStr' : t;
};
const cellFactory = {
    getTemplate(config, idx, currentSheet) {
        const { ref, data, styleId } = config;
        const { type, value } = data || { type: 'empty', value: null };
        let convertedType = type;
        if (type === 'f') {
            convertedType = 'str';
        }
        else if (type.charAt(0) === type.charAt(0).toUpperCase()) {
            convertedType = convertLegacyType(type);
        }
        const obj = {
            name: 'c',
            properties: {
                rawMap: {
                    r: ref,
                    t: convertedType === 'empty' ? undefined : convertedType,
                    s: styleId ? (0, stylesheet_1.getStyleId)(styleId, currentSheet) : undefined,
                },
            },
        };
        if (convertedType === 'empty') {
            return obj;
        }
        let children;
        if (convertedType === 'str' && type === 'f') {
            children = [
                {
                    name: 'f',
                    textNode: (0, ag_grid_community_1._escapeString)((0, excelUtils_1.replaceInvisibleCharacters)(value), false),
                },
            ];
        }
        else if (convertedType === 'inlineStr') {
            children = [
                {
                    name: 'is',
                    children: [
                        {
                            name: 't',
                            textNode: (0, ag_grid_community_1._escapeString)((0, excelUtils_1.replaceInvisibleCharacters)(value), false),
                        },
                    ],
                },
            ];
        }
        else {
            children = [
                {
                    name: 'v',
                    textNode: value,
                },
            ];
        }
        return Object.assign({}, obj, { children });
    },
};
exports["default"] = cellFactory;


/***/ }),

/***/ 3285:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths
const getExcelCellWidth = (width) => Math.ceil((width - 12) / 7 + 1);
const colFactory = {
    getTemplate(config) {
        const { min, max, outlineLevel, s, width, hidden, bestFit } = config;
        let excelWidth = 1;
        let customWidth = '0';
        if (width > 1) {
            excelWidth = getExcelCellWidth(width);
            customWidth = '1';
        }
        return {
            name: 'col',
            properties: {
                rawMap: {
                    min: min,
                    max: max,
                    outlineLevel: outlineLevel != null ? outlineLevel : undefined,
                    width: excelWidth,
                    style: s,
                    hidden: hidden ? '1' : '0',
                    bestFit: bestFit ? '1' : '0',
                    customWidth: customWidth,
                },
            },
        };
    },
};
exports["default"] = colFactory;


/***/ }),

/***/ 2654:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const contentTypeFactory = {
    getTemplate(config) {
        const { name, ContentType, Extension, PartName } = config;
        return {
            name,
            properties: {
                rawMap: {
                    Extension,
                    PartName,
                    ContentType,
                },
            },
        };
    },
};
exports["default"] = contentTypeFactory;


/***/ }),

/***/ 541:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._normaliseImageExtension = void 0;
const tslib_1 = __webpack_require__(5608);
const excelXlsxFactory_1 = __webpack_require__(7165);
const contentType_1 = tslib_1.__importDefault(__webpack_require__(2654));
const _normaliseImageExtension = (ext) => (ext === 'jpg' ? 'jpeg' : ext);
exports._normaliseImageExtension = _normaliseImageExtension;
const contentTypesFactory = {
    getTemplate(sheetLen) {
        const worksheets = new Array(sheetLen).fill(undefined).map((v, i) => ({
            name: 'Override',
            ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
            PartName: `/xl/worksheets/sheet${i + 1}.xml`,
        }));
        const sheetsWithImages = excelXlsxFactory_1.XLSX_WORKSHEET_IMAGES.size;
        const headerFooterImages = excelXlsxFactory_1.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.size;
        const imageTypesObject = {};
        excelXlsxFactory_1.XLSX_WORKBOOK_IMAGE_IDS.forEach((v) => {
            imageTypesObject[(0, exports._normaliseImageExtension)(v.type)] = true;
        });
        const imageDocs = new Array(sheetsWithImages).fill(undefined).map((v, i) => ({
            name: 'Override',
            ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
            PartName: `/xl/drawings/drawing${i + 1}.xml`,
        }));
        const tableDocs = [];
        excelXlsxFactory_1.XLSX_WORKSHEET_DATA_TABLES.forEach(({ name }) => {
            tableDocs.push({
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
                PartName: `/xl/tables/${name}.xml`,
            });
        });
        const imageTypes = Object.keys(imageTypesObject).map((ext) => ({
            name: 'Default',
            ContentType: `image/${ext}`,
            Extension: ext,
        }));
        if (headerFooterImages) {
            imageTypes.push({
                name: 'Default',
                Extension: 'vml',
                ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',
            });
        }
        const children = [
            ...imageTypes,
            {
                name: 'Default',
                Extension: 'rels',
                ContentType: 'application/vnd.openxmlformats-package.relationships+xml',
            },
            {
                name: 'Default',
                ContentType: 'application/xml',
                Extension: 'xml',
            },
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
                PartName: '/xl/workbook.xml',
            },
            ...worksheets,
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',
                PartName: '/xl/theme/theme1.xml',
            },
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
                PartName: '/xl/styles.xml',
            },
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
                PartName: '/xl/sharedStrings.xml',
            },
            ...imageDocs,
            ...tableDocs,
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',
                PartName: '/docProps/core.xml',
            },
        ].map((contentType) => contentType_1.default.getTemplate(contentType));
        return {
            name: 'Types',
            properties: {
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',
                },
            },
            children,
        };
    },
};
exports["default"] = contentTypesFactory;


/***/ }),

/***/ 1528:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const coreFactory = {
    getTemplate(author) {
        const dt = new Date();
        const jsonDate = dt.toJSON();
        return {
            name: 'cp:coreProperties',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'xmlns:',
                        map: {
                            cp: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
                            dc: 'http://purl.org/dc/elements/1.1/',
                            dcterms: 'http://purl.org/dc/terms/',
                            dcmitype: 'http://purl.org/dc/dcmitype/',
                            xsi: 'http://www.w3.org/2001/XMLSchema-instance',
                        },
                    },
                ],
            },
            children: [
                {
                    name: 'dc:creator',
                    textNode: author,
                },
                {
                    name: 'dc:title',
                    textNode: 'Workbook',
                },
                {
                    name: 'dcterms:created',
                    properties: {
                        rawMap: {
                            'xsi:type': 'dcterms:W3CDTF',
                        },
                    },
                    textNode: jsonDate,
                },
                {
                    name: 'dcterms:modified',
                    properties: {
                        rawMap: {
                            'xsi:type': 'dcterms:W3CDTF',
                        },
                    },
                    textNode: jsonDate,
                },
            ],
        };
    },
};
exports["default"] = coreFactory;


/***/ }),

/***/ 6161:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelUtils_1 = __webpack_require__(3237);
const excelXlsxFactory_1 = __webpack_require__(7165);
const getAnchor = (name, imageAnchor) => ({
    name: `xdr:${name}`,
    children: [
        {
            name: 'xdr:col',
            textNode: imageAnchor.col.toString(),
        },
        {
            name: 'xdr:colOff',
            textNode: imageAnchor.offsetX.toString(),
        },
        {
            name: 'xdr:row',
            textNode: imageAnchor.row.toString(),
        },
        {
            name: 'xdr:rowOff',
            textNode: imageAnchor.offsetY.toString(),
        },
    ],
});
const getExt = (image) => {
    const children = [
        {
            name: 'a:ext',
            properties: {
                rawMap: {
                    uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}',
                },
            },
            children: [
                {
                    name: 'a16:creationId',
                    properties: {
                        rawMap: {
                            id: '{822E6D20-D7BC-2841-A643-D49A6EF008A2}',
                            'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',
                        },
                    },
                },
            ],
        },
    ];
    const recolor = image.recolor && image.recolor.toLowerCase();
    switch (recolor) {
        case 'grayscale':
        case 'sepia':
        case 'washout':
            children.push({
                name: 'a:ext',
                properties: {
                    rawMap: {
                        uri: '{C183D7F6-B498-43B3-948B-1728B52AA6E4}',
                    },
                },
                children: [
                    {
                        name: 'adec:decorative',
                        properties: {
                            rawMap: {
                                val: '0',
                                'xmlns:adec': 'http://schemas.microsoft.com/office/drawing/2017/decorative',
                            },
                        },
                    },
                ],
            });
    }
    return {
        name: 'a:extLst',
        children,
    };
};
const getNvPicPr = (image, index) => ({
    name: 'xdr:nvPicPr',
    children: [
        {
            name: 'xdr:cNvPr',
            properties: {
                rawMap: {
                    id: index,
                    name: image.id,
                    descr: image.altText != null ? image.altText : undefined,
                },
            },
            children: [getExt(image)],
        },
        {
            name: 'xdr:cNvPicPr',
            properties: {
                rawMap: {
                    preferRelativeResize: '0',
                },
            },
            children: [
                {
                    name: 'a:picLocks',
                },
            ],
        },
    ],
});
const getColorDetails = (color) => {
    if (!color.saturation && !color.tint) {
        return;
    }
    const ret = [];
    if (color.saturation) {
        ret.push({
            name: 'a:satMod',
            properties: {
                rawMap: {
                    val: color.saturation * 1000,
                },
            },
        });
    }
    if (color.tint) {
        ret.push({
            name: 'a:tint',
            properties: {
                rawMap: {
                    val: color.tint * 1000,
                },
            },
        });
    }
    return ret;
};
const getDuoTone = (primaryColor, secondaryColor) => {
    return {
        name: 'a:duotone',
        children: [
            {
                name: 'a:prstClr',
                properties: {
                    rawMap: {
                        val: primaryColor.color,
                    },
                },
                children: getColorDetails(primaryColor),
            },
            {
                name: 'a:srgbClr',
                properties: {
                    rawMap: {
                        val: secondaryColor.color,
                    },
                },
                children: getColorDetails(secondaryColor),
            },
        ],
    };
};
const getBlipFill = (image, index) => {
    let blipChildren;
    if (image.transparency) {
        const transparency = Math.min(Math.max(image.transparency, 0), 100);
        blipChildren = [
            {
                name: 'a:alphaModFix',
                properties: {
                    rawMap: {
                        amt: 100000 - Math.round(transparency * 1000),
                    },
                },
            },
        ];
    }
    if (image.recolor) {
        if (!blipChildren) {
            blipChildren = [];
        }
        switch (image.recolor.toLocaleLowerCase()) {
            case 'grayscale':
                blipChildren.push({ name: 'a:grayscl' });
                break;
            case 'sepia':
                blipChildren.push(getDuoTone({ color: 'black' }, { color: 'D9C3A5', tint: 50, saturation: 180 }));
                break;
            case 'washout':
                blipChildren.push({
                    name: 'a:lum',
                    properties: {
                        rawMap: {
                            bright: '70000',
                            contrast: '-70000',
                        },
                    },
                });
                break;
            default:
        }
    }
    return {
        name: 'xdr:blipFill',
        children: [
            {
                name: 'a:blip',
                properties: {
                    rawMap: {
                        cstate: 'print',
                        'r:embed': `rId${index}`,
                        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                    },
                },
                children: blipChildren,
            },
            {
                name: 'a:stretch',
                children: [
                    {
                        name: 'a:fillRect',
                    },
                ],
            },
        ],
    };
};
const getSpPr = (image, imageBoxSize) => {
    const xfrm = {
        name: 'a:xfrm',
        children: [
            {
                name: 'a:off',
                properties: {
                    rawMap: {
                        x: 0,
                        y: 0,
                    },
                },
            },
            {
                name: 'a:ext',
                properties: {
                    rawMap: {
                        cx: imageBoxSize.width,
                        cy: imageBoxSize.height,
                    },
                },
            },
        ],
    };
    if (image.rotation) {
        const rotation = image.rotation;
        xfrm.properties = {
            rawMap: {
                rot: Math.min(Math.max(rotation, 0), 360) * 60000,
            },
        };
    }
    const prstGeom = {
        name: 'a:prstGeom',
        properties: {
            rawMap: {
                prst: 'rect',
            },
        },
        children: [{ name: 'a:avLst' }],
    };
    const ret = {
        name: 'xdr:spPr',
        children: [xfrm, prstGeom],
    };
    return ret;
};
const getImageBoxSize = (image) => {
    image.fitCell = !!image.fitCell || !image.width || !image.height;
    const { position = {}, fitCell, width = 0, height = 0, totalHeight, totalWidth } = image;
    const { offsetX = 0, offsetY = 0, row = 1, rowSpan = 1, column = 1, colSpan = 1 } = position;
    return {
        from: {
            row: row - 1,
            col: column - 1,
            offsetX: (0, excelUtils_1.pixelsToEMU)(offsetX),
            offsetY: (0, excelUtils_1.pixelsToEMU)(offsetY),
        },
        to: {
            row: row - 1 + (fitCell ? 1 : rowSpan - 1),
            col: column - 1 + (fitCell ? 1 : colSpan - 1),
            offsetX: (0, excelUtils_1.pixelsToEMU)(width + offsetX),
            offsetY: (0, excelUtils_1.pixelsToEMU)(height + offsetY),
        },
        height: (0, excelUtils_1.pixelsToEMU)(totalHeight || height),
        width: (0, excelUtils_1.pixelsToEMU)(totalWidth || width),
    };
};
const getPicture = (image, currentIndex, worksheetImageIndex, imageBoxSize) => {
    return {
        name: 'xdr:pic',
        children: [
            getNvPicPr(image, currentIndex + 1),
            getBlipFill(image, worksheetImageIndex + 1),
            getSpPr(image, imageBoxSize),
        ],
    };
};
const drawingFactory = {
    getTemplate(config) {
        const { sheetIndex } = config;
        const sheetImages = excelXlsxFactory_1.XLSX_WORKSHEET_IMAGES.get(sheetIndex);
        const sheetImageIds = excelXlsxFactory_1.XLSX_WORKSHEET_IMAGE_IDS.get(sheetIndex);
        const children = sheetImages.map((image, idx) => {
            const boxSize = getImageBoxSize(image);
            return {
                name: 'xdr:twoCellAnchor',
                properties: {
                    rawMap: {
                        editAs: 'absolute',
                    },
                },
                children: [
                    getAnchor('from', boxSize.from),
                    getAnchor('to', boxSize.to),
                    getPicture(image, idx, sheetImageIds.get(image.id).index, boxSize),
                    { name: 'xdr:clientData' },
                ],
            };
        });
        return {
            name: 'xdr:wsDr',
            properties: {
                rawMap: {
                    'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
                },
            },
            children,
        };
    },
};
exports["default"] = drawingFactory;


/***/ }),

/***/ 1775:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const mergeCellFactory = {
    getTemplate(ref) {
        return {
            name: 'mergeCell',
            properties: {
                rawMap: {
                    ref: ref,
                },
            },
        };
    },
};
exports["default"] = mergeCellFactory;


/***/ }),

/***/ 637:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const relationshipFactory = {
    getTemplate(config) {
        const { Id, Type, Target } = config;
        return {
            name: 'Relationship',
            properties: {
                rawMap: {
                    Id,
                    Type,
                    Target,
                },
            },
        };
    },
};
exports["default"] = relationshipFactory;


/***/ }),

/***/ 7348:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const relationship_1 = tslib_1.__importDefault(__webpack_require__(637));
const relationshipsFactory = {
    getTemplate(c) {
        const children = c.map((relationship) => relationship_1.default.getTemplate(relationship));
        return {
            name: 'Relationships',
            properties: {
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
                },
            },
            children,
        };
    },
};
exports["default"] = relationshipsFactory;


/***/ }),

/***/ 7067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const excelUtils_1 = __webpack_require__(3237);
const cell_1 = tslib_1.__importDefault(__webpack_require__(3391));
const addEmptyCells = (cells, rowIdx) => {
    const mergeMap = [];
    let posCounter = 0;
    for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        if (cell.mergeAcross) {
            mergeMap.push({
                pos: i,
                excelPos: posCounter,
            });
            posCounter += cell.mergeAcross;
        }
        posCounter++;
    }
    if (mergeMap.length) {
        for (let i = mergeMap.length - 1; i >= 0; i--) {
            const mergedCells = [];
            const cell = cells[mergeMap[i].pos];
            for (let j = 1; j <= cell.mergeAcross; j++) {
                mergedCells.push({
                    ref: `${(0, excelUtils_1.getExcelColumnName)(mergeMap[i].excelPos + 1 + j)}${rowIdx + 1}`,
                    styleId: cell.styleId,
                    data: { type: 'empty', value: null },
                });
            }
            if (mergedCells.length) {
                cells.splice(mergeMap[i].pos + 1, 0, ...mergedCells);
            }
        }
    }
};
const shouldDisplayCell = (cell) => cell.data?.value !== '' || cell.styleId !== undefined;
const rowFactory = {
    getTemplate(config, idx, currentSheet) {
        const { collapsed, hidden, height, outlineLevel, cells = [] } = config;
        addEmptyCells(cells, idx);
        const children = cells
            .filter(shouldDisplayCell)
            .map((cell, idx) => cell_1.default.getTemplate(cell, idx, currentSheet));
        return {
            name: 'row',
            properties: {
                rawMap: {
                    r: idx + 1,
                    collapsed: collapsed ? '1' : '0',
                    hidden: hidden ? '1' : '0',
                    ht: height,
                    customHeight: height != null ? '1' : '0',
                    spans: '1:1',
                    outlineLevel: outlineLevel || undefined,
                },
            },
            children,
        };
    },
};
exports["default"] = rowFactory;


/***/ }),

/***/ 1126:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelUtils_1 = __webpack_require__(3237);
const sharedStrings = {
    getTemplate(strings) {
        return {
            name: 'sst',
            properties: {
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    count: strings.size,
                    uniqueCount: strings.size,
                },
            },
            children: (0, excelUtils_1.buildSharedString)(strings),
        };
    },
};
exports["default"] = sharedStrings;


/***/ }),

/***/ 7440:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sheetFactory = {
    getTemplate(name, idx) {
        const sheetId = (idx + 1).toString();
        return {
            name: 'sheet',
            properties: {
                rawMap: {
                    name: name,
                    sheetId: sheetId,
                    'r:id': `rId${sheetId}`,
                },
            },
        };
    },
};
exports["default"] = sheetFactory;


/***/ }),

/***/ 2023:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const sheet_1 = tslib_1.__importDefault(__webpack_require__(7440));
const sheetsFactory = {
    getTemplate(names) {
        return {
            name: 'sheets',
            children: names.map((sheet, idx) => sheet_1.default.getTemplate(sheet, idx)),
        };
    },
};
exports["default"] = sheetsFactory;


/***/ }),

/***/ 1951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelLegacyConvert_1 = __webpack_require__(1842);
const getReadingOrderId = (readingOrder) => {
    const order = ['Context', 'LeftToRight', 'RightToLeft'];
    const pos = order.indexOf(readingOrder);
    return Math.max(pos, 0);
};
const alignmentFactory = {
    getTemplate(alignment) {
        const { horizontal, indent, readingOrder, rotate, shrinkToFit, vertical, wrapText } = alignment;
        return {
            name: 'alignment',
            properties: {
                rawMap: {
                    horizontal: horizontal && (0, excelLegacyConvert_1.convertLegacyHorizontalAlignment)(horizontal),
                    indent,
                    readingOrder: readingOrder && getReadingOrderId(readingOrder),
                    textRotation: rotate,
                    shrinkToFit,
                    vertical: vertical && (0, excelLegacyConvert_1.convertLegacyVerticalAlignment)(vertical),
                    wrapText,
                },
            },
        };
    },
};
exports["default"] = alignmentFactory;


/***/ }),

/***/ 3142:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelLegacyConvert_1 = __webpack_require__(1842);
const getBorderColor = (color) => {
    return {
        name: 'color',
        properties: {
            rawMap: {
                rgb: (0, excelLegacyConvert_1.convertLegacyColor)(color || '#000000'),
            },
        },
    };
};
const borderFactory = {
    getTemplate(border) {
        const { left, right, top, bottom, diagonal } = border;
        const leftChildren = left ? [getBorderColor(left.color)] : undefined;
        const rightChildren = right ? [getBorderColor(right.color)] : undefined;
        const topChildren = top ? [getBorderColor(top.color)] : undefined;
        const bottomChildren = bottom ? [getBorderColor(bottom.color)] : undefined;
        const diagonalChildren = diagonal ? [getBorderColor(diagonal.color)] : undefined;
        return {
            name: 'border',
            children: [
                {
                    name: 'left',
                    properties: { rawMap: { style: left && left.style } },
                    children: leftChildren,
                },
                {
                    name: 'right',
                    properties: { rawMap: { style: right && right.style } },
                    children: rightChildren,
                },
                {
                    name: 'top',
                    properties: { rawMap: { style: top && top.style } },
                    children: topChildren,
                },
                {
                    name: 'bottom',
                    properties: { rawMap: { style: bottom && bottom.style } },
                    children: bottomChildren,
                },
                {
                    name: 'diagonal',
                    properties: { rawMap: { style: diagonal && diagonal.style } },
                    children: diagonalChildren,
                },
            ],
        };
    },
};
exports["default"] = borderFactory;


/***/ }),

/***/ 773:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const border_1 = tslib_1.__importDefault(__webpack_require__(3142));
const bordersFactory = {
    getTemplate(borders) {
        return {
            name: 'borders',
            properties: {
                rawMap: {
                    count: borders.length,
                },
            },
            children: borders.map((border) => border_1.default.getTemplate(border)),
        };
    },
};
exports["default"] = bordersFactory;


/***/ }),

/***/ 5271:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const borderFactory = {
    getTemplate(cellStyle) {
        const { builtinId, name, xfId } = cellStyle;
        return {
            name: 'cellStyle',
            properties: {
                rawMap: {
                    builtinId,
                    name,
                    xfId,
                },
            },
        };
    },
};
exports["default"] = borderFactory;


/***/ }),

/***/ 4100:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const xf_1 = tslib_1.__importDefault(__webpack_require__(7234));
const cellStylesXfsFactory = {
    getTemplate(xfs) {
        return {
            name: 'cellStyleXfs',
            properties: {
                rawMap: {
                    count: xfs.length,
                },
            },
            children: xfs.map((xf) => xf_1.default.getTemplate(xf)),
        };
    },
};
exports["default"] = cellStylesXfsFactory;


/***/ }),

/***/ 3246:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const cellStyle_1 = tslib_1.__importDefault(__webpack_require__(5271));
const cellStylesFactory = {
    getTemplate(cellStyles) {
        return {
            name: 'cellStyles',
            properties: {
                rawMap: {
                    count: cellStyles.length,
                },
            },
            children: cellStyles.map((cellStyle) => cellStyle_1.default.getTemplate(cellStyle)),
        };
    },
};
exports["default"] = cellStylesFactory;


/***/ }),

/***/ 4473:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const xf_1 = tslib_1.__importDefault(__webpack_require__(7234));
const cellXfsFactory = {
    getTemplate(xfs) {
        return {
            name: 'cellXfs',
            properties: {
                rawMap: {
                    count: xfs.length,
                },
            },
            children: xfs.map((xf) => xf_1.default.getTemplate(xf)),
        };
    },
};
exports["default"] = cellXfsFactory;


/***/ }),

/***/ 3153:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fillFactory = {
    getTemplate(fill) {
        const { patternType, fgTheme, fgTint, fgRgb, bgRgb, bgIndexed } = fill;
        const pf = {
            name: 'patternFill',
            properties: {
                rawMap: {
                    patternType,
                },
            },
        };
        if (fgTheme || fgTint || fgRgb) {
            pf.children = [
                {
                    name: 'fgColor',
                    properties: {
                        rawMap: {
                            theme: fgTheme,
                            tint: fgTint,
                            rgb: fgRgb,
                        },
                    },
                },
            ];
        }
        if (bgIndexed || bgRgb) {
            if (!pf.children) {
                pf.children = [];
            }
            pf.children.push({
                name: 'bgColor',
                properties: {
                    rawMap: {
                        indexed: bgIndexed,
                        rgb: bgRgb,
                    },
                },
            });
        }
        return {
            name: 'fill',
            children: [pf],
        };
    },
};
exports["default"] = fillFactory;


/***/ }),

/***/ 9392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const fill_1 = tslib_1.__importDefault(__webpack_require__(3153));
const fillsFactory = {
    getTemplate(fills) {
        return {
            name: 'fills',
            properties: {
                rawMap: {
                    count: fills.length,
                },
            },
            children: fills.map((fill) => fill_1.default.getTemplate(fill)),
        };
    },
};
exports["default"] = fillsFactory;


/***/ }),

/***/ 585:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fontFactory = {
    getTemplate(font) {
        const { size, colorTheme, color = 'FF000000', fontName = 'Calibri', family, scheme, italic, bold, strikeThrough, outline, shadow, underline, verticalAlign, } = font;
        const children = [
            { name: 'sz', properties: { rawMap: { val: size } } },
            { name: 'color', properties: { rawMap: { theme: colorTheme, rgb: color } } },
            { name: 'name', properties: { rawMap: { val: fontName } } },
        ];
        if (family) {
            children.push({ name: 'family', properties: { rawMap: { val: family } } });
        }
        if (scheme) {
            children.push({ name: 'scheme', properties: { rawMap: { val: scheme } } });
        }
        if (italic) {
            children.push({ name: 'i' });
        }
        if (bold) {
            children.push({ name: 'b' });
        }
        if (strikeThrough) {
            children.push({ name: 'strike' });
        }
        if (outline) {
            children.push({ name: 'outline' });
        }
        if (shadow) {
            children.push({ name: 'shadow' });
        }
        if (underline) {
            children.push({ name: 'u', properties: { rawMap: { val: underline } } });
        }
        if (verticalAlign) {
            children.push({ name: 'vertAlign', properties: { rawMap: { val: verticalAlign } } });
        }
        return { name: 'font', children };
    },
};
exports["default"] = fontFactory;


/***/ }),

/***/ 3704:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const font_1 = tslib_1.__importDefault(__webpack_require__(585));
const fontsFactory = {
    getTemplate(fonts) {
        return {
            name: 'fonts',
            properties: {
                rawMap: {
                    count: fonts.length,
                },
            },
            children: fonts.map((font) => font_1.default.getTemplate(font)),
        };
    },
};
exports["default"] = fontsFactory;


/***/ }),

/***/ 7282:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ag_grid_community_1 = __webpack_require__(6624);
function prepareString(str) {
    const split = str.split(/(\[[^\]]*\])/);
    for (let i = 0; i < split.length; i++) {
        // excel formulas require symbols to be escaped. Excel also requires $ to be
        // placed in quotes but only when the $ is not wrapped inside of square brackets.
        let currentString = split[i];
        if (!currentString.length) {
            continue;
        }
        if (!currentString.startsWith('[')) {
            currentString = currentString.replace(/\$/g, '"$"');
        }
        split[i] = (0, ag_grid_community_1._escapeString)(currentString);
    }
    return split.join('');
}
const numberFormatFactory = {
    getTemplate(numberFormat) {
        let { formatCode, numFmtId } = numberFormat;
        if (formatCode.length) {
            formatCode = prepareString(formatCode);
        }
        return {
            name: 'numFmt',
            properties: {
                rawMap: {
                    formatCode,
                    numFmtId,
                },
            },
        };
    },
};
exports["default"] = numberFormatFactory;


/***/ }),

/***/ 5305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const numberFormat_1 = tslib_1.__importDefault(__webpack_require__(7282));
const numberFormatsFactory = {
    getTemplate(numberFormats) {
        return {
            name: 'numFmts',
            properties: {
                rawMap: {
                    count: numberFormats.length,
                },
            },
            children: numberFormats.map((numberFormat) => numberFormat_1.default.getTemplate(numberFormat)),
        };
    },
};
exports["default"] = numberFormatsFactory;


/***/ }),

/***/ 8187:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const protectionFactory = {
    getTemplate(protection) {
        const locked = protection.protected === false ? 0 : 1;
        const hidden = protection.hideFormula === true ? 1 : 0;
        return {
            name: 'protection',
            properties: {
                rawMap: {
                    hidden,
                    locked,
                },
            },
        };
    },
};
exports["default"] = protectionFactory;


/***/ }),

/***/ 3056:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerStyles = exports.getStyleId = void 0;
const tslib_1 = __webpack_require__(5608);
const excelConstants_1 = __webpack_require__(2805);
const excelLegacyConvert_1 = __webpack_require__(1842);
const excelUtils_1 = __webpack_require__(3237);
const borders_1 = tslib_1.__importDefault(__webpack_require__(773));
const cellStyleXfs_1 = tslib_1.__importDefault(__webpack_require__(4100));
const cellStyles_1 = tslib_1.__importDefault(__webpack_require__(3246));
const cellXfs_1 = tslib_1.__importDefault(__webpack_require__(4473));
const fills_1 = tslib_1.__importDefault(__webpack_require__(9392));
const fonts_1 = tslib_1.__importDefault(__webpack_require__(3704));
const numberFormats_1 = tslib_1.__importDefault(__webpack_require__(5305));
let stylesMap;
let registeredNumberFmts;
let registeredFonts;
let registeredFills;
let registeredBorders;
let registeredCellStyleXfs;
let registeredCellXfs;
let registeredCellStyles;
let currentSheet;
const getStyleName = (name, currentSheet) => {
    if (name.indexOf('mixedStyle') !== -1 && currentSheet > 1) {
        name += `_${currentSheet}`;
    }
    return name;
};
const resetStylesheetValues = () => {
    stylesMap = { base: 0 };
    registeredNumberFmts = [];
    registeredFonts = [{ fontName: 'Calibri', colorTheme: '1', family: '2', scheme: 'minor' }];
    registeredFills = [{ patternType: 'none' }, { patternType: 'gray125' }];
    registeredBorders = [{ left: undefined, right: undefined, top: undefined, bottom: undefined, diagonal: undefined }];
    registeredCellStyleXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0 }];
    registeredCellXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0, xfId: 0 }];
    registeredCellStyles = [{ builtinId: 0, name: 'Normal', xfId: 0 }];
};
const registerFill = (fill) => {
    const convertedPattern = (0, excelLegacyConvert_1.convertLegacyPattern)(fill.pattern);
    const convertedFillColor = (0, excelLegacyConvert_1.convertLegacyColor)(fill.color);
    const convertedPatternColor = (0, excelLegacyConvert_1.convertLegacyColor)(fill.patternColor);
    let pos = registeredFills.findIndex((currentFill) => {
        const { patternType, fgRgb, bgRgb } = currentFill;
        if (patternType != convertedPattern || fgRgb != convertedFillColor || bgRgb != convertedPatternColor) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredFills.length;
        registeredFills.push({
            patternType: convertedPattern,
            fgRgb: convertedFillColor,
            bgRgb: convertedPatternColor,
        });
    }
    return pos;
};
const registerNumberFmt = (format) => {
    if (excelConstants_1.numberFormatMap[format]) {
        return excelConstants_1.numberFormatMap[format];
    }
    let pos = registeredNumberFmts.findIndex((currentFormat) => currentFormat.formatCode === format);
    if (pos === -1) {
        pos = registeredNumberFmts.length + 164;
        registeredNumberFmts.push({ formatCode: format, numFmtId: pos });
    }
    else {
        pos = registeredNumberFmts[pos].numFmtId;
    }
    return pos;
};
const registerBorders = (borders) => {
    const { borderBottom, borderTop, borderLeft, borderRight } = borders;
    let bottomStyle;
    let topStyle;
    let leftStyle;
    let rightStyle;
    let bottomColor;
    let topColor;
    let leftColor;
    let rightColor;
    if (borderLeft) {
        leftStyle = (0, excelLegacyConvert_1.convertLegacyBorder)(borderLeft.lineStyle, borderLeft.weight);
        leftColor = (0, excelLegacyConvert_1.convertLegacyColor)(borderLeft.color);
    }
    if (borderRight) {
        rightStyle = (0, excelLegacyConvert_1.convertLegacyBorder)(borderRight.lineStyle, borderRight.weight);
        rightColor = (0, excelLegacyConvert_1.convertLegacyColor)(borderRight.color);
    }
    if (borderBottom) {
        bottomStyle = (0, excelLegacyConvert_1.convertLegacyBorder)(borderBottom.lineStyle, borderBottom.weight);
        bottomColor = (0, excelLegacyConvert_1.convertLegacyColor)(borderBottom.color);
    }
    if (borderTop) {
        topStyle = (0, excelLegacyConvert_1.convertLegacyBorder)(borderTop.lineStyle, borderTop.weight);
        topColor = (0, excelLegacyConvert_1.convertLegacyColor)(borderTop.color);
    }
    let pos = registeredBorders.findIndex((currentBorder) => {
        const { left, right, top, bottom } = currentBorder;
        if (!left && (leftStyle || leftColor)) {
            return false;
        }
        if (!right && (rightStyle || rightColor)) {
            return false;
        }
        if (!top && (topStyle || topColor)) {
            return false;
        }
        if (!bottom && (bottomStyle || bottomColor)) {
            return false;
        }
        const { style: clS, color: clC } = left || {};
        const { style: crS, color: crC } = right || {};
        const { style: ctS, color: ctC } = top || {};
        const { style: cbS, color: cbC } = bottom || {};
        if (clS != leftStyle || clC != leftColor) {
            return false;
        }
        if (crS != rightStyle || crC != rightColor) {
            return false;
        }
        if (ctS != topStyle || ctC != topColor) {
            return false;
        }
        if (cbS != bottomStyle || cbC != bottomColor) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredBorders.length;
        registeredBorders.push({
            left: {
                style: leftStyle,
                color: leftColor,
            },
            right: {
                style: rightStyle,
                color: rightColor,
            },
            top: {
                style: topStyle,
                color: topColor,
            },
            bottom: {
                style: bottomStyle,
                color: bottomColor,
            },
            diagonal: {
                style: undefined,
                color: undefined,
            },
        });
    }
    return pos;
};
const registerFont = (font) => {
    const { fontName: name = 'Calibri', color, size, bold, italic, outline, shadow, strikeThrough, underline, family, verticalAlign, } = font;
    const convertedColor = (0, excelLegacyConvert_1.convertLegacyColor)(color);
    const familyId = (0, excelUtils_1.getFontFamilyId)(family);
    const convertedUnderline = underline ? underline.toLocaleLowerCase() : undefined;
    const convertedVerticalAlign = verticalAlign ? verticalAlign.toLocaleLowerCase() : undefined;
    let pos = registeredFonts.findIndex((currentFont) => {
        if (currentFont.fontName != name ||
            currentFont.color != convertedColor ||
            currentFont.size != size ||
            currentFont.bold != bold ||
            currentFont.italic != italic ||
            currentFont.outline != outline ||
            currentFont.shadow != shadow ||
            currentFont.strikeThrough != strikeThrough ||
            currentFont.underline != convertedUnderline ||
            currentFont.verticalAlign != convertedVerticalAlign ||
            currentFont.family != familyId) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredFonts.length;
        registeredFonts.push({
            fontName: name,
            color: convertedColor,
            size,
            bold,
            italic,
            outline,
            shadow,
            strikeThrough,
            underline: convertedUnderline,
            verticalAlign: convertedVerticalAlign,
            family: familyId != null ? familyId.toString() : undefined,
        });
    }
    return pos;
};
const registerStyle = (config) => {
    const { alignment, borders, font, interior, numberFormat, protection, quotePrefix } = config;
    let { id } = config;
    let currentFill = 0;
    let currentBorder = 0;
    let currentFont = 0;
    let currentNumberFmt = 0;
    if (!id) {
        return;
    }
    id = getStyleName(id, currentSheet);
    if (stylesMap[id] != undefined) {
        return;
    }
    if (interior) {
        currentFill = registerFill(interior);
    }
    if (borders) {
        currentBorder = registerBorders(borders);
    }
    if (font) {
        currentFont = registerFont(font);
    }
    if (numberFormat) {
        currentNumberFmt = registerNumberFmt(numberFormat.format);
    }
    stylesMap[id] = registeredCellXfs.length;
    registeredCellXfs.push({
        alignment,
        borderId: currentBorder || 0,
        fillId: currentFill || 0,
        fontId: currentFont || 0,
        numFmtId: currentNumberFmt || 0,
        protection,
        quotePrefix: quotePrefix,
        xfId: 0,
    });
};
const stylesheetFactory = {
    getTemplate(defaultFontSize) {
        const numberFormats = numberFormats_1.default.getTemplate(registeredNumberFmts);
        const fonts = fonts_1.default.getTemplate(registeredFonts.map((font) => ({ ...font, size: font.size != null ? font.size : defaultFontSize })));
        const fills = fills_1.default.getTemplate(registeredFills);
        const borders = borders_1.default.getTemplate(registeredBorders);
        const cellStylesXfs = cellStyleXfs_1.default.getTemplate(registeredCellStyleXfs);
        const cellXfs = cellXfs_1.default.getTemplate(registeredCellXfs);
        const cellStyles = cellStyles_1.default.getTemplate(registeredCellStyles);
        resetStylesheetValues();
        return {
            name: 'styleSheet',
            properties: {
                rawMap: {
                    'mc:Ignorable': 'x14ac x16r2 xr',
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
                    'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
                    'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',
                    'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
                },
            },
            children: [
                numberFormats,
                fonts,
                fills,
                borders,
                cellStylesXfs,
                cellXfs,
                cellStyles,
                {
                    name: 'tableStyles',
                    properties: {
                        rawMap: {
                            count: 0,
                            defaultPivotStyle: 'PivotStyleLight16',
                            defaultTableStyle: 'TableStyleMedium2',
                        },
                    },
                },
            ],
        };
    },
};
const getStyleId = (name, currentSheet) => {
    return stylesMap[getStyleName(name, currentSheet)] || 0;
};
exports.getStyleId = getStyleId;
const registerStyles = (styles, _currentSheet) => {
    currentSheet = _currentSheet;
    if (currentSheet === 1) {
        resetStylesheetValues();
    }
    styles.forEach(registerStyle);
};
exports.registerStyles = registerStyles;
exports["default"] = stylesheetFactory;


/***/ }),

/***/ 7234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const alignment_1 = tslib_1.__importDefault(__webpack_require__(1951));
const protection_1 = tslib_1.__importDefault(__webpack_require__(8187));
const xfFactory = {
    getTemplate(xf) {
        const { alignment, borderId, fillId, fontId, numFmtId, protection, quotePrefix, xfId } = xf;
        const children = [];
        if (alignment) {
            children.push(alignment_1.default.getTemplate(alignment));
        }
        if (protection) {
            children.push(protection_1.default.getTemplate(protection));
        }
        return {
            name: 'xf',
            properties: {
                rawMap: {
                    applyAlignment: alignment ? 1 : undefined,
                    applyProtection: protection ? 1 : undefined,
                    applyBorder: borderId ? 1 : undefined,
                    applyFill: fillId ? 1 : undefined,
                    borderId,
                    fillId,
                    applyFont: fontId ? 1 : undefined,
                    fontId,
                    applyNumberFormat: numFmtId ? 1 : undefined,
                    numFmtId,
                    quotePrefix: quotePrefix ? 1 : undefined,
                    xfId,
                },
            },
            children: children.length ? children : undefined,
        };
    },
};
exports["default"] = xfFactory;


/***/ }),

/***/ 859:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelUtils_1 = __webpack_require__(3237);
const tableFactory = {
    getTemplate(dataTable, idx) {
        const { name, columns, rowRange, displayName, showRowStripes, showColumnStripes, showFilterButtons, highlightFirstColumn, highlightLastColumn, } = dataTable || {};
        const noRows = !rowRange || rowRange[0] - rowRange[1] === 0;
        if (!dataTable || !name || !Array.isArray(columns) || !columns.length || noRows) {
            return { name: 'table' };
        }
        const filterColumns = columns.map((col, idx) => ({
            name: 'filterColumn',
            properties: {
                rawMap: {
                    colId: idx.toString(),
                    hiddenButton: showFilterButtons[idx] ? 0 : 1,
                },
            },
        }));
        const firstCell = `A${rowRange[0]}`;
        const lastCell = `${(0, excelUtils_1.getExcelColumnName)(columns.length)}${rowRange[1]}`;
        const ref = `${firstCell}:${lastCell}`;
        const id = `${idx + 1}`;
        const displayNameToUse = idx ? `${displayName}_${id}` : displayName;
        return {
            name: 'table',
            properties: {
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
                    'mc:Ignorable': 'xr xr3',
                    'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
                    'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',
                    name,
                    displayName: displayNameToUse,
                    ref,
                    totalsRowShown: 0,
                    id,
                },
            },
            children: [
                {
                    name: 'autoFilter',
                    properties: {
                        rawMap: {
                            ref,
                        },
                    },
                    children: filterColumns,
                },
                {
                    name: 'tableColumns',
                    properties: {
                        rawMap: {
                            count: columns.length,
                        },
                    },
                    children: columns.map((col, idx) => ({
                        name: 'tableColumn',
                        properties: {
                            rawMap: {
                                id: (idx + 1).toString(),
                                name: col,
                                dataCellStyle: 'Normal',
                            },
                        },
                    })),
                },
                {
                    name: 'tableStyleInfo',
                    properties: {
                        rawMap: {
                            name: 'TableStyleLight1',
                            showFirstColumn: highlightFirstColumn ? 1 : 0,
                            showLastColumn: highlightLastColumn ? 1 : 0,
                            showRowStripes: showRowStripes ? 1 : 0,
                            showColumnStripes: showColumnStripes ? 1 : 0,
                        },
                    },
                },
            ],
        };
    },
};
exports["default"] = tableFactory;


/***/ }),

/***/ 6316:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const themeElements_1 = tslib_1.__importDefault(__webpack_require__(2119));
const officeTheme = {
    getTemplate() {
        return {
            name: 'a:theme',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'xmlns:',
                        map: {
                            a: 'http://schemas.openxmlformats.org/drawingml/2006/main',
                        },
                    },
                ],
                rawMap: {
                    name: 'Office Theme',
                },
            },
            children: [
                themeElements_1.default.getTemplate(),
                {
                    name: 'a:objectDefaults',
                },
                {
                    name: 'a:extraClrSchemeLst',
                },
            ],
        };
    },
};
exports["default"] = officeTheme;


/***/ }),

/***/ 9119:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const getColorChildren = (props) => {
    const [type, innerType, val, lastClr] = props;
    return {
        name: `a:${type}`,
        children: [
            {
                name: `a:${innerType}`,
                properties: {
                    rawMap: {
                        val,
                        lastClr,
                    },
                },
            },
        ],
    };
};
const colorScheme = {
    getTemplate() {
        return {
            name: 'a:clrScheme',
            properties: {
                rawMap: {
                    name: 'Office',
                },
            },
            children: [
                getColorChildren(['dk1', 'sysClr', 'windowText', '000000']),
                getColorChildren(['lt1', 'sysClr', 'window', 'FFFFFF']),
                getColorChildren(['dk2', 'srgbClr', '44546A']),
                getColorChildren(['lt2', 'srgbClr', 'E7E6E6']),
                getColorChildren(['accent1', 'srgbClr', '4472C4']),
                getColorChildren(['accent2', 'srgbClr', 'ED7D31']),
                getColorChildren(['accent3', 'srgbClr', 'A5A5A5']),
                getColorChildren(['accent4', 'srgbClr', 'FFC000']),
                getColorChildren(['accent5', 'srgbClr', '5B9BD5']),
                getColorChildren(['accent6', 'srgbClr', '70AD47']),
                getColorChildren(['hlink', 'srgbClr', '0563C1']),
                getColorChildren(['folHlink', 'srgbClr', '954F72']),
            ],
        };
    },
};
exports["default"] = colorScheme;


/***/ }),

/***/ 221:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const getFont = (props) => {
    const [type, typeface, script, panose] = props;
    return {
        name: `a:${type}`,
        properties: {
            rawMap: {
                script,
                typeface,
                panose,
            },
        },
    };
};
const fontScheme = {
    getTemplate() {
        return {
            name: 'a:fontScheme',
            properties: {
                rawMap: {
                    name: 'Office',
                },
            },
            children: [
                {
                    name: 'a:majorFont',
                    children: [
                        getFont(['latin', 'Calibri Light', undefined, '020F0302020204030204']),
                        getFont(['ea', '']),
                        getFont(['cs', '']),
                        getFont(['font', '游ゴシック Light', 'Jpan']),
                        getFont(['font', '맑은 고딕', 'Hang']),
                        getFont(['font', '等线 Light', 'Hans']),
                        getFont(['font', '新細明體', 'Hant']),
                        getFont(['font', 'Times New Roman', 'Arab']),
                        getFont(['font', 'Times New Roman', 'Hebr']),
                        getFont(['font', 'Tahoma', 'Thai']),
                        getFont(['font', 'Nyala', 'Ethi']),
                        getFont(['font', 'Vrinda', 'Beng']),
                        getFont(['font', 'Shruti', 'Gujr']),
                        getFont(['font', 'MoolBoran', 'Khmr']),
                        getFont(['font', 'Tunga', 'Knda']),
                        getFont(['font', 'Raavi', 'Guru']),
                        getFont(['font', 'Euphemia', 'Cans']),
                        getFont(['font', 'Plantagenet Cherokee', 'Cher']),
                        getFont(['font', 'Microsoft Yi Baiti', 'Yiii']),
                        getFont(['font', 'Microsoft Himalaya', 'Tibt']),
                        getFont(['font', 'MV Boli', 'Thaa']),
                        getFont(['font', 'Mangal', 'Deva']),
                        getFont(['font', 'Gautami', 'Telu']),
                        getFont(['font', 'Latha', 'Taml']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrc']),
                        getFont(['font', 'Kalinga', 'Orya']),
                        getFont(['font', 'Kartika', 'Mlym']),
                        getFont(['font', 'DokChampa', 'Laoo']),
                        getFont(['font', 'Iskoola Pota', 'Sinh']),
                        getFont(['font', 'Mongolian Baiti', 'Mong']),
                        getFont(['font', 'Times New Roman', 'Viet']),
                        getFont(['font', 'Microsoft Uighur', 'Uigh']),
                        getFont(['font', 'Sylfaen', 'Geor']),
                        getFont(['font', 'Arial', 'Armn']),
                        getFont(['font', 'Leelawadee UI', 'Bugi']),
                        getFont(['font', 'Microsoft JhengHei', 'Bopo']),
                        getFont(['font', 'Javanese Text', 'Java']),
                        getFont(['font', 'Segoe UI', 'Lisu']),
                        getFont(['font', 'Myanmar Text', 'Mymr']),
                        getFont(['font', 'Ebrima', 'Nkoo']),
                        getFont(['font', 'Nirmala UI', 'Olck']),
                        getFont(['font', 'Ebrima', 'Osma']),
                        getFont(['font', 'Phagspa', 'Phag']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrn']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrj']),
                        getFont(['font', 'Estrangelo Edessa', 'Syre']),
                        getFont(['font', 'Nirmala UI', 'Sora']),
                        getFont(['font', 'Microsoft Tai Le', 'Tale']),
                        getFont(['font', 'Microsoft New Tai Lue', 'Talu']),
                        getFont(['font', 'Ebrima', 'Tfng']),
                    ],
                },
                {
                    name: 'a:minorFont',
                    children: [
                        getFont(['latin', 'Calibri', undefined, '020F0502020204030204']),
                        getFont(['ea', '']),
                        getFont(['cs', '']),
                        getFont(['font', '游ゴシック', 'Jpan']),
                        getFont(['font', '맑은 고딕', 'Hang']),
                        getFont(['font', '等线', 'Hans']),
                        getFont(['font', '新細明體', 'Hant']),
                        getFont(['font', 'Arial', 'Arab']),
                        getFont(['font', 'Arial', 'Hebr']),
                        getFont(['font', 'Tahoma', 'Thai']),
                        getFont(['font', 'Nyala', 'Ethi']),
                        getFont(['font', 'Vrinda', 'Beng']),
                        getFont(['font', 'Shruti', 'Gujr']),
                        getFont(['font', 'DaunPenh', 'Khmr']),
                        getFont(['font', 'Tunga', 'Knda']),
                        getFont(['font', 'Raavi', 'Guru']),
                        getFont(['font', 'Euphemia', 'Cans']),
                        getFont(['font', 'Plantagenet Cherokee', 'Cher']),
                        getFont(['font', 'Microsoft Yi Baiti', 'Yiii']),
                        getFont(['font', 'Microsoft Himalaya', 'Tibt']),
                        getFont(['font', 'MV Boli', 'Thaa']),
                        getFont(['font', 'Mangal', 'Deva']),
                        getFont(['font', 'Gautami', 'Telu']),
                        getFont(['font', 'Latha', 'Taml']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrc']),
                        getFont(['font', 'Kalinga', 'Orya']),
                        getFont(['font', 'Kartika', 'Mlym']),
                        getFont(['font', 'DokChampa', 'Laoo']),
                        getFont(['font', 'Iskoola Pota', 'Sinh']),
                        getFont(['font', 'Mongolian Baiti', 'Mong']),
                        getFont(['font', 'Arial', 'Viet']),
                        getFont(['font', 'Microsoft Uighur', 'Uigh']),
                        getFont(['font', 'Sylfaen', 'Geor']),
                        getFont(['font', 'Arial', 'Armn']),
                        getFont(['font', 'Leelawadee UI', 'Bugi']),
                        getFont(['font', 'Microsoft JhengHei', 'Bopo']),
                        getFont(['font', 'Javanese Text', 'Java']),
                        getFont(['font', 'Segoe UI', 'Lisu']),
                        getFont(['font', 'Myanmar Text', 'Mymr']),
                        getFont(['font', 'Ebrima', 'Nkoo']),
                        getFont(['font', 'Nirmala UI', 'Olck']),
                        getFont(['font', 'Ebrima', 'Osma']),
                        getFont(['font', 'Phagspa', 'Phag']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrn']),
                        getFont(['font', 'Estrangelo Edessa', 'Syrj']),
                        getFont(['font', 'Estrangelo Edessa', 'Syre']),
                        getFont(['font', 'Nirmala UI', 'Sora']),
                        getFont(['font', 'Microsoft Tai Le', 'Tale']),
                        getFont(['font', 'Microsoft New Tai Lue', 'Talu']),
                        getFont(['font', 'Ebrima', 'Tfng']),
                    ],
                },
            ],
        };
    },
};
exports["default"] = fontScheme;


/***/ }),

/***/ 1203:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const getPropertyVal = (name, val, children) => ({
    name: `a:${name}`,
    properties: {
        rawMap: {
            val,
        },
    },
    children,
});
const getGs = (props) => {
    const [pos, schemeColor, satMod, lumMod, tint, shade] = props;
    const children = [];
    children.push(getPropertyVal('satMod', satMod));
    if (lumMod) {
        children.push(getPropertyVal('lumMod', lumMod));
    }
    if (tint) {
        children.push(getPropertyVal('tint', tint));
    }
    if (shade) {
        children.push(getPropertyVal('shade', shade));
    }
    return {
        name: 'a:gs',
        properties: {
            rawMap: {
                pos,
            },
        },
        children: [
            {
                name: 'a:schemeClr',
                properties: {
                    rawMap: {
                        val: schemeColor,
                    },
                },
                children,
            },
        ],
    };
};
const getSolidFill = (val, children) => ({
    name: 'a:solidFill',
    children: [getPropertyVal('schemeClr', val, children)],
});
const getGradFill = (props) => {
    const [rotWithShape, gs1, gs2, gs3, lin] = props;
    const [ang, scaled] = lin;
    return {
        name: 'a:gradFill',
        properties: {
            rawMap: {
                rotWithShape,
            },
        },
        children: [
            {
                name: 'a:gsLst',
                children: [getGs(gs1), getGs(gs2), getGs(gs3)],
            },
            {
                name: 'a:lin',
                properties: {
                    rawMap: {
                        ang: ang,
                        scaled: scaled,
                    },
                },
            },
        ],
    };
};
const getLine = (props) => {
    const [w, cap, cmpd, algn] = props;
    return {
        name: 'a:ln',
        properties: {
            rawMap: { w, cap, cmpd, algn },
        },
        children: [
            getSolidFill('phClr'),
            getPropertyVal('prstDash', 'solid'),
            {
                name: 'a:miter',
                properties: {
                    rawMap: {
                        lim: '800000',
                    },
                },
            },
        ],
    };
};
const getEffectStyle = (shadow) => {
    const children = [];
    if (shadow) {
        const [blurRad, dist, dir, algn, rotWithShape] = shadow;
        children.push({
            name: 'a:outerShdw',
            properties: {
                rawMap: { blurRad, dist, dir, algn, rotWithShape },
            },
            children: [getPropertyVal('srgbClr', '000000', [getPropertyVal('alpha', '63000')])],
        });
    }
    return {
        name: 'a:effectStyle',
        children: [
            Object.assign({}, {
                name: 'a:effectLst',
            }, children.length ? { children } : {}),
        ],
    };
};
const getFillStyleList = () => ({
    name: 'a:fillStyleLst',
    children: [
        getSolidFill('phClr'),
        getGradFill([
            '1',
            ['0', 'phClr', '105000', '110000', '67000'],
            ['50000', 'phClr', '103000', '105000', '73000'],
            ['100000', 'phClr', '109000', '105000', '81000'],
            ['5400000', '0'],
        ]),
        getGradFill([
            '1',
            ['0', 'phClr', '103000', '102000', '94000'],
            ['50000', 'phClr', '110000', '100000', undefined, '100000'],
            ['100000', 'phClr', '120000', '99000', undefined, '78000'],
            ['5400000', '0'],
        ]),
    ],
});
const getLineStyleList = () => ({
    name: 'a:lnStyleLst',
    children: [
        getLine(['6350', 'flat', 'sng', 'ctr']),
        getLine(['12700', 'flat', 'sng', 'ctr']),
        getLine(['19050', 'flat', 'sng', 'ctr']),
    ],
});
const getEffectStyleList = () => ({
    name: 'a:effectStyleLst',
    children: [getEffectStyle(), getEffectStyle(), getEffectStyle(['57150', '19050', '5400000', 'ctr', '0'])],
});
const getBgFillStyleList = () => ({
    name: 'a:bgFillStyleLst',
    children: [
        getSolidFill('phClr'),
        getSolidFill('phClr', [getPropertyVal('tint', '95000'), getPropertyVal('satMod', '170000')]),
        getGradFill([
            '1',
            ['0', 'phClr', '150000', '102000', '93000', '98000'],
            ['50000', 'phClr', '130000', '103000', '98000', '90000'],
            ['100000', 'phClr', '120000', undefined, undefined, '63000'],
            ['5400000', '0'],
        ]),
    ],
});
const formatScheme = {
    getTemplate() {
        return {
            name: 'a:fmtScheme',
            properties: {
                rawMap: {
                    name: 'Office',
                },
            },
            children: [getFillStyleList(), getLineStyleList(), getEffectStyleList(), getBgFillStyleList()],
        };
    },
};
exports["default"] = formatScheme;


/***/ }),

/***/ 2119:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const colorScheme_1 = tslib_1.__importDefault(__webpack_require__(9119));
const fontScheme_1 = tslib_1.__importDefault(__webpack_require__(221));
const formatScheme_1 = tslib_1.__importDefault(__webpack_require__(1203));
const themeElements = {
    getTemplate() {
        return {
            name: 'a:themeElements',
            children: [colorScheme_1.default.getTemplate(), fontScheme_1.default.getTemplate(), formatScheme_1.default.getTemplate()],
        };
    },
};
exports["default"] = themeElements;


/***/ }),

/***/ 5592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const excelXlsxFactory_1 = __webpack_require__(7165);
const getShapeLayout = () => ({
    name: 'o:shapelayout',
    properties: {
        prefixedAttributes: [
            {
                prefix: 'v:',
                map: {
                    ext: 'edit',
                },
            },
        ],
    },
    children: [
        {
            name: 'o:idmap',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'v:',
                        map: {
                            ext: 'edit',
                        },
                    },
                ],
                rawMap: {
                    data: '1',
                },
            },
        },
    ],
});
const getStroke = () => ({
    name: 'v:stroke',
    properties: {
        rawMap: {
            joinstyle: 'miter',
        },
    },
});
const getFormulas = (formulas) => ({
    name: 'v:formulas',
    children: formulas.map((formula) => ({
        name: 'v:f',
        properties: {
            rawMap: {
                eqn: formula,
            },
        },
    })),
});
const getPath = () => ({
    name: 'v:path',
    properties: {
        prefixedAttributes: [
            {
                prefix: 'o:',
                map: {
                    connecttype: 'rect',
                    extrusionok: 'f',
                },
            },
        ],
        rawMap: {
            gradientshapeok: 't',
        },
    },
});
const getLock = (params) => {
    const { aspectratio, rotation } = params || {};
    const rawMap = {};
    if (aspectratio) {
        rawMap.aspectratio = 't';
    }
    if (rotation) {
        rawMap.rotation = 't';
    }
    return {
        name: 'o:lock',
        properties: {
            prefixedAttributes: [
                {
                    prefix: 'v:',
                    map: {
                        ext: 'edit',
                    },
                },
            ],
            rawMap,
        },
    };
};
function mapNumber(value, startSource, endSource, startTarget, endTarget) {
    return ((value - startSource) / (endSource - startSource)) * (endTarget - startTarget) + startTarget;
}
const getImageData = (image, idx) => {
    let rawMap;
    const { recolor, brightness, contrast, id } = image;
    if (recolor) {
        rawMap = {};
        if (recolor === 'Washout' || recolor === 'Grayscale') {
            rawMap.gain = '19661f';
            rawMap.blacklevel = '22938f';
        }
        if (recolor === 'Black & White' || recolor === 'Grayscale') {
            rawMap.grayscale = 't';
            if (recolor === 'Black & White') {
                rawMap.bilevel = 't';
            }
        }
    }
    if (!recolor || recolor === 'Grayscale') {
        if (!rawMap) {
            rawMap = {};
        }
        if (contrast != null && contrast !== 50) {
            let gain = '1';
            if (contrast >= 0) {
                if (contrast < 50) {
                    gain = String(contrast / 50);
                }
                else if (contrast < 100) {
                    gain = String(50 / (100 - contrast));
                }
                else if (contrast === 100) {
                    gain = '2147483647f';
                }
            }
            rawMap.gain = gain;
        }
        if (brightness != null && brightness !== 50) {
            rawMap.blacklevel = mapNumber(brightness, 0, 100, -0.5, 0.5).toString();
        }
    }
    return {
        name: 'v:imagedata',
        properties: {
            prefixedAttributes: [
                {
                    prefix: 'o:',
                    map: {
                        relid: `rId${idx}`,
                        title: id,
                    },
                },
            ],
            rawMap,
        },
    };
};
const getShapeType = () => {
    const formulas = [
        'if lineDrawn pixelLineWidth 0',
        'sum @0 1 0',
        'sum 0 0 @1',
        'prod @2 1 2',
        'prod @3 21600 pixelWidth',
        'prod @3 21600 pixelHeight',
        'sum @0 0 1',
        'prod @6 1 2',
        'prod @7 21600 pixelWidth',
        'sum @8 21600 0',
        'prod @7 21600 pixelHeight',
        'sum @10 21600 0',
    ];
    return {
        name: 'v:shapetype',
        properties: {
            prefixedAttributes: [
                {
                    prefix: 'o:',
                    map: {
                        spt: '75',
                        preferrelative: 't',
                    },
                },
            ],
            rawMap: {
                coordsize: '21600,21600',
                filled: 'f',
                id: '_x0000_t75',
                path: 'm@4@5l@4@11@9@11@9@5xe',
                stroked: 'f',
            },
        },
        children: [getStroke(), getFormulas(formulas), getPath(), getLock({ aspectratio: true })],
    };
};
const pixelToPoint = (value) => Math.floor((value ?? 0) * 0.74999943307122);
const getShape = (image, idx) => {
    const { width = 0, height = 0, altText } = image;
    const imageWidth = pixelToPoint(width);
    const imageHeight = pixelToPoint(height);
    return {
        name: 'v:shape',
        properties: {
            rawMap: {
                id: image.headerFooterPosition,
                'o:spid': '_x0000_s1025',
                style: `position: absolute; margin-left: 0; margin-top: 10in; margin-bottom: 0; margin-right: 0; width: ${imageWidth}pt; height: ${imageHeight}pt; z-index: ${idx + 1}`,
                type: '#_x0000_t75',
                alt: altText,
            },
        },
        children: [getImageData(image, idx + 1), getLock({ rotation: true })],
    };
};
const vmlDrawingFactory = {
    getTemplate(params) {
        const headerFooterImages = excelXlsxFactory_1.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.get(params.sheetIndex) || [];
        const children = [
            getShapeLayout(),
            getShapeType(),
            ...headerFooterImages.map((img, idx) => getShape(img, idx)),
        ];
        return {
            name: 'xml',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'xmlns:',
                        map: {
                            v: 'urn:schemas-microsoft-com:vml',
                            o: 'urn:schemas-microsoft-com:office:office',
                            x: 'urn:schemas-microsoft-com:office:excel',
                        },
                    },
                ],
            },
            children,
        };
    },
};
exports["default"] = vmlDrawingFactory;


/***/ }),

/***/ 2519:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const sheets_1 = tslib_1.__importDefault(__webpack_require__(2023));
const workbookFactory = {
    getTemplate(names, activeTab) {
        return {
            name: 'workbook',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'xmlns:',
                        map: {
                            r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                        },
                    },
                ],
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                },
            },
            children: [
                {
                    name: 'bookViews',
                    children: [
                        {
                            name: 'workbookView',
                            properties: {
                                rawMap: {
                                    activeTab,
                                },
                            },
                        },
                    ],
                },
                sheets_1.default.getTemplate(names),
            ],
        };
    },
};
exports["default"] = workbookFactory;


/***/ }),

/***/ 559:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(5608);
const ag_grid_community_1 = __webpack_require__(6624);
const excelUtils_1 = __webpack_require__(3237);
const excelXlsxFactory_1 = __webpack_require__(7165);
const column_1 = tslib_1.__importDefault(__webpack_require__(3285));
const mergeCell_1 = tslib_1.__importDefault(__webpack_require__(1775));
const row_1 = tslib_1.__importDefault(__webpack_require__(7067));
const getMergedCellsAndAddColumnGroups = (rows, cols, suppressColumnOutline) => {
    const mergedCells = [];
    const cellsWithCollapsibleGroups = [];
    rows.forEach((currentRow, rowIdx) => {
        const cells = currentRow.cells;
        let merges = 0;
        let lastCol;
        cells.forEach((currentCell, cellIdx) => {
            const min = cellIdx + merges + 1;
            const start = (0, excelUtils_1.getExcelColumnName)(min);
            const outputRow = rowIdx + 1;
            if (currentCell.mergeAcross) {
                merges += currentCell.mergeAcross;
                const end = (0, excelUtils_1.getExcelColumnName)(cellIdx + merges + 1);
                mergedCells.push(`${start}${outputRow}:${end}${outputRow}`);
            }
            if (!cols[min - 1]) {
                cols[min - 1] = {};
            }
            const { collapsibleRanges } = currentCell;
            if (collapsibleRanges) {
                collapsibleRanges.forEach((range) => {
                    cellsWithCollapsibleGroups.push([min + range[0], min + range[1]]);
                });
            }
            lastCol = cols[min - 1];
            lastCol.min = min;
            lastCol.max = min;
            currentCell.ref = `${start}${outputRow}`;
        });
    });
    cellsWithCollapsibleGroups.sort((a, b) => {
        if (a[0] !== b[0]) {
            return a[0] - b[0];
        }
        return b[1] - a[1];
    });
    const rangeMap = new Map();
    const outlineLevel = new Map();
    cellsWithCollapsibleGroups
        .filter((currentRange) => {
        const rangeString = currentRange.toString();
        const inMap = rangeMap.get(rangeString);
        if (inMap) {
            return false;
        }
        rangeMap.set(rangeString, true);
        return true;
    })
        .forEach((range) => {
        const refCol = cols.find((col) => col.min == range[0] && col.max == range[1]);
        const currentOutlineLevel = outlineLevel.get(range[0]);
        cols.push({
            min: range[0],
            max: range[1],
            outlineLevel: suppressColumnOutline ? undefined : currentOutlineLevel || 1,
            width: (refCol || { width: 100 }).width,
        });
        outlineLevel.set(range[0], (currentOutlineLevel || 0) + 1);
    });
    return mergedCells;
};
const getPageOrientation = (orientation) => {
    if (!orientation || (orientation !== 'Portrait' && orientation !== 'Landscape')) {
        return 'portrait';
    }
    return orientation.toLocaleLowerCase();
};
const getPageSize = (pageSize) => {
    if (pageSize == null) {
        return 1;
    }
    const positions = [
        'Letter',
        'Letter Small',
        'Tabloid',
        'Ledger',
        'Legal',
        'Statement',
        'Executive',
        'A3',
        'A4',
        'A4 Small',
        'A5',
        'A6',
        'B4',
        'B5',
        'Folio',
        'Envelope',
        'Envelope DL',
        'Envelope C5',
        'Envelope B5',
        'Envelope C3',
        'Envelope C4',
        'Envelope C6',
        'Envelope Monarch',
        'Japanese Postcard',
        'Japanese Double Postcard',
    ];
    const pos = positions.indexOf(pageSize);
    return pos === -1 ? 1 : pos + 1;
};
const replaceHeaderFooterTokens = (value) => {
    const map = {
        '&[Page]': '&P',
        '&[Pages]': '&N',
        '&[Date]': '&D',
        '&[Time]': '&T',
        '&[Tab]': '&A',
        '&[Path]': '&Z',
        '&[File]': '&F',
        '&[Picture]': '&G',
    };
    Object.entries(map).forEach(([key, val]) => {
        value = value.replace(key, val);
    });
    return value;
};
const getHeaderPosition = (position) => {
    if (position === 'Center') {
        return 'C';
    }
    if (position === 'Right') {
        return 'R';
    }
    return 'L';
};
const applyHeaderFontStyle = (headerString, font) => {
    if (!font) {
        return headerString;
    }
    headerString += '&amp;&quot;';
    headerString += font.fontName || 'Calibri';
    if (font.bold !== font.italic) {
        headerString += font.bold ? ',Bold' : ',Italic';
    }
    else if (font.bold) {
        headerString += ',Bold Italic';
    }
    else {
        headerString += ',Regular';
    }
    headerString += '&quot;';
    if (font.size) {
        headerString += `&amp;${font.size}`;
    }
    if (font.strikeThrough) {
        headerString += '&amp;S';
    }
    if (font.underline) {
        headerString += `&amp;${font.underline === 'Double' ? 'E' : 'U'}`;
    }
    if (font.color) {
        headerString += `&amp;K${font.color.replace('#', '').toUpperCase()}`;
    }
    return headerString;
};
const processHeaderFooterContent = (content, location, rule) => content.reduce((prev, curr, idx) => {
    const pos = getHeaderPosition(curr.position);
    const output = applyHeaderFontStyle(`${prev}&amp;${pos}`, curr.font);
    const PositionMap = ['Left', 'Center', 'Right'];
    if (!curr.position) {
        curr.position = PositionMap[idx];
    }
    const { image } = curr;
    if (curr.value === '&[Picture]' && image) {
        const imagePosition = `${pos}${location}${rule}`;
        (0, excelXlsxFactory_1.addXlsxHeaderFooterImageToMap)(image, imagePosition);
    }
    return `${output}${(0, ag_grid_community_1._escapeString)(replaceHeaderFooterTokens(curr.value))}`;
}, '');
const buildHeaderFooter = (headerFooterConfig) => {
    const rules = ['all', 'first', 'even'];
    const headersAndFooters = [];
    rules.forEach((rule) => {
        const headerFooter = headerFooterConfig[rule];
        const namePrefix = rule === 'all' ? 'odd' : rule;
        if (!headerFooter) {
            return;
        }
        for (const [key, value] of Object.entries(headerFooter)) {
            const nameSuffix = `${key.charAt(0).toUpperCase()}${key.slice(1)}`;
            const location = key[0].toUpperCase();
            if (value) {
                const normalizedRule = rule === 'all' ? '' : rule.toUpperCase();
                headersAndFooters.push({
                    name: `${namePrefix}${nameSuffix}`,
                    properties: {
                        rawMap: { 'xml:space': 'preserve' },
                    },
                    textNode: processHeaderFooterContent(value, location, normalizedRule),
                });
            }
        }
    });
    return headersAndFooters;
};
const addColumns = (columns) => {
    return (params) => {
        if (columns.length) {
            params.children.push({
                name: 'cols',
                children: columns.map((column) => column_1.default.getTemplate(column)),
            });
        }
        return params;
    };
};
const addSheetData = (rows, sheetNumber) => {
    return (params) => {
        if (rows.length) {
            params.children.push({
                name: 'sheetData',
                children: rows.map((row, idx) => row_1.default.getTemplate(row, idx, sheetNumber)),
            });
        }
        return params;
    };
};
const addMergeCells = (mergeCells) => {
    return (params) => {
        if (mergeCells.length) {
            params.children.push({
                name: 'mergeCells',
                properties: {
                    rawMap: {
                        count: mergeCells.length,
                    },
                },
                children: mergeCells.map((mergedCell) => mergeCell_1.default.getTemplate(mergedCell)),
            });
        }
        return params;
    };
};
const addPageMargins = (margins) => {
    return (params) => {
        const { top = 0.75, right = 0.7, bottom = 0.75, left = 0.7, header = 0.3, footer = 0.3 } = margins;
        params.children.push({
            name: 'pageMargins',
            properties: {
                rawMap: { bottom, footer, header, left, right, top },
            },
        });
        return params;
    };
};
const addPageSetup = (pageSetup) => {
    return (params) => {
        if (pageSetup) {
            params.children.push({
                name: 'pageSetup',
                properties: {
                    rawMap: {
                        horizontalDpi: 0,
                        verticalDpi: 0,
                        orientation: getPageOrientation(pageSetup.orientation),
                        paperSize: getPageSize(pageSetup.pageSize),
                    },
                },
            });
        }
        return params;
    };
};
const addHeaderFooter = (headerFooterConfig) => {
    return (params) => {
        if (!headerFooterConfig) {
            return params;
        }
        const differentFirst = headerFooterConfig.first != null ? 1 : 0;
        const differentOddEven = headerFooterConfig.even != null ? 1 : 0;
        params.children.push({
            name: 'headerFooter',
            properties: {
                rawMap: {
                    differentFirst,
                    differentOddEven,
                },
            },
            children: buildHeaderFooter(headerFooterConfig),
        });
        return params;
    };
};
const addExcelTableRel = (excelTable) => {
    return (params) => {
        if (excelTable) {
            params.children.push({
                name: 'tableParts',
                properties: {
                    rawMap: {
                        count: '1',
                    },
                },
                children: [
                    {
                        name: 'tablePart',
                        properties: {
                            rawMap: {
                                'r:id': `rId${++params.rIdCounter}`,
                            },
                        },
                    },
                ],
            });
        }
        return params;
    };
};
const addDrawingRel = (currentSheet) => {
    return (params) => {
        const worksheetImages = excelXlsxFactory_1.XLSX_WORKSHEET_IMAGES.get(currentSheet);
        if (worksheetImages?.length) {
            params.children.push({
                name: 'drawing',
                properties: {
                    rawMap: {
                        'r:id': `rId${++params.rIdCounter}`,
                    },
                },
            });
        }
        return params;
    };
};
const addVmlDrawingRel = (currentSheet) => {
    return (params) => {
        if (excelXlsxFactory_1.XLSX_WORKSHEET_HEADER_FOOTER_IMAGES.get(currentSheet)) {
            params.children.push({
                name: 'legacyDrawingHF',
                properties: {
                    rawMap: {
                        'r:id': `rId${++params.rIdCounter}`,
                    },
                },
            });
        }
        return params;
    };
};
const getPane = (xSplit = 0, ySplit = 0) => {
    const shouldSplit = xSplit > 0 || ySplit > 0;
    return shouldSplit
        ? [
            {
                name: 'pane',
                properties: {
                    rawMap: {
                        state: shouldSplit ? 'frozen' : undefined,
                        topLeftCell: shouldSplit ? `${(0, excelUtils_1.getExcelColumnName)(xSplit + 1)}${ySplit + 1}` : undefined,
                        xSplit: xSplit === 0 ? undefined : xSplit,
                        ySplit: ySplit === 0 ? undefined : ySplit,
                    },
                },
            },
        ]
        : undefined;
};
const addSheetViews = (rtl = false, xSplit, ySplit) => {
    return (params) => {
        params.children.push({
            name: 'sheetViews',
            children: [
                {
                    name: 'sheetView',
                    properties: {
                        rawMap: {
                            rightToLeft: rtl === true ? '1' : '0',
                            workbookViewId: '0',
                        },
                    },
                    children: getPane(xSplit, ySplit),
                },
            ],
        });
        return params;
    };
};
const addSheetPr = () => {
    return (params) => {
        params.children.push({
            name: 'sheetPr',
            children: [
                {
                    name: 'outlinePr',
                    properties: {
                        rawMap: {
                            summaryBelow: 0,
                        },
                    },
                },
            ],
        });
        return params;
    };
};
const addSheetFormatPr = (rows) => {
    return (params) => {
        const maxOutline = rows.reduce((prev, row) => {
            if (row.outlineLevel && row.outlineLevel > prev) {
                return row.outlineLevel;
            }
            return prev;
        }, 0);
        params.children.push({
            name: 'sheetFormatPr',
            properties: {
                rawMap: {
                    baseColWidth: 10,
                    defaultRowHeight: 16,
                    outlineLevelRow: maxOutline ? maxOutline : undefined,
                },
            },
        });
        return params;
    };
};
const worksheetFactory = {
    getTemplate(params) {
        const { worksheet, currentSheet, config } = params;
        const { margins = {}, pageSetup, headerFooterConfig, suppressColumnOutline, rightToLeft, frozenRowCount, frozenColumnCount, } = config;
        const { table } = worksheet;
        const { rows, columns } = table;
        const mergedCells = columns && columns.length ? getMergedCellsAndAddColumnGroups(rows, columns, !!suppressColumnOutline) : [];
        const worksheetExcelTables = excelXlsxFactory_1.XLSX_WORKSHEET_DATA_TABLES.get(currentSheet);
        const { children } = [
            addSheetPr(),
            addSheetViews(rightToLeft, frozenColumnCount, frozenRowCount),
            addSheetFormatPr(rows),
            addColumns(columns),
            addSheetData(rows, currentSheet + 1),
            addMergeCells(mergedCells),
            addPageMargins(margins),
            addPageSetup(pageSetup),
            addHeaderFooter(headerFooterConfig),
            addDrawingRel(currentSheet),
            addVmlDrawingRel(currentSheet),
            addExcelTableRel(worksheetExcelTables),
        ].reduce((composed, f) => f(composed), { children: [], rIdCounter: 0 });
        return {
            name: 'worksheet',
            properties: {
                prefixedAttributes: [
                    {
                        prefix: 'xmlns:',
                        map: {
                            r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                        },
                    },
                ],
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                },
            },
            children,
        };
    },
};
exports["default"] = worksheetFactory;


/***/ }),

/***/ 5552:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deflateLocalFile = void 0;
const compressBlob = async (data) => {
    // Callback to extract the compressed data
    let chunksSize = 0;
    const chunks = [];
    const writeCompressedData = new WritableStream({
        write: (chunk) => {
            chunks.push(chunk);
            chunksSize += chunk.length;
        },
    });
    // Create readable stream from blob
    const readable = new ReadableStream({
        start: (controller) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                if (e.target?.result) {
                    controller.enqueue(e.target.result);
                }
                controller.close();
            };
            reader.readAsArrayBuffer(data);
        },
    });
    // Perform the compression using the browser's native CompressionStream API
    // Ref https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream for details
    const compressStream = new window.CompressionStream('deflate-raw');
    await readable.pipeThrough(compressStream).pipeTo(writeCompressedData);
    // Return the compressed data
    return {
        size: chunksSize,
        content: new Blob(chunks),
    };
};
const deflateLocalFile = async (rawContent) => {
    const contentAsBlob = new Blob([rawContent]);
    const { size: compressedSize, content: compressedContent } = await compressBlob(contentAsBlob);
    const compressedContentAsUint8Array = new Uint8Array(await compressedContent.arrayBuffer());
    return {
        size: compressedSize,
        content: compressedContentAsUint8Array,
    };
};
exports.deflateLocalFile = deflateLocalFile;


/***/ }),

/***/ 4557:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertDecToHex = exports.convertDate = exports.convertTime = void 0;
const convertTime = (date) => {
    let time = date.getHours();
    time <<= 6;
    time = time | date.getMinutes();
    time <<= 5;
    time = time | (date.getSeconds() / 2);
    return time;
};
exports.convertTime = convertTime;
const convertDate = (date) => {
    let dt = date.getFullYear() - 1980;
    dt <<= 4;
    dt = dt | (date.getMonth() + 1);
    dt <<= 5;
    dt = dt | date.getDate();
    return dt;
};
exports.convertDate = convertDate;
function convertDecToHex(number, bytes) {
    let hex = '';
    for (let i = 0; i < bytes; i++) {
        hex += String.fromCharCode(number & 0xff);
        number >>>= 8;
    }
    return hex;
}
exports.convertDecToHex = convertDecToHex;


/***/ }),

/***/ 758:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCrcFromCrc32Table = void 0;
const getCrcFromCrc32TableAndByteArray = (content) => {
    if (!content.length) {
        return 0;
    }
    let crc = 0 ^ -1;
    let j = 0;
    let k = 0;
    let l = 0;
    for (let i = 0; i < content.length; i++) {
        j = content[i];
        k = (crc ^ j) & 0xff;
        l = crcTable[k];
        crc = (crc >>> 8) ^ l;
    }
    return crc ^ -1;
};
const getCrcFromCrc32Table = (content) => {
    if (!content.length) {
        return 0;
    }
    if (typeof content === 'string') {
        return getCrcFromCrc32TableAndByteArray(new TextEncoder().encode(content));
    }
    return getCrcFromCrc32TableAndByteArray(content);
};
exports.getCrcFromCrc32Table = getCrcFromCrc32Table;
// Table for crc calculation from:
// https://referencesource.microsoft.com/#System/sys/System/IO/compression/Crc32Helper.cs,3b31978c7d7f7246,references
const crcTable = /* #__PURE__ */ new Uint32Array([
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
]);


/***/ }),

/***/ 5950:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZipContainer = void 0;
const zipContainerHelper_1 = __webpack_require__(6090);
class ZipContainer {
    constructor() {
        this.folders = [];
        this.files = [];
    }
    addFolders(paths) {
        paths.forEach(this.addFolder.bind(this));
    }
    addFolder(path) {
        this.folders.push({
            path,
            created: new Date(),
            isBase64: false,
            type: 'folder',
        });
    }
    addFile(path, content, isBase64 = false) {
        this.files.push({
            path,
            created: new Date(),
            content: isBase64 ? content : new TextEncoder().encode(content),
            isBase64,
            type: 'file',
        });
    }
    async getZipFile(mimeType = 'application/zip') {
        const textOutput = await this.buildCompressedFileStream();
        this.clearStream();
        return new Blob([textOutput], { type: mimeType });
    }
    getUncompressedZipFile(mimeType = 'application/zip') {
        const textOutput = this.buildFileStream();
        this.clearStream();
        return new Blob([textOutput], { type: mimeType });
    }
    clearStream() {
        this.folders = [];
        this.files = [];
    }
    packageFiles(files) {
        let fileLen = 0;
        let folderLen = 0;
        for (const currentFile of files) {
            const { localFileHeader, centralDirectoryHeader, content } = currentFile;
            fileLen += localFileHeader.length + content.length;
            folderLen += centralDirectoryHeader.length;
        }
        const fileData = new Uint8Array(fileLen);
        const folderData = new Uint8Array(folderLen);
        let fileOffset = 0;
        let folderOffset = 0;
        for (const currentFile of files) {
            const { localFileHeader, centralDirectoryHeader, content } = currentFile;
            // Append fileHeader to fData
            fileData.set(localFileHeader, fileOffset);
            fileOffset += localFileHeader.length;
            // Append content to fData
            fileData.set(content, fileOffset);
            fileOffset += content.length;
            // Append folder header to foData
            folderData.set(centralDirectoryHeader, folderOffset);
            folderOffset += centralDirectoryHeader.length;
        }
        const folderEnd = (0, zipContainerHelper_1.buildCentralDirectoryEnd)(files.length, folderLen, fileLen);
        // Append folder data and file data
        const result = new Uint8Array(fileData.length + folderData.length + folderEnd.length);
        result.set(fileData);
        result.set(folderData, fileData.length);
        result.set(folderEnd, fileData.length + folderData.length);
        return result;
    }
    async buildCompressedFileStream() {
        const totalFiles = [...this.folders, ...this.files];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles) {
            const output = await (0, zipContainerHelper_1.getDeflatedHeaderAndContent)(currentFile, lL);
            const { localFileHeader, content } = output;
            readyFiles.push(output);
            lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
    }
    buildFileStream() {
        const totalFiles = [...this.folders, ...this.files];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles) {
            const readyFile = (0, zipContainerHelper_1.getHeaderAndContent)(currentFile, lL);
            const { localFileHeader, content } = readyFile;
            readyFiles.push(readyFile);
            lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
    }
}
exports.ZipContainer = ZipContainer;


/***/ }),

/***/ 6090:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCentralDirectoryEnd = exports.getHeaderAndContent = exports.getDeflatedHeaderAndContent = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const compress_1 = __webpack_require__(5552);
const convert_1 = __webpack_require__(4557);
const crcTable_1 = __webpack_require__(758);
/**
 * It encodes any string in UTF-8 format
 * taken from https://github.com/mathiasbynens/utf8.js
 * @param {string} s
 * @returns {string}
 */
function _utf8_encode(s) {
    const stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
        const output = [];
        if (!string) {
            return [];
        }
        const len = string.length;
        let counter = 0;
        let value;
        let extra;
        while (counter < len) {
            value = string.charCodeAt(counter++);
            if (value >= 0xd800 && value <= 0xdbff && counter < len) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xfc00) == 0xdc00) {
                    // low surrogate
                    output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                }
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            }
            else {
                output.push(value);
            }
        }
        return output;
    }
    function checkScalarValue(point) {
        if (point >= 0xd800 && point <= 0xdfff) {
            throw Error((0, ag_grid_community_1._errMsg)(255, { point }));
        }
    }
    function createByte(point, shift) {
        return stringFromCharCode(((point >> shift) & 0x3f) | 0x80);
    }
    function encodeCodePoint(point) {
        if ((point & 0xffffff80) == 0) {
            // 1-byte sequence
            return stringFromCharCode(point);
        }
        let symbol = '';
        if ((point & 0xfffff800) == 0) {
            // 2-byte sequence
            symbol = stringFromCharCode(((point >> 6) & 0x1f) | 0xc0);
        }
        else if ((point & 0xffff0000) == 0) {
            // 3-byte sequence
            checkScalarValue(point);
            symbol = stringFromCharCode(((point >> 12) & 0x0f) | 0xe0);
            symbol += createByte(point, 6);
        }
        else if ((point & 0xffe00000) == 0) {
            // 4-byte sequence
            symbol = stringFromCharCode(((point >> 18) & 0x07) | 0xf0);
            symbol += createByte(point, 12);
            symbol += createByte(point, 6);
        }
        symbol += stringFromCharCode((point & 0x3f) | 0x80);
        return symbol;
    }
    const codePoints = ucs2decode(s);
    const length = codePoints.length;
    let index = -1;
    let codePoint;
    let byteString = '';
    while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint);
    }
    return byteString;
}
const getHeaders = (currentFile, isCompressed, offset, rawSize, rawContent, deflatedSize) => {
    const { content, path, created: creationDate } = currentFile;
    const time = (0, convert_1.convertTime)(creationDate);
    const dt = (0, convert_1.convertDate)(creationDate);
    const crcFlag = (0, crcTable_1.getCrcFromCrc32Table)(rawContent);
    const zipSize = deflatedSize !== undefined ? deflatedSize : rawSize;
    const utfPath = _utf8_encode(path);
    const isUTF8 = utfPath !== path;
    let extraFields = '';
    if (isUTF8) {
        const uExtraFieldPath = (0, convert_1.convertDecToHex)(1, 1) + (0, convert_1.convertDecToHex)((0, crcTable_1.getCrcFromCrc32Table)(utfPath), 4) + utfPath;
        extraFields = '\x75\x70' + (0, convert_1.convertDecToHex)(uExtraFieldPath.length, 2) + uExtraFieldPath;
    }
    const commonHeader = '\x14\x00' + // version needed to extract
        (isUTF8 ? '\x00\x08' : '\x00\x00') + // Language encoding flag (EFS) (12th bit turned on)
        (0, convert_1.convertDecToHex)(isCompressed ? 8 : 0, 2) + // As per ECMA-376 Part 2 specs
        (0, convert_1.convertDecToHex)(time, 2) + // last modified time
        (0, convert_1.convertDecToHex)(dt, 2) + // last modified date
        (0, convert_1.convertDecToHex)(zipSize ? crcFlag : 0, 4) +
        (0, convert_1.convertDecToHex)(deflatedSize ?? rawSize, 4) + // compressed size
        (0, convert_1.convertDecToHex)(rawSize, 4) + // uncompressed size
        (0, convert_1.convertDecToHex)(utfPath.length, 2) + // file name length
        (0, convert_1.convertDecToHex)(extraFields.length, 2); // extra field length
    const localFileHeader = 'PK\x03\x04' + commonHeader + utfPath + extraFields;
    const centralDirectoryHeader = 'PK\x01\x02' + // central header
        '\x14\x00' +
        commonHeader + // file header
        '\x00\x00' +
        '\x00\x00' +
        '\x00\x00' +
        (content ? '\x00\x00\x00\x00' : '\x10\x00\x00\x00') + // external file attributes
        (0, convert_1.convertDecToHex)(offset, 4) + // relative offset of local header
        utfPath + // file name
        extraFields; // extra field
    return {
        localFileHeader: Uint8Array.from(localFileHeader, (c) => c.charCodeAt(0)),
        centralDirectoryHeader: Uint8Array.from(centralDirectoryHeader, (c) => c.charCodeAt(0)),
    };
};
const getDecodedContent = (content) => {
    let contentToUse;
    // base64 content is passed as string
    if (typeof content === 'string') {
        const base64String = atob(content.split(';base64,')[1]);
        contentToUse = Uint8Array.from(base64String, (c) => c.charCodeAt(0));
    }
    else {
        contentToUse = content;
    }
    return {
        size: contentToUse.length,
        content: contentToUse,
    };
};
const getDeflatedHeaderAndContent = async (currentFile, offset) => {
    const { content } = currentFile;
    const { size, content: rawContent } = !content
        ? { size: 0, content: Uint8Array.from([]) }
        : getDecodedContent(content);
    let deflatedContent = undefined;
    let deflatedSize = undefined;
    let deflationPerformed = false;
    const shouldDeflate = currentFile.type === 'file' && rawContent && size > 0;
    if (shouldDeflate) {
        const result = await (0, compress_1.deflateLocalFile)(rawContent);
        deflatedContent = result.content;
        deflatedSize = result.size;
        deflationPerformed = true;
    }
    const headers = getHeaders(currentFile, deflationPerformed, offset, size, rawContent, deflatedSize);
    return {
        ...headers,
        content: deflatedContent || rawContent,
        isCompressed: deflationPerformed,
    };
};
exports.getDeflatedHeaderAndContent = getDeflatedHeaderAndContent;
const getHeaderAndContent = (currentFile, offset) => {
    const { content } = currentFile;
    const { content: rawContent } = !content ? { content: Uint8Array.from([]) } : getDecodedContent(content);
    const headers = getHeaders(currentFile, false, offset, rawContent.length, rawContent, undefined);
    return {
        ...headers,
        content: rawContent,
        isCompressed: false,
    };
};
exports.getHeaderAndContent = getHeaderAndContent;
const buildCentralDirectoryEnd = (tLen, cLen, lLen) => {
    const str = 'PK\x05\x06' + // central folder end
        '\x00\x00' +
        '\x00\x00' +
        (0, convert_1.convertDecToHex)(tLen, 2) + // total number of entries in the central folder
        (0, convert_1.convertDecToHex)(tLen, 2) + // total number of entries in the central folder
        (0, convert_1.convertDecToHex)(cLen, 4) + // size of the central folder
        (0, convert_1.convertDecToHex)(lLen, 4) + // central folder start offset
        '\x00\x00';
    return Uint8Array.from(str, (c) => c.charCodeAt(0));
};
exports.buildCentralDirectoryEnd = buildCentralDirectoryEnd;


/***/ }),

/***/ 5760:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VirtualListDragFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const LIST_ITEM_HOVERED = 'ag-list-item-hovered';
class VirtualListDragFeature extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.dragAndDrop = beans.dragAndDrop;
    }
    constructor(comp, virtualList, params) {
        super();
        this.comp = comp;
        this.virtualList = virtualList;
        this.params = params;
        this.currentDragValue = null;
        this.lastHoveredListItem = null;
    }
    postConstruct() {
        this.addManagedListeners(this.params.eventSource, {
            [this.params.listItemDragStartEvent]: this.listItemDragStart.bind(this),
            [this.params.listItemDragEndEvent]: this.listItemDragEnd.bind(this),
        });
        this.createDropTarget();
        this.createAutoScrollService();
    }
    listItemDragStart(event) {
        this.currentDragValue = this.params.getCurrentDragValue(event);
        this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue);
    }
    listItemDragEnd() {
        window.setTimeout(() => {
            this.currentDragValue = null;
            this.moveBlocked = false;
        }, 10);
    }
    createDropTarget() {
        const dropTarget = {
            isInterestedIn: (type) => type === this.params.dragSourceType,
            getIconName: () => (this.moveBlocked ? 'pinned' : 'move'),
            getContainer: () => this.comp.getGui(),
            onDragging: (e) => this.onDragging(e),
            onDragStop: () => this.onDragStop(),
            onDragLeave: () => this.onDragLeave(),
            onDragCancel: () => this.onDragCancel(),
        };
        this.dragAndDrop?.addDropTarget(dropTarget);
    }
    createAutoScrollService() {
        const virtualListGui = this.virtualList.getGui();
        this.autoScrollService = new ag_grid_community_1.AutoScrollService({
            scrollContainer: virtualListGui,
            scrollAxis: 'y',
            getVerticalPosition: () => virtualListGui.scrollTop,
            setVerticalPosition: (position) => (virtualListGui.scrollTop = position),
        });
    }
    onDragging(e) {
        if (!this.currentDragValue || this.moveBlocked) {
            return;
        }
        const hoveredListItem = this.getListDragItem(e);
        const comp = this.virtualList.getComponentAt(hoveredListItem.rowIndex);
        if (!comp) {
            return;
        }
        const el = comp.getGui().parentElement;
        if (this.lastHoveredListItem &&
            this.lastHoveredListItem.rowIndex === hoveredListItem.rowIndex &&
            this.lastHoveredListItem.position === hoveredListItem.position) {
            return;
        }
        this.autoScrollService.check(e.event);
        this.clearHoveredItems();
        this.lastHoveredListItem = hoveredListItem;
        (0, ag_grid_community_1._radioCssClass)(el, LIST_ITEM_HOVERED);
        (0, ag_grid_community_1._radioCssClass)(el, `ag-item-highlight-${hoveredListItem.position}`);
    }
    getListDragItem(e) {
        const virtualListGui = this.virtualList.getGui();
        const paddingTop = parseFloat(window.getComputedStyle(virtualListGui).paddingTop);
        const rowHeight = this.virtualList.getRowHeight();
        const scrollTop = this.virtualList.getScrollTop();
        const rowIndex = Math.max(0, (e.y - paddingTop + scrollTop) / rowHeight);
        const maxLen = this.params.getNumRows(this.comp) - 1;
        const normalizedRowIndex = Math.min(maxLen, rowIndex) | 0;
        return {
            rowIndex: normalizedRowIndex,
            position: Math.round(rowIndex) > rowIndex || rowIndex > maxLen ? 'bottom' : 'top',
            component: this.virtualList.getComponentAt(normalizedRowIndex),
        };
    }
    onDragStop() {
        if (this.moveBlocked) {
            return;
        }
        this.params.moveItem(this.currentDragValue, this.lastHoveredListItem);
        this.clearDragProperties();
    }
    onDragCancel() {
        this.clearDragProperties();
    }
    onDragLeave() {
        this.clearDragProperties();
    }
    clearDragProperties() {
        this.clearHoveredItems();
        this.autoScrollService.ensureCleared();
    }
    clearHoveredItems() {
        const virtualListGui = this.virtualList.getGui();
        virtualListGui.querySelectorAll(`.${LIST_ITEM_HOVERED}`).forEach((el) => {
            [LIST_ITEM_HOVERED, 'ag-item-highlight-top', 'ag-item-highlight-bottom'].forEach((cls) => {
                el.classList.remove(cls);
            });
        });
        this.lastHoveredListItem = null;
    }
}
exports.VirtualListDragFeature = VirtualListDragFeature;


/***/ }),

/***/ 8046:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgFiltersToolPanelHeaderSelector = exports.AgFiltersToolPanelHeader = exports.EXPAND_STATE = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
var EXPAND_STATE;
(function (EXPAND_STATE) {
    EXPAND_STATE[EXPAND_STATE["EXPANDED"] = 0] = "EXPANDED";
    EXPAND_STATE[EXPAND_STATE["COLLAPSED"] = 1] = "COLLAPSED";
    EXPAND_STATE[EXPAND_STATE["INDETERMINATE"] = 2] = "INDETERMINATE";
})(EXPAND_STATE || (exports.EXPAND_STATE = EXPAND_STATE = {}));
class AgFiltersToolPanelHeader extends ag_grid_community_1.Component {
    constructor() {
        super(...arguments);
        this.eExpand = ag_grid_community_1.RefPlaceholder;
        this.eFilterTextField = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.setTemplate(
        /* html */
        `<div class="ag-filter-toolpanel-search" role="presentation">
                <div data-ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <ag-input-text-field data-ref="eFilterTextField" class="ag-filter-toolpanel-search-input"></ag-input-text-field>
            </div>`, [ag_grid_community_1.AgInputTextFieldSelector]);
        const translate = this.getLocaleTextFunc();
        this.eFilterTextField
            .setAutoComplete(false)
            .setInputAriaLabel(translate('ariaFilterColumnsInput', 'Filter Columns Input'))
            .onValueChange(this.onSearchTextChanged.bind(this));
        this.createExpandIcons();
        this.setExpandState(EXPAND_STATE.EXPANDED);
        this.addManagedElementListeners(this.eExpand, { click: this.onExpandClicked.bind(this) });
        this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
    }
    init(params) {
        this.params = params;
        if (this.beans.colModel.ready) {
            this.showOrHideOptions();
        }
    }
    createExpandIcons() {
        const { eExpand, beans } = this;
        eExpand.appendChild((this.eExpandChecked = (0, ag_grid_community_1._createIconNoSpan)('accordionOpen', beans)));
        eExpand.appendChild((this.eExpandUnchecked = (0, ag_grid_community_1._createIconNoSpan)('accordionClosed', beans)));
        eExpand.appendChild((this.eExpandIndeterminate = (0, ag_grid_community_1._createIconNoSpan)('accordionIndeterminate', beans)));
    }
    // we only show expand / collapse if we are showing filters
    showOrHideOptions() {
        const { params, eFilterTextField } = this;
        const showFilterSearch = !params.suppressFilterSearch;
        const showExpand = !params.suppressExpandAll;
        const translate = this.getLocaleTextFunc();
        eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));
        const isFilterGroupPresent = (col) => col.getOriginalParent() && col.isFilterAllowed();
        const filterGroupsPresent = this.beans.colModel.getCols().some(isFilterGroupPresent);
        (0, ag_grid_community_1._setDisplayed)(eFilterTextField.getGui(), showFilterSearch);
        (0, ag_grid_community_1._setDisplayed)(this.eExpand, showExpand && filterGroupsPresent);
    }
    onSearchTextChanged() {
        if (!this.onSearchTextChangedDebounced) {
            this.onSearchTextChangedDebounced = (0, ag_grid_community_1._debounce)(this, () => this.dispatchLocalEvent({ type: 'searchChanged', searchText: this.eFilterTextField.getValue() }), 300);
        }
        this.onSearchTextChangedDebounced();
    }
    onExpandClicked() {
        const event = this.currentExpandState === EXPAND_STATE.EXPANDED ? { type: 'collapseAll' } : { type: 'expandAll' };
        this.dispatchLocalEvent(event);
    }
    setExpandState(state) {
        this.currentExpandState = state;
        (0, ag_grid_community_1._setDisplayed)(this.eExpandChecked, state === EXPAND_STATE.EXPANDED);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandUnchecked, state === EXPAND_STATE.COLLAPSED);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandIndeterminate, state === EXPAND_STATE.INDETERMINATE);
    }
}
exports.AgFiltersToolPanelHeader = AgFiltersToolPanelHeader;
exports.AgFiltersToolPanelHeaderSelector = {
    selector: 'AG-FILTERS-TOOL-PANEL-HEADER',
    component: AgFiltersToolPanelHeader,
};


/***/ }),

/***/ 7291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgFiltersToolPanelListSelector = exports.AgFiltersToolPanelList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const toolPanelColDefService_1 = __webpack_require__(6092);
const agFiltersToolPanelHeader_1 = __webpack_require__(8046);
const toolPanelFilterComp_1 = __webpack_require__(3905);
const toolPanelFilterGroupComp_1 = __webpack_require__(5296);
class AgFiltersToolPanelList extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.colModel = beans.colModel;
    }
    constructor() {
        super(/* html */ `<div class="ag-filter-list-panel"></div>`);
        this.initialised = false;
        this.hasLoadedInitialState = false;
        this.isInitialState = false;
        this.filterGroupComps = [];
        // If a column drag is happening, we suppress handling the event until it has completed
        this.suppressOnColumnsChanged = false;
        this.onColumnsChangedPending = false;
    }
    init(params) {
        this.initialised = true;
        const defaultParams = this.gos.addGridCommonParams({
            suppressExpandAll: false,
            suppressFilterSearch: false,
            suppressSyncLayoutWithGrid: false,
        });
        (0, ag_grid_community_1._mergeDeep)(defaultParams, params);
        this.params = defaultParams;
        if (!defaultParams.suppressSyncLayoutWithGrid) {
            this.addManagedEventListeners({ columnMoved: () => this.onColumnsChanged() });
        }
        this.addManagedEventListeners({
            newColumnsLoaded: () => this.onColumnsChanged(),
            toolPanelVisibleChanged: (event) => {
                // when re-entering the filters tool panel we need to refresh the virtual lists in the set filters in case
                // filters have been changed elsewhere, i.e. via an api call.
                if (event.key === 'filters') {
                    this.refreshFilters(event.visible);
                }
            },
            dragStarted: () => {
                this.suppressOnColumnsChanged = true;
            },
            dragStopped: () => {
                this.suppressOnColumnsChanged = false;
                if (this.onColumnsChangedPending) {
                    this.onColumnsChangedPending = false;
                    this.onColumnsChanged();
                }
            },
        });
        if (this.colModel.ready) {
            this.onColumnsChanged();
        }
    }
    onColumnsChanged() {
        if (this.suppressOnColumnsChanged) {
            this.onColumnsChangedPending = true;
            return;
        }
        const pivotModeActive = this.colModel.isPivotMode();
        const shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;
        shouldSyncColumnLayoutWithGrid ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs();
        this.refreshAriaLabel();
    }
    syncFilterLayout() {
        (0, toolPanelColDefService_1.syncLayoutWithGrid)(this.colModel, this.setFiltersLayout.bind(this));
        this.refreshAriaLabel();
    }
    buildTreeFromProvidedColumnDefs() {
        const columnTree = this.colModel.getColDefColTree();
        this.recreateFilters(columnTree);
    }
    setFiltersLayout(colDefs) {
        const columnTree = (0, toolPanelColDefService_1.toolPanelCreateColumnTree)(this.colModel, colDefs);
        this.recreateFilters(columnTree);
    }
    recreateFilters(columnTree) {
        // Underlying filter comp/element won't get recreated if the column still exists (the element just gets detached/re-attached).
        // We can therefore restore focus if an element in the filter tool panel was focused.
        const activeElement = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        if (!this.hasLoadedInitialState) {
            this.hasLoadedInitialState = true;
            this.isInitialState = !!this.params.initialState;
        }
        // Want to restore the expansion state where possible.
        const expansionState = this.getExpansionState();
        this.destroyFilters();
        const filterGroupComps = this.recursivelyAddComps(columnTree, 0, expansionState);
        this.filterGroupComps = filterGroupComps;
        const len = filterGroupComps.length;
        if (len) {
            // skip the destroy function because this will be managed
            // by the `destroyFilters` function
            filterGroupComps.forEach((comp) => this.appendChild(comp));
            this.setFirstAndLastVisible(0, len - 1);
        }
        const searchFilterText = this.searchFilterText;
        // perform search if searchFilterText exists
        if ((0, ag_grid_community_1._exists)(searchFilterText)) {
            this.searchFilters(searchFilterText);
        }
        // notify header of expand
        this.fireExpandedEvent();
        // We only care about restoring focus if the originally focused element was in the filter tool panel.
        if (this.getGui().contains(activeElement)) {
            activeElement.focus();
        }
        this.isInitialState = false;
        this.refreshAriaLabel();
    }
    recursivelyAddComps(tree, depth, expansionState) {
        return tree
            .map((child) => {
            if ((0, ag_grid_community_1.isProvidedColumnGroup)(child)) {
                return this.recursivelyAddFilterGroupComps(child, depth, expansionState)?.flatMap((a) => a) ?? [];
            }
            const column = child;
            if (!this.shouldDisplayFilter(column)) {
                return [];
            }
            const hideFilterCompHeader = depth === 0;
            const filterComp = new toolPanelFilterComp_1.ToolPanelFilterComp(hideFilterCompHeader, () => this.onFilterExpanded());
            this.createBean(filterComp);
            filterComp.setColumn(column);
            if (expansionState.get(column.getId())) {
                // Default state on creation and desired state are both collapsed. Expand if expanded before.
                filterComp.expand();
            }
            if (depth > 0) {
                return filterComp;
            }
            const filterGroupComp = this.createBean(new toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp(column, [filterComp], this.onGroupExpanded.bind(this), depth, true));
            filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');
            if (!expansionState.get(filterGroupComp.getFilterGroupId())) {
                // Default state on creation is expanded. Desired initial state is collapsed. Always collapse unless expanded before.
                filterGroupComp.collapse();
            }
            return filterGroupComp;
        })
            .flatMap((a) => a);
    }
    refreshAriaLabel() {
        const translate = this.getLocaleTextFunc();
        const filterListName = translate('ariaFilterPanelList', 'Filter List');
        const localeFilters = translate('filters', 'Filters');
        const eGui = this.getGui();
        const groupSelector = '.ag-filter-toolpanel-group-wrapper';
        const itemSelector = '.ag-filter-toolpanel-group-item';
        const hiddenSelector = '.ag-hidden';
        const visibleItems = eGui.querySelectorAll(`${itemSelector}:not(${groupSelector}, ${hiddenSelector})`);
        const totalVisibleItems = visibleItems.length;
        (0, ag_grid_community_1._setAriaLabel)(this.getAriaElement(), `${filterListName} ${totalVisibleItems} ${localeFilters}`);
    }
    recursivelyAddFilterGroupComps(columnGroup, depth, expansionState) {
        if (!this.filtersExistInChildren(columnGroup.getChildren())) {
            return;
        }
        const colGroupDef = columnGroup.getColGroupDef();
        if (colGroupDef && colGroupDef.suppressFiltersToolPanel) {
            return [];
        }
        const newDepth = columnGroup.isPadding() ? depth : depth + 1;
        const childFilterComps = this.recursivelyAddComps(columnGroup.getChildren(), newDepth, expansionState).flatMap((a) => a);
        if (columnGroup.isPadding()) {
            return childFilterComps;
        }
        const filterGroupComp = new toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp(columnGroup, childFilterComps, this.onGroupExpanded.bind(this), depth, false);
        this.createBean(filterGroupComp);
        filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');
        const expansionStateValue = expansionState.get(filterGroupComp.getFilterGroupId());
        if ((this.isInitialState && !expansionStateValue) || expansionStateValue === false) {
            // Default state on creation is expanded. Desired initial state is expanded. Only collapse if collapsed before or using initial state.
            filterGroupComp.collapse();
        }
        return [filterGroupComp];
    }
    filtersExistInChildren(tree) {
        return tree.some((child) => {
            if ((0, ag_grid_community_1.isProvidedColumnGroup)(child)) {
                return this.filtersExistInChildren(child.getChildren());
            }
            return this.shouldDisplayFilter(child);
        });
    }
    shouldDisplayFilter(column) {
        const suppressFiltersToolPanel = column.getColDef() && column.getColDef().suppressFiltersToolPanel;
        return column.isFilterAllowed() && !suppressFiltersToolPanel;
    }
    getExpansionState() {
        const expansionState = new Map();
        if (this.isInitialState) {
            const { expandedColIds, expandedGroupIds } = this.params.initialState;
            expandedColIds.forEach((id) => expansionState.set(id, true));
            expandedGroupIds.forEach((id) => expansionState.set(id, true));
            return expansionState;
        }
        const recursiveGetExpansionState = (filterGroupComp) => {
            expansionState.set(filterGroupComp.getFilterGroupId(), filterGroupComp.isExpanded());
            filterGroupComp.getChildren().forEach((child) => {
                if (child instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp) {
                    recursiveGetExpansionState(child);
                }
                else {
                    expansionState.set(child.getColumn().getId(), child.isExpanded());
                }
            });
        };
        this.filterGroupComps.forEach(recursiveGetExpansionState);
        return expansionState;
    }
    // we don't support refreshing, but must implement because it's on the tool panel interface
    refresh() { }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    expandFilterGroups(expand, groupIds) {
        const updatedGroupIds = [];
        const updateGroupExpandState = (filterGroup) => {
            const groupId = filterGroup.getFilterGroupId();
            const shouldExpandOrCollapse = !groupIds || groupIds.includes(groupId);
            if (shouldExpandOrCollapse) {
                // don't expand 'column groups', i.e. top level columns wrapped in a group
                if (expand && filterGroup.isColumnGroup()) {
                    filterGroup.expand();
                }
                else {
                    filterGroup.collapse();
                }
                updatedGroupIds.push(groupId);
            }
            // recursively look for more groups to expand / collapse
            filterGroup.getChildren().forEach((child) => {
                if (child instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp) {
                    updateGroupExpandState(child);
                }
            });
        };
        this.filterGroupComps.forEach(updateGroupExpandState);
        // update header expand / collapse icon
        this.onGroupExpanded();
        if (groupIds) {
            const unrecognisedGroupIds = groupIds.filter((groupId) => updatedGroupIds.indexOf(groupId) < 0);
            if (unrecognisedGroupIds.length > 0) {
                (0, ag_grid_community_1._warn)(166, { unrecognisedGroupIds });
            }
        }
    }
    expandFilters(expand, colIds) {
        const updatedColIds = [];
        const updateGroupExpandState = (filterComp) => {
            if (filterComp instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp) {
                let anyChildrenChanged = false;
                filterComp.getChildren().forEach((child) => {
                    const childUpdated = updateGroupExpandState(child);
                    if (childUpdated) {
                        if (expand) {
                            filterComp.expand();
                            anyChildrenChanged = true;
                        }
                        else if (!filterComp.isColumnGroup()) {
                            // we only collapse columns wrapped in groups
                            filterComp.collapse();
                        }
                    }
                });
                return anyChildrenChanged;
            }
            const colId = filterComp.getColumn().getColId();
            const updateFilterExpandState = !colIds || colIds.includes(colId);
            if (updateFilterExpandState) {
                expand ? filterComp.expand() : filterComp.collapse();
                updatedColIds.push(colId);
            }
            return updateFilterExpandState;
        };
        this.filterGroupComps.forEach(updateGroupExpandState);
        // update header expand / collapse icon
        this.onGroupExpanded();
        if (colIds) {
            const unrecognisedColIds = colIds.filter((colId) => updatedColIds.indexOf(colId) < 0);
            if (unrecognisedColIds.length > 0) {
                (0, ag_grid_community_1._warn)(167, { unrecognisedColIds });
            }
        }
    }
    onGroupExpanded() {
        this.fireExpandedEvent();
    }
    onFilterExpanded() {
        this.dispatchLocalEvent({ type: 'filterExpanded' });
    }
    fireExpandedEvent() {
        let expandedCount = 0;
        let notExpandedCount = 0;
        const updateExpandCounts = (filterGroup) => {
            if (!filterGroup.isColumnGroup()) {
                return;
            }
            filterGroup.isExpanded() ? expandedCount++ : notExpandedCount++;
            filterGroup.getChildren().forEach((child) => {
                if (child instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp) {
                    updateExpandCounts(child);
                }
            });
        };
        this.filterGroupComps.forEach(updateExpandCounts);
        let state;
        if (expandedCount > 0 && notExpandedCount > 0) {
            state = agFiltersToolPanelHeader_1.EXPAND_STATE.INDETERMINATE;
        }
        else if (notExpandedCount > 0) {
            state = agFiltersToolPanelHeader_1.EXPAND_STATE.COLLAPSED;
        }
        else {
            state = agFiltersToolPanelHeader_1.EXPAND_STATE.EXPANDED;
        }
        this.dispatchLocalEvent({ type: 'groupExpanded', state: state });
    }
    performFilterSearch(searchText) {
        this.searchFilterText = (0, ag_grid_community_1._exists)(searchText) ? searchText.toLowerCase() : null;
        this.searchFilters(this.searchFilterText);
    }
    searchFilters(searchFilter) {
        const passesFilter = (groupName) => {
            return !(0, ag_grid_community_1._exists)(searchFilter) || groupName.toLowerCase().indexOf(searchFilter) !== -1;
        };
        const recursivelySearch = (filterItem, parentPasses) => {
            if (!(filterItem instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp)) {
                return passesFilter(filterItem.getColumnFilterName() || '');
            }
            const children = filterItem.getChildren();
            const groupNamePasses = passesFilter(filterItem.getFilterGroupName());
            // if group or parent already passed - ensure this group and all children are visible
            const alreadyPassed = parentPasses || groupNamePasses;
            if (alreadyPassed) {
                // ensure group visible
                filterItem.hideGroup(false);
                // ensure all children are visible
                for (let i = 0; i < children.length; i++) {
                    recursivelySearch(children[i], alreadyPassed);
                    filterItem.hideGroupItem(false, i);
                }
                return true;
            }
            // hide group item filters
            let anyChildPasses = false;
            children.forEach((child, index) => {
                const childPasses = recursivelySearch(child, parentPasses);
                filterItem.hideGroupItem(!childPasses, index);
                if (childPasses) {
                    anyChildPasses = true;
                }
            });
            // hide group if no children pass
            filterItem.hideGroup(!anyChildPasses);
            return anyChildPasses;
        };
        let firstVisible;
        let lastVisible;
        this.filterGroupComps.forEach((filterGroup, idx) => {
            recursivelySearch(filterGroup, false);
            if (firstVisible === undefined) {
                if (!filterGroup.containsCssClass('ag-hidden')) {
                    firstVisible = idx;
                    lastVisible = idx;
                }
            }
            else if (!filterGroup.containsCssClass('ag-hidden') && lastVisible !== idx) {
                lastVisible = idx;
            }
        });
        this.setFirstAndLastVisible(firstVisible, lastVisible);
        this.refreshAriaLabel();
    }
    setFirstAndLastVisible(firstIdx, lastIdx) {
        this.filterGroupComps.forEach((filterGroup, idx) => {
            filterGroup.removeCssClass('ag-first-group-visible');
            filterGroup.removeCssClass('ag-last-group-visible');
            if (idx === firstIdx) {
                filterGroup.addCssClass('ag-first-group-visible');
            }
            if (idx === lastIdx) {
                filterGroup.addCssClass('ag-last-group-visible');
            }
        });
    }
    refreshFilters(isDisplayed) {
        this.filterGroupComps.forEach((filterGroupComp) => filterGroupComp.refreshFilters(isDisplayed));
    }
    getExpandedFiltersAndGroups() {
        const expandedGroupIds = [];
        const expandedColIds = new Set();
        const getExpandedFiltersAndGroups = (filterComp) => {
            if (filterComp instanceof toolPanelFilterGroupComp_1.ToolPanelFilterGroupComp) {
                filterComp.getChildren().forEach((child) => getExpandedFiltersAndGroups(child));
                const groupId = filterComp.getFilterGroupId();
                if (filterComp.isExpanded() && !expandedColIds.has(groupId)) {
                    expandedGroupIds.push(groupId);
                }
            }
            else {
                if (filterComp.isExpanded()) {
                    expandedColIds.add(filterComp.getColumn().getColId());
                }
            }
        };
        this.filterGroupComps.forEach(getExpandedFiltersAndGroups);
        return { expandedGroupIds, expandedColIds: Array.from(expandedColIds) };
    }
    destroyFilters() {
        this.filterGroupComps = this.destroyBeans(this.filterGroupComps);
        (0, ag_grid_community_1._clearElement)(this.getGui());
    }
    destroy() {
        this.destroyFilters();
        super.destroy();
    }
}
exports.AgFiltersToolPanelList = AgFiltersToolPanelList;
exports.AgFiltersToolPanelListSelector = {
    selector: 'AG-FILTERS-TOOL-PANEL-LIST',
    component: AgFiltersToolPanelList,
};


/***/ }),

/***/ 662:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filtersToolPanelCSS = void 0;
exports.filtersToolPanelCSS = `.ag-filter-toolpanel{flex:1 1 0px;min-width:0}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{align-items:center;color:var(--ag-header-text-color);display:flex;font-weight:500;padding:0 var(--ag-spacing);>*{align-items:center;display:flex}}.ag-filter-toolpanel-header{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing);position:relative;&:focus-visible{border-radius:var(--ag-border-radius);box-shadow:inset var(--ag-focus-shadow)}}:where(.ag-ltr) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-ltr) .ag-filter-toolpanel-instance-header-icon{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-rtl) .ag-filter-toolpanel-instance-header-icon{margin-right:var(--ag-spacing)}.ag-filter-toolpanel-search{margin-bottom:var(--ag-spacing);margin-top:var(--ag-widget-container-vertical-padding)}:where(.ag-filter-toolpanel-group:not(.ag-has-filter)>.ag-group-title-bar) .ag-filter-toolpanel-group-instance-header-icon{display:none}.ag-filter-toolpanel-search-input{flex-grow:1;height:calc(var(--ag-spacing)*4)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar-icon{margin-left:var(--ag-spacing)}.ag-filter-toolpanel-expand{cursor:pointer}:where(.ag-ltr) .ag-filter-toolpanel-expand{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-expand{margin-left:var(--ag-spacing)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar,:where(.ag-ltr) .ag-filter-toolpanel-instance-header{padding-left:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar,:where(.ag-rtl) .ag-filter-toolpanel-instance-header{padding-right:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-ltr) .ag-filter-toolpanel-instance-body{margin-left:var(--ag-filter-tool-panel-group-indent)}:where(.ag-rtl) .ag-filter-toolpanel-instance-body{margin-right:var(--ag-filter-tool-panel-group-indent)}.ag-filter-toolpanel-instance-filter{background-color:var(--ag-chrome-background-color)}.ag-filter-toolpanel-group-level-0{border-top:none}`;


/***/ }),

/***/ 983:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FiltersToolPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agFiltersToolPanelHeader_1 = __webpack_require__(8046);
const agFiltersToolPanelList_1 = __webpack_require__(7291);
const filtersToolPanel_css_GENERATED_1 = __webpack_require__(662);
class FiltersToolPanel extends ag_grid_community_1.Component {
    constructor() {
        super(
        /* html */ `<div class="ag-filter-toolpanel">
            <ag-filters-tool-panel-header data-ref="filtersToolPanelHeaderPanel"></ag-filters-tool-panel-header>
            <ag-filters-tool-panel-list data-ref="filtersToolPanelListPanel"></ag-filters-tool-panel-list>
         </div>`, [agFiltersToolPanelHeader_1.AgFiltersToolPanelHeaderSelector, agFiltersToolPanelList_1.AgFiltersToolPanelListSelector]);
        this.filtersToolPanelHeaderPanel = ag_grid_community_1.RefPlaceholder;
        this.filtersToolPanelListPanel = ag_grid_community_1.RefPlaceholder;
        this.initialised = false;
        this.listenerDestroyFuncs = [];
        this.registerCSS(filtersToolPanel_css_GENERATED_1.filtersToolPanelCSS);
    }
    init(params) {
        // if initialised is true, means this is a refresh
        if (this.initialised) {
            this.listenerDestroyFuncs.forEach((func) => func());
            this.listenerDestroyFuncs = [];
        }
        this.initialised = true;
        const defaultParams = this.gos.addGridCommonParams({
            suppressExpandAll: false,
            suppressFilterSearch: false,
            suppressSyncLayoutWithGrid: false,
        });
        const newParams = {
            ...defaultParams,
            ...params,
        };
        this.params = newParams;
        const { filtersToolPanelHeaderPanel, filtersToolPanelListPanel } = this;
        filtersToolPanelHeaderPanel.init(newParams);
        filtersToolPanelListPanel.init(newParams);
        const hideExpand = newParams.suppressExpandAll;
        const hideSearch = newParams.suppressFilterSearch;
        if (hideExpand && hideSearch) {
            filtersToolPanelHeaderPanel.setDisplayed(false);
        }
        // this is necessary to prevent a memory leak while refreshing the tool panel
        this.listenerDestroyFuncs.push(...this.addManagedListeners(filtersToolPanelHeaderPanel, {
            expandAll: () => filtersToolPanelListPanel.expandFilterGroups(true),
            collapseAll: () => filtersToolPanelListPanel.expandFilterGroups(false),
            searchChanged: (event) => filtersToolPanelListPanel.performFilterSearch(event.searchText),
        }), ...this.addManagedListeners(filtersToolPanelListPanel, {
            filterExpanded: newParams.onStateUpdated,
            groupExpanded: (event) => {
                filtersToolPanelHeaderPanel.setExpandState(event.state);
                newParams.onStateUpdated();
            },
        }));
    }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    setFilterLayout(colDefs) {
        this.filtersToolPanelListPanel.setFiltersLayout(colDefs);
    }
    expandFilterGroups(groupIds) {
        this.filtersToolPanelListPanel.expandFilterGroups(true, groupIds);
    }
    collapseFilterGroups(groupIds) {
        this.filtersToolPanelListPanel.expandFilterGroups(false, groupIds);
    }
    expandFilters(colIds) {
        this.filtersToolPanelListPanel.expandFilters(true, colIds);
    }
    collapseFilters(colIds) {
        this.filtersToolPanelListPanel.expandFilters(false, colIds);
    }
    syncLayoutWithGrid() {
        this.filtersToolPanelListPanel.syncFilterLayout();
    }
    refresh(params) {
        this.init(params);
        return true;
    }
    getState() {
        return this.filtersToolPanelListPanel.getExpandedFiltersAndGroups();
    }
}
exports.FiltersToolPanel = FiltersToolPanel;


/***/ }),

/***/ 2515:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FiltersToolPanelModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const sideBarModule_1 = __webpack_require__(6358);
const version_1 = __webpack_require__(7205);
const filtersToolPanel_1 = __webpack_require__(983);
/**
 * @feature Accessories -> Filters Tool Panel
 */
exports.FiltersToolPanelModule = {
    moduleName: 'FiltersToolPanel',
    version: version_1.VERSION,
    userComponents: { agFiltersToolPanel: filtersToolPanel_1.FiltersToolPanel },
    icons: {
        // filter tool panel tab
        filtersToolPanel: 'filter',
    },
    dependsOn: [sideBarModule_1.SideBarModule, agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._ColumnFilterModule],
};


/***/ }),

/***/ 3905:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelFilterComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ToolPanelFilterComp extends ag_grid_community_1.Component {
    constructor(hideHeader, expandedCallback) {
        super(/* html */ `
            <div class="ag-filter-toolpanel-instance">
                <div class="ag-filter-toolpanel-header ag-filter-toolpanel-instance-header" data-ref="eFilterToolPanelHeader" role="button" aria-expanded="false">
                    <div data-ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                    <span data-ref="eFilterName" class="ag-header-cell-text"></span>
                    <span data-ref="eFilterIcon" class="ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon" aria-hidden="true"></span>
                </div>
                <div class="ag-filter-toolpanel-instance-body ag-filter" data-ref="agFilterToolPanelBody"></div>
            </div>`);
        this.hideHeader = hideHeader;
        this.expandedCallback = expandedCallback;
        this.eFilterToolPanelHeader = ag_grid_community_1.RefPlaceholder;
        this.eFilterName = ag_grid_community_1.RefPlaceholder;
        this.agFilterToolPanelBody = ag_grid_community_1.RefPlaceholder;
        this.eFilterIcon = ag_grid_community_1.RefPlaceholder;
        this.eExpand = ag_grid_community_1.RefPlaceholder;
        this.expanded = false;
    }
    postConstruct() {
        const { beans, eExpand } = this;
        const eExpandChecked = (0, ag_grid_community_1._createIconNoSpan)('accordionOpen', beans);
        this.eExpandChecked = eExpandChecked;
        const eExpandUnchecked = (0, ag_grid_community_1._createIconNoSpan)('accordionClosed', beans);
        this.eExpandUnchecked = eExpandUnchecked;
        eExpand.appendChild(eExpandChecked);
        eExpand.appendChild(eExpandUnchecked);
    }
    setColumn(column) {
        this.column = column;
        const { beans, eFilterToolPanelHeader, eFilterIcon, eExpandChecked, hideHeader } = this;
        this.eFilterName.innerText = beans.colNames.getDisplayNameForColumn(column, 'filterToolPanel', false) || '';
        this.addManagedListeners(eFilterToolPanelHeader, {
            click: this.toggleExpanded.bind(this),
            keydown: this.onKeyDown.bind(this),
        });
        this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) });
        this.addInIcon('filterActive', eFilterIcon, column);
        (0, ag_grid_community_1._setDisplayed)(eFilterIcon, this.isFilterActive(), { skipAriaHidden: true });
        (0, ag_grid_community_1._setDisplayed)(eExpandChecked, false);
        if (hideHeader) {
            (0, ag_grid_community_1._setDisplayed)(eFilterToolPanelHeader, false);
            eFilterToolPanelHeader.removeAttribute('tabindex');
        }
        else {
            eFilterToolPanelHeader.setAttribute('tabindex', '0');
        }
        this.addManagedListeners(column, { filterChanged: this.onFilterChanged.bind(this) });
    }
    onKeyDown(e) {
        const { key } = e;
        const { ENTER, SPACE, LEFT, RIGHT } = ag_grid_community_1.KeyCode;
        if (key !== ENTER && key !== SPACE && key !== LEFT && key !== RIGHT) {
            return;
        }
        e.preventDefault();
        if (key === ENTER || key === SPACE) {
            this.toggleExpanded();
        }
        else if (key === ag_grid_community_1.KeyCode.LEFT) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    getColumn() {
        return this.column;
    }
    getColumnFilterName() {
        return this.beans.colNames.getDisplayNameForColumn(this.column, 'filterToolPanel', false);
    }
    addCssClassToTitleBar(cssClass) {
        this.eFilterToolPanelHeader.classList.add(cssClass);
    }
    addInIcon(iconName, eParent, column) {
        if (eParent == null) {
            return;
        }
        const eIcon = (0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans, column);
        eParent.appendChild(eIcon);
    }
    isFilterActive() {
        return !!this.beans.filterManager?.isFilterActive(this.column);
    }
    onFilterChanged() {
        (0, ag_grid_community_1._setDisplayed)(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: true });
        this.dispatchLocalEvent({ type: 'filterChanged' });
    }
    toggleExpanded() {
        this.expanded ? this.collapse() : this.expand();
    }
    expand() {
        if (this.expanded) {
            return;
        }
        this.expanded = true;
        (0, ag_grid_community_1._setAriaExpanded)(this.eFilterToolPanelHeader, true);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandChecked, true);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandUnchecked, false);
        this.addFilterElement();
        this.expandedCallback();
    }
    addFilterElement(suppressFocus) {
        const filterPanelWrapper = (0, ag_grid_community_1._loadTemplate)(/* html */ `<div class="ag-filter-toolpanel-instance-filter"></div>`);
        const comp = this.createManagedBean(new ag_grid_community_1.FilterWrapperComp(this.column, 'TOOLBAR'));
        this.filterWrapperComp = comp;
        if (!comp.hasFilter()) {
            return;
        }
        comp.getFilter()?.then((filter) => {
            this.underlyingFilter = filter;
            if (!filter) {
                return;
            }
            filterPanelWrapper.appendChild(comp.getGui());
            this.agFilterToolPanelBody.appendChild(filterPanelWrapper);
            comp.afterGuiAttached({ container: 'toolPanel', suppressFocus });
        });
    }
    collapse() {
        if (!this.expanded) {
            return;
        }
        this.expanded = false;
        (0, ag_grid_community_1._setAriaExpanded)(this.eFilterToolPanelHeader, false);
        this.removeFilterElement();
        (0, ag_grid_community_1._setDisplayed)(this.eExpandChecked, false);
        (0, ag_grid_community_1._setDisplayed)(this.eExpandUnchecked, true);
        const filterWrapperComp = this.filterWrapperComp;
        filterWrapperComp?.afterGuiDetached();
        this.destroyBean(filterWrapperComp);
        this.expandedCallback();
    }
    removeFilterElement() {
        (0, ag_grid_community_1._clearElement)(this.agFilterToolPanelBody);
    }
    isExpanded() {
        return this.expanded;
    }
    refreshFilter(isDisplayed) {
        if (!this.expanded) {
            return;
        }
        const filter = this.underlyingFilter;
        if (!filter) {
            return;
        }
        if (isDisplayed) {
            // set filters should be updated when the filter has been changed elsewhere, i.e. via api. Note that we can't
            // use 'afterGuiAttached' to refresh the virtual list as it also focuses on the mini filter which changes the
            // scroll position in the filter list panel
            if (typeof filter.refreshVirtualList === 'function') {
                filter.refreshVirtualList();
            }
        }
        else {
            filter.afterGuiDetached?.();
        }
    }
    onFilterOpened(event) {
        if (event.source !== 'COLUMN_MENU') {
            return;
        }
        if (event.column !== this.column) {
            return;
        }
        if (!this.expanded) {
            return;
        }
        this.collapse();
    }
}
exports.ToolPanelFilterComp = ToolPanelFilterComp;


/***/ }),

/***/ 5296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelFilterGroupComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const toolPanelFilterComp_1 = __webpack_require__(3905);
class ToolPanelFilterGroupComp extends ag_grid_community_1.Component {
    constructor(columnGroup, childFilterComps, expandedCallback, depth, showingColumn) {
        super();
        this.columnGroup = columnGroup;
        this.childFilterComps = childFilterComps;
        this.expandedCallback = expandedCallback;
        this.depth = depth;
        this.showingColumn = showingColumn;
        this.filterGroupComp = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const groupParams = {
            cssIdentifier: 'filter-toolpanel',
            direction: 'vertical',
        };
        this.setTemplate(
        /* html */ `<div class="ag-filter-toolpanel-group-wrapper">
            <ag-group-component data-ref="filterGroupComp"></ag-group-component>
        </div>`, [agGroupComponent_1.AgGroupComponentSelector], { filterGroupComp: groupParams });
        this.setGroupTitle();
        const { filterGroupComp, depth, childFilterComps, gos } = this;
        filterGroupComp.setAlignItems('stretch');
        filterGroupComp.addCssClass(`ag-filter-toolpanel-group-level-${depth}`);
        filterGroupComp.getGui().style.setProperty('--ag-indentation-level', String(depth));
        filterGroupComp.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${depth}-header`);
        childFilterComps.forEach((filterComp) => {
            filterGroupComp.addItem(filterComp);
            filterComp.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${depth + 1}-header`);
            filterComp.getGui().style.setProperty('--ag-indentation-level', String(depth + 1));
        });
        this.tooltipFeature = this.createOptionalManagedBean(this.beans.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getLocation: () => 'filterToolPanelColumnGroup',
            shouldDisplayTooltip: (0, ag_grid_community_1._getShouldDisplayTooltip)(gos, () => filterGroupComp.getGui().querySelector('.ag-group-title')),
        }));
        this.refreshFilterClass();
        this.addExpandCollapseListeners();
        this.addFilterChangedListeners();
        this.setupTooltip();
        this.addInIcon('filterActive');
    }
    setupTooltip() {
        // we don't show tooltips for groups, as when the group expands, it's div contains the columns which also
        // have tooltips, so the tooltips would clash. Eg mouse over group, tooltip shows, mouse over column, another
        // tooltip shows but cos we didn't leave the group the group tooltip remains. this should be fixed in the future,
        // maybe the group shouldn't contain the children form a DOM perspective.
        if (!this.showingColumn) {
            return;
        }
        const refresh = () => {
            this.tooltipFeature?.setTooltipAndRefresh(this.columnGroup.getColDef().headerTooltip);
        };
        refresh();
        this.addManagedEventListeners({ newColumnsLoaded: refresh });
    }
    addCssClassToTitleBar(cssClass) {
        this.filterGroupComp.addCssClassToTitleBar(cssClass);
    }
    refreshFilters(isDisplayed) {
        this.childFilterComps.forEach((filterComp) => {
            if (filterComp instanceof ToolPanelFilterGroupComp) {
                filterComp.refreshFilters(isDisplayed);
            }
            else {
                filterComp.refreshFilter(isDisplayed);
            }
        });
    }
    isColumnGroup() {
        return (0, ag_grid_community_1.isProvidedColumnGroup)(this.columnGroup);
    }
    isExpanded() {
        return this.filterGroupComp.isExpanded();
    }
    getChildren() {
        return this.childFilterComps;
    }
    getFilterGroupName() {
        return this.filterGroupName ?? '';
    }
    getFilterGroupId() {
        return this.columnGroup.getId();
    }
    hideGroupItem(hide, index) {
        this.filterGroupComp.hideItem(hide, index);
    }
    hideGroup(hide) {
        this.setDisplayed(!hide);
    }
    addInIcon(iconName) {
        const eIcon = (0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans);
        if (eIcon) {
            eIcon.classList.add('ag-filter-toolpanel-group-instance-header-icon');
        }
        this.filterGroupComp.addTitleBarWidget(eIcon);
    }
    forEachToolPanelFilterChild(action) {
        this.childFilterComps.forEach((filterComp) => {
            if (filterComp instanceof toolPanelFilterComp_1.ToolPanelFilterComp) {
                action(filterComp);
            }
        });
    }
    addExpandCollapseListeners() {
        const expandListener = this.isColumnGroup()
            ? () => this.expandedCallback()
            : () => this.forEachToolPanelFilterChild((filterComp) => filterComp.expand());
        const collapseListener = this.isColumnGroup()
            ? () => this.expandedCallback()
            : () => this.forEachToolPanelFilterChild((filterComp) => filterComp.collapse());
        this.addManagedListeners(this.filterGroupComp, {
            expanded: expandListener,
            collapsed: collapseListener,
        });
    }
    getColumns() {
        if ((0, ag_grid_community_1.isProvidedColumnGroup)(this.columnGroup)) {
            return this.columnGroup.getLeafColumns();
        }
        return [this.columnGroup];
    }
    addFilterChangedListeners() {
        this.getColumns().forEach((column) => {
            this.addManagedListeners(column, { filterChanged: () => this.refreshFilterClass() });
        });
        if (!(0, ag_grid_community_1.isProvidedColumnGroup)(this.columnGroup)) {
            this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) });
        }
    }
    refreshFilterClass() {
        const columns = this.getColumns();
        const anyChildFiltersActive = () => columns.some((col) => col.isFilterActive());
        this.filterGroupComp.addOrRemoveCssClass('ag-has-filter', anyChildFiltersActive());
    }
    onFilterOpened(event) {
        // when a filter is opened elsewhere, i.e. column menu we close the filter comp so we also need to collapse
        // the column group. This approach means we don't need to try and sync filter models on the same column.
        if (event.source !== 'COLUMN_MENU') {
            return;
        }
        if (event.column !== this.columnGroup) {
            return;
        }
        if (!this.isExpanded()) {
            return;
        }
        this.collapse();
    }
    expand() {
        this.filterGroupComp.toggleGroupExpand(true);
    }
    collapse() {
        this.filterGroupComp.toggleGroupExpand(false);
    }
    setGroupTitle() {
        const columnGroup = this.columnGroup;
        const filterGroupName = (0, ag_grid_community_1.isProvidedColumnGroup)(columnGroup)
            ? this.getColumnGroupName(columnGroup)
            : this.getColumnName(columnGroup);
        this.filterGroupName = filterGroupName;
        this.filterGroupComp.setTitle(filterGroupName || '');
    }
    getColumnGroupName(columnGroup) {
        return this.beans.colNames.getDisplayNameForProvidedColumnGroup(null, columnGroup, 'filterToolPanel');
    }
    getColumnName(column) {
        return this.beans.colNames.getDisplayNameForColumn(column, 'filterToolPanel', false);
    }
    destroyFilters() {
        this.childFilterComps = this.destroyBeans(this.childFilterComps);
        (0, ag_grid_community_1._clearElement)(this.getGui());
    }
    destroy() {
        this.destroyFilters();
        super.destroy();
    }
}
exports.ToolPanelFilterGroupComp = ToolPanelFilterGroupComp;


/***/ }),

/***/ 3159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridLicenseManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const licenseManager_1 = __webpack_require__(6565);
const watermark_1 = __webpack_require__(3879);
class GridLicenseManager extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'licenseManager';
    }
    postConstruct() {
        this.validateLicense();
    }
    validateLicense() {
        this.licenseManager = new licenseManager_1.LicenseManager((0, ag_grid_community_1._getDocument)(this.beans));
        this.licenseManager.validateLicense();
    }
    static getLicenseDetails(licenseKey) {
        return new licenseManager_1.LicenseManager(null).getLicenseDetails(licenseKey);
    }
    getWatermarkSelector() {
        return watermark_1.AgWatermarkSelector;
    }
    isDisplayWatermark() {
        return this.licenseManager.isDisplayWatermark();
    }
    getWatermarkMessage() {
        return this.licenseManager.getWatermarkMessage();
    }
    static setLicenseKey(licenseKey) {
        licenseManager_1.LicenseManager.setLicenseKey(licenseKey);
    }
    static setChartsLicenseManager(chartsLicenseManager) {
        licenseManager_1.LicenseManager.setChartsLicenseManager(chartsLicenseManager);
    }
}
exports.GridLicenseManager = GridLicenseManager;


/***/ }),

/***/ 6565:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LicenseManager = void 0;
const md5_1 = __webpack_require__(1555);
const LICENSE_TYPES = {
    '01': 'GRID',
    '02': 'CHARTS',
    '0102': 'BOTH',
};
const LICENSING_HELP_URL = 'https://ag-grid.com/licensing/';
class LicenseManager {
    constructor(document) {
        this.watermarkMessage = undefined;
        this.totalMessageLength = 124;
        this.document = document;
        this.md5 = new md5_1.MD5();
        this.md5.init();
    }
    validateLicense() {
        const licenseDetails = this.getLicenseDetails(LicenseManager.licenseKey);
        const currentLicenseName = `AG Grid ${licenseDetails.currentLicenseType === 'BOTH' ? 'and AG Charts ' : ''}Enterprise`;
        const suppliedLicenseName = licenseDetails.suppliedLicenseType === undefined
            ? ''
            : `AG ${licenseDetails.suppliedLicenseType === 'BOTH' ? 'Grid and AG Charts' : licenseDetails.suppliedLicenseType === 'GRID' ? 'Grid' : 'Charts'} Enterprise`;
        if (licenseDetails.missing) {
            if (!this.isWebsiteUrl() || this.isForceWatermark()) {
                this.outputMissingLicenseKey(currentLicenseName);
            }
        }
        else if (licenseDetails.expired) {
            const gridReleaseDate = LicenseManager.getGridReleaseDate();
            const formattedReleaseDate = LicenseManager.formatDate(gridReleaseDate);
            this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, currentLicenseName, suppliedLicenseName);
        }
        else if (!licenseDetails.valid) {
            this.outputInvalidLicenseKey(!!licenseDetails.incorrectLicenseType, currentLicenseName, suppliedLicenseName);
        }
        else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
            this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
        }
    }
    static extractExpiry(license) {
        const restrictionHashed = license.substring(license.lastIndexOf('_') + 1, license.length);
        return new Date(parseInt(LicenseManager.decode(restrictionHashed), 10));
    }
    static extractLicenseComponents(licenseKey) {
        // when users copy the license key from a PDF extra zero width characters are sometimes copied too
        // carriage returns and line feeds are problematic too
        // all of which causes license key validation to fail - strip these out
        let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, '');
        cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, '');
        // the hash that follows the key is 32 chars long
        if (licenseKey.length <= 32) {
            return { md5: null, license: licenseKey, version: null, isTrial: null };
        }
        const hashStart = cleanedLicenseKey.length - 32;
        const md5 = cleanedLicenseKey.substring(hashStart);
        const license = cleanedLicenseKey.substring(0, hashStart);
        const [version, isTrial, type] = LicenseManager.extractBracketedInformation(cleanedLicenseKey);
        return { md5, license, version, isTrial, type };
    }
    getLicenseDetails(licenseKey) {
        const currentLicenseType = LicenseManager.chartsLicenseManager ? 'BOTH' : 'GRID';
        if (!licenseKey?.length) {
            return {
                licenseKey,
                valid: false,
                missing: true,
                currentLicenseType,
            };
        }
        const gridReleaseDate = LicenseManager.getGridReleaseDate();
        const { md5, license, version, isTrial, type } = LicenseManager.extractLicenseComponents(licenseKey);
        let valid = md5 === this.md5.md5(license) && licenseKey.indexOf('For_Trialing_ag-Grid_Only') === -1;
        let trialExpired = undefined;
        let expired = undefined;
        let expiry = null;
        let incorrectLicenseType = false;
        let suppliedLicenseType = undefined;
        function handleTrial() {
            const now = new Date();
            trialExpired = expiry < now;
            expired = undefined;
        }
        if (valid) {
            expiry = LicenseManager.extractExpiry(license);
            valid = !isNaN(expiry.getTime());
            if (valid) {
                expired = gridReleaseDate > expiry;
                switch (version) {
                    case 'legacy':
                    case '2': {
                        if (isTrial) {
                            handleTrial();
                        }
                        break;
                    }
                    case '3': {
                        if (!type?.length) {
                            valid = false;
                        }
                        else {
                            suppliedLicenseType = type;
                            if ((type !== LICENSE_TYPES['01'] && type !== LICENSE_TYPES['0102']) ||
                                (currentLicenseType === 'BOTH' && suppliedLicenseType !== 'BOTH')) {
                                valid = false;
                                incorrectLicenseType = true;
                            }
                            else if (isTrial) {
                                handleTrial();
                            }
                        }
                    }
                }
            }
        }
        if (!valid) {
            return {
                licenseKey,
                valid,
                incorrectLicenseType,
                currentLicenseType,
                suppliedLicenseType,
            };
        }
        return {
            licenseKey,
            valid,
            expiry: LicenseManager.formatDate(expiry),
            expired,
            version,
            isTrial,
            trialExpired,
            incorrectLicenseType,
            currentLicenseType,
            suppliedLicenseType,
        };
    }
    isDisplayWatermark() {
        return (this.isForceWatermark() || (!this.isLocalhost() && !this.isWebsiteUrl() && !!this.watermarkMessage?.length));
    }
    getWatermarkMessage() {
        return this.watermarkMessage || '';
    }
    getHostname() {
        const win = this.document.defaultView || window;
        const loc = win.location;
        const { hostname = '' } = loc;
        return hostname;
    }
    isForceWatermark() {
        const win = this.document.defaultView || window;
        const loc = win.location;
        const { pathname } = loc;
        return pathname ? pathname.indexOf('forceWatermark') !== -1 : false;
    }
    isWebsiteUrl() {
        const hostname = this.getHostname();
        return hostname.match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
    }
    isLocalhost() {
        const hostname = this.getHostname();
        return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
    }
    static formatDate(date) {
        const monthNames = [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December',
        ];
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        return day + ' ' + monthNames[monthIndex] + ' ' + year;
    }
    static getGridReleaseDate() {
        return new Date(parseInt(LicenseManager.decode(LicenseManager.RELEASE_INFORMATION), 10));
    }
    static decode(input) {
        const keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let t = '';
        let n, r, i;
        let s, o, u, a;
        let f = 0;
        const e = input.replace(/[^A-Za-z0-9+/=]/g, '');
        while (f < e.length) {
            s = keystr.indexOf(e.charAt(f++));
            o = keystr.indexOf(e.charAt(f++));
            u = keystr.indexOf(e.charAt(f++));
            a = keystr.indexOf(e.charAt(f++));
            n = (s << 2) | (o >> 4);
            r = ((o & 15) << 4) | (u >> 2);
            i = ((u & 3) << 6) | a;
            t = t + String.fromCharCode(n);
            if (u != 64) {
                t = t + String.fromCharCode(r);
            }
            if (a != 64) {
                t = t + String.fromCharCode(i);
            }
        }
        t = LicenseManager.utf8_decode(t);
        return t;
    }
    static utf8_decode(input) {
        input = input.replace(/rn/g, 'n');
        let t = '';
        for (let n = 0; n < input.length; n++) {
            const r = input.charCodeAt(n);
            if (r < 128) {
                t += String.fromCharCode(r);
            }
            else if (r > 127 && r < 2048) {
                t += String.fromCharCode((r >> 6) | 192);
                t += String.fromCharCode((r & 63) | 128);
            }
            else {
                t += String.fromCharCode((r >> 12) | 224);
                t += String.fromCharCode(((r >> 6) & 63) | 128);
                t += String.fromCharCode((r & 63) | 128);
            }
        }
        return t;
    }
    static setChartsLicenseManager(dependantLicenseManager) {
        this.chartsLicenseManager = dependantLicenseManager;
    }
    static setLicenseKey(licenseKey) {
        this.licenseKey = licenseKey;
        this.chartsLicenseManager?.setLicenseKey(licenseKey, true);
    }
    static extractBracketedInformation(licenseKey) {
        // legacy no trial key
        if (!licenseKey.includes('[')) {
            return ['legacy', false, undefined];
        }
        const matches = licenseKey.match(/\[(.*?)\]/g).map((match) => match.replace('[', '').replace(']', ''));
        if (!matches || matches.length === 0) {
            return ['legacy', false, undefined];
        }
        const isTrial = matches.filter((match) => match === 'TRIAL').length === 1;
        const rawVersion = matches.filter((match) => match.indexOf('v') === 0)[0];
        const version = rawVersion ? rawVersion.replace('v', '') : 'legacy';
        const type = LICENSE_TYPES[matches.filter((match) => LICENSE_TYPES[match])[0]];
        return [version, isTrial, type];
    }
    centerPadAndOutput(input) {
        const paddingRequired = this.totalMessageLength - input.length;
        // eslint-disable-next-line no-console
        console.error(input.padStart(paddingRequired / 2 + input.length, '*').padEnd(this.totalMessageLength, '*'));
    }
    padAndOutput(input, padding = '*', terminateWithPadding = '') {
        // eslint-disable-next-line no-console
        console.error(input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding);
    }
    outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
        if (incorrectLicenseType) {
            // TC4, TC5,TC10
            this.centerPadAndOutput('');
            this.centerPadAndOutput(` ${currentLicenseName} License `);
            this.centerPadAndOutput(' Incompatible License Key ');
            this.padAndOutput(`* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`, ' ', '*');
            this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, ' ', '*');
            this.centerPadAndOutput('');
            this.centerPadAndOutput('');
        }
        else {
            // TC3, TC9
            this.centerPadAndOutput('');
            this.centerPadAndOutput(` ${currentLicenseName} License `);
            this.centerPadAndOutput(' Invalid License Key ');
            this.padAndOutput(`* Your license key is not valid.`, ' ', '*');
            this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, ' ', '*');
            this.centerPadAndOutput('');
            this.centerPadAndOutput('');
        }
        this.watermarkMessage = 'Invalid License';
    }
    outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
        // TC14
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' Trial Period Expired. ');
        this.padAndOutput(`* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`, ' ', '*');
        this.padAndOutput('* Please email info@ag-grid.com to purchase a license.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = 'Trial Period Expired';
    }
    outputMissingLicenseKey(currentLicenseName) {
        // TC6, TC12
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' License Key Not Found ');
        this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, ' ', '*');
        this.padAndOutput('* If you want to hide the watermark please email info@ag-grid.com for a trial license key.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = 'For Trial Use Only';
    }
    outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName, suppliedLicenseName) {
        // TC2
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' Incompatible Software Version ');
        this.padAndOutput(`* Your license key works with versions of ${suppliedLicenseName} released before ${formattedExpiryDate}.`, ' ', '*');
        this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, ' ', '*');
        this.padAndOutput('* Please contact info@ag-grid.com to renew your license key.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = 'License Expired';
    }
}
exports.LicenseManager = LicenseManager;
LicenseManager.RELEASE_INFORMATION = 'MTczMzc1NjY3OTc2Mw==';


/***/ }),

/***/ 1555:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MD5 = void 0;
class MD5 {
    constructor() {
        this.ieCompatibility = false;
    }
    init() {
        this.ieCompatibility = this.md5('hello') != '5d41402abc4b2a76b9719d911017c592';
    }
    md5cycle(x, k) {
        let a = x[0], b = x[1], c = x[2], d = x[3];
        a = this.ff(a, b, c, d, k[0], 7, -680876936);
        d = this.ff(d, a, b, c, k[1], 12, -389564586);
        c = this.ff(c, d, a, b, k[2], 17, 606105819);
        b = this.ff(b, c, d, a, k[3], 22, -1044525330);
        a = this.ff(a, b, c, d, k[4], 7, -176418897);
        d = this.ff(d, a, b, c, k[5], 12, 1200080426);
        c = this.ff(c, d, a, b, k[6], 17, -1473231341);
        b = this.ff(b, c, d, a, k[7], 22, -45705983);
        a = this.ff(a, b, c, d, k[8], 7, 1770035416);
        d = this.ff(d, a, b, c, k[9], 12, -1958414417);
        c = this.ff(c, d, a, b, k[10], 17, -42063);
        b = this.ff(b, c, d, a, k[11], 22, -1990404162);
        a = this.ff(a, b, c, d, k[12], 7, 1804603682);
        d = this.ff(d, a, b, c, k[13], 12, -40341101);
        c = this.ff(c, d, a, b, k[14], 17, -1502002290);
        b = this.ff(b, c, d, a, k[15], 22, 1236535329);
        a = this.gg(a, b, c, d, k[1], 5, -165796510);
        d = this.gg(d, a, b, c, k[6], 9, -1069501632);
        c = this.gg(c, d, a, b, k[11], 14, 643717713);
        b = this.gg(b, c, d, a, k[0], 20, -373897302);
        a = this.gg(a, b, c, d, k[5], 5, -701558691);
        d = this.gg(d, a, b, c, k[10], 9, 38016083);
        c = this.gg(c, d, a, b, k[15], 14, -660478335);
        b = this.gg(b, c, d, a, k[4], 20, -405537848);
        a = this.gg(a, b, c, d, k[9], 5, 568446438);
        d = this.gg(d, a, b, c, k[14], 9, -1019803690);
        c = this.gg(c, d, a, b, k[3], 14, -187363961);
        b = this.gg(b, c, d, a, k[8], 20, 1163531501);
        a = this.gg(a, b, c, d, k[13], 5, -1444681467);
        d = this.gg(d, a, b, c, k[2], 9, -51403784);
        c = this.gg(c, d, a, b, k[7], 14, 1735328473);
        b = this.gg(b, c, d, a, k[12], 20, -1926607734);
        a = this.hh(a, b, c, d, k[5], 4, -378558);
        d = this.hh(d, a, b, c, k[8], 11, -2022574463);
        c = this.hh(c, d, a, b, k[11], 16, 1839030562);
        b = this.hh(b, c, d, a, k[14], 23, -35309556);
        a = this.hh(a, b, c, d, k[1], 4, -1530992060);
        d = this.hh(d, a, b, c, k[4], 11, 1272893353);
        c = this.hh(c, d, a, b, k[7], 16, -155497632);
        b = this.hh(b, c, d, a, k[10], 23, -1094730640);
        a = this.hh(a, b, c, d, k[13], 4, 681279174);
        d = this.hh(d, a, b, c, k[0], 11, -358537222);
        c = this.hh(c, d, a, b, k[3], 16, -722521979);
        b = this.hh(b, c, d, a, k[6], 23, 76029189);
        a = this.hh(a, b, c, d, k[9], 4, -640364487);
        d = this.hh(d, a, b, c, k[12], 11, -421815835);
        c = this.hh(c, d, a, b, k[15], 16, 530742520);
        b = this.hh(b, c, d, a, k[2], 23, -995338651);
        a = this.ii(a, b, c, d, k[0], 6, -198630844);
        d = this.ii(d, a, b, c, k[7], 10, 1126891415);
        c = this.ii(c, d, a, b, k[14], 15, -1416354905);
        b = this.ii(b, c, d, a, k[5], 21, -57434055);
        a = this.ii(a, b, c, d, k[12], 6, 1700485571);
        d = this.ii(d, a, b, c, k[3], 10, -1894986606);
        c = this.ii(c, d, a, b, k[10], 15, -1051523);
        b = this.ii(b, c, d, a, k[1], 21, -2054922799);
        a = this.ii(a, b, c, d, k[8], 6, 1873313359);
        d = this.ii(d, a, b, c, k[15], 10, -30611744);
        c = this.ii(c, d, a, b, k[6], 15, -1560198380);
        b = this.ii(b, c, d, a, k[13], 21, 1309151649);
        a = this.ii(a, b, c, d, k[4], 6, -145523070);
        d = this.ii(d, a, b, c, k[11], 10, -1120210379);
        c = this.ii(c, d, a, b, k[2], 15, 718787259);
        b = this.ii(b, c, d, a, k[9], 21, -343485551);
        x[0] = this.add32(a, x[0]);
        x[1] = this.add32(b, x[1]);
        x[2] = this.add32(c, x[2]);
        x[3] = this.add32(d, x[3]);
    }
    cmn(q, a, b, x, s, t) {
        a = this.add32(this.add32(a, q), this.add32(x, t));
        return this.add32((a << s) | (a >>> (32 - s)), b);
    }
    ff(a, b, c, d, x, s, t) {
        return this.cmn((b & c) | (~b & d), a, b, x, s, t);
    }
    gg(a, b, c, d, x, s, t) {
        return this.cmn((b & d) | (c & ~d), a, b, x, s, t);
    }
    hh(a, b, c, d, x, s, t) {
        return this.cmn(b ^ c ^ d, a, b, x, s, t);
    }
    ii(a, b, c, d, x, s, t) {
        return this.cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    md51(s) {
        const n = s.length;
        const state = [1732584193, -271733879, -1732584194, 271733878];
        let i;
        for (i = 64; i <= s.length; i += 64) {
            this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < s.length; i++) {
            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 0x80 << (i % 4 << 3);
        if (i > 55) {
            this.md5cycle(state, tail);
            for (i = 0; i < 16; i++) {
                tail[i] = 0;
            }
        }
        tail[14] = n * 8;
        this.md5cycle(state, tail);
        return state;
    }
    /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
     * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
     * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
     * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
     * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
     * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
     * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
     */
    md5blk(s) {
        /* I figured global was faster.   */
        const md5blks = [];
        /* Andy King said do it this way. */
        for (let i = 0; i < 64; i += 4) {
            md5blks[i >> 2] =
                s.charCodeAt(i) +
                    (s.charCodeAt(i + 1) << 8) +
                    (s.charCodeAt(i + 2) << 16) +
                    (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }
    rhex(n) {
        const hex_chr = '0123456789abcdef'.split('');
        let s = '', j = 0;
        for (; j < 4; j++) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0f] + hex_chr[(n >> (j * 8)) & 0x0f];
        }
        return s;
    }
    hex(x) {
        for (let i = 0; i < x.length; i++) {
            x[i] = this.rhex(x[i]);
        }
        return x.join('');
    }
    md5(s) {
        return this.hex(this.md51(s));
    }
    add32(a, b) {
        return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
    }
    /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
     need the idiotic second function, generated by an if clause.  */
    add32Std(a, b) {
        return (a + b) & 0xffffffff;
    }
    add32Compat(x, y) {
        const lsw = (x & 0xffff) + (y & 0xffff), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xffff);
    }
}
exports.MD5 = MD5;


/***/ }),

/***/ 454:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watermarkCSS = void 0;
exports.watermarkCSS = `.ag-watermark{bottom:20px;color:#9b9b9b;opacity:.7;position:absolute;transition:opacity 1s ease-out 3s;&:before{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDkiIGhlaWdodD0iMzYiIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyMDkgMzYiPjxwYXRoIGZpbGw9IiM5QjlCOUIiIGQ9Ik0xOTIuOTkzIDIzLjY1OHYtNy45NDZoLTEzLjU0MWwtNy45NDcgNy45NDZ6TTIwOC4yNSAzLjk1aC0xNi45NzRsLTguMDEgNy45NDdoMjQuOTg0ek0xNjMuNjIyIDMxLjYwNWw0LjA2OS00LjA2OWgxMy43MzJ2Ny45NDdoLTE3LjgwMXoiLz48cGF0aCBmaWxsPSIjOUI5QjlCIiBkPSJNMTY2LjYxIDE5Ljc4aDguNzczbDguMDEtNy45NDZIMTY2LjYxek0xNTcuMDExIDMxLjYwNWg2LjYxMWw3Ljg4My03Ljk0N2gtMTQuNDk0ek0xOTEuMjc2IDMuOTVsLTQuMDY4IDQuMDdIMTYxLjI3Vi4wNzJoMzAuMDA2ek0yMC44NCAzMC4yMDZIOC4zNzhsLTIuMTYyIDUuMzRILjc1TDEyLjI1NyA4LjU5Mmg0Ljc2OEwyOC41MyAzNS41NDZoLTUuNTN6bS0xLjcxNy00LjI2TDE0LjYwOSAxNC45NWwtNC41MTQgMTAuOTk4ek0xMDQuNDM3IDE4LjUwOWMxLjU4OS0yLjM1MiA1LjU5NC0yLjYwNyA3LjI0Ny0yLjYwN3Y0LjU3OGMtMi4wMzQgMC00LjA2OS4wNjMtNS4yNzcuOTUzLTEuMjA3Ljg5LTEuODQzIDIuMDk4LTEuODQzIDMuNTZ2MTAuNTUzaC00Ljk1OVYxNS45MDJoNC43Njh6TTExOS4zNzYgMTUuOTAyaC00Ljk1OHYxOS42NDRoNC45NTh6TTExOS4zNzYgNy4xM2gtNC45NTh2NS44NDhoNC45NTh6TTE0My45NzkgNy4xM3YyOC40MTZoLTQuNzY4bC0uMTI3LTIuOTg4YTguMyA4LjMgMCAwIDEtMi42NyAyLjQ4Yy0xLjA4MS41NzItMi40MTYuODktMy45NDIuODktMS4zMzUgMC0yLjYwNi0uMjU1LTMuNjg3LS43LTEuMTQ0LS41MDgtMi4xNjItMS4xNDQtMi45ODgtMi4wMzRhOS42IDkuNiAwIDAgMS0xLjk3MS0zLjE3OWMtLjUwOC0xLjIwNy0uNjk5LTIuNjA2LS42OTktNC4xMzJzLjI1NC0yLjkyNC42OTktNC4xOTZjLjUwOS0xLjI3MSAxLjE0NS0yLjM1MiAxLjk3MS0zLjI0MnMxLjg0NC0xLjU4OSAyLjk4OC0yLjA5OCAyLjM1Mi0uNzYzIDMuNjg3LS43NjNjMS41MjYgMCAyLjc5Ny4yNTUgMy44NzguODI3czEuOTcxIDEuMzM1IDIuNjcgMi40MTZWNy4xOTNoNC45NTl6bS0xMC40MjYgMjQuNTM4YzEuNjUzIDAgMi45MjQtLjU3MiAzLjk0MS0xLjY1M3MxLjUyNi0yLjU0MyAxLjUyNi00LjMyMy0uNTA5LTMuMTc4LTEuNTI2LTQuMzIyYy0xLjAxNy0xLjA4MS0yLjI4OC0xLjY1My0zLjk0MS0xLjY1My0xLjU5IDAtMi45MjUuNTcyLTMuODc4IDEuNjUzLTEuMDE3IDEuMDgtMS41MjYgMi41NDMtMS41MjYgNC4zMjIgMCAxLjc4LjUwOSAzLjE4IDEuNTI2IDQuMjYgMS4wMTcgMS4xNDQgMi4yODggMS43MTYgMy44NzggMS43MTZNNTcuMjAyIDIwLjM1M0g0NC45MzN2NC4yNTloNi45OTNjLS4xOSAyLjE2MS0xLjAxNyAzLjgxNC0yLjQxNiA1LjE1LTEuMzk4IDEuMjctMy4xNzggMS45MDYtNS40NjcgMS45MDYtMS4yNzEgMC0yLjQ4LS4yNTQtMy40OTYtLjY5OWE3IDcgMCAwIDEtMi43MzQtMS45N2MtLjc2My0uODI3LTEuMzM1LTEuODQ0LTEuNzgtMy4wNTJzLS42MzYtMi40OC0uNjM2LTMuOTQyLjE5LTIuNzMzLjYzNi0zLjk0MWMuMzgxLTEuMjA4IDEuMDE3LTIuMTYyIDEuNzgtMy4wNTIuNzYzLS44MjYgMS42NTMtMS40NjIgMi43MzMtMS45N2E5LjEgOS4xIDAgMCAxIDMuNTYtLjdxNC4wMDUgMCA2LjEwMyAxLjkwN2wzLjMwNi0zLjMwNWMtMi40OC0xLjkwNy01LjY1OC0yLjkyNS05LjQwOS0yLjkyNS0yLjA5NyAwLTQuMDA0LjMxOC01LjcyMSAxLjAxOC0xLjcxNi42OTktMy4xNzkgMS41ODktNC4zODYgMi43OTdBMTIuMSAxMi4xIDAgMCAwIDMxLjIgMTYuMjJjLS42MzUgMS43MTctLjk1MyAzLjYyNC0uOTUzIDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1NyAxLjAxNyAyLjAzNSAwIDMuODc4LS4zMTggNS41MzEtMS4wMTcgMS42NTMtLjcgMy4wNTItMS41OSA0LjE5Ni0yLjc5N3ExLjcxNi0xLjgxMiAyLjY3LTQuMzg3Yy42MzYtMS43MTYuOTU0LTMuNjIzLjk1NC01LjY1OHYtLjgyNmMtLjE5MS0uMTI3LS4yNTUtLjQ0NS0uMjU1LS43TTk1Ljk4MiAyMC4zNTNoLTEyLjI3djQuMjU5aDYuOTkzYy0uMTkgMi4xNjEtMS4wMTcgMy44MTQtMi40MTYgNS4xNS0xLjM5OCAxLjI3LTMuMTc4IDEuOTA2LTUuNDY3IDEuOTA2LTEuMjcxIDAtMi40OC0uMjU0LTMuNDk2LS42OTlhNyA3IDAgMCAxLTIuNzM0LTEuOTdjLS43NjMtLjgyNy0xLjMzNS0xLjg0NC0xLjc4LTMuMDUycy0uNjM2LTIuNDgtLjYzNi0zLjk0Mi4xOS0yLjczMy42MzYtMy45NDFjLjM4MS0xLjIwOCAxLjAxNy0yLjE2MiAxLjc4LTMuMDUyLjc2My0uODI2IDEuNjUzLTEuNDYyIDIuNzM0LTEuOTdhOS4xIDkuMSAwIDAgMSAzLjU2LS43cTQuMDA1IDAgNi4xMDMgMS45MDdsMy4zMDUtMy4zMDVjLTIuNDc5LTEuOTA3LTUuNjU4LTIuOTI1LTkuNDA4LTIuOTI1LTIuMDk4IDAtNC4wMDUuMzE4LTUuNzIyIDEuMDE4LTEuNzE2LjY5OS0zLjE3OCAxLjU4OS00LjM4NiAyLjc5N2ExMi4xIDEyLjEgMCAwIDAtMi43OTcgNC4zODZjLS42MzYgMS43MTctLjk1NCAzLjYyNC0uOTU0IDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1OCAxLjAxNyAyLjAzNCAwIDMuODc4LS4zMTggNS41My0xLjAxNyAxLjY1My0uNyAzLjA1Mi0xLjU5IDQuMTk2LTIuNzk3cTEuNzE4LTEuODEyIDIuNjctNC4zODdjLjYzNi0xLjcxNi45NTQtMy42MjMuOTU0LTUuNjU4di0uODI2Yy0uMTktLjEyNy0uMjU1LS40NDUtLjI1NS0uNyIvPjwvc3ZnPg==");background-repeat:no-repeat;background-size:170px 40px;content:"";display:block;height:40px;width:170px}}:where(.ag-ltr) .ag-watermark{right:25px}:where(.ag-rtl) .ag-watermark{left:25px}.ag-watermark-text{font-family:Impact,sans-serif;font-size:19px;font-weight:700;opacity:.5}:where(.ag-ltr) .ag-watermark-text{padding-left:.7rem}:where(.ag-rtl) .ag-watermark-text{padding-right:.7rem}`;


/***/ }),

/***/ 3879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgWatermarkSelector = exports.AgWatermark = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const watermark_css_GENERATED_1 = __webpack_require__(454);
class AgWatermark extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.licenseManager = beans.licenseManager;
    }
    constructor() {
        super(
        /* html*/
        `<div class="ag-watermark">
                <div data-ref="eLicenseTextRef" class="ag-watermark-text"></div>
            </div>`);
        this.eLicenseTextRef = ag_grid_community_1.RefPlaceholder;
        this.registerCSS(watermark_css_GENERATED_1.watermarkCSS);
    }
    postConstruct() {
        const show = this.shouldDisplayWatermark();
        this.setDisplayed(show);
        if (show) {
            this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage();
            window.setTimeout(() => this.addCssClass('ag-opacity-zero'), 0);
            window.setTimeout(() => this.setDisplayed(false), 5000);
        }
    }
    shouldDisplayWatermark() {
        return this.licenseManager.isDisplayWatermark();
    }
}
exports.AgWatermark = AgWatermark;
exports.AgWatermarkSelector = {
    selector: 'AG-WATERMARK',
    component: AgWatermark,
};


/***/ }),

/***/ 4769:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGrid = void 0;
const tslib_1 = __webpack_require__(5608);
/*
 * Used for umd bundles without styles
 */
const ag_grid_community_1 = __webpack_require__(6624);
const main_1 = __webpack_require__(12);
ag_grid_community_1.ModuleRegistry.registerModules([main_1.AllEnterpriseModule]);
tslib_1.__exportStar(__webpack_require__(6624), exports);
tslib_1.__exportStar(__webpack_require__(12), exports);
// Export the overridden createGrid function which automatically registers AG Charts modules if present
var main_umd_shared_1 = __webpack_require__(6825);
Object.defineProperty(exports, "createGrid", ({ enumerable: true, get: function () { return main_umd_shared_1.createGrid; } }));


/***/ }),

/***/ 6825:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGrid = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const ag_grid_community_2 = __webpack_require__(6624);
const main_1 = __webpack_require__(12);
function autoRegisterAgCharts() {
    const agChartsDynamic = globalThis?.agCharts;
    const agChartsModule = agChartsDynamic?.AgChartsEnterpriseModule ?? agChartsDynamic?.AgChartsCommunityModule;
    if (agChartsModule) {
        ag_grid_community_1.ModuleRegistry.registerModules([
            main_1.IntegratedChartsModule.with(agChartsModule),
            main_1.SparklinesModule.with(agChartsModule),
        ]);
    }
}
/**
 * Creates a grid inside the provided HTML element.
 * @param eGridDiv Parent element to contain the grid.
 * @param gridOptions Configuration for the grid.
 * @param params Individually register AG Grid Modules to this grid.
 * @returns api to be used to interact with the grid.
 */
function createGrid(eGridDiv, gridOptions, params) {
    // Look for the AG Charts modules and register them if present
    autoRegisterAgCharts();
    // Call the original createGrid function
    return (0, ag_grid_community_2.createGrid)(eGridDiv, gridOptions, params);
}
exports.createGrid = createGrid;


/***/ }),

/***/ 12:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllEnterpriseModule = exports.IntegratedChartsModule = exports.GridChartsModule = exports.PivotModule = exports.AggregationModule = exports.TreeDataModule = exports.SparklinesModule = exports.ServerSideRowModelApiModule = exports.ServerSideRowModelModule = exports.RangeSelectionModule = exports.CellSelectionModule = exports.MasterDetailModule = exports.FiltersToolPanelModule = exports.ClipboardModule = exports.ViewportRowModelModule = exports.SideBarModule = exports.RowGroupingModule = exports.RowGroupingPanelModule = exports.GroupFilterModule = exports.MultiFilterModule = exports.ExcelExportModule = exports.StatusBarModule = exports.SetFilterModule = exports.RichSelectModule = exports.ContextMenuModule = exports.ColumnMenuModule = exports.MenuModule = exports.ColumnsToolPanelModule = exports.AdvancedFilterModule = exports.exportMultipleSheetsAsExcel = exports.getMultipleSheetsAsExcel = exports.LicenseManager = void 0;
const tslib_1 = __webpack_require__(5608);
var gridLicenseManager_1 = __webpack_require__(3159);
Object.defineProperty(exports, "LicenseManager", ({ enumerable: true, get: function () { return gridLicenseManager_1.GridLicenseManager; } }));
var excelCreator_1 = __webpack_require__(1790);
Object.defineProperty(exports, "getMultipleSheetsAsExcel", ({ enumerable: true, get: function () { return excelCreator_1.getMultipleSheetsAsExcel; } }));
Object.defineProperty(exports, "exportMultipleSheetsAsExcel", ({ enumerable: true, get: function () { return excelCreator_1.exportMultipleSheetsAsExcel; } }));
var advancedFilterModule_1 = __webpack_require__(7976);
Object.defineProperty(exports, "AdvancedFilterModule", ({ enumerable: true, get: function () { return advancedFilterModule_1.AdvancedFilterModule; } }));
var columnsToolPanelModule_1 = __webpack_require__(6455);
Object.defineProperty(exports, "ColumnsToolPanelModule", ({ enumerable: true, get: function () { return columnsToolPanelModule_1.ColumnsToolPanelModule; } }));
var menuModule_1 = __webpack_require__(7130);
Object.defineProperty(exports, "MenuModule", ({ enumerable: true, get: function () { return menuModule_1.MenuModule; } }));
Object.defineProperty(exports, "ColumnMenuModule", ({ enumerable: true, get: function () { return menuModule_1.ColumnMenuModule; } }));
Object.defineProperty(exports, "ContextMenuModule", ({ enumerable: true, get: function () { return menuModule_1.ContextMenuModule; } }));
var richSelectModule_1 = __webpack_require__(9327);
Object.defineProperty(exports, "RichSelectModule", ({ enumerable: true, get: function () { return richSelectModule_1.RichSelectModule; } }));
var setFilterModule_1 = __webpack_require__(9002);
Object.defineProperty(exports, "SetFilterModule", ({ enumerable: true, get: function () { return setFilterModule_1.SetFilterModule; } }));
var statusBarModule_1 = __webpack_require__(8450);
Object.defineProperty(exports, "StatusBarModule", ({ enumerable: true, get: function () { return statusBarModule_1.StatusBarModule; } }));
var excelExportModule_1 = __webpack_require__(2886);
Object.defineProperty(exports, "ExcelExportModule", ({ enumerable: true, get: function () { return excelExportModule_1.ExcelExportModule; } }));
var multiFilterModule_1 = __webpack_require__(5434);
Object.defineProperty(exports, "MultiFilterModule", ({ enumerable: true, get: function () { return multiFilterModule_1.MultiFilterModule; } }));
var rowGroupingModule_1 = __webpack_require__(1442);
Object.defineProperty(exports, "GroupFilterModule", ({ enumerable: true, get: function () { return rowGroupingModule_1.GroupFilterModule; } }));
Object.defineProperty(exports, "RowGroupingPanelModule", ({ enumerable: true, get: function () { return rowGroupingModule_1.RowGroupingPanelModule; } }));
Object.defineProperty(exports, "RowGroupingModule", ({ enumerable: true, get: function () { return rowGroupingModule_1.RowGroupingModule; } }));
var sideBarModule_1 = __webpack_require__(6358);
Object.defineProperty(exports, "SideBarModule", ({ enumerable: true, get: function () { return sideBarModule_1.SideBarModule; } }));
var viewportRowModelModule_1 = __webpack_require__(7794);
Object.defineProperty(exports, "ViewportRowModelModule", ({ enumerable: true, get: function () { return viewportRowModelModule_1.ViewportRowModelModule; } }));
var clipboardModule_1 = __webpack_require__(3766);
Object.defineProperty(exports, "ClipboardModule", ({ enumerable: true, get: function () { return clipboardModule_1.ClipboardModule; } }));
var filtersToolPanelModule_1 = __webpack_require__(2515);
Object.defineProperty(exports, "FiltersToolPanelModule", ({ enumerable: true, get: function () { return filtersToolPanelModule_1.FiltersToolPanelModule; } }));
var masterDetailModule_1 = __webpack_require__(1594);
Object.defineProperty(exports, "MasterDetailModule", ({ enumerable: true, get: function () { return masterDetailModule_1.MasterDetailModule; } }));
var rangeSelectionModule_1 = __webpack_require__(266);
Object.defineProperty(exports, "CellSelectionModule", ({ enumerable: true, get: function () { return rangeSelectionModule_1.CellSelectionModule; } }));
Object.defineProperty(exports, "RangeSelectionModule", ({ enumerable: true, get: function () { return rangeSelectionModule_1.RangeSelectionModule; } }));
var serverSideRowModelModule_1 = __webpack_require__(9074);
Object.defineProperty(exports, "ServerSideRowModelModule", ({ enumerable: true, get: function () { return serverSideRowModelModule_1.ServerSideRowModelModule; } }));
Object.defineProperty(exports, "ServerSideRowModelApiModule", ({ enumerable: true, get: function () { return serverSideRowModelModule_1.ServerSideRowModelApiModule; } }));
var sparklinesModule_1 = __webpack_require__(2949);
Object.defineProperty(exports, "SparklinesModule", ({ enumerable: true, get: function () { return sparklinesModule_1.SparklinesModule; } }));
var treeDataModule_1 = __webpack_require__(9428);
Object.defineProperty(exports, "TreeDataModule", ({ enumerable: true, get: function () { return treeDataModule_1.TreeDataModule; } }));
var aggregationModule_1 = __webpack_require__(7032);
Object.defineProperty(exports, "AggregationModule", ({ enumerable: true, get: function () { return aggregationModule_1.AggregationModule; } }));
var pivotModule_1 = __webpack_require__(5470);
Object.defineProperty(exports, "PivotModule", ({ enumerable: true, get: function () { return pivotModule_1.PivotModule; } }));
var integratedChartsModule_1 = __webpack_require__(1527);
Object.defineProperty(exports, "GridChartsModule", ({ enumerable: true, get: function () { return integratedChartsModule_1.GridChartsModule; } }));
Object.defineProperty(exports, "IntegratedChartsModule", ({ enumerable: true, get: function () { return integratedChartsModule_1.IntegratedChartsModule; } }));
var allEnterpriseModule_1 = __webpack_require__(1809);
Object.defineProperty(exports, "AllEnterpriseModule", ({ enumerable: true, get: function () { return allEnterpriseModule_1.AllEnterpriseModule; } }));
tslib_1.__exportStar(__webpack_require__(6624), exports);


/***/ }),

/***/ 3763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetailCellRenderer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const detailCellRendererCtrl_1 = __webpack_require__(3210);
const detailFrameworkComponentWrapper_1 = __webpack_require__(7324);
class DetailCellRenderer extends ag_grid_community_1.Component {
    constructor() {
        super(...arguments);
        this.eDetailGrid = ag_grid_community_1.RefPlaceholder;
    }
    wireBeans(beans) {
        this.context = beans.context;
    }
    init(params) {
        this.params = params;
        this.selectAndSetTemplate();
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
            addOrRemoveDetailGridCssClass: (cssClassName, on) => this.eDetailGrid.classList.toggle(cssClassName, on),
            setDetailGrid: (gridOptions) => this.setDetailGrid(gridOptions),
            setRowData: (rowData) => this.setRowData(rowData),
            getGui: () => this.eDetailGrid,
        };
        this.ctrl = this.createManagedBean(new detailCellRendererCtrl_1.DetailCellRendererCtrl());
        this.ctrl.init(compProxy, params);
    }
    refresh() {
        return this.ctrl && this.ctrl.refresh();
    }
    selectAndSetTemplate() {
        const params = this.params;
        if (params.pinned) {
            this.setTemplate(/* html*/ `<div class="ag-details-row"></div>`);
            return;
        }
        const setDefaultTemplate = () => {
            this.setTemplate(/* html */ `<div class="ag-details-row" role="gridcell">
                <div data-ref="eDetailGrid" class="ag-details-grid" role="presentation"></div>
            </div>`);
        };
        if ((0, ag_grid_community_1._missing)(params.template)) {
            // use default template
            setDefaultTemplate();
        }
        else {
            // use user provided template
            if (typeof params.template === 'string') {
                this.setTemplate(params.template, []);
            }
            else if (typeof params.template === 'function') {
                const templateFunc = params.template;
                const template = templateFunc(params);
                this.setTemplate(template, []);
            }
            else {
                (0, ag_grid_community_1._warn)(168);
                setDefaultTemplate();
            }
        }
        if (this.eDetailGrid == null) {
            (0, ag_grid_community_1._warn)(169);
        }
    }
    setDetailGrid(gridOptions) {
        if (!this.eDetailGrid) {
            return;
        }
        // when we create detail grid, the detail grid needs frameworkCompWrapper so that
        // it created child components correctly, ie  Angular detail grid can have Angular cell renderer.
        // this is only used by Angular and Vue, as React uses native React AG Grid detail grids
        const parentFrameworkComponentWrapper = this.context.getBean('frameworkCompWrapper');
        const frameworkCompWrapper = new detailFrameworkComponentWrapper_1.DetailFrameworkComponentWrapper(parentFrameworkComponentWrapper);
        const { frameworkOverrides } = this.beans;
        const api = (0, ag_grid_community_1.createGrid)(this.eDetailGrid, gridOptions, {
            frameworkOverrides,
            providedBeanInstances: {
                frameworkCompWrapper: frameworkCompWrapper,
            },
            modules: (0, ag_grid_community_1._getGridRegisteredModules)(this.params.api.getGridId(), gridOptions.rowModelType ?? 'clientSide'),
        });
        this.detailApi = api;
        this.ctrl.registerDetailWithMaster(api);
        this.addDestroyFunc(() => {
            api?.destroy();
        });
    }
    setRowData(rowData) {
        // ensure detail grid api still exists (grid may be destroyed when async call tries to set data)
        this.detailApi?.setGridOption('rowData', rowData);
    }
}
exports.DetailCellRenderer = DetailCellRenderer;


/***/ }),

/***/ 3210:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetailCellRendererCtrl = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class DetailCellRendererCtrl extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.loadRowDataVersion = 0;
    }
    init(comp, params) {
        this.params = params;
        this.comp = comp;
        const doNothingBecauseInsidePinnedSection = params.pinned != null;
        if (doNothingBecauseInsidePinnedSection) {
            return;
        }
        this.setAutoHeightClasses();
        this.setupRefreshStrategy();
        this.createDetailGrid();
        this.loadRowData();
        this.addManagedEventListeners({ fullWidthRowFocused: this.onFullWidthRowFocused.bind(this) });
    }
    onFullWidthRowFocused(e) {
        const params = this.params;
        const row = { rowIndex: params.node.rowIndex, rowPinned: params.node.rowPinned };
        const eventRow = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
        const isSameRow = (0, ag_grid_community_1._isSameRow)(row, eventRow);
        if (!isSameRow) {
            return;
        }
        (0, ag_grid_community_1._focusInto)(this.comp.getGui(), e.fromBelow);
    }
    setAutoHeightClasses() {
        const autoHeight = this.gos.get('detailRowAutoHeight');
        const parentClass = autoHeight ? 'ag-details-row-auto-height' : 'ag-details-row-fixed-height';
        const detailClass = autoHeight ? 'ag-details-grid-auto-height' : 'ag-details-grid-fixed-height';
        const comp = this.comp;
        comp.addOrRemoveCssClass(parentClass, true);
        comp.addOrRemoveDetailGridCssClass(detailClass, true);
    }
    setupRefreshStrategy() {
        const providedStrategy = this.params.refreshStrategy;
        const validSelection = providedStrategy == 'everything' || providedStrategy == 'nothing' || providedStrategy == 'rows';
        if (validSelection) {
            this.refreshStrategy = providedStrategy;
            return;
        }
        if (providedStrategy != null) {
            (0, ag_grid_community_1._warn)(170, { providedStrategy });
        }
        this.refreshStrategy = 'rows';
    }
    createDetailGrid() {
        const { params, gos } = this;
        if ((0, ag_grid_community_1._missing)(params.detailGridOptions)) {
            (0, ag_grid_community_1._warn)(171);
            return;
        }
        // we clone the detail grid options, as otherwise it would be shared
        // across many instances, and that would be a problem because we set
        // api into gridOptions
        const gridOptions = { ...params.detailGridOptions };
        const autoHeight = gos.get('detailRowAutoHeight');
        if (autoHeight) {
            gridOptions.domLayout = 'autoHeight';
        }
        gridOptions.theme || (gridOptions.theme = gos.get('theme'));
        this.comp.setDetailGrid(gridOptions);
    }
    registerDetailWithMaster(api) {
        const params = this.params;
        const rowId = params.node.id;
        const masterGridApi = params.api;
        const gridInfo = {
            id: rowId,
            api: api,
        };
        const rowNode = params.node;
        // register with api if the master api is still alive
        if (masterGridApi.isDestroyed()) {
            return;
        }
        masterGridApi.addDetailGridInfo(rowId, gridInfo);
        // register with node
        rowNode.detailGridInfo = gridInfo;
        this.addDestroyFunc(() => {
            // the gridInfo can be stale if a refresh happens and
            // a new row is created before the old one is destroyed.
            if (rowNode.detailGridInfo !== gridInfo) {
                return;
            }
            if (!masterGridApi.isDestroyed()) {
                masterGridApi.removeDetailGridInfo(rowId); // unregister from api
            }
            rowNode.detailGridInfo = null; // unregister from node
        });
    }
    loadRowData() {
        // in case a refresh happens before the last refresh completes (as we depend on async
        // application logic) we keep track on what the latest call was.
        this.loadRowDataVersion++;
        const versionThisCall = this.loadRowDataVersion;
        const params = this.params;
        if (params.detailGridOptions?.rowModelType === 'serverSide') {
            const node = params.node;
            node.detailGridInfo?.api?.refreshServerSide({ purge: true });
            return;
        }
        const userFunc = params.getDetailRowData;
        if (!userFunc) {
            (0, ag_grid_community_1._warn)(172);
            return;
        }
        const successCallback = (rowData) => {
            const mostRecentCall = this.loadRowDataVersion === versionThisCall;
            if (mostRecentCall) {
                this.comp.setRowData(rowData);
            }
        };
        const funcParams = {
            node: params.node,
            // we take data from node, rather than params.data
            // as the data could have been updated with new instance
            data: params.node.data,
            successCallback: successCallback,
            context: this.gos.getGridCommonParams().context,
        };
        userFunc(funcParams);
    }
    refresh() {
        const GET_GRID_TO_REFRESH = false;
        const GET_GRID_TO_DO_NOTHING = true;
        switch (this.refreshStrategy) {
            // ignore this refresh, make grid think we've refreshed but do nothing
            case 'nothing':
                return GET_GRID_TO_DO_NOTHING;
            // grid will destroy and recreate the cell
            case 'everything':
                return GET_GRID_TO_REFRESH;
        }
        // do the refresh here, and tell the grid to do nothing
        this.loadRowData();
        return GET_GRID_TO_DO_NOTHING;
    }
}
exports.DetailCellRendererCtrl = DetailCellRendererCtrl;


/***/ }),

/***/ 7324:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetailFrameworkComponentWrapper = void 0;
// this wrapper is to prevent detail grids from destroying the parent wrappers
class DetailFrameworkComponentWrapper {
    constructor(parentWrapper) {
        this.parentWrapper = parentWrapper;
    }
    wrap(frameworkComponent, mandatoryMethods, optionalMethods, componentType) {
        return this.parentWrapper.wrap(frameworkComponent, mandatoryMethods, optionalMethods, componentType);
    }
}
exports.DetailFrameworkComponentWrapper = DetailFrameworkComponentWrapper;


/***/ }),

/***/ 4276:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEachDetailGridInfo = exports.getDetailGridInfo = exports.removeDetailGridInfo = exports.addDetailGridInfo = void 0;
function operateOnStore(beans, callback) {
    const store = beans.masterDetailSvc?.store;
    return store ? callback(store) : undefined;
}
function addDetailGridInfo(beans, id, gridInfo) {
    operateOnStore(beans, (store) => {
        store[id] = gridInfo;
    });
}
exports.addDetailGridInfo = addDetailGridInfo;
function removeDetailGridInfo(beans, id) {
    operateOnStore(beans, (store) => {
        delete store[id];
    });
}
exports.removeDetailGridInfo = removeDetailGridInfo;
function getDetailGridInfo(beans, id) {
    return operateOnStore(beans, (store) => store[id]);
}
exports.getDetailGridInfo = getDetailGridInfo;
function forEachDetailGridInfo(beans, callback) {
    operateOnStore(beans, (store) => {
        let index = 0;
        Object.values(store).forEach((gridInfo) => {
            // check for undefined, as old references will still be lying around
            if (gridInfo) {
                callback(gridInfo, index++);
            }
        });
    });
}
exports.forEachDetailGridInfo = forEachDetailGridInfo;


/***/ }),

/***/ 2283:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.masterDetailModuleCSS = void 0;
exports.masterDetailModuleCSS = `.ag-details-row{width:100%}.ag-details-row-fixed-height{height:100%}.ag-details-grid{width:100%}.ag-details-grid-fixed-height{height:100%}`;


/***/ }),

/***/ 1594:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MasterDetailModule = exports.SharedMasterDetailModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const rowHierarchyModule_1 = __webpack_require__(6858);
const version_1 = __webpack_require__(7205);
const detailCellRenderer_1 = __webpack_require__(3763);
const detailCellRendererCtrl_1 = __webpack_require__(3210);
const masterDetailApi_1 = __webpack_require__(4276);
const masterDetailModule_css_GENERATED_1 = __webpack_require__(2283);
const masterDetailService_1 = __webpack_require__(2771);
/**
 * @internal
 */
exports.SharedMasterDetailModule = {
    moduleName: 'SharedMasterDetail',
    version: version_1.VERSION,
    beans: [masterDetailService_1.MasterDetailService],
    userComponents: { agDetailCellRenderer: detailCellRenderer_1.DetailCellRenderer },
    dynamicBeans: { detailCellRendererCtrl: detailCellRendererCtrl_1.DetailCellRendererCtrl },
    apiFunctions: {
        addDetailGridInfo: masterDetailApi_1.addDetailGridInfo,
        removeDetailGridInfo: masterDetailApi_1.removeDetailGridInfo,
        getDetailGridInfo: masterDetailApi_1.getDetailGridInfo,
        forEachDetailGridInfo: masterDetailApi_1.forEachDetailGridInfo,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, rowHierarchyModule_1.GroupCellRendererModule, rowHierarchyModule_1.StickyRowModule],
    css: [masterDetailModule_css_GENERATED_1.masterDetailModuleCSS],
};
/**
 * @feature Master Detail
 * @gridOption masterDetail
 */
exports.MasterDetailModule = {
    moduleName: 'MasterDetail',
    version: version_1.VERSION,
    dependsOn: [exports.SharedMasterDetailModule, rowHierarchyModule_1.ClientSideRowModelHierarchyModule],
};


/***/ }),

/***/ 2771:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MasterDetailService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class MasterDetailService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'masterDetailSvc';
        this.store = {};
    }
    isEnabled() {
        const gos = this.gos;
        return (gos.get('masterDetail') &&
            // TODO: AG-1752: [Tree Data] Allow tree data leaf rows to serve as master rows for detail grids (Tree Data hosting Master/Detail)"
            !gos.get('treeData'));
    }
    postConstruct() {
        if ((0, ag_grid_community_1._isClientSideRowModel)(this.gos)) {
            this.enabled = this.isEnabled();
            this.addManagedEventListeners({ beforeRefreshModel: this.beforeRefreshModel.bind(this) });
        }
    }
    beforeRefreshModel({ params }) {
        if (params.changedProps) {
            const enabled = this.isEnabled();
            if (this.enabled !== enabled) {
                this.setMasters(null);
                return;
            }
        }
        if (params.rowDataUpdated) {
            this.setMasters(params.changedRowNodes);
        }
    }
    setMasters(changedRowNodes) {
        const enabled = this.isEnabled();
        this.enabled = enabled;
        const gos = this.gos;
        const isRowMaster = gos.get('isRowMaster');
        const groupDefaultExpanded = gos.get('groupDefaultExpanded');
        const setMaster = (row, created, updated) => {
            const oldMaster = row.master;
            let newMaster = enabled;
            if (enabled) {
                if (created || updated) {
                    if (isRowMaster) {
                        const data = row.data;
                        newMaster = !!data && !!isRowMaster(data);
                    }
                }
                else {
                    newMaster = oldMaster;
                }
            }
            if (newMaster && created) {
                // TODO: AG-11476 isGroupOpenByDefault callback doesn't apply to master/detail grid
                if (groupDefaultExpanded === -1) {
                    row.expanded = true;
                }
                else {
                    // need to take row group into account when determining level
                    const masterRowLevel = this.beans.rowGroupColsSvc?.columns.length ?? 0;
                    row.expanded = masterRowLevel < groupDefaultExpanded;
                }
            }
            else if (!newMaster && oldMaster) {
                row.expanded = false; // if changing AWAY from master, then un-expand, otherwise next time it's shown it is expanded again
            }
            if (newMaster !== oldMaster) {
                row.master = newMaster;
                row.dispatchRowEvent('masterChanged');
            }
        };
        if (changedRowNodes) {
            const updates = changedRowNodes.updates;
            for (const node of updates.keys()) {
                const created = updates.get(node);
                setMaster(node, created, !created);
            }
        }
        else {
            const allLeafChildren = (0, ag_grid_community_1._getClientSideRowModel)(this.beans)?.rootNode?.allLeafChildren;
            if (allLeafChildren) {
                for (let i = 0, len = allLeafChildren.length; i < len; ++i) {
                    setMaster(allLeafChildren[i], true, false);
                }
            }
        }
    }
    /** Used by flatten stage to get or create a detail node from a master node */
    getDetail(masterNode) {
        if (!masterNode.master || !masterNode.expanded) {
            return null;
        }
        let detailNode = masterNode.detailNode;
        if (detailNode) {
            return detailNode;
        }
        detailNode = new ag_grid_community_1.RowNode(this.beans);
        detailNode.detail = true;
        detailNode.selectable = false;
        detailNode.parent = masterNode;
        if ((0, ag_grid_community_1._exists)(masterNode.id)) {
            detailNode.id = 'detail_' + masterNode.id;
        }
        detailNode.data = masterNode.data;
        detailNode.level = masterNode.level + 1;
        masterNode.detailNode = detailNode;
        return detailNode;
    }
    setupDetailRowAutoHeight(rowCtrl, eDetailGui) {
        const { gos, beans } = this;
        if (!gos.get('detailRowAutoHeight')) {
            return;
        }
        const checkRowSizeFunc = () => {
            const clientHeight = eDetailGui.clientHeight;
            // if the UI is not ready, the height can be 0, which we ignore, as otherwise a flicker will occur
            // as UI goes from the default height, to 0, then to the real height as UI becomes ready. this means
            // it's not possible for have 0 as auto-height, however this is an improbable use case, as even an
            // empty detail grid would still have some styling around it giving at least a few pixels.
            if (clientHeight != null && clientHeight > 0) {
                // we do the update in a timeout, to make sure we are not calling from inside the grid
                // doing another update
                const updateRowHeightFunc = () => {
                    const { rowModel } = this.beans;
                    const { rowNode } = rowCtrl;
                    rowNode.setRowHeight(clientHeight);
                    if ((0, ag_grid_community_1._isClientSideRowModel)(gos, rowModel) || (0, ag_grid_community_1._isServerSideRowModel)(gos, rowModel)) {
                        rowModel.onRowHeightChanged();
                    }
                };
                window.setTimeout(updateRowHeightFunc, 0);
            }
        };
        const resizeObserverDestroyFunc = (0, ag_grid_community_1._observeResize)(beans, eDetailGui, checkRowSizeFunc);
        rowCtrl.addDestroyFunc(resizeObserverDestroyFunc);
        checkRowSizeFunc();
    }
    destroy() {
        this.store = {};
        super.destroy();
    }
}
exports.MasterDetailService = MasterDetailService;


/***/ }),

/***/ 5636:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChartMenuItemMapper = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ChartMenuItemMapper extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'chartMenuItemMapper';
    }
    getChartItems(key) {
        const beans = this.beans;
        const chartSvc = beans.chartSvc;
        const isPivot = key === 'pivotChart';
        if (!chartSvc) {
            return null;
        }
        const getLocaleTextFunc = this.getLocaleTextFunc.bind(this);
        const builder = isPivot
            ? new PivotMenuItemMapper(beans, chartSvc, getLocaleTextFunc)
            : new RangeMenuItemMapper(beans, chartSvc, getLocaleTextFunc);
        const isEnterprise = chartSvc.isEnterprise();
        let topLevelMenuItem = builder.getMenuItem();
        if (topLevelMenuItem && topLevelMenuItem.subMenu && !isEnterprise) {
            // Filter out enterprise-only menu items if 'Community Integrated'
            const filterEnterpriseItems = (m) => ({
                ...m,
                subMenu: m.subMenu?.filter((menu) => !menu._enterprise).map((menu) => filterEnterpriseItems(menu)),
            });
            topLevelMenuItem = filterEnterpriseItems(topLevelMenuItem);
        }
        const chartGroupsDef = this.gos.get('chartToolPanelsDef')?.settingsPanel?.chartGroupsDef;
        if (chartGroupsDef) {
            topLevelMenuItem = this.filterAndOrderChartMenu(topLevelMenuItem, chartGroupsDef, builder.getConfigLookup());
        }
        return this.cleanInternals(topLevelMenuItem);
    }
    // Remove our internal _key and _enterprise properties so this does not leak out of the class on the menu items.
    cleanInternals(menuItem) {
        if (!menuItem) {
            return menuItem;
        }
        const removeKeys = (m) => {
            delete m?._key;
            delete m?._enterprise;
            m?.subMenu?.forEach((s) => removeKeys(s));
            return m;
        };
        return removeKeys(menuItem);
    }
    buildLookup(menuItem) {
        const itemLookup = {};
        const addItem = (item) => {
            itemLookup[item._key] = item;
            if (item.subMenu) {
                item.subMenu.forEach((s) => addItem(s));
            }
        };
        addItem(menuItem);
        return itemLookup;
    }
    /**
     * Make the MenuItem match the charts provided and their ordering on the ChartGroupsDef config object as provided by the user.
     */
    filterAndOrderChartMenu(topLevelMenuItem, chartGroupsDef, configLookup) {
        const menuItemLookup = this.buildLookup(topLevelMenuItem);
        const orderedAndFiltered = { ...topLevelMenuItem, subMenu: [] };
        Object.entries(chartGroupsDef).forEach(([group, chartTypes]) => {
            const chartConfigGroup = configLookup[group];
            // Skip any context panels that are not enabled for the current chart type
            if (chartConfigGroup === null)
                return;
            if (chartConfigGroup == undefined) {
                (0, ag_grid_community_1._warn)(173, { group });
                return;
            }
            const menuItem = menuItemLookup[chartConfigGroup._key];
            if (menuItem) {
                if (menuItem.subMenu) {
                    const subMenus = chartTypes
                        .map((chartType) => {
                        const itemKey = chartConfigGroup[chartType];
                        if (itemKey == undefined) {
                            (0, ag_grid_community_1._warn)(174, { group, chartType });
                            return undefined;
                        }
                        return menuItemLookup[itemKey];
                    })
                        .filter((s) => s !== undefined);
                    if (subMenus.length > 0) {
                        menuItem.subMenu = subMenus;
                        orderedAndFiltered.subMenu?.push(menuItem);
                    }
                }
                else {
                    // Handles line case which is not actually a sub subMenu
                    orderedAndFiltered.subMenu?.push(menuItem);
                }
            }
        });
        if (orderedAndFiltered.subMenu?.length == 0) {
            return null;
        }
        return orderedAndFiltered;
    }
}
exports.ChartMenuItemMapper = ChartMenuItemMapper;
class PivotMenuItemMapper {
    constructor(beans, chartSvc, getLocaleTextFunc) {
        this.beans = beans;
        this.chartSvc = chartSvc;
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getMenuItem() {
        const localeTextFunc = this.getLocaleTextFunc();
        const getMenuItem = (localeKey, defaultText, chartType, key, enterprise = false) => {
            return {
                name: localeTextFunc(localeKey, defaultText),
                action: () => this.chartSvc.createPivotChart({ chartType }),
                _key: key,
                _enterprise: enterprise,
            };
        };
        return {
            name: localeTextFunc('pivotChart', 'Pivot Chart'),
            _key: 'pivotChart',
            subMenu: [
                {
                    _key: 'pivotColumnChart',
                    name: localeTextFunc('columnChart', 'Column'),
                    subMenu: [
                        getMenuItem('groupedColumn', 'Grouped&lrm;', 'groupedColumn', 'pivotGroupedColumn'),
                        getMenuItem('stackedColumn', 'Stacked&lrm;', 'stackedColumn', 'pivotStackedColumn'),
                        getMenuItem('normalizedColumn', '100% Stacked&lrm;', 'normalizedColumn', 'pivotNormalizedColumn'),
                    ],
                },
                {
                    _key: 'pivotBarChart',
                    name: localeTextFunc('barChart', 'Bar'),
                    subMenu: [
                        getMenuItem('groupedBar', 'Grouped&lrm;', 'groupedBar', 'pivotGroupedBar'),
                        getMenuItem('stackedBar', 'Stacked&lrm;', 'stackedBar', 'pivotStackedBar'),
                        getMenuItem('normalizedBar', '100% Stacked&lrm;', 'normalizedBar', 'pivotNormalizedBar'),
                    ],
                },
                {
                    _key: 'pivotPieChart',
                    name: localeTextFunc('pieChart', 'Pie'),
                    subMenu: [
                        getMenuItem('pie', 'Pie&lrm;', 'pie', 'pivotPie'),
                        getMenuItem('donut', 'Donut&lrm;', 'donut', 'pivotDonut'),
                    ],
                },
                {
                    _key: 'pivotLineChart',
                    name: localeTextFunc('lineChart', 'Line'),
                    subMenu: [
                        getMenuItem('lineChart', 'Line&lrm;', 'line', 'pivotLineChart'),
                        getMenuItem('stackedLine', 'Stacked&lrm;', 'stackedLine', 'pivotStackedLine'),
                        getMenuItem('normalizedLine', '100% Stacked&lrm;', 'normalizedLine', 'pivotNormalizedLine'),
                    ],
                },
                {
                    _key: 'pivotAreaChart',
                    name: localeTextFunc('areaChart', 'Area'),
                    subMenu: [
                        getMenuItem('areaChart', 'Area&lrm;', 'area', 'pivotArea'),
                        getMenuItem('stackedArea', 'Stacked&lrm;', 'stackedArea', 'pivotStackedArea'),
                        getMenuItem('normalizedArea', '100% Stacked&lrm;', 'normalizedArea', 'pivotNormalizedArea'),
                    ],
                },
                {
                    _key: 'pivotXYChart',
                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),
                    subMenu: [
                        getMenuItem('scatter', 'Scatter&lrm;', 'scatter', 'pivotScatter'),
                        getMenuItem('bubble', 'Bubble&lrm;', 'bubble', 'pivotBubble'),
                    ],
                },
                {
                    _key: 'pivotStatisticalChart',
                    _enterprise: false,
                    name: localeTextFunc('statisticalChart', 'Statistical'),
                    subMenu: [getMenuItem('histogramChart', 'Histogram&lrm;', 'histogram', 'pivotHistogram', false)],
                },
                {
                    _key: 'pivotHierarchicalChart',
                    _enterprise: true,
                    name: localeTextFunc('hierarchicalChart', 'Hierarchical'),
                    subMenu: [
                        getMenuItem('treemapChart', 'Treemap&lrm;', 'treemap', 'pivotTreemap', true),
                        getMenuItem('sunburstChart', 'Sunburst&lrm;', 'sunburst', 'pivotSunburst', true),
                    ],
                },
                {
                    _key: 'pivotCombinationChart',
                    name: localeTextFunc('combinationChart', 'Combination'),
                    subMenu: [
                        getMenuItem('columnLineCombo', 'Column & Line&lrm;', 'columnLineCombo', 'pivotColumnLineCombo'),
                        getMenuItem('AreaColumnCombo', 'Area & Column&lrm;', 'areaColumnCombo', 'pivotAreaColumnCombo'),
                    ],
                },
            ],
            icon: (0, ag_grid_community_1._createIconNoSpan)('chart', this.beans, undefined),
        };
    }
    getConfigLookup() {
        return {
            columnGroup: {
                _key: 'pivotColumnChart',
                column: 'pivotGroupedColumn',
                stackedColumn: 'pivotStackedColumn',
                normalizedColumn: 'pivotNormalizedColumn',
            },
            barGroup: {
                _key: 'pivotBarChart',
                bar: 'pivotGroupedBar',
                stackedBar: 'pivotStackedBar',
                normalizedBar: 'pivotNormalizedBar',
            },
            pieGroup: {
                _key: 'pivotPieChart',
                pie: 'pivotPie',
                donut: 'pivotDonut',
                doughnut: 'pivotDonut',
            },
            lineGroup: {
                _key: 'pivotLineChart',
                line: 'pivotLineChart',
                stackedLine: 'pivotStackedLine',
                normalizedLine: 'pivotNormalizedLine',
            },
            areaGroup: {
                _key: 'pivotAreaChart',
                area: 'pivotArea',
                stackedArea: 'pivotStackedArea',
                normalizedArea: 'pivotNormalizedArea',
            },
            scatterGroup: {
                _key: 'pivotXYChart',
                bubble: 'pivotBubble',
                scatter: 'pivotScatter',
            },
            combinationGroup: {
                _key: 'pivotCombinationChart',
                columnLineCombo: 'pivotColumnLineCombo',
                areaColumnCombo: 'pivotAreaColumnCombo',
                customCombo: null, // Not currently supported
            },
            hierarchicalGroup: {
                _key: 'pivotHierarchicalChart',
                treemap: 'pivotTreemap',
                sunburst: 'pivotSunburst',
            },
            statisticalGroup: {
                _key: 'pivotStatisticalChart',
                histogram: 'pivotHistogram',
                // Some statistical charts do not currently support pivot mode
                rangeBar: null,
                rangeArea: null,
                boxPlot: null,
            },
            // Polar charts do not support pivot mode
            polarGroup: null,
            // Specialized charts do not currently support pivot mode
            specializedGroup: null,
        };
    }
}
class RangeMenuItemMapper {
    constructor(beans, chartSvc, getLocaleTextFunc) {
        this.beans = beans;
        this.chartSvc = chartSvc;
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getMenuItem() {
        const localeTextFunc = this.getLocaleTextFunc();
        const getMenuItem = (localeKey, defaultText, chartType, key, enterprise = false) => {
            return {
                name: localeTextFunc(localeKey, defaultText),
                action: () => this.chartSvc.createChartFromCurrentRange(chartType),
                _key: key,
                _enterprise: enterprise,
            };
        };
        return {
            name: localeTextFunc('chartRange', 'Chart Range'),
            _key: 'chartRange',
            subMenu: [
                {
                    name: localeTextFunc('columnChart', 'Column'),
                    subMenu: [
                        getMenuItem('groupedColumn', 'Grouped&lrm;', 'groupedColumn', 'rangeGroupedColumn'),
                        getMenuItem('stackedColumn', 'Stacked&lrm;', 'stackedColumn', 'rangeStackedColumn'),
                        getMenuItem('normalizedColumn', '100% Stacked&lrm;', 'normalizedColumn', 'rangeNormalizedColumn'),
                    ],
                    _key: 'rangeColumnChart',
                },
                {
                    name: localeTextFunc('barChart', 'Bar'),
                    subMenu: [
                        getMenuItem('groupedBar', 'Grouped&lrm;', 'groupedBar', 'rangeGroupedBar'),
                        getMenuItem('stackedBar', 'Stacked&lrm;', 'stackedBar', 'rangeStackedBar'),
                        getMenuItem('normalizedBar', '100% Stacked&lrm;', 'normalizedBar', 'rangeNormalizedBar'),
                    ],
                    _key: 'rangeBarChart',
                },
                {
                    name: localeTextFunc('pieChart', 'Pie'),
                    subMenu: [
                        getMenuItem('pie', 'Pie&lrm;', 'pie', 'rangePie'),
                        getMenuItem('donut', 'Donut&lrm;', 'donut', 'rangeDonut'),
                    ],
                    _key: 'rangePieChart',
                },
                {
                    name: localeTextFunc('lineChart', 'Line'),
                    subMenu: [
                        getMenuItem('lineChart', 'Line&lrm;', 'line', 'rangeLineChart'),
                        getMenuItem('stackedLine', 'Stacked&lrm;', 'stackedLine', 'rangeStackedLine'),
                        getMenuItem('normalizedLine', '100% Stacked&lrm;', 'normalizedLine', 'rangeNormalizedLine'),
                    ],
                    _key: 'rangeLineChart',
                },
                {
                    name: localeTextFunc('areaChart', 'Area'),
                    subMenu: [
                        getMenuItem('areaChart', 'Area&lrm;', 'area', 'rangeArea'),
                        getMenuItem('stackedArea', 'Stacked&lrm;', 'stackedArea', 'rangeStackedArea'),
                        getMenuItem('normalizedArea', '100% Stacked&lrm;', 'normalizedArea', 'rangeNormalizedArea'),
                    ],
                    _key: 'rangeAreaChart',
                },
                {
                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),
                    subMenu: [
                        getMenuItem('scatter', 'Scatter&lrm;', 'scatter', 'rangeScatter'),
                        getMenuItem('bubble', 'Bubble&lrm;', 'bubble', 'rangeBubble'),
                    ],
                    _key: 'rangeXYChart',
                },
                {
                    name: localeTextFunc('polarChart', 'Polar'),
                    subMenu: [
                        getMenuItem('radarLine', 'Radar Line&lrm;', 'radarLine', 'rangeRadarLine'),
                        getMenuItem('radarArea', 'Radar Area&lrm;', 'radarArea', 'rangeRadarArea'),
                        getMenuItem('nightingale', 'Nightingale&lrm;', 'nightingale', 'rangeNightingale'),
                        getMenuItem('radialColumn', 'Radial Column&lrm;', 'radialColumn', 'rangeRadialColumn'),
                        getMenuItem('radialBar', 'Radial Bar&lrm;', 'radialBar', 'rangeRadialBar'),
                    ],
                    _key: 'rangePolarChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('statisticalChart', 'Statistical'),
                    subMenu: [
                        getMenuItem('boxPlot', 'Box Plot&lrm;', 'boxPlot', 'rangeBoxPlot', true),
                        getMenuItem('histogramChart', 'Histogram&lrm;', 'histogram', 'rangeHistogram', false),
                        getMenuItem('rangeBar', 'Range Bar&lrm;', 'rangeBar', 'rangeRangeBar', true),
                        getMenuItem('rangeArea', 'Range Area&lrm;', 'rangeArea', 'rangeRangeArea', true),
                    ],
                    _key: 'rangeStatisticalChart',
                    _enterprise: false, // histogram chart is available in both community and enterprise distributions
                },
                {
                    name: localeTextFunc('hierarchicalChart', 'Hierarchical'),
                    subMenu: [
                        getMenuItem('treemap', 'Treemap&lrm;', 'treemap', 'rangeTreemap'),
                        getMenuItem('sunburst', 'Sunburst&lrm;', 'sunburst', 'rangeSunburst'),
                    ],
                    _key: 'rangeHierarchicalChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('specializedChart', 'Specialized'),
                    subMenu: [
                        getMenuItem('heatmap', 'Heatmap&lrm;', 'heatmap', 'rangeHeatmap'),
                        getMenuItem('waterfall', 'Waterfall&lrm;', 'waterfall', 'rangeWaterfall'),
                    ],
                    _key: 'rangeSpecializedChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('combinationChart', 'Combination'),
                    subMenu: [
                        getMenuItem('columnLineCombo', 'Column & Line&lrm;', 'columnLineCombo', 'rangeColumnLineCombo'),
                        getMenuItem('AreaColumnCombo', 'Area & Column&lrm;', 'areaColumnCombo', 'rangeAreaColumnCombo'),
                    ],
                    _key: 'rangeCombinationChart',
                },
            ],
            icon: (0, ag_grid_community_1._createIconNoSpan)('chart', this.beans, undefined),
        };
    }
    getConfigLookup() {
        return {
            columnGroup: {
                _key: 'rangeColumnChart',
                column: 'rangeGroupedColumn',
                stackedColumn: 'rangeStackedColumn',
                normalizedColumn: 'rangeNormalizedColumn',
            },
            barGroup: {
                _key: 'rangeBarChart',
                bar: 'rangeGroupedBar',
                stackedBar: 'rangeStackedBar',
                normalizedBar: 'rangeNormalizedBar',
            },
            pieGroup: {
                _key: 'rangePieChart',
                pie: 'rangePie',
                donut: 'rangeDonut',
                doughnut: 'rangeDonut',
            },
            lineGroup: {
                _key: 'rangeLineChart',
                line: 'rangeLineChart',
                stackedLine: 'rangeStackedLine',
                normalizedLine: 'rangeNormalizedLine',
            },
            areaGroup: {
                _key: 'rangeAreaChart',
                area: 'rangeArea',
                stackedArea: 'rangeStackedArea',
                normalizedArea: 'rangeNormalizedArea',
            },
            scatterGroup: {
                _key: 'rangeXYChart',
                bubble: 'rangeBubble',
                scatter: 'rangeScatter',
            },
            polarGroup: {
                _key: 'rangePolarChart',
                radarLine: 'rangeRadarLine',
                radarArea: 'rangeRadarArea',
                nightingale: 'rangeNightingale',
                radialColumn: 'rangeRadialColumn',
                radialBar: 'rangeRadialBar',
            },
            statisticalGroup: {
                _key: 'rangeStatisticalChart',
                boxPlot: 'rangeBoxPlot',
                histogram: 'rangeHistogram',
                rangeBar: 'rangeRangeBar',
                rangeArea: 'rangeRangeArea',
            },
            hierarchicalGroup: {
                _key: 'rangeHierarchicalChart',
                treemap: 'rangeTreemap',
                sunburst: 'rangeSunburst',
            },
            specializedGroup: {
                _key: 'rangeSpecializedChart',
                heatmap: 'rangeHeatmap',
                waterfall: 'rangeWaterfall',
            },
            combinationGroup: {
                _key: 'rangeCombinationChart',
                columnLineCombo: 'rangeColumnLineCombo',
                areaColumnCombo: 'rangeAreaColumnCombo',
                customCombo: null, // Not currently supported
            },
        };
    }
}


/***/ }),

/***/ 9262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnChooserFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPrimaryCols_1 = __webpack_require__(1269);
const agDialog_1 = __webpack_require__(8775);
class ColumnChooserFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colChooserFactory';
    }
    createColumnSelectPanel(parent, column, draggable, params) {
        const columnSelectPanel = parent.createManagedBean(new agPrimaryCols_1.AgPrimaryCols());
        const columnChooserParams = params ?? column?.getColDef().columnChooserParams ?? {};
        const { contractColumnSelection, suppressColumnExpandAll, suppressColumnFilter, suppressColumnSelectAll, suppressSyncLayoutWithGrid, columnLayout, } = columnChooserParams;
        columnSelectPanel.init(!!draggable, this.gos.addGridCommonParams({
            suppressColumnMove: false,
            suppressValues: false,
            suppressPivots: false,
            suppressRowGroups: false,
            suppressPivotMode: false,
            contractColumnSelection: !!contractColumnSelection,
            suppressColumnExpandAll: !!suppressColumnExpandAll,
            suppressColumnFilter: !!suppressColumnFilter,
            suppressColumnSelectAll: !!suppressColumnSelectAll,
            suppressSyncLayoutWithGrid: !!columnLayout || !!suppressSyncLayoutWithGrid,
            onStateUpdated: () => { },
        }), 'columnMenu');
        if (columnLayout) {
            columnSelectPanel.setColumnLayout(columnLayout);
        }
        return columnSelectPanel;
    }
    showColumnChooser({ column, chooserParams, eventSource }) {
        this.hideActiveColumnChooser();
        const columnSelectPanel = this.createColumnSelectPanel(this, column, true, chooserParams);
        const translate = this.getLocaleTextFunc();
        const beans = this.beans;
        const { visibleCols, focusSvc, menuUtils } = beans;
        const columnIndex = visibleCols.allCols.indexOf(column);
        const headerPosition = column ? focusSvc.focusedHeader : null;
        this.activeColumnChooserDialog = this.createBean(new agDialog_1.AgDialog({
            title: translate('chooseColumns', 'Choose Columns'),
            component: columnSelectPanel,
            width: 300,
            height: 300,
            resizable: true,
            movable: true,
            centered: true,
            closable: true,
            afterGuiAttached: () => {
                (0, ag_grid_community_1._findNextFocusableElement)(beans, columnSelectPanel.getGui())?.focus({
                    preventScroll: true,
                });
                this.dispatchVisibleChangedEvent(true, column);
            },
            closedCallback: (event) => {
                const eComp = this.activeColumnChooser.getGui();
                this.destroyBean(this.activeColumnChooser);
                this.activeColumnChooser = undefined;
                this.activeColumnChooserDialog = undefined;
                this.dispatchVisibleChangedEvent(false, column);
                if (column) {
                    menuUtils.restoreFocusOnClose({ column, headerPosition, columnIndex, eventSource }, eComp, event, true);
                }
            },
            postProcessPopupParams: {
                type: 'columnChooser',
                column,
                eventSource,
            },
        }));
        this.activeColumnChooser = columnSelectPanel;
    }
    hideActiveColumnChooser() {
        this.destroyBean(this.activeColumnChooserDialog);
    }
    dispatchVisibleChangedEvent(visible, column) {
        this.eventSvc.dispatchEvent({
            type: 'columnMenuVisibleChanged',
            visible,
            switchingTab: false,
            key: 'columnChooser',
            column: column ?? null,
        });
    }
}
exports.ColumnChooserFactory = ColumnChooserFactory;


/***/ }),

/***/ 5884:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnMenuFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
const agMenuList_1 = __webpack_require__(9476);
const menuItemMapper_1 = __webpack_require__(1708);
class ColumnMenuFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colMenuFactory';
    }
    createMenu(parent, menuItems, column, sourceElement) {
        const menuList = parent.createManagedBean(new agMenuList_1.AgMenuList(0, {
            column: column ?? null,
            node: null,
            value: null,
        }));
        const menuItemsMapped = this.beans.menuItemMapper.mapWithStockItems(menuItems, column ?? null, sourceElement, 'columnMenu');
        menuList.addMenuItems(menuItemsMapped);
        return menuList;
    }
    getMenuItems(column = null, columnGroup = null) {
        const defaultItems = this.getDefaultMenuOptions(column);
        let result;
        const columnMainMenuItems = (column?.getColDef() ?? columnGroup?.getColGroupDef())?.mainMenuItems;
        if (Array.isArray(columnMainMenuItems)) {
            result = columnMainMenuItems;
        }
        else if (typeof columnMainMenuItems === 'function') {
            result = columnMainMenuItems(this.gos.addGridCommonParams({
                column,
                columnGroup,
                defaultItems,
            }));
        }
        else {
            const userFunc = this.gos.getCallback('getMainMenuItems');
            if (userFunc) {
                result = userFunc({
                    column,
                    columnGroup,
                    defaultItems,
                });
            }
            else {
                result = defaultItems;
            }
        }
        // GUI looks weird when two separators are side by side. this can happen accidentally
        // if we remove items from the menu then two separators can edit up adjacent.
        (0, menuItemMapper_1._removeRepeatsFromArray)(result, menuItemMapper_1.MENU_ITEM_SEPARATOR);
        return result;
    }
    getDefaultMenuOptions(column) {
        const result = [];
        const { beans, gos } = this;
        const { colChooserFactory, rowGroupColsSvc, colModel, expansionSvc, sortSvc, menuSvc, pinnedCols, aggFuncSvc, colAutosize, } = beans;
        const isLegacyMenuEnabled = (0, ag_grid_community_1._isLegacyMenuEnabled)(gos);
        const addColumnItems = () => {
            if (!isLegacyMenuEnabled && colChooserFactory) {
                result.push('columnChooser');
            }
            result.push('resetColumns');
        };
        if (!column) {
            addColumnItems();
            return result;
        }
        const { colDef } = column;
        const allowPinning = pinnedCols && !colDef.lockPinned;
        const rowGroupCount = rowGroupColsSvc?.columns.length ?? 0;
        const doingGrouping = rowGroupCount > 0;
        const isPrimary = column.isPrimary();
        const allowValueAgg = (aggFuncSvc &&
            // if primary, then only allow aggValue if grouping and it's a value columns
            isPrimary &&
            doingGrouping &&
            column.isAllowValue()) ||
            // secondary columns can always have aggValue, as it means it's a pivot value column
            !isPrimary;
        if (sortSvc && !isLegacyMenuEnabled && column.isSortable()) {
            const sort = column.getSort();
            if (sort !== 'asc') {
                result.push('sortAscending');
            }
            if (sort !== 'desc') {
                result.push('sortDescending');
            }
            if (sort) {
                result.push('sortUnSort');
            }
            result.push(menuItemMapper_1.MENU_ITEM_SEPARATOR);
        }
        if (menuSvc?.isFilterMenuItemEnabled(column)) {
            result.push('columnFilter');
            result.push(menuItemMapper_1.MENU_ITEM_SEPARATOR);
        }
        if (allowPinning) {
            result.push('pinSubMenu');
        }
        if (allowValueAgg) {
            result.push('valueAggSubMenu');
        }
        if (allowPinning || allowValueAgg) {
            result.push(menuItemMapper_1.MENU_ITEM_SEPARATOR);
        }
        if (colAutosize) {
            result.push('autoSizeThis');
            result.push('autoSizeAll');
            result.push(menuItemMapper_1.MENU_ITEM_SEPARATOR);
        }
        if (rowGroupColsSvc && gos.isModuleRegistered('SharedRowGrouping')) {
            const numItems = result.length;
            const showRowGroup = colDef.showRowGroup;
            if (showRowGroup) {
                result.push('rowUnGroup');
            }
            else if (column.isAllowRowGroup() && isPrimary) {
                if (column.isRowGroupActive()) {
                    const groupLocked = (0, rowGroupingUtils_1.isRowGroupColLocked)(column, beans);
                    if (!groupLocked) {
                        result.push('rowUnGroup');
                    }
                }
                else {
                    result.push('rowGroup');
                }
            }
            if (result.length > numItems) {
                // only add separator if added group items
                result.push(menuItemMapper_1.MENU_ITEM_SEPARATOR);
            }
        }
        addColumnItems();
        // only add grouping expand/collapse if grouping in the InMemoryRowModel
        // if pivoting, we only have expandable groups if grouping by 2 or more columns
        // as the lowest level group is not expandable while pivoting.
        // if not pivoting, then any active row group can be expanded.
        if (expansionSvc &&
            (0, ag_grid_community_1._isClientSideRowModel)(gos) &&
            (gos.get('treeData') || rowGroupCount > (colModel.isPivotMode() ? 1 : 0))) {
            result.push('expandAll');
            result.push('contractAll');
        }
        return result;
    }
}
exports.ColumnMenuFactory = ColumnMenuFactory;


/***/ }),

/***/ 3461:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextMenuService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agMenuList_1 = __webpack_require__(9476);
const CSS_MENU = 'ag-menu';
const CSS_CONTEXT_MENU_OPEN = 'ag-context-menu-open';
const CSS_CONTEXT_MENU_LOADING_ICON = 'ag-context-menu-loading-icon';
class ContextMenuService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'contextMenuSvc';
        this.destroyLoadingSpinner = null;
        this.lastPromise = 0;
    }
    hideActiveMenu() {
        this.destroyBean(this.activeMenu);
    }
    getMenuItems(node, column, value, mouseEvent) {
        const defaultMenuOptions = [];
        const { clipboardSvc, chartSvc, csvCreator, excelCreator, colModel, rangeSvc, gos } = this.beans;
        if ((0, ag_grid_community_1._exists)(node) && clipboardSvc) {
            if (column) {
                // only makes sense if column exists, could have originated from a row
                if (!gos.get('suppressCutToClipboard')) {
                    defaultMenuOptions.push('cut');
                }
                defaultMenuOptions.push('copy', 'copyWithHeaders', 'copyWithGroupHeaders', 'paste', 'separator');
            }
        }
        if (gos.get('enableCharts') && chartSvc) {
            if (colModel.isPivotMode()) {
                defaultMenuOptions.push('pivotChart');
            }
            if (rangeSvc && !rangeSvc.isEmpty()) {
                defaultMenuOptions.push('chartRange');
            }
        }
        if ((0, ag_grid_community_1._exists)(node)) {
            // if user clicks a cell
            const suppressExcel = gos.get('suppressExcelExport') || !excelCreator;
            const suppressCsv = gos.get('suppressCsvExport') || !csvCreator;
            const onIPad = (0, ag_grid_community_1._isIOSUserAgent)();
            const anyExport = !onIPad && (!suppressExcel || !suppressCsv);
            if (anyExport) {
                defaultMenuOptions.push('export');
            }
        }
        const defaultItems = defaultMenuOptions.length ? defaultMenuOptions : undefined;
        const columnContextMenuItems = column?.getColDef().contextMenuItems;
        if (Array.isArray(columnContextMenuItems)) {
            return columnContextMenuItems;
        }
        if (typeof columnContextMenuItems === 'function') {
            return columnContextMenuItems(gos.addGridCommonParams({
                column,
                node,
                value,
                defaultItems,
                event: mouseEvent,
            }));
        }
        const userFunc = gos.getCallback('getContextMenuItems');
        if (userFunc) {
            return userFunc({ column, node, value, defaultItems, event: mouseEvent });
        }
        return defaultMenuOptions;
    }
    getContextMenuPosition(rowNode, column) {
        const rowCtrl = this.getRowCtrl(rowNode);
        const eGui = this.getCellGui(rowCtrl, column);
        if (!eGui) {
            if (rowCtrl) {
                return { x: 0, y: rowCtrl.getRowYPosition() };
            }
            return { x: 0, y: 0 };
        }
        const rect = eGui.getBoundingClientRect();
        return {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2,
        };
    }
    showContextMenu(params) {
        const rowNode = params.rowNode;
        const column = params.column;
        let { anchorToElement, value } = params;
        if (rowNode && column && value == null) {
            value = this.beans.valueSvc.getValueForDisplay(column, rowNode);
        }
        if (anchorToElement == null) {
            anchorToElement = this.getContextMenuAnchorElement(rowNode, column);
        }
        this.onContextMenu(params.mouseEvent ?? null, params.touchEvent ?? null, rowNode ?? null, column ?? null, value, anchorToElement);
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, rowComp, cellCtrl) {
        const rowNode = rowComp?.rowNode ?? null;
        const column = cellCtrl?.column ?? null;
        const { valueSvc, ctrlsSvc } = this.beans;
        const value = column ? valueSvc.getValue(column, rowNode) : null;
        // if user clicked on a cell, anchor to that cell, otherwise anchor to the grid panel
        const gridBodyCon = ctrlsSvc.getGridBodyCtrl();
        const anchorToElement = cellCtrl ? cellCtrl.eGui : gridBodyCon.eGridBody;
        this.showContextMenu({
            mouseEvent,
            touchEvent,
            rowNode,
            column,
            value,
            anchorToElement,
        });
    }
    onContextMenu(mouseEvent, touchEvent, rowNode, column, value, anchorToElement) {
        this.beans.menuUtils.onContextMenu(mouseEvent, touchEvent, (eventOrTouch) => this.showMenu(rowNode, column, value, eventOrTouch, anchorToElement));
    }
    showMenu(node, column, value, mouseEvent, anchorToElement) {
        const menuItems = this.getMenuItems(node, column, value, mouseEvent);
        if ((0, ag_grid_community_1._isPromise)(menuItems)) {
            const currentPromise = this.lastPromise + 1;
            this.lastPromise = currentPromise;
            if (!this.destroyLoadingSpinner) {
                this.createLoadingIcon(mouseEvent);
            }
            menuItems.then((menuItems) => {
                if (this.lastPromise !== currentPromise) {
                    return;
                }
                const shouldShowMenu = 
                // check if there are actual menu items to be displayed
                menuItems &&
                    menuItems.length &&
                    // check if the element that triggered the context menu was removed from the DOM
                    (0, ag_grid_community_1._isVisible)(mouseEvent.target) &&
                    // overlay was displayed
                    !this.beans.overlays?.isExclusive();
                if (shouldShowMenu) {
                    this.createContextMenu({ menuItems, node, column, value, mouseEvent, anchorToElement });
                }
                if (this.destroyLoadingSpinner) {
                    this.destroyLoadingSpinner();
                }
            });
            return true;
        }
        if (menuItems === undefined || !menuItems?.length) {
            return false;
        }
        this.createContextMenu({ menuItems, node, column, value, mouseEvent, anchorToElement });
        return true;
    }
    createLoadingIcon(mouseEvent) {
        const { beans } = this;
        const translate = this.getLocaleTextFunc();
        const loadingIcon = (0, ag_grid_community_1._createIconNoSpan)('loadingMenuItems', beans);
        const wrapperEl = document.createElement('div');
        wrapperEl.classList.add(CSS_CONTEXT_MENU_LOADING_ICON);
        wrapperEl.appendChild(loadingIcon);
        const rootNode = (0, ag_grid_community_1._getRootNode)(beans);
        const targetEl = (0, ag_grid_community_1._getPageBody)(beans);
        if (!targetEl) {
            (0, ag_grid_community_1._warn)(54);
            return;
        }
        targetEl.appendChild(wrapperEl);
        beans.ariaAnnounce?.announceValue(translate('ariaLabelLoadingContextMenu', 'Loading Context Menu'), 'contextmenu');
        beans.environment.applyThemeClasses(wrapperEl);
        (0, ag_grid_community_1._anchorElementToMouseMoveEvent)(wrapperEl, mouseEvent, beans);
        const mouseMoveCallback = (e) => {
            (0, ag_grid_community_1._anchorElementToMouseMoveEvent)(wrapperEl, e, beans);
        };
        rootNode.addEventListener('mousemove', mouseMoveCallback);
        this.destroyLoadingSpinner = () => {
            rootNode.removeEventListener('mousemove', mouseMoveCallback);
            targetEl.removeChild(wrapperEl);
            this.destroyLoadingSpinner = null;
        };
    }
    createContextMenu(params) {
        const { menuItems, node, column, value, mouseEvent, anchorToElement } = params;
        const { ctrlsSvc, focusSvc, popupSvc } = this.beans;
        const eGridBodyGui = ctrlsSvc.getGridBodyCtrl().eGridBody;
        const menu = new ContextMenu(menuItems, column, node, value);
        this.createBean(menu);
        const eMenuGui = menu.getGui();
        if (!column) {
            // the context menu has been opened not on a cell, therefore we don't want to
            // display the previous cell as focused, or return focus there after
            focusSvc.clearFocusedCell();
        }
        const positionParams = {
            column: column,
            rowNode: node,
            type: 'contextMenu',
            mouseEvent: mouseEvent,
            ePopup: eMenuGui,
            // move one pixel away so that accidentally double clicking
            // won't show the browser's contextmenu
            nudgeY: 1,
        };
        const translate = this.getLocaleTextFunc();
        const addPopupRes = popupSvc.addPopup({
            modal: true,
            eChild: eMenuGui,
            closeOnEsc: true,
            closedCallback: (e) => {
                eGridBodyGui.classList.remove(CSS_CONTEXT_MENU_OPEN);
                this.destroyBean(menu);
                this.dispatchVisibleChangedEvent(false, e === undefined ? 'api' : 'ui');
            },
            click: mouseEvent,
            positionCallback: () => {
                const isRtl = this.gos.get('enableRtl');
                popupSvc.positionPopupUnderMouseEvent({
                    ...positionParams,
                    nudgeX: isRtl ? (eMenuGui.offsetWidth + 1) * -1 : 1,
                });
            },
            // so when browser is scrolled down, or grid is scrolled, context menu stays with cell
            anchorToElement: anchorToElement,
            ariaLabel: translate('ariaLabelContextMenu', 'Context Menu'),
        });
        if (addPopupRes) {
            eGridBodyGui.classList.add(CSS_CONTEXT_MENU_OPEN);
            menu.afterGuiAttached({ container: 'contextMenu', hidePopup: addPopupRes.hideFunc });
        }
        // there should never be an active menu at this point, however it was found
        // that you could right click a second time just 1 or 2 pixels from the first
        // click, and another menu would pop up. so somehow the logic for closing the
        // first menu (clicking outside should close it) was glitchy somehow. an easy
        // way to avoid this is just remove the old context menu here if it exists.
        if (this.activeMenu) {
            this.hideActiveMenu();
        }
        this.activeMenu = menu;
        menu.addEventListener('destroyed', () => {
            if (this.activeMenu === menu) {
                this.activeMenu = null;
            }
        });
        // hide the popup if something gets selected
        if (addPopupRes) {
            menu.addEventListener('closeMenu', (e) => addPopupRes.hideFunc({
                mouseEvent: e.mouseEvent ?? undefined,
                keyboardEvent: e.keyboardEvent ?? undefined,
                forceHide: true,
            }));
        }
        // we check for a mousedown event because `gridApi.showContextMenu`
        // generates a `mousedown` event to display the context menu.
        const isApi = mouseEvent && mouseEvent instanceof MouseEvent && mouseEvent.type === 'mousedown';
        this.dispatchVisibleChangedEvent(true, isApi ? 'api' : 'ui');
    }
    dispatchVisibleChangedEvent(visible, source = 'ui') {
        this.eventSvc.dispatchEvent({
            type: 'contextMenuVisibleChanged',
            visible,
            source,
        });
    }
    getRowCtrl(rowNode) {
        const { rowIndex, rowPinned } = rowNode || {};
        if (rowIndex == null) {
            return;
        }
        return this.beans.rowRenderer.getRowByPosition({ rowIndex, rowPinned }) || undefined;
    }
    getCellGui(rowCtrl, column) {
        if (!rowCtrl || !column) {
            return;
        }
        const cellCtrl = rowCtrl.getCellCtrl(column);
        return cellCtrl?.eGui || undefined;
    }
    getContextMenuAnchorElement(rowNode, column) {
        const gridBodyEl = this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody;
        const rowCtrl = this.getRowCtrl(rowNode);
        if (!rowCtrl) {
            return gridBodyEl;
        }
        const cellGui = this.getCellGui(rowCtrl, column);
        if (cellGui) {
            return cellGui;
        }
        if (rowCtrl.isFullWidth()) {
            return rowCtrl.getFullWidthElement();
        }
        return gridBodyEl;
    }
    destroy() {
        this.destroyLoadingSpinner?.();
        super.destroy();
    }
}
exports.ContextMenuService = ContextMenuService;
class ContextMenu extends ag_grid_community_1.Component {
    constructor(menuItems, column, node, value) {
        super(/* html */ `<div class="${CSS_MENU}" role="presentation"></div>`);
        this.menuItems = menuItems;
        this.column = column;
        this.node = node;
        this.value = value;
        this.menuList = null;
        this.focusedCell = null;
    }
    postConstruct() {
        const menuList = this.createManagedBean(new agMenuList_1.AgMenuList(0, {
            column: this.column,
            node: this.node,
            value: this.value,
        }));
        const menuItemsMapped = this.beans.menuItemMapper.mapWithStockItems(this.menuItems, null, () => this.getGui(), 'contextMenu');
        menuList.addMenuItems(menuItemsMapped);
        this.appendChild(menuList);
        this.menuList = menuList;
        menuList.addEventListener('closeMenu', (e) => this.dispatchLocalEvent(e));
    }
    afterGuiAttached(params) {
        if (params.hidePopup) {
            this.addDestroyFunc(params.hidePopup);
        }
        this.focusedCell = this.beans.focusSvc.getFocusedCell();
        const menuList = this.menuList;
        if (menuList) {
            (0, ag_grid_community_1._focusInto)(menuList.getGui());
        }
    }
    restoreFocusedCell() {
        const { beans, focusedCell } = this;
        const focusSvc = beans.focusSvc;
        const currentFocusedCell = focusSvc.getFocusedCell();
        if (currentFocusedCell && focusedCell && (0, ag_grid_community_1._areCellsEqual)(currentFocusedCell, focusedCell)) {
            const { rowIndex, rowPinned, column } = focusedCell;
            if ((0, ag_grid_community_1._isNothingFocused)(beans)) {
                focusSvc.setFocusedCell({
                    rowIndex,
                    column,
                    rowPinned,
                    forceBrowserFocus: true,
                    preventScrollOnBrowserFocus: !(0, ag_grid_community_1._isKeyboardMode)(),
                });
            }
        }
    }
    destroy() {
        this.restoreFocusedCell();
        super.destroy();
    }
}


/***/ }),

/***/ 6345:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnterpriseMenuFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const tabbedLayout_1 = __webpack_require__(5875);
const TAB_FILTER = 'filterMenuTab';
const TAB_GENERAL = 'generalMenuTab';
const TAB_COLUMNS = 'columnsMenuTab';
const TABS_DEFAULT = [TAB_GENERAL, TAB_FILTER, TAB_COLUMNS];
class EnterpriseMenuFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'enterpriseMenuFactory';
    }
    hideActiveMenu() {
        this.destroyBean(this.activeMenu);
    }
    showMenuAfterMouseEvent(columnOrGroup, mouseEvent, containerType, filtersOnly) {
        const { column, columnGroup } = this.splitColumnOrGroup(columnOrGroup);
        const defaultTab = filtersOnly ? 'filterMenuTab' : undefined;
        this.showMenu(column, columnGroup, (menu) => {
            const ePopup = menu.getGui();
            this.beans.popupSvc.positionPopupUnderMouseEvent({
                type: containerType,
                column,
                mouseEvent,
                ePopup,
            });
            if (defaultTab) {
                menu.showTab?.(defaultTab);
            }
            this.dispatchVisibleChangedEvent(true, false, column, columnGroup, defaultTab);
        }, containerType, defaultTab, undefined, mouseEvent.target);
    }
    splitColumnOrGroup(columnOrGroup) {
        const colIsColumn = columnOrGroup && (0, ag_grid_community_1.isColumn)(columnOrGroup);
        const column = colIsColumn ? columnOrGroup : undefined;
        const columnGroup = colIsColumn ? undefined : columnOrGroup;
        return { column, columnGroup };
    }
    showMenuAfterButtonClick(columnOrGroup, eventSource, containerType, filtersOnly) {
        let multiplier = -1;
        let alignSide = 'left';
        if (this.gos.get('enableRtl')) {
            multiplier = 1;
            alignSide = 'right';
        }
        const defaultTab = filtersOnly ? 'filterMenuTab' : undefined;
        const restrictToTabs = defaultTab ? [defaultTab] : undefined;
        const isLegacyMenuEnabled = (0, ag_grid_community_1._isLegacyMenuEnabled)(this.gos);
        const nudgeX = (isLegacyMenuEnabled ? 9 : 4) * multiplier;
        const nudgeY = isLegacyMenuEnabled ? -23 : 4;
        const { column, columnGroup } = this.splitColumnOrGroup(columnOrGroup);
        this.showMenu(column, columnGroup, (menu) => {
            const ePopup = menu.getGui();
            this.beans.popupSvc.positionPopupByComponent({
                type: containerType,
                column,
                eventSource,
                ePopup,
                alignSide,
                nudgeX,
                nudgeY,
                position: 'under',
                keepWithinBounds: true,
            });
            if (defaultTab) {
                menu.showTab?.(defaultTab);
            }
            this.dispatchVisibleChangedEvent(true, false, column, columnGroup, defaultTab);
        }, containerType, defaultTab, restrictToTabs, eventSource);
    }
    showMenu(column, columnGroup, positionCallback, containerType, defaultTab, restrictToTabs, eventSource) {
        const menuParams = this.getMenuParams(column, columnGroup, restrictToTabs, eventSource);
        if (!menuParams) {
            // can't create menu
            return;
        }
        const { menu, eMenuGui, anchorToElement, restoreFocusParams } = menuParams;
        const closedFuncs = [];
        const { menuUtils, popupSvc } = this.beans;
        closedFuncs.push((e) => {
            const eComp = menu.getGui();
            this.destroyBean(menu);
            if (column) {
                (0, ag_grid_community_1._setColMenuVisible)(column, false, 'contextMenu');
                // if we don't have a column, then the menu wasn't launched via keyboard navigation
                menuUtils.restoreFocusOnClose(restoreFocusParams, eComp, e);
            }
        });
        const translate = this.getLocaleTextFunc();
        // need to show filter before positioning, as only after filter
        // is visible can we find out what the width of it is
        popupSvc.addPopup({
            modal: true,
            eChild: eMenuGui,
            closeOnEsc: true,
            closedCallback: (e) => {
                // menu closed callback
                closedFuncs.forEach((f) => f(e));
                this.dispatchVisibleChangedEvent(false, false, column, columnGroup, defaultTab);
            },
            afterGuiAttached: (params) => menu.afterGuiAttached(Object.assign({}, { container: containerType }, params)),
            // if defaultTab is not present, positionCallback will be called
            // after `showTabBasedOnPreviousSelection` is called.
            positionCallback: defaultTab ? () => positionCallback(menu) : undefined,
            ariaLabel: translate('ariaLabelColumnMenu', 'Column Menu'),
        });
        if (!defaultTab) {
            menu.showTabBasedOnPreviousSelection?.();
            // reposition the menu because the method above could load
            // an element that is bigger than enterpriseMenu header.
            positionCallback(menu);
        }
        if ((0, ag_grid_community_1._isColumnMenuAnchoringEnabled)(this.gos)) {
            // if user starts showing / hiding columns, or otherwise move the underlying column
            // for this menu, we want to stop tracking the menu with the column position. otherwise
            // the menu would move as the user is using the columns tab inside the menu.
            const stopAnchoringPromise = popupSvc.setPopupPositionRelatedToElement(eMenuGui, anchorToElement);
            if (stopAnchoringPromise && column) {
                this.addStopAnchoring(stopAnchoringPromise, column, closedFuncs);
            }
        }
        menu.addEventListener('tabSelected', (event) => {
            this.dispatchVisibleChangedEvent(false, true, column);
            this.lastSelectedTab = event.key;
            this.dispatchVisibleChangedEvent(true, true, column);
        });
        if (column) {
            (0, ag_grid_community_1._setColMenuVisible)(column, true, 'contextMenu');
        }
        this.activeMenu = menu;
        menu.addEventListener('destroyed', () => {
            if (this.activeMenu === menu) {
                this.activeMenu = null;
            }
        });
    }
    addStopAnchoring(stopAnchoringPromise, column, closedFuncsArr) {
        stopAnchoringPromise.then((stopAnchoringFunc) => {
            column.addEventListener('leftChanged', stopAnchoringFunc);
            column.addEventListener('visibleChanged', stopAnchoringFunc);
            closedFuncsArr.push(() => {
                column.removeEventListener('leftChanged', stopAnchoringFunc);
                column.removeEventListener('visibleChanged', stopAnchoringFunc);
            });
        });
    }
    getMenuParams(column, columnGroup, restrictToTabs, eventSource) {
        const { focusSvc, visibleCols, ctrlsSvc } = this.beans;
        const restoreFocusParams = {
            column,
            headerPosition: focusSvc.focusedHeader,
            columnIndex: visibleCols.allCols.indexOf(column),
            eventSource,
        };
        const menu = this.createMenu(column, columnGroup, restoreFocusParams, restrictToTabs, eventSource);
        return menu
            ? {
                menu,
                eMenuGui: menu.getGui(),
                anchorToElement: eventSource || ctrlsSvc.getGridBodyCtrl().eGridBody,
                restoreFocusParams,
            }
            : undefined;
    }
    createMenu(column, columnGroup, restoreFocusParams, restrictToTabs, eventSource) {
        if ((0, ag_grid_community_1._isLegacyMenuEnabled)(this.gos)) {
            return this.createBean(new TabbedColumnMenu(column, restoreFocusParams, this.lastSelectedTab, restrictToTabs, eventSource));
        }
        else {
            const menuItems = this.beans.colMenuFactory.getMenuItems(column, columnGroup);
            return menuItems.length
                ? this.createBean(new ColumnContextMenu(menuItems, column, restoreFocusParams, eventSource))
                : undefined;
        }
    }
    dispatchVisibleChangedEvent(visible, switchingTab, column, columnGroup, defaultTab) {
        this.eventSvc.dispatchEvent({
            type: 'columnMenuVisibleChanged',
            visible,
            switchingTab,
            key: (this.lastSelectedTab ??
                defaultTab ??
                ((0, ag_grid_community_1._isLegacyMenuEnabled)(this.gos) ? TAB_GENERAL : 'columnMenu')),
            column: column ?? null,
            columnGroup: columnGroup ?? null,
        });
    }
    isMenuEnabled(column) {
        if (!(0, ag_grid_community_1._isLegacyMenuEnabled)(this.gos)) {
            return true;
        }
        // Determine whether there are any tabs to show in the menu, given that the filter tab may be hidden
        const isFilterDisabled = !this.beans.filterManager?.isFilterAllowed(column);
        const tabs = column.getColDef().menuTabs ?? TABS_DEFAULT;
        const numActiveTabs = isFilterDisabled && tabs.includes(TAB_FILTER) ? tabs.length - 1 : tabs.length;
        return numActiveTabs > 0;
    }
    showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent) {
        this.beans.menuUtils.onContextMenu(mouseEvent, touchEvent, (eventOrTouch) => {
            this.showMenuAfterMouseEvent(column, eventOrTouch, 'columnMenu');
            return true;
        });
    }
}
exports.EnterpriseMenuFactory = EnterpriseMenuFactory;
class TabbedColumnMenu extends ag_grid_community_1.BeanStub {
    constructor(column, restoreFocusParams, initialSelection, restrictTo, sourceElement) {
        super();
        this.column = column;
        this.restoreFocusParams = restoreFocusParams;
        this.initialSelection = initialSelection;
        this.restrictTo = restrictTo;
        this.sourceElement = sourceElement;
        this.tabFactories = {};
        this.includeChecks = {};
        const { tabFactories, includeChecks } = this;
        tabFactories[TAB_GENERAL] = this.createMainPanel.bind(this);
        tabFactories[TAB_FILTER] = this.createFilterPanel.bind(this);
        tabFactories[TAB_COLUMNS] = this.createColumnsPanel.bind(this);
        includeChecks[TAB_GENERAL] = () => true;
        includeChecks[TAB_FILTER] = () => (column ? !!this.beans.filterManager?.isFilterAllowed(column) : false);
        includeChecks[TAB_COLUMNS] = () => true;
    }
    postConstruct() {
        const tabs = this.getTabsToCreate().map((name) => this.createTab(name));
        const tabbedLayout = new tabbedLayout_1.TabbedLayout({
            items: tabs,
            cssClass: 'ag-menu',
            onActiveItemClicked: this.onHidePopup.bind(this),
            onItemClicked: this.onTabItemClicked.bind(this),
        });
        this.tabbedLayout = this.createBean(tabbedLayout);
        this.mainMenuList?.setParentComponent(tabbedLayout);
        this.addDestroyFunc(() => this.destroyBean(tabbedLayout));
    }
    getTabsToCreate() {
        if (this.restrictTo) {
            return this.restrictTo;
        }
        return (this.column?.getColDef().menuTabs ?? TABS_DEFAULT).filter((tabName) => this.isValidMenuTabItem(tabName) && this.isNotSuppressed(tabName));
    }
    isValidMenuTabItem(menuTabName) {
        let isValid = true;
        let itemsToConsider = TABS_DEFAULT;
        if (this.restrictTo != null) {
            isValid = this.restrictTo.indexOf(menuTabName) > -1;
            itemsToConsider = this.restrictTo;
        }
        isValid = isValid && TABS_DEFAULT.indexOf(menuTabName) > -1;
        if (!isValid) {
            (0, ag_grid_community_1._warn)(175, { menuTabName, itemsToConsider });
        }
        return isValid;
    }
    isNotSuppressed(menuTabName) {
        return this.includeChecks[menuTabName]();
    }
    createTab(name) {
        return this.tabFactories[name]();
    }
    showTabBasedOnPreviousSelection() {
        // show the tab the user was on last time they had a menu open
        this.showTab(this.initialSelection);
    }
    showTab(toShow) {
        const { tabItemColumns, tabbedLayout, tabItemFilter, tabItemGeneral } = this;
        if (tabItemColumns && toShow === TAB_COLUMNS) {
            tabbedLayout.showItem(tabItemColumns);
        }
        else if (tabItemFilter && toShow === TAB_FILTER) {
            tabbedLayout.showItem(tabItemFilter);
        }
        else if (tabItemGeneral && toShow === TAB_GENERAL) {
            tabbedLayout.showItem(tabItemGeneral);
        }
        else {
            tabbedLayout.showFirstItem();
        }
    }
    onTabItemClicked(event) {
        let key = null;
        switch (event.item) {
            case this.tabItemColumns:
                key = TAB_COLUMNS;
                break;
            case this.tabItemFilter:
                key = TAB_FILTER;
                break;
            case this.tabItemGeneral:
                key = TAB_GENERAL;
                break;
        }
        if (key) {
            this.activateTab(key);
        }
    }
    activateTab(tab) {
        const ev = {
            type: 'tabSelected',
            key: tab,
        };
        this.dispatchLocalEvent(ev);
    }
    createMainPanel() {
        const { beans, column } = this;
        const colMenuFactory = beans.colMenuFactory;
        const mainMenuList = colMenuFactory.createMenu(this, colMenuFactory.getMenuItems(column), this.column, () => this.sourceElement ?? this.getGui());
        this.mainMenuList = mainMenuList;
        mainMenuList.addEventListener('closeMenu', this.onHidePopup.bind(this));
        const tabItemGeneral = {
            title: (0, ag_grid_community_1._createIconNoSpan)('legacyMenu', beans, column),
            titleLabel: TAB_GENERAL.replace('MenuTab', ''),
            bodyPromise: ag_grid_community_1.AgPromise.resolve(mainMenuList.getGui()),
            name: TAB_GENERAL,
        };
        this.tabItemGeneral = tabItemGeneral;
        return tabItemGeneral;
    }
    onHidePopup(event) {
        this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(this.hidePopupFunc, this.restoreFocusParams, event);
    }
    createFilterPanel() {
        const comp = this.column ? this.createBean(new ag_grid_community_1.FilterWrapperComp(this.column, 'COLUMN_MENU')) : null;
        this.filterComp = comp;
        if (!comp?.hasFilter()) {
            (0, ag_grid_community_1._error)(119);
        }
        const afterAttachedCallback = (params) => comp?.afterGuiAttached(params);
        const afterDetachedCallback = () => comp?.afterGuiDetached();
        this.tabItemFilter = {
            title: (0, ag_grid_community_1._createIconNoSpan)('filterTab', this.beans, this.column),
            titleLabel: TAB_FILTER.replace('MenuTab', ''),
            bodyPromise: ag_grid_community_1.AgPromise.resolve(comp?.getGui()),
            afterAttachedCallback,
            afterDetachedCallback,
            name: TAB_FILTER,
        };
        return this.tabItemFilter;
    }
    createColumnsPanel() {
        const eWrapperDiv = document.createElement('div');
        eWrapperDiv.classList.add('ag-menu-column-select-wrapper');
        const { beans, column } = this;
        const columnSelectPanel = beans.colChooserFactory.createColumnSelectPanel(this, column);
        const columnSelectPanelGui = columnSelectPanel.getGui();
        columnSelectPanelGui.classList.add('ag-menu-column-select');
        eWrapperDiv.appendChild(columnSelectPanelGui);
        const tabItemColumns = {
            title: (0, ag_grid_community_1._createIconNoSpan)('columns', beans, column),
            titleLabel: TAB_COLUMNS.replace('MenuTab', ''),
            bodyPromise: ag_grid_community_1.AgPromise.resolve(eWrapperDiv),
            name: TAB_COLUMNS,
        };
        this.tabItemColumns = tabItemColumns;
        return tabItemColumns;
    }
    afterGuiAttached(params) {
        const { container, hidePopup } = params;
        this.tabbedLayout.setAfterAttachedParams({ container, hidePopup });
        if (hidePopup) {
            this.hidePopupFunc = hidePopup;
            this.addDestroyFunc(hidePopup);
        }
    }
    getGui() {
        return this.tabbedLayout.getGui();
    }
    destroy() {
        super.destroy();
        // Needs to be destroyed last to ensure that `afterGuiDetached` runs
        this.destroyBean(this.filterComp);
    }
}
class ColumnContextMenu extends ag_grid_community_1.Component {
    constructor(menuItems, column, restoreFocusParams, sourceElement) {
        super(/* html */ `
            <div data-ref="eColumnMenu" role="presentation" class="ag-menu ag-column-menu"></div>
        `);
        this.menuItems = menuItems;
        this.column = column;
        this.restoreFocusParams = restoreFocusParams;
        this.sourceElement = sourceElement;
        this.eColumnMenu = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const mainMenuList = this.beans.colMenuFactory.createMenu(this, this.menuItems, this.column, () => this.sourceElement ?? this.getGui());
        this.mainMenuList = mainMenuList;
        mainMenuList.addEventListener('closeMenu', this.onHidePopup.bind(this));
        this.eColumnMenu.appendChild(mainMenuList.getGui());
    }
    onHidePopup(event) {
        this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(this.hidePopupFunc, this.restoreFocusParams, event);
    }
    afterGuiAttached({ hidePopup }) {
        if (hidePopup) {
            this.hidePopupFunc = hidePopup;
            this.addDestroyFunc(hidePopup);
        }
        (0, ag_grid_community_1._focusInto)(this.mainMenuList.getGui());
    }
}


/***/ }),

/***/ 8228:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hideColumnChooser = exports.showColumnChooser = exports.showContextMenu = void 0;
function showContextMenu(beans, params) {
    const { contextMenuSvc } = beans;
    if (!contextMenuSvc) {
        return;
    }
    const { rowNode, column, value, x, y } = params || {};
    let { x: clientX, y: clientY } = contextMenuSvc.getContextMenuPosition(rowNode, column);
    if (x != null) {
        clientX = x;
    }
    if (y != null) {
        clientY = y;
    }
    contextMenuSvc.showContextMenu({
        mouseEvent: new MouseEvent('mousedown', { clientX, clientY }),
        rowNode,
        column,
        value,
    });
}
exports.showContextMenu = showContextMenu;
function showColumnChooser(beans, params) {
    beans.colChooserFactory?.showColumnChooser({ chooserParams: params });
}
exports.showColumnChooser = showColumnChooser;
function hideColumnChooser(beans) {
    beans.colChooserFactory?.hideActiveColumnChooser();
}
exports.hideColumnChooser = hideColumnChooser;


/***/ }),

/***/ 1708:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuItemMapper = exports._removeRepeatsFromArray = exports.MENU_ITEM_SEPARATOR = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
exports.MENU_ITEM_SEPARATOR = 'separator';
function _removeRepeatsFromArray(array, object) {
    if (!array) {
        return;
    }
    for (let index = array.length - 2; index >= 0; index--) {
        const thisOneMatches = array[index] === object;
        const nextOneMatches = array[index + 1] === object;
        if (thisOneMatches && nextOneMatches) {
            array.splice(index + 1, 1);
        }
    }
}
exports._removeRepeatsFromArray = _removeRepeatsFromArray;
class MenuItemMapper extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'menuItemMapper';
    }
    mapWithStockItems(originalList, column, sourceElement, source) {
        if (!originalList) {
            return [];
        }
        const resultList = [];
        const localeTextFunc = this.getLocaleTextFunc();
        const { beans, gos } = this;
        const { validation, pinnedCols, colAutosize, aggFuncSvc, rowGroupColsSvc, colNames, colModel, clipboardSvc, expansionSvc, focusSvc, csvCreator, excelCreator, menuSvc, colChooserFactory, sortSvc, chartMenuItemMapper, valueColsSvc, } = beans;
        const getStockMenuItem = (key, column, sourceElement, source) => {
            validation?.validateMenuItem(key);
            switch (key) {
                case 'pinSubMenu':
                    return pinnedCols && column
                        ? {
                            name: localeTextFunc('pinColumn', 'Pin Column'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('menuPin', beans, null),
                            subMenu: ['clearPinned', 'pinLeft', 'pinRight'],
                        }
                        : null;
                case 'pinLeft':
                    return pinnedCols && column
                        ? {
                            name: localeTextFunc('pinLeft', 'Pin Left'),
                            action: () => pinnedCols.setColsPinned([column], 'left', source),
                            checked: !!column && column.isPinnedLeft(),
                        }
                        : null;
                case 'pinRight':
                    return pinnedCols && column
                        ? {
                            name: localeTextFunc('pinRight', 'Pin Right'),
                            action: () => pinnedCols.setColsPinned([column], 'right', source),
                            checked: !!column && column.isPinnedRight(),
                        }
                        : null;
                case 'clearPinned':
                    return pinnedCols && column
                        ? {
                            name: localeTextFunc('noPin', 'No Pin'),
                            action: () => pinnedCols.setColsPinned([column], null, source),
                            checked: !!column && !column.isPinned(),
                        }
                        : null;
                case 'valueAggSubMenu':
                    if (aggFuncSvc && valueColsSvc && (column?.isPrimary() || column?.getColDef().pivotValueColumn)) {
                        return {
                            name: localeTextFunc('valueAggregation', 'Value Aggregation'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('menuValue', beans, null),
                            subMenu: createAggregationSubMenu(column, aggFuncSvc, valueColsSvc, localeTextFunc),
                            disabled: gos.get('functionsReadOnly'),
                        };
                    }
                    else {
                        return null;
                    }
                case 'autoSizeThis':
                    return colAutosize
                        ? {
                            name: localeTextFunc('autosizeThisColumn', 'Autosize This Column'),
                            action: () => colAutosize.autoSizeColumn(column, source, gos.get('skipHeaderOnAutoSize')),
                        }
                        : null;
                case 'autoSizeAll':
                    return colAutosize
                        ? {
                            name: localeTextFunc('autosizeAllColumns', 'Autosize All Columns'),
                            action: () => colAutosize.autoSizeAllColumns(source, gos.get('skipHeaderOnAutoSize')),
                        }
                        : null;
                case 'rowGroup':
                    return rowGroupColsSvc
                        ? {
                            name: localeTextFunc('groupBy', 'Group by') +
                                ' ' +
                                (0, ag_grid_community_1._escapeString)(colNames.getDisplayNameForColumn(column, 'header')),
                            disabled: gos.get('functionsReadOnly') ||
                                column?.isRowGroupActive() ||
                                !column?.getColDef().enableRowGroup,
                            action: () => rowGroupColsSvc.addColumns([column], source),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('menuAddRowGroup', beans, null),
                        }
                        : null;
                case 'rowUnGroup': {
                    if (rowGroupColsSvc && gos.isModuleRegistered('SharedRowGrouping')) {
                        const showRowGroup = column?.getColDef().showRowGroup;
                        const lockedGroups = gos.get('groupLockGroupColumns');
                        let name;
                        let disabled;
                        let action;
                        // Handle single auto group column
                        if (showRowGroup === true) {
                            name = localeTextFunc('ungroupAll', 'Un-Group All');
                            disabled =
                                gos.get('functionsReadOnly') ||
                                    lockedGroups === -1 ||
                                    lockedGroups >= (rowGroupColsSvc.columns.length ?? 0);
                            action = () => rowGroupColsSvc.setColumns(rowGroupColsSvc.columns.slice(0, lockedGroups), source);
                        }
                        else if (typeof showRowGroup === 'string') {
                            // Handle multiple auto group columns
                            const underlyingColumn = colModel.getColDefCol(showRowGroup);
                            const ungroupByName = underlyingColumn != null
                                ? (0, ag_grid_community_1._escapeString)(colNames.getDisplayNameForColumn(underlyingColumn, 'header'))
                                : showRowGroup;
                            name = localeTextFunc('ungroupBy', 'Un-Group by') + ' ' + ungroupByName;
                            disabled = gos.get('functionsReadOnly') || (0, rowGroupingUtils_1.isRowGroupColLocked)(underlyingColumn, beans);
                            action = () => {
                                rowGroupColsSvc.removeColumns([showRowGroup], source);
                            };
                        }
                        else {
                            // Handle primary column
                            name =
                                localeTextFunc('ungroupBy', 'Un-Group by') +
                                    ' ' +
                                    (0, ag_grid_community_1._escapeString)(colNames.getDisplayNameForColumn(column, 'header'));
                            disabled =
                                gos.get('functionsReadOnly') ||
                                    !column?.isRowGroupActive() ||
                                    !column?.getColDef().enableRowGroup ||
                                    (0, rowGroupingUtils_1.isRowGroupColLocked)(column, beans);
                            action = () => rowGroupColsSvc.removeColumns([column], source);
                        }
                        return {
                            name,
                            disabled,
                            action,
                            icon: (0, ag_grid_community_1._createIconNoSpan)('menuRemoveRowGroup', beans, null),
                        };
                    }
                    else {
                        return null;
                    }
                }
                case 'resetColumns':
                    return {
                        name: localeTextFunc('resetColumns', 'Reset Columns'),
                        action: () => (0, ag_grid_community_1._resetColumnState)(beans, source),
                    };
                case 'expandAll':
                    return expansionSvc
                        ? {
                            name: localeTextFunc('expandAll', 'Expand All Row Groups'),
                            action: () => expansionSvc.expandAll(true),
                        }
                        : null;
                case 'contractAll':
                    return expansionSvc
                        ? {
                            name: localeTextFunc('collapseAll', 'Collapse All Row Groups'),
                            action: () => expansionSvc.expandAll(false),
                        }
                        : null;
                case 'copy':
                    return clipboardSvc
                        ? {
                            name: localeTextFunc('copy', 'Copy'),
                            shortcut: localeTextFunc('ctrlC', 'Ctrl+C'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('clipboardCopy', beans, null),
                            action: () => clipboardSvc.copyToClipboard(),
                        }
                        : null;
                case 'copyWithHeaders':
                    return clipboardSvc
                        ? {
                            name: localeTextFunc('copyWithHeaders', 'Copy with Headers'),
                            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('clipboardCopy', beans, null),
                            action: () => clipboardSvc.copyToClipboard({ includeHeaders: true }),
                        }
                        : null;
                case 'copyWithGroupHeaders':
                    return clipboardSvc
                        ? {
                            name: localeTextFunc('copyWithGroupHeaders', 'Copy with Group Headers'),
                            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('clipboardCopy', beans, null),
                            action: () => clipboardSvc.copyToClipboard({ includeHeaders: true, includeGroupHeaders: true }),
                        }
                        : null;
                case 'cut':
                    if (clipboardSvc) {
                        const focusedCell = focusSvc.getFocusedCell();
                        const rowNode = focusedCell ? (0, ag_grid_community_1._getRowNode)(beans, focusedCell) : null;
                        const isEditable = rowNode ? focusedCell?.column.isCellEditable(rowNode) : false;
                        return {
                            name: localeTextFunc('cut', 'Cut'),
                            shortcut: localeTextFunc('ctrlX', 'Ctrl+X'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('clipboardCut', beans, null),
                            disabled: !isEditable || gos.get('suppressCutToClipboard'),
                            action: () => clipboardSvc.cutToClipboard(undefined, 'contextMenu'),
                        };
                    }
                    else {
                        return null;
                    }
                case 'paste':
                    return clipboardSvc
                        ? {
                            name: localeTextFunc('paste', 'Paste'),
                            shortcut: localeTextFunc('ctrlV', 'Ctrl+V'),
                            disabled: true,
                            icon: (0, ag_grid_community_1._createIconNoSpan)('clipboardPaste', beans, null),
                            action: () => clipboardSvc.pasteFromClipboard(),
                        }
                        : null;
                case 'export': {
                    const exportSubMenuItems = [];
                    if (!gos.get('suppressCsvExport') && csvCreator) {
                        exportSubMenuItems.push('csvExport');
                    }
                    if (!gos.get('suppressExcelExport') && excelCreator) {
                        exportSubMenuItems.push('excelExport');
                    }
                    return exportSubMenuItems.length
                        ? {
                            name: localeTextFunc('export', 'Export'),
                            subMenu: exportSubMenuItems,
                            icon: (0, ag_grid_community_1._createIconNoSpan)('save', beans, null),
                        }
                        : null;
                }
                case 'csvExport':
                    return csvCreator
                        ? {
                            name: localeTextFunc('csvExport', 'CSV Export'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('csvExport', beans, null),
                            action: () => csvCreator.exportDataAsCsv(),
                        }
                        : null;
                case 'excelExport':
                    return excelCreator
                        ? {
                            name: localeTextFunc('excelExport', 'Excel Export'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('excelExport', beans, null),
                            action: () => excelCreator.exportDataAsExcel(),
                        }
                        : null;
                case 'separator':
                    return 'separator';
                case 'pivotChart':
                case 'chartRange':
                    return chartMenuItemMapper.getChartItems(key);
                case 'columnFilter':
                    return menuSvc && column
                        ? {
                            name: localeTextFunc('columnFilter', 'Column Filter'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('filter', beans, null),
                            action: () => menuSvc.showFilterMenu({
                                column,
                                buttonElement: sourceElement(),
                                containerType: 'columnFilter',
                                positionBy: 'button',
                            }),
                        }
                        : null;
                case 'columnChooser':
                    return colChooserFactory
                        ? {
                            name: localeTextFunc('columnChooser', 'Choose Columns'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('columns', beans, null),
                            action: () => colChooserFactory.showColumnChooser({
                                column,
                                eventSource: sourceElement(),
                            }),
                        }
                        : null;
                case 'sortAscending':
                    return sortSvc
                        ? {
                            name: localeTextFunc('sortAscending', 'Sort Ascending'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('sortAscending', beans, null),
                            action: () => sortSvc.setSortForColumn(column, 'asc', false, source),
                        }
                        : null;
                case 'sortDescending':
                    return sortSvc
                        ? {
                            name: localeTextFunc('sortDescending', 'Sort Descending'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('sortDescending', beans, null),
                            action: () => sortSvc.setSortForColumn(column, 'desc', false, source),
                        }
                        : null;
                case 'sortUnSort':
                    return sortSvc
                        ? {
                            name: localeTextFunc('sortUnSort', 'Clear Sort'),
                            icon: (0, ag_grid_community_1._createIconNoSpan)('sortUnSort', beans, null),
                            action: () => sortSvc.setSortForColumn(column, null, false, source),
                        }
                        : null;
                default: {
                    (0, ag_grid_community_1._warn)(176, { key });
                    return null;
                }
            }
        };
        originalList.forEach((menuItemOrString) => {
            let result;
            if (typeof menuItemOrString === 'string') {
                result = getStockMenuItem(menuItemOrString, column, sourceElement, source);
            }
            else {
                // Spread to prevent leaking mapped subMenus back into the original menuItem
                result = { ...menuItemOrString };
            }
            // if no mapping, can happen when module is not loaded but user tries to use module anyway
            if (!result) {
                return;
            }
            const resultDef = result;
            const { subMenu } = resultDef;
            if (subMenu && subMenu instanceof Array) {
                resultDef.subMenu = this.mapWithStockItems(subMenu, column, sourceElement, source);
            }
            if (result != null) {
                resultList.push(result);
            }
        });
        // items could have been removed due to missing modules
        _removeRepeatsFromArray(resultList, exports.MENU_ITEM_SEPARATOR);
        return resultList;
    }
}
exports.MenuItemMapper = MenuItemMapper;
function createAggregationSubMenu(column, aggFuncSvc, valueColsSvc, localeTextFunc) {
    let columnToUse;
    if (column.isPrimary()) {
        columnToUse = column;
    }
    else {
        const pivotValueColumn = column.getColDef().pivotValueColumn;
        columnToUse = (0, ag_grid_community_1._exists)(pivotValueColumn) ? pivotValueColumn : undefined;
    }
    const result = [];
    if (columnToUse) {
        const columnIsAlreadyAggValue = columnToUse.isValueActive();
        const funcNames = aggFuncSvc.getFuncNames(columnToUse);
        result.push({
            name: localeTextFunc('noAggregation', 'None'),
            action: () => {
                valueColsSvc.removeColumns([columnToUse], 'contextMenu');
                valueColsSvc.setColumnAggFunc(columnToUse, undefined, 'contextMenu');
            },
            checked: !columnIsAlreadyAggValue,
        });
        funcNames.forEach((funcName) => {
            result.push({
                name: localeTextFunc(funcName, aggFuncSvc.getDefaultFuncLabel(funcName)),
                action: () => {
                    valueColsSvc.setColumnAggFunc(columnToUse, funcName, 'contextMenu');
                    valueColsSvc.addColumns([columnToUse], 'contextMenu');
                },
                checked: columnIsAlreadyAggValue && columnToUse.getAggFunc() === funcName,
            });
        });
    }
    return result;
}


/***/ }),

/***/ 7130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuModule = exports.ContextMenuModule = exports.ColumnMenuModule = exports.MenuCoreModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const menuItemModule_1 = __webpack_require__(3375);
const chartMenuItemMapper_1 = __webpack_require__(5636);
const columnChooserFactory_1 = __webpack_require__(9262);
const columnMenuFactory_1 = __webpack_require__(5884);
const contextMenu_1 = __webpack_require__(3461);
const enterpriseMenu_1 = __webpack_require__(6345);
const menuApi_1 = __webpack_require__(8228);
const menuItemMapper_1 = __webpack_require__(1708);
const menuUtils_1 = __webpack_require__(3569);
/**
 * @internal
 */
exports.MenuCoreModule = {
    moduleName: 'MenuCore',
    version: version_1.VERSION,
    beans: [menuItemMapper_1.MenuItemMapper, chartMenuItemMapper_1.ChartMenuItemMapper, menuUtils_1.MenuUtils],
    icons: {
        // context menu chart item
        chart: 'chart',
        // columns in menu (column chooser / columns tab)
        columns: 'columns',
        // loading async menu items
        loadingMenuItems: 'loading',
        // "Pin column" item in column header menu
        menuPin: 'pin',
        // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
        menuValue: 'aggregation',
        // "Group by {column-name}" item in column header menu
        menuAddRowGroup: 'group',
        // "Un-Group by {column-name}" item in column header menu
        menuRemoveRowGroup: 'group',
        // context menu copy item
        clipboardCopy: 'copy',
        // context menu cut item
        clipboardCut: 'cut',
        // context menu paste item
        clipboardPaste: 'paste',
        // context menu export item
        save: 'save',
        // csv export
        csvExport: 'csv',
        // excel export,
        excelExport: 'excel',
        // show on column header when column is sorted ascending
        sortAscending: 'asc',
        // show on column header when column is sorted descending
        sortDescending: 'desc',
        // show on column header when column has no sort, only when enabled with colDef.unSortIcon=true
        sortUnSort: 'none',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._PopupModule, ag_grid_community_1._SharedMenuModule, menuItemModule_1.MenuItemModule],
};
/**
 * @feature Accessories -> Column Menu
 */
exports.ColumnMenuModule = {
    moduleName: 'ColumnMenu',
    version: version_1.VERSION,
    beans: [enterpriseMenu_1.EnterpriseMenuFactory, columnMenuFactory_1.ColumnMenuFactory, columnChooserFactory_1.ColumnChooserFactory],
    icons: {
        // menu tab icon in legacy tabbed enterprise column menu
        legacyMenu: 'menu',
        // filter tab icon in legacy tabbed enterprise column menu
        filterTab: 'filter',
        // column tool panel column group contracted (click to expand)
        columnSelectClosed: 'tree-closed',
        // column tool panel column group expanded (click to contract)
        columnSelectOpen: 'tree-open',
        // column tool panel header expand/collapse all button, shown when some children are expanded and
        //     others are collapsed
        columnSelectIndeterminate: 'tree-indeterminate',
    },
    apiFunctions: {
        showColumnChooser: menuApi_1.showColumnChooser,
        hideColumnChooser: menuApi_1.hideColumnChooser,
    },
    dependsOn: [exports.MenuCoreModule, ag_grid_community_1._SharedDragAndDropModule, ag_grid_community_1._ColumnMoveModule],
};
/**
 * @feature Accessories -> Context Menu
 */
exports.ContextMenuModule = {
    moduleName: 'ContextMenu',
    version: version_1.VERSION,
    beans: [contextMenu_1.ContextMenuService],
    apiFunctions: {
        showContextMenu: menuApi_1.showContextMenu,
    },
    dependsOn: [exports.MenuCoreModule],
};
/**
 * @feature Accessories -> Column Menu / Context Menu
 */
exports.MenuModule = {
    moduleName: 'Menu',
    version: version_1.VERSION,
    dependsOn: [exports.ColumnMenuModule, exports.ContextMenuModule],
};


/***/ }),

/***/ 3569:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuUtils = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class MenuUtils extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'menuUtils';
    }
    restoreFocusOnClose(restoreFocusParams, eComp, e, restoreIfMouseEvent) {
        const { eventSource } = restoreFocusParams;
        const isKeyboardEvent = e instanceof KeyboardEvent;
        if ((!restoreIfMouseEvent && !isKeyboardEvent) || !eventSource) {
            return;
        }
        const activeEl = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        if (
        // focus is outside of comp
        !eComp.contains(activeEl) &&
            // something else has focus
            !(0, ag_grid_community_1._isNothingFocused)(this.beans)) {
            // don't return focus to the header
            return;
        }
        this.focusHeaderCell(restoreFocusParams);
    }
    closePopupAndRestoreFocusOnSelect(hidePopupFunc, restoreFocusParams, event) {
        let keyboardEvent;
        if (event && event.keyboardEvent) {
            keyboardEvent = event.keyboardEvent;
        }
        hidePopupFunc(keyboardEvent && { keyboardEvent });
        const beans = this.beans;
        const focusSvc = beans.focusSvc;
        // this method only gets called when the menu was closed by selecting an option
        // in this case we focus the cell that was previously focused, otherwise the header
        const focusedCell = focusSvc.getFocusedCell();
        if ((0, ag_grid_community_1._isNothingFocused)(beans)) {
            if (focusedCell) {
                const { rowIndex, rowPinned, column } = focusedCell;
                focusSvc.setFocusedCell({
                    rowIndex,
                    column,
                    rowPinned,
                    forceBrowserFocus: true,
                    preventScrollOnBrowserFocus: true,
                });
            }
            else {
                this.focusHeaderCell(restoreFocusParams);
            }
        }
    }
    onContextMenu(mouseEvent, touchEvent, showMenuCallback) {
        // to allow us to debug in chrome, we ignore the event if ctrl is pressed.
        // not everyone wants this, so first 'if' below allows to turn this hack off.
        if (!this.gos.get('allowContextMenuWithControlKey')) {
            // then do the check
            if (mouseEvent && (mouseEvent.ctrlKey || mouseEvent.metaKey)) {
                return;
            }
        }
        // need to do this regardless of context menu showing or not, so doing
        // before the isSuppressContextMenu() check
        if (mouseEvent) {
            this.blockMiddleClickScrollsIfNeeded(mouseEvent);
        }
        if (this.gos.get('suppressContextMenu')) {
            return;
        }
        const eventOrTouch = mouseEvent ?? touchEvent.touches[0];
        if (showMenuCallback(eventOrTouch)) {
            const event = mouseEvent ?? touchEvent;
            if (event && event.cancelable) {
                event.preventDefault();
            }
        }
    }
    // make this async for react
    async focusHeaderCell(restoreFocusParams) {
        const { column, columnIndex, headerPosition, eventSource } = restoreFocusParams;
        const { visibleCols, headerNavigation, focusSvc } = this.beans;
        // DO NOT REMOVE `await` from the statement below
        // even though `getAllCols` is a synchronous method, we use `await` to make it async
        const isColumnStillVisible = await visibleCols.allCols.some((col) => col === column);
        if (column && !column.isAlive()) {
            return;
        }
        if (isColumnStillVisible && eventSource && (0, ag_grid_community_1._isVisible)(eventSource)) {
            const focusableEl = (0, ag_grid_community_1._findTabbableParent)(eventSource);
            if (focusableEl) {
                if (column) {
                    headerNavigation?.scrollToColumn(column);
                }
                focusableEl.focus();
            }
        }
        // if the focusEl is no longer in the DOM, we try to focus
        // the header that is closest to the previous header position
        else if (headerPosition && columnIndex !== -1) {
            const allColumns = visibleCols.allCols;
            const columnToFocus = allColumns[columnIndex] || (0, ag_grid_community_1._last)(allColumns);
            if (columnToFocus) {
                focusSvc.focusHeaderPosition({
                    headerPosition: {
                        headerRowIndex: headerPosition.headerRowIndex,
                        column: columnToFocus,
                    },
                });
            }
        }
    }
    blockMiddleClickScrollsIfNeeded(mouseEvent) {
        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
        // button in the browser). so this property allows the user to receive middle button clicks if
        // they want.
        if (this.gos.get('suppressMiddleClickScrolls') && mouseEvent.which === 2) {
            mouseEvent.preventDefault();
        }
    }
}
exports.MenuUtils = MenuUtils;


/***/ }),

/***/ 6242:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTargetUnderManagedComponent = exports.findFocusableElementBeforeTabGuard = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function findFocusableElementBeforeTabGuard(rootNode, referenceElement) {
    if (!referenceElement) {
        return null;
    }
    const focusableElements = (0, ag_grid_community_1._findFocusableElements)(rootNode);
    const referenceIndex = focusableElements.indexOf(referenceElement);
    if (referenceIndex === -1) {
        return null;
    }
    let lastTabGuardIndex = -1;
    for (let i = referenceIndex - 1; i >= 0; i--) {
        if (focusableElements[i].classList.contains(ag_grid_community_1.TabGuardClassNames.TAB_GUARD_TOP)) {
            lastTabGuardIndex = i;
            break;
        }
    }
    if (lastTabGuardIndex <= 0) {
        return null;
    }
    return focusableElements[lastTabGuardIndex - 1];
}
exports.findFocusableElementBeforeTabGuard = findFocusableElementBeforeTabGuard;
function isTargetUnderManagedComponent(rootNode, target) {
    if (!target) {
        return false;
    }
    const managedContainers = rootNode.querySelectorAll(`.${ag_grid_community_1._FOCUS_MANAGED_CLASS}`);
    if (!managedContainers.length) {
        return false;
    }
    for (let i = 0; i < managedContainers.length; i++) {
        if (managedContainers[i].contains(target)) {
            return true;
        }
    }
    return false;
}
exports.isTargetUnderManagedComponent = isTargetUnderManagedComponent;


/***/ }),

/***/ 9038:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiFilter = exports.getMultiFilterDefs = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGroupComponent_1 = __webpack_require__(1421);
const agMenuItemComponent_1 = __webpack_require__(7040);
const agMenuItemRenderer_1 = __webpack_require__(3360);
function getMultiFilterDefs(params) {
    const { filters } = params;
    return filters && filters.length > 0
        ? filters
        : [{ filter: 'agTextColumnFilter' }, { filter: 'agSetColumnFilter' }];
}
exports.getMultiFilterDefs = getMultiFilterDefs;
function _forEachReverse(list, action) {
    if (list == null) {
        return;
    }
    for (let i = list.length - 1; i >= 0; i--) {
        action(list[i], i);
    }
}
function getFilterTitle(filter, filterDef) {
    if (filterDef.title != null) {
        return filterDef.title;
    }
    return filter instanceof ag_grid_community_1.ProvidedFilter ? filter.getFilterTitle() : 'Filter';
}
class MultiFilter extends ag_grid_community_1.TabGuardComp {
    constructor() {
        super(/* html */ `<div class="ag-multi-filter ag-menu-list-compact"></div>`);
        this.filterType = 'multi';
        this.filterDefs = [];
        this.filters = [];
        this.guiDestroyFuncs = [];
        // this could be the accordion/sub menu element depending on the display type
        this.filterGuis = [];
        this.activeFilterIndices = [];
        this.lastActivatedMenuItem = null;
        this.afterFiltersReadyFuncs = [];
    }
    postConstruct() {
        this.initialiseTabGuard({
            onFocusIn: (e) => this.onFocusIn(e),
        });
    }
    init(params) {
        this.params = params;
        this.filterDefs = getMultiFilterDefs(params);
        const { column, filterChangedCallback } = params;
        this.column = column;
        this.filterChangedCallback = filterChangedCallback;
        const filterPromises = [];
        this.filterDefs.forEach((filterDef, index) => {
            const filterPromise = this.createFilter(filterDef, index);
            if (filterPromise != null) {
                filterPromises.push(filterPromise);
            }
        });
        // we have to refresh the GUI here to ensure that Angular components are not rendered in odd places
        return new ag_grid_community_1.AgPromise((resolve) => {
            ag_grid_community_1.AgPromise.all(filterPromises).then((filters) => {
                this.filters = filters;
                this.refreshGui('columnMenu').then(() => {
                    resolve();
                });
            });
        }).then(() => {
            this.afterFiltersReadyFuncs.forEach((f) => f());
            this.afterFiltersReadyFuncs.length = 0;
        });
    }
    refreshGui(container) {
        if (container === this.lastOpenedInContainer) {
            return ag_grid_community_1.AgPromise.resolve();
        }
        this.tabGuardFeature.removeAllChildrenExceptTabGuards();
        this.destroyChildren();
        return ag_grid_community_1.AgPromise.all(this.filters.map((filter, index) => {
            const filterDef = this.filterDefs[index];
            const filterTitle = getFilterTitle(filter, filterDef);
            let filterGuiPromise;
            if (filterDef.display === 'subMenu' && container !== 'toolPanel') {
                // prevent sub-menu being used in tool panel
                filterGuiPromise = this.insertFilterMenu(filter, filterTitle).then((menuItem) => menuItem.getGui());
            }
            else if (filterDef.display === 'subMenu' || filterDef.display === 'accordion') {
                // sub-menus should appear as groups in the tool panel
                const group = this.insertFilterGroup(filter, filterTitle);
                filterGuiPromise = ag_grid_community_1.AgPromise.resolve(group.getGui());
            }
            else {
                // display inline
                filterGuiPromise = ag_grid_community_1.AgPromise.resolve(filter.getGui());
            }
            return filterGuiPromise;
        })).then((filterGuis) => {
            filterGuis.forEach((filterGui, index) => {
                if (index > 0) {
                    this.appendChild((0, ag_grid_community_1._loadTemplate)(/* html */ `<div class="ag-filter-separator"></div>`));
                }
                this.appendChild(filterGui);
            });
            this.filterGuis = filterGuis;
            this.lastOpenedInContainer = container;
        });
    }
    destroyChildren() {
        this.guiDestroyFuncs.forEach((func) => func());
        this.guiDestroyFuncs.length = 0;
        this.filterGuis.length = 0;
    }
    insertFilterMenu(filter, name) {
        const menuItem = this.createBean(new agMenuItemComponent_1.AgMenuItemComponent());
        return menuItem
            .init({
            menuItemDef: {
                name,
                subMenu: [],
                cssClasses: ['ag-multi-filter-menu-item'],
                menuItem: agMenuItemRenderer_1.AgMenuItemRenderer,
                menuItemParams: {
                    cssClassPrefix: 'ag-compact-menu-option',
                    isCompact: true,
                },
            },
            level: 0,
            isAnotherSubMenuOpen: () => false,
            childComponent: filter,
            contextParams: {
                column: null,
                node: null,
                value: null,
            },
        })
            .then(() => {
            menuItem.setParentComponent(this);
            this.guiDestroyFuncs.push(() => this.destroyBean(menuItem));
            this.addManagedListeners(menuItem, {
                menuItemActivated: (event) => {
                    if (this.lastActivatedMenuItem && this.lastActivatedMenuItem !== event.menuItem) {
                        this.lastActivatedMenuItem.deactivate();
                    }
                    this.lastActivatedMenuItem = event.menuItem;
                },
            });
            const menuItemGui = menuItem.getGui();
            menuItem.addManagedElementListeners(menuItemGui, {
                // `AgMenuList` normally handles keyboard navigation, so need to do here
                keydown: (e) => {
                    const { key } = e;
                    switch (key) {
                        case ag_grid_community_1.KeyCode.UP:
                        case ag_grid_community_1.KeyCode.RIGHT:
                        case ag_grid_community_1.KeyCode.DOWN:
                        case ag_grid_community_1.KeyCode.LEFT:
                            e.preventDefault();
                            if (key === ag_grid_community_1.KeyCode.RIGHT) {
                                menuItem.openSubMenu(true);
                            }
                            break;
                    }
                },
                focusin: () => menuItem.activate(),
                focusout: () => {
                    if (!menuItem.isSubMenuOpen() && !menuItem.isSubMenuOpening()) {
                        menuItem.deactivate();
                    }
                },
            });
            return menuItem;
        });
    }
    insertFilterGroup(filter, title) {
        const group = this.createBean(new agGroupComponent_1.AgGroupComponent({
            title,
            cssIdentifier: 'multi-filter',
        }));
        this.guiDestroyFuncs.push(() => this.destroyBean(group));
        group.addItem(filter.getGui());
        group.toggleGroupExpand(false);
        if (filter.afterGuiAttached) {
            group.addManagedListeners(group, {
                expanded: () => filter.afterGuiAttached({
                    container: this.lastOpenedInContainer,
                    suppressFocus: true,
                    hidePopup: this.hidePopup,
                }),
            });
        }
        return group;
    }
    isFilterActive() {
        return this.filters.some((filter) => filter.isFilterActive());
    }
    getLastActiveFilterIndex() {
        const activeFilterIndices = this.activeFilterIndices;
        return activeFilterIndices.length > 0 ? activeFilterIndices[activeFilterIndices.length - 1] : null;
    }
    doesFilterPass(params, filterToSkip) {
        let rowPasses = true;
        this.filters.forEach((filter) => {
            if (!rowPasses || filter === filterToSkip || !filter.isFilterActive()) {
                return;
            }
            rowPasses = filter.doesFilterPass(params);
        });
        return rowPasses;
    }
    getModelFromUi() {
        const model = {
            filterType: this.filterType,
            filterModels: this.filters.map((filter) => {
                const providedFilter = filter;
                if (typeof providedFilter.getModelFromUi === 'function') {
                    return providedFilter.getModelFromUi();
                }
                return null;
            }),
        };
        return model;
    }
    getModel() {
        if (!this.isFilterActive()) {
            return null;
        }
        const model = {
            filterType: this.filterType,
            filterModels: this.filters.map((filter) => {
                if (filter.isFilterActive()) {
                    return filter.getModel();
                }
                return null;
            }),
        };
        return model;
    }
    setModel(model) {
        const setFilterModel = (filter, filterModel) => {
            return new ag_grid_community_1.AgPromise((resolve) => {
                const promise = filter.setModel(filterModel);
                promise ? promise.then(() => resolve()) : resolve();
            });
        };
        let promises = [];
        if (model == null) {
            promises = this.filters.map((filter, index) => {
                const res = setFilterModel(filter, null).then(() => {
                    this.updateActiveList(index);
                });
                return res;
            });
        }
        else {
            this.filters.forEach((filter, index) => {
                const filterModel = model.filterModels.length > index ? model.filterModels[index] : null;
                const res = setFilterModel(filter, filterModel).then(() => {
                    this.updateActiveList(index);
                });
                promises.push(res);
            });
        }
        return ag_grid_community_1.AgPromise.all(promises).then(() => { });
    }
    applyModel(source = 'api') {
        let result = false;
        this.filters.forEach((filter) => {
            if (filter instanceof ag_grid_community_1.ProvidedFilter) {
                result = filter.applyModel(source) || result;
            }
        });
        return result;
    }
    getChildFilterInstance(index) {
        return this.filters[index];
    }
    afterGuiAttached(params) {
        let refreshPromise;
        if (params) {
            this.hidePopup = params.hidePopup;
            refreshPromise = this.refreshGui(params.container);
        }
        else {
            this.hidePopup = undefined;
            refreshPromise = ag_grid_community_1.AgPromise.resolve();
        }
        const suppressFocus = params?.suppressFocus;
        refreshPromise.then(() => {
            const { filterDefs, filters, filterGuis, beans } = this;
            // don't want to focus later if focus suppressed
            let hasFocused = !!suppressFocus;
            if (filterDefs) {
                _forEachReverse(filterDefs, (filterDef, index) => {
                    const isFirst = index === 0;
                    const notInlineDisplayType = filterDef.display && filterDef.display !== 'inline';
                    const suppressFocusForFilter = suppressFocus || !isFirst || notInlineDisplayType;
                    const afterGuiAttachedParams = { ...(params ?? {}), suppressFocus: suppressFocusForFilter };
                    const filter = filters?.[index];
                    if (filter) {
                        this.executeFunctionIfExistsOnFilter(filter, 'afterGuiAttached', afterGuiAttachedParams);
                        if (isFirst && !suppressFocusForFilter) {
                            hasFocused = true;
                        }
                    }
                    if (!suppressFocus && isFirst && notInlineDisplayType) {
                        // focus the first filter container instead (accordion/sub menu)
                        const filterGui = filterGuis[index];
                        if (filterGui) {
                            if (!(0, ag_grid_community_1._focusInto)(filterGui)) {
                                // menu item contains no focusable elements but is focusable itself
                                filterGui.focus({ preventScroll: true });
                            }
                            hasFocused = true;
                        }
                    }
                });
            }
            const activeEl = (0, ag_grid_community_1._getActiveDomElement)(beans);
            // if we haven't focused the first item in the filter, we might run into two scenarios:
            // 1 - we are loading the filter for the first time and the component isn't ready,
            //     which means the document will have focus.
            // 2 - The focus will be somewhere inside the component due to auto focus
            // In both cases we need to force the focus somewhere valid but outside the filter.
            if (!hasFocused && ((0, ag_grid_community_1._isNothingFocused)(beans) || this.getGui().contains(activeEl))) {
                // reset focus to the top of the container, and blur
                this.forceFocusOutOfContainer(true);
            }
        });
    }
    afterGuiDetached() {
        this.executeFunctionIfExists('afterGuiDetached');
    }
    onAnyFilterChanged() {
        this.executeFunctionIfExists('onAnyFilterChanged');
    }
    onNewRowsLoaded() {
        this.executeFunctionIfExists('onNewRowsLoaded');
    }
    destroy() {
        this.filters.forEach((filter) => this.destroyBean(filter));
        this.filters.length = 0;
        this.destroyChildren();
        this.hidePopup = undefined;
        super.destroy();
    }
    executeFunctionIfExists(name, ...params) {
        // The first filter is always the "dominant" one. By iterating in reverse order we ensure the first filter
        // always gets the last say
        _forEachReverse(this.filters, (filter) => {
            this.executeFunctionIfExistsOnFilter(filter, name, params);
        });
    }
    executeFunctionIfExistsOnFilter(filter, name, ...params) {
        const func = filter[name];
        if (typeof func === 'function') {
            func.apply(filter, params);
        }
    }
    createFilter(filterDef, index) {
        const { filterModifiedCallback, doesRowPassOtherFilter } = this.params;
        const { filterManager, userCompFactory } = this.beans;
        let filterInstance;
        const filterParams = {
            ...filterManager.createFilterParams(this.column, this.column.getColDef()),
            filterModifiedCallback,
            filterChangedCallback: (additionalEventAttributes) => {
                this.executeWhenAllFiltersReady(() => this.filterChanged(index, additionalEventAttributes));
            },
            doesRowPassOtherFilter: (node) => doesRowPassOtherFilter(node) && this.doesFilterPass({ node, data: node.data }, filterInstance),
        };
        const compDetails = (0, ag_grid_community_1._getFilterDetails)(userCompFactory, filterDef, filterParams, 'agTextColumnFilter');
        if (!compDetails) {
            return null;
        }
        const filterPromise = compDetails.newAgStackInstance();
        filterPromise.then((filter) => (filterInstance = filter));
        return filterPromise;
    }
    executeWhenAllFiltersReady(action) {
        if ((this.filters?.length ?? 0) > 0) {
            action();
        }
        else {
            this.afterFiltersReadyFuncs.push(action);
        }
    }
    updateActiveList(index) {
        const { filters, activeFilterIndices } = this;
        const changedFilter = filters[index];
        (0, ag_grid_community_1._removeFromArray)(activeFilterIndices, index);
        if (changedFilter.isFilterActive()) {
            activeFilterIndices.push(index);
        }
    }
    filterChanged(index, additionalEventAttributes) {
        this.updateActiveList(index);
        this.filterChangedCallback(additionalEventAttributes);
        const changedFilter = this.filters[index];
        this.filters.forEach((filter) => {
            if (filter === changedFilter) {
                return;
            }
            if (typeof filter.onAnyFilterChanged === 'function') {
                filter.onAnyFilterChanged();
            }
        });
    }
    onFocusIn(e) {
        const lastActivatedMenuItem = this.lastActivatedMenuItem;
        if (lastActivatedMenuItem != null && !lastActivatedMenuItem.getGui().contains(e.target)) {
            lastActivatedMenuItem.deactivate();
            this.lastActivatedMenuItem = null;
        }
    }
    getModelAsString(model) {
        if (!this.filters || !model?.filterModels?.length) {
            return '';
        }
        const lastActiveIndex = this.getLastActiveFilterIndex() ?? 0;
        const activeFilter = this.filters[lastActiveIndex];
        return activeFilter.getModelAsString?.(model.filterModels[lastActiveIndex]) ?? '';
    }
}
exports.MultiFilter = MultiFilter;


/***/ }),

/***/ 5434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiFilterModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const menuItemModule_1 = __webpack_require__(3375);
const multiFilter_1 = __webpack_require__(9038);
const multiFloatingFilter_1 = __webpack_require__(2335);
/**
 * @feature Filtering -> Multi Filter
 */
exports.MultiFilterModule = {
    moduleName: 'MultiFilter',
    version: version_1.VERSION,
    userComponents: { agMultiColumnFilter: multiFilter_1.MultiFilter, agMultiColumnFloatingFilter: multiFloatingFilter_1.MultiFloatingFilterComp },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._ColumnFilterModule, menuItemModule_1.MenuItemModule],
};


/***/ }),

/***/ 2335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiFloatingFilterComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const multiFilter_1 = __webpack_require__(9038);
class MultiFloatingFilterComp extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-multi-floating-filter ag-floating-filter-input"></div>`);
        this.floatingFilters = [];
        this.compDetailsList = [];
    }
    init(params) {
        this.params = params;
        const { compDetailsList } = this.getCompDetailsList(params);
        return this.setParams(compDetailsList);
    }
    setParams(compDetailsList) {
        const floatingFilterPromises = [];
        compDetailsList.forEach((compDetails) => {
            const floatingFilterPromise = compDetails?.newAgStackInstance();
            if (floatingFilterPromise != null) {
                this.compDetailsList.push(compDetails);
                floatingFilterPromises.push(floatingFilterPromise);
            }
        });
        return ag_grid_community_1.AgPromise.all(floatingFilterPromises).then((floatingFilters) => {
            floatingFilters.forEach((floatingFilter, index) => {
                this.floatingFilters.push(floatingFilter);
                const gui = floatingFilter.getGui();
                this.appendChild(gui);
                if (index > 0) {
                    (0, ag_grid_community_1._setDisplayed)(gui, false);
                }
            });
        });
    }
    refresh(params) {
        this.params = params;
        const { compDetailsList: newCompDetailsList, floatingFilterParamsList } = this.getCompDetailsList(params);
        const allFloatingFilterCompsUnchanged = newCompDetailsList.length === this.compDetailsList.length &&
            newCompDetailsList.every((newCompDetails, index) => !this.beans.filterManager?.areFilterCompsDifferent(this.compDetailsList[index], newCompDetails));
        if (allFloatingFilterCompsUnchanged) {
            floatingFilterParamsList.forEach((floatingFilterParams, index) => {
                const floatingFilter = this.floatingFilters[index];
                floatingFilter.refresh?.(floatingFilterParams);
            });
        }
        else {
            (0, ag_grid_community_1._clearElement)(this.getGui());
            this.destroyBeans(this.floatingFilters);
            this.floatingFilters = [];
            this.compDetailsList = [];
            this.setParams(newCompDetailsList);
        }
    }
    getCompDetailsList(params) {
        const compDetailsList = [];
        const floatingFilterParamsList = [];
        const filterParams = params.filterParams;
        const currentParentModel = params.currentParentModel;
        (0, multiFilter_1.getMultiFilterDefs)(filterParams).forEach((filterDef, index) => {
            const floatingFilterParams = {
                ...params,
                // set the parent filter instance for each floating filter to the relevant child filter instance
                parentFilterInstance: (callback) => {
                    this.parentMultiFilterInstance((parent) => {
                        const child = parent.getChildFilterInstance(index);
                        if (child == null) {
                            return;
                        }
                        callback(child);
                    });
                },
                // return the parent model for the specific filter
                currentParentModel: () => currentParentModel()?.filterModels?.[index] ?? null,
            };
            (0, ag_grid_community_1._mergeDeep)(floatingFilterParams.filterParams, filterDef.filterParams);
            const compDetails = this.getCompDetails(filterDef, floatingFilterParams);
            if (compDetails) {
                compDetailsList.push(compDetails);
                floatingFilterParamsList.push(floatingFilterParams);
            }
        });
        return { compDetailsList, floatingFilterParamsList };
    }
    onParentModelChanged(model, event) {
        // We don't want to update the floating filter if the floating filter caused the change,
        // because the UI is already in sync. if we didn't do this, the UI would behave strangely
        // as it would be updating as the user is typing
        if (event && event.afterFloatingFilter) {
            return;
        }
        this.parentMultiFilterInstance((parent) => {
            if (model == null) {
                this.floatingFilters.forEach((filter, i) => {
                    filter.onParentModelChanged(null, event);
                    (0, ag_grid_community_1._setDisplayed)(filter.getGui(), i === 0);
                });
            }
            else {
                const lastActiveFloatingFilterIndex = parent.getLastActiveFilterIndex();
                this.floatingFilters.forEach((filter, i) => {
                    const filterModel = model.filterModels.length > i ? model.filterModels[i] : null;
                    filter.onParentModelChanged(filterModel, event);
                    const shouldShow = lastActiveFloatingFilterIndex == null ? i === 0 : i === lastActiveFloatingFilterIndex;
                    (0, ag_grid_community_1._setDisplayed)(filter.getGui(), shouldShow);
                });
            }
        });
    }
    destroy() {
        this.destroyBeans(this.floatingFilters);
        this.floatingFilters.length = 0;
        super.destroy();
    }
    getCompDetails(filterDef, params) {
        const { filterManager, frameworkOverrides, userCompFactory } = this.beans;
        const defaultComponentName = (0, ag_grid_community_1._getDefaultFloatingFilterType)(frameworkOverrides, filterDef, () => filterManager.getDefaultFloatingFilter(this.params.column)) ?? 'agReadOnlyFloatingFilter';
        return (0, ag_grid_community_1._getFloatingFilterCompDetails)(userCompFactory, filterDef, params, defaultComponentName);
    }
    parentMultiFilterInstance(cb) {
        this.params.parentFilterInstance((parent) => {
            if (!(parent instanceof multiFilter_1.MultiFilter)) {
                (0, ag_grid_community_1._error)(120);
            }
            cb(parent);
        });
    }
}
exports.MultiFloatingFilterComp = MultiFloatingFilterComp;


/***/ }),

/***/ 5792:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPivotResultColumns = exports.setPivotResultColumns = exports.getPivotColumns = exports.addPivotColumns = exports.removePivotColumns = exports.setPivotColumns = exports.addValueColumns = exports.removeValueColumns = exports.getValueColumns = exports.setValueColumns = exports.getPivotResultColumn = exports.isPivotMode = void 0;
function isPivotMode(beans) {
    return beans.colModel.isPivotMode();
}
exports.isPivotMode = isPivotMode;
function getPivotResultColumn(beans, pivotKeys, valueColKey) {
    return beans.pivotResultCols?.lookupPivotResultCol(pivotKeys, valueColKey) ?? null;
}
exports.getPivotResultColumn = getPivotResultColumn;
function setValueColumns(beans, colKeys) {
    beans.valueColsSvc?.setColumns(colKeys, 'api');
}
exports.setValueColumns = setValueColumns;
function getValueColumns(beans) {
    return beans.valueColsSvc?.columns ?? [];
}
exports.getValueColumns = getValueColumns;
function removeValueColumns(beans, colKeys) {
    beans.valueColsSvc?.removeColumns(colKeys, 'api');
}
exports.removeValueColumns = removeValueColumns;
function addValueColumns(beans, colKeys) {
    beans.valueColsSvc?.addColumns(colKeys, 'api');
}
exports.addValueColumns = addValueColumns;
function setPivotColumns(beans, colKeys) {
    beans.pivotColsSvc?.setColumns(colKeys, 'api');
}
exports.setPivotColumns = setPivotColumns;
function removePivotColumns(beans, colKeys) {
    beans.pivotColsSvc?.removeColumns(colKeys, 'api');
}
exports.removePivotColumns = removePivotColumns;
function addPivotColumns(beans, colKeys) {
    beans.pivotColsSvc?.addColumns(colKeys, 'api');
}
exports.addPivotColumns = addPivotColumns;
function getPivotColumns(beans) {
    return beans.pivotColsSvc?.columns ?? [];
}
exports.getPivotColumns = getPivotColumns;
function setPivotResultColumns(beans, colDefs) {
    beans.pivotResultCols?.setPivotResultCols(colDefs, 'api');
}
exports.setPivotResultColumns = setPivotResultColumns;
function getPivotResultColumns(beans) {
    const pivotResultCols = beans.pivotResultCols?.getPivotResultCols();
    return pivotResultCols ? pivotResultCols.list : null;
}
exports.getPivotResultColumns = getPivotResultColumns;


/***/ }),

/***/ 6616:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotColDefService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const PIVOT_ROW_TOTAL_PREFIX = 'PivotRowTotal_';
class PivotColDefService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pivotColDefSvc';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.pivotColsSvc = beans.pivotColsSvc;
        this.valueColsSvc = beans.valueColsSvc;
        this.colNames = beans.colNames;
    }
    postConstruct() {
        const getFieldSeparator = () => this.gos.get('serverSidePivotResultFieldSeparator') ?? '_';
        this.fieldSeparator = getFieldSeparator();
        this.addManagedPropertyListener('serverSidePivotResultFieldSeparator', () => {
            this.fieldSeparator = getFieldSeparator();
        });
        const getPivotDefaultExpanded = () => this.gos.get('pivotDefaultExpanded');
        this.pivotDefaultExpanded = getPivotDefaultExpanded();
        this.addManagedPropertyListener('pivotDefaultExpanded', () => {
            this.pivotDefaultExpanded = getPivotDefaultExpanded();
        });
    }
    createPivotColumnDefs(uniqueValues) {
        // this is passed to the colModel, to configure the columns and groups we show
        const pivotColumnGroupDefs = this.createPivotColumnsFromUniqueValues(uniqueValues);
        function extractColDefs(input, arr = []) {
            input.forEach((def) => {
                if (def.children !== undefined) {
                    extractColDefs(def.children, arr);
                }
                else {
                    arr.push(def);
                }
            });
            return arr;
        }
        const pivotColumnDefs = extractColDefs(pivotColumnGroupDefs);
        // additional columns that contain the aggregated total for each value column per row
        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs);
        // additional group columns that contain child totals for each collapsed child column / group
        this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs);
        // additional group columns that contain an aggregated total across all child columns
        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs);
        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that
        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,
        // as these use the col defs also
        const pivotColumnDefsClone = pivotColumnDefs.map((colDef) => ({ ...colDef }));
        return {
            pivotColumnGroupDefs: pivotColumnGroupDefs,
            pivotColumnDefs: pivotColumnDefsClone,
        };
    }
    createPivotColumnsFromUniqueValues(uniqueValues) {
        const pivotColumns = this.pivotColsSvc?.columns ?? [];
        const maxDepth = pivotColumns.length;
        const pivotColumnGroupDefs = this.recursivelyBuildGroup(0, uniqueValues, [], maxDepth, pivotColumns);
        return pivotColumnGroupDefs;
    }
    recursivelyBuildGroup(index, uniqueValue, pivotKeys, maxDepth, primaryPivotColumns) {
        const measureColumns = this.valueColsSvc?.columns;
        if (index >= maxDepth) {
            // Base case - build the measure columns
            return this.buildMeasureCols(pivotKeys);
        }
        // sort by either user provided comparator, or our own one
        const primaryPivotColumnDefs = primaryPivotColumns[index].getColDef();
        const comparator = this.headerNameComparator.bind(this, primaryPivotColumnDefs.pivotComparator);
        // Base case for the compact layout, instead of recursing build the last layer of groups as measure columns instead
        if (measureColumns?.length === 1 &&
            this.gos.get('removePivotHeaderRowWhenSingleValueColumn') &&
            index === maxDepth - 1) {
            const leafCols = [];
            for (const key of Object.keys(uniqueValue)) {
                const newPivotKeys = [...pivotKeys, key];
                const colDef = this.createColDef(measureColumns[0], key, newPivotKeys);
                colDef.columnGroupShow = 'open';
                leafCols.push(colDef);
            }
            leafCols.sort(comparator);
            return leafCols;
        }
        // Recursive case
        const groups = [];
        for (const [key, value] of Object.entries(uniqueValue)) {
            // expand group by default based on depth of group. (pivotDefaultExpanded provides desired level of depth for expanding group by default)
            const openByDefault = this.pivotDefaultExpanded === -1 || index < this.pivotDefaultExpanded;
            const newPivotKeys = [...pivotKeys, key];
            groups.push({
                children: this.recursivelyBuildGroup(index + 1, value, newPivotKeys, maxDepth, primaryPivotColumns),
                headerName: key,
                pivotKeys: newPivotKeys,
                columnGroupShow: 'open',
                openByDefault: openByDefault,
                groupId: this.generateColumnGroupId(newPivotKeys),
            });
        }
        groups.sort(comparator);
        return groups;
    }
    buildMeasureCols(pivotKeys) {
        const measureColumns = this.valueColsSvc?.columns ?? [];
        if (measureColumns.length === 0) {
            // if no value columns selected, then we insert one blank column, so the user at least sees columns
            // rendered. otherwise the grid would render with no columns (just empty groups) which would give the
            // impression that the grid is broken
            return [this.createColDef(null, '-', pivotKeys)];
        }
        return measureColumns.map((measureCol) => {
            const columnName = this.colNames.getDisplayNameForColumn(measureCol, 'header');
            return {
                ...this.createColDef(measureCol, columnName, pivotKeys),
                columnGroupShow: 'open',
            };
        });
    }
    addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs) {
        const isSuppressExpand = this.gos.get('suppressExpandablePivotGroups');
        if (isSuppressExpand || this.gos.get('pivotColumnGroupTotals')) {
            return;
        }
        const recursivelyAddSubTotals = (def, currentPivotColumnDefs, acc) => {
            if ('children' in def) {
                const childAcc = new Map();
                def.children.forEach((grp) => {
                    recursivelyAddSubTotals(grp, currentPivotColumnDefs, childAcc);
                });
                const leafGroup = !def.children.some((child) => child.children);
                this.valueColsSvc?.columns.forEach((valueColumn) => {
                    const columnName = this.colNames.getDisplayNameForColumn(valueColumn, 'header');
                    const totalColDef = this.createColDef(valueColumn, columnName, def.pivotKeys);
                    totalColDef.pivotTotalColumnIds = childAcc.get(valueColumn.getColId());
                    totalColDef.columnGroupShow = !isSuppressExpand ? 'closed' : 'open';
                    totalColDef.aggFunc = valueColumn.getAggFunc();
                    if (!leafGroup) {
                        // add total colDef to group and pivot colDefs array
                        const children = def.children;
                        children.push(totalColDef);
                        currentPivotColumnDefs.push(totalColDef);
                    }
                });
                this.merge(acc, childAcc);
                return;
            }
            // check that value column exists, i.e. aggFunc is supplied
            if (!def.pivotValueColumn) {
                return;
            }
            const pivotValueColId = def.pivotValueColumn.getColId();
            const exists = acc.has(pivotValueColId);
            if (exists) {
                const arr = acc.get(pivotValueColId);
                arr.push(def.colId);
            }
            else {
                acc.set(pivotValueColId, [def.colId]);
            }
        };
        pivotColumnGroupDefs.forEach((groupDef) => {
            recursivelyAddSubTotals(groupDef, pivotColumnDefs, new Map());
        });
    }
    addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs) {
        if (!this.gos.get('pivotColumnGroupTotals')) {
            return;
        }
        const insertAfter = this.gos.get('pivotColumnGroupTotals') === 'after';
        const valueCols = this.valueColsSvc?.columns;
        const aggFuncs = valueCols?.map((valueCol) => valueCol.getAggFunc());
        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same
        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {
            // console.warn('AG Grid: aborting adding pivot total columns - value columns require same aggFunc');
            return;
        }
        if (valueCols) {
            // arbitrarily select a value column to use as a template for pivot columns
            const valueColumn = valueCols[0];
            pivotColumnGroupDefs.forEach((groupDef) => {
                this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter);
            });
        }
    }
    recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter) {
        const group = groupDef;
        if (!group.children) {
            const def = groupDef;
            return def.colId ? [def.colId] : null;
        }
        let colIds = [];
        // need to recurse children first to obtain colIds used in the aggregation stage
        group.children.forEach((grp) => {
            const childColIds = this.recursivelyAddPivotTotal(grp, pivotColumnDefs, valueColumn, insertAfter);
            if (childColIds) {
                colIds = colIds.concat(childColIds);
            }
        });
        // only add total colDef if there is more than 1 child node
        if (group.children.length > 1) {
            const localeTextFunc = this.getLocaleTextFunc();
            const headerName = localeTextFunc('pivotColumnGroupTotals', 'Total');
            //create total colDef using an arbitrary value column as a template
            const totalColDef = this.createColDef(valueColumn, headerName, groupDef.pivotKeys, true);
            totalColDef.pivotTotalColumnIds = colIds;
            totalColDef.aggFunc = valueColumn.getAggFunc();
            totalColDef.columnGroupShow = this.gos.get('suppressExpandablePivotGroups') ? 'open' : undefined;
            // add total colDef to group and pivot colDefs array
            const children = groupDef.children;
            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);
            pivotColumnDefs.push(totalColDef);
        }
        return colIds;
    }
    addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs) {
        if (!this.gos.get('pivotRowTotals')) {
            return;
        }
        const insertAtEnd = this.gos.get('pivotRowTotals') === 'after';
        const valueColumns = this.valueColsSvc?.columns ?? [];
        const valueCols = valueColumns.slice();
        if (!insertAtEnd) {
            // if inserting before, we use unshift to insert at the start, so reverse the order to maintain the order of value cols
            valueCols.reverse();
        }
        const isCreateTotalGroups = valueCols.length > 1 || !this.gos.get('removePivotHeaderRowWhenSingleValueColumn');
        for (let i = 0; i < valueCols.length; i++) {
            const valueCol = valueCols[i];
            const columnName = this.colNames.getDisplayNameForColumn(valueCol, 'header');
            const colDef = this.createColDef(valueCol, columnName, []);
            const colIds = [];
            for (let i = 0; i < pivotColumnDefs.length; i++) {
                const colDef = pivotColumnDefs[i];
                if (colDef.pivotValueColumn === valueCol) {
                    colIds.push(colDef.colId);
                }
            }
            colDef.pivotTotalColumnIds = colIds;
            colDef.colId = PIVOT_ROW_TOTAL_PREFIX + colDef.colId;
            const valueGroup = isCreateTotalGroups
                ? {
                    children: [colDef],
                    pivotKeys: [],
                    groupId: `${PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${valueCol.getColId()}`,
                }
                : colDef;
            pivotColumnDefs.push(colDef);
            insertAtEnd ? pivotColumnGroupDefs.push(valueGroup) : pivotColumnGroupDefs.unshift(valueGroup);
        }
    }
    createColDef(valueColumn, headerName, pivotKeys, totalColumn = false) {
        const colDef = {};
        // This is null when there are no measure columns and we're creating placeholder columns
        if (valueColumn) {
            const colDefToCopy = valueColumn.getColDef();
            Object.assign(colDef, colDefToCopy);
            // even if original column was hidden, we always show the pivot value column, otherwise it would be
            // very confusing for people thinking the pivot is broken
            colDef.hide = false;
        }
        colDef.headerName = headerName;
        colDef.colId = this.generateColumnId(pivotKeys || [], valueColumn && !totalColumn ? valueColumn.getColId() : '');
        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to
        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.
        colDef.field = colDef.colId;
        // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
        // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
        colDef.valueGetter = (params) => params.data?.[params.colDef.field];
        colDef.pivotKeys = pivotKeys;
        colDef.pivotValueColumn = valueColumn;
        if (colDef.filter === true) {
            colDef.filter = 'agNumberColumnFilter';
        }
        return colDef;
    }
    sameAggFuncs(aggFuncs) {
        if (aggFuncs.length == 1) {
            return true;
        }
        //check if all aggFunc's match
        for (let i = 1; i < aggFuncs.length; i++) {
            if (aggFuncs[i] !== aggFuncs[0]) {
                return false;
            }
        }
        return true;
    }
    headerNameComparator(userComparator, a, b) {
        if (userComparator) {
            return userComparator(a.headerName, b.headerName);
        }
        else {
            if (a.headerName && !b.headerName) {
                return 1;
            }
            else if (!a.headerName && b.headerName) {
                return -1;
            }
            // slightly naff here - just to satify typescript
            // really should be &&, but if so ts complains
            // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are
            // ..still naff though
            if (!a.headerName || !b.headerName) {
                return 0;
            }
            if (a.headerName < b.headerName) {
                return -1;
            }
            if (a.headerName > b.headerName) {
                return 1;
            }
            return 0;
        }
    }
    merge(m1, m2) {
        m2.forEach((value, key) => {
            const existingList = m1.has(key) ? m1.get(key) : [];
            const updatedList = [...existingList, ...value];
            m1.set(key, updatedList);
        });
    }
    generateColumnGroupId(pivotKeys) {
        const pivotCols = (this.pivotColsSvc?.columns ?? []).map((col) => col.getColId());
        return `pivotGroup_${pivotCols.join('-')}_${pivotKeys.join('-')}`;
    }
    generateColumnId(pivotKeys, measureColumnId) {
        const pivotCols = (this.pivotColsSvc?.columns ?? []).map((col) => col.getColId());
        return `pivot_${pivotCols.join('-')}_${pivotKeys.join('-')}_${measureColumnId}`;
    }
    /**
     * Used by the SSRM to create secondary columns from provided fields
     * @param fields
     */
    createColDefsFromFields(fields) {
        // tear the ids down into groups, while this could be done in-step with the next stage, the lookup is faster
        // than searching col group children array for the right group
        const uniqueValues = {};
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const parts = field.split(this.fieldSeparator);
            let level = uniqueValues;
            for (let p = 0; p < parts.length; p++) {
                const part = parts[p];
                if (level[part] == null) {
                    level[part] = {};
                }
                level = level[part];
            }
        }
        const uniqueValuesToGroups = (id, key, uniqueValues, depth) => {
            const children = [];
            for (const key of Object.keys(uniqueValues)) {
                const item = uniqueValues[key];
                const child = uniqueValuesToGroups(`${id}${this.fieldSeparator}${key}`, key, item, depth + 1);
                children.push(child);
            }
            if (children.length === 0) {
                const potentialAggCol = this.colModel.getColDefCol(key);
                if (potentialAggCol) {
                    const headerName = this.colNames.getDisplayNameForColumn(potentialAggCol, 'header') ?? key;
                    const colDef = this.createColDef(potentialAggCol, headerName, undefined, false);
                    colDef.colId = id;
                    colDef.aggFunc = potentialAggCol.getAggFunc();
                    colDef.valueGetter = (params) => params.data?.[id];
                    return colDef;
                }
                const col = {
                    colId: id,
                    headerName: key,
                    // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
                    // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
                    valueGetter: (params) => params.data?.[id],
                };
                return col;
            }
            // this is a bit sketchy. As the fields can be anything we just build groups as deep as the fields go.
            // nothing says user has to give us groups the same depth.
            const collapseSingleChildren = this.gos.get('removePivotHeaderRowWhenSingleValueColumn');
            if (collapseSingleChildren && children.length === 1 && 'colId' in children[0]) {
                children[0].headerName = key;
                return children[0];
            }
            const group = {
                openByDefault: this.pivotDefaultExpanded === -1 || depth < this.pivotDefaultExpanded,
                groupId: id,
                headerName: key,
                children,
            };
            return group;
        };
        const res = [];
        for (const key of Object.keys(uniqueValues)) {
            const item = uniqueValues[key];
            const col = uniqueValuesToGroups(key, key, item, 0);
            res.push(col);
        }
        return res;
    }
}
exports.PivotColDefService = PivotColDefService;


/***/ }),

/***/ 3227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotColsSvc = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class PivotColsSvc extends ag_grid_community_1.BaseColsService {
    constructor() {
        super(...arguments);
        this.beanName = 'pivotColsSvc';
        this.eventName = 'columnPivotChanged';
        this.columnProcessors = {
            set: (column, added, source) => this.setColPivotActive(column, added, source),
            add: (column, added, source) => this.setColPivotActive(column, true, source),
            remove: (column, added, source) => this.setColPivotActive(column, false, source),
        };
        this.columnOrdering = {
            enableProp: 'pivot',
            initialEnableProp: 'initialPivot',
            indexProp: 'pivotIndex',
            initialIndexProp: 'initialPivotIndex',
        };
        this.columnExtractors = {
            setFlagFunc: (col, flag, source) => this.setColPivotActive(col, flag, source),
            getIndexFunc: (colDef) => colDef.pivotIndex,
            getInitialIndexFunc: (colDef) => colDef.initialPivotIndex,
            getValueFunc: (colDef) => colDef.pivot,
            getInitialValueFunc: (colDef) => colDef.initialPivot,
        };
        this.modifyColumnsNoEventsCallbacks = {
            addCol: (column) => this.columns.push(column),
            removeCol: (column) => (0, ag_grid_community_1._removeFromArray)(this.columns, column),
        };
    }
    syncColumnWithState(column, source, getValue, rowIndex) {
        const { value1: pivot, value2: pivotIndex } = getValue('pivot', 'pivotIndex');
        if (pivot !== undefined || pivotIndex !== undefined) {
            if (typeof pivotIndex === 'number' || pivot) {
                if (!column.isPivotActive()) {
                    this.setColPivotActive(column, true, source);
                    this.modifyColumnsNoEventsCallbacks.addCol(column);
                }
                if (rowIndex && typeof pivotIndex === 'number') {
                    rowIndex[column.getId()] = pivotIndex;
                }
            }
            else {
                if (column.isPivotActive()) {
                    this.setColPivotActive(column, false, source);
                    this.modifyColumnsNoEventsCallbacks.removeCol(column);
                }
            }
        }
    }
    setColPivotActive(column, pivot, source) {
        if (column.pivotActive !== pivot) {
            column.pivotActive = pivot;
            column.dispatchColEvent('columnPivotChanged', source);
        }
        column.dispatchStateUpdatedEvent('pivot');
    }
}
exports.PivotColsSvc = PivotColsSvc;


/***/ }),

/***/ 5470:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotModule = exports.SharedPivotModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingModule_1 = __webpack_require__(1442);
const rowHierarchyModule_1 = __webpack_require__(6858);
const version_1 = __webpack_require__(7205);
const pivotApi_1 = __webpack_require__(5792);
const pivotColDefService_1 = __webpack_require__(6616);
const pivotColsSvc_1 = __webpack_require__(3227);
const pivotResultColsService_1 = __webpack_require__(6465);
const pivotStage_1 = __webpack_require__(5374);
/**
 * @internal
 */
exports.SharedPivotModule = {
    moduleName: 'SharedPivot',
    version: version_1.VERSION,
    beans: [pivotResultColsService_1.PivotResultColsService, pivotColDefService_1.PivotColDefService, pivotColsSvc_1.PivotColsSvc],
    apiFunctions: {
        isPivotMode: pivotApi_1.isPivotMode,
        getPivotResultColumn: pivotApi_1.getPivotResultColumn,
        setValueColumns: pivotApi_1.setValueColumns,
        getValueColumns: pivotApi_1.getValueColumns,
        removeValueColumns: pivotApi_1.removeValueColumns,
        addValueColumns: pivotApi_1.addValueColumns,
        setPivotColumns: pivotApi_1.setPivotColumns,
        removePivotColumns: pivotApi_1.removePivotColumns,
        addPivotColumns: pivotApi_1.addPivotColumns,
        getPivotColumns: pivotApi_1.getPivotColumns,
        setPivotResultColumns: pivotApi_1.setPivotResultColumns,
        getPivotResultColumns: pivotApi_1.getPivotResultColumns,
    },
    dependsOn: [rowGroupingModule_1.SharedRowGroupingModule, ag_grid_community_1._ColumnGroupModule],
};
/**
 * @feature Pivoting
 * @colDef pivot, enablePivot
 * @gridOption pivotMode
 */
exports.PivotModule = {
    moduleName: 'Pivot',
    version: version_1.VERSION,
    rowModels: ['clientSide'],
    beans: [pivotStage_1.PivotStage],
    dependsOn: [exports.SharedPivotModule, rowGroupingModule_1.RowGroupingModule, rowHierarchyModule_1.ClientSideRowModelHierarchyModule],
};


/***/ }),

/***/ 6465:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotResultColsService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class PivotResultColsService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pivotResultCols';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.visibleCols = beans.visibleCols;
    }
    destroy() {
        (0, ag_grid_community_1._destroyColumnTree)(this.beans, this.pivotResultCols?.tree);
        super.destroy();
    }
    isPivotResultColsPresent() {
        return this.pivotResultCols != null;
    }
    lookupPivotResultCol(pivotKeys, valueColKey) {
        if (this.pivotResultCols == null) {
            return null;
        }
        const valueColumnToFind = this.colModel.getColDefCol(valueColKey);
        let foundColumn = null;
        this.pivotResultCols.list.forEach((column) => {
            const thisPivotKeys = column.getColDef().pivotKeys;
            const pivotValueColumn = column.getColDef().pivotValueColumn;
            const pivotKeyMatches = (0, ag_grid_community_1._areEqual)(thisPivotKeys, pivotKeys);
            const pivotValueMatches = pivotValueColumn === valueColumnToFind;
            if (pivotKeyMatches && pivotValueMatches) {
                foundColumn = column;
            }
        });
        return foundColumn;
    }
    getPivotResultCols() {
        return this.pivotResultCols;
    }
    getPivotResultCol(key) {
        if (!this.pivotResultCols) {
            return null;
        }
        return this.colModel.getColFromCollection(key, this.pivotResultCols);
    }
    setPivotResultCols(colDefs, source) {
        if (!this.colModel.ready) {
            return;
        }
        // if no cols passed, and we had no cols anyway, then do nothing
        if (colDefs == null && this.pivotResultCols == null) {
            return;
        }
        if (colDefs) {
            this.processPivotResultColDef(colDefs);
            const balancedTreeResult = (0, ag_grid_community_1._createColumnTree)(this.beans, colDefs, false, this.pivotResultCols?.tree || this.previousPivotResultCols || undefined, source);
            (0, ag_grid_community_1._destroyColumnTree)(this.beans, this.pivotResultCols?.tree, balancedTreeResult.columnTree);
            const tree = balancedTreeResult.columnTree;
            const treeDepth = balancedTreeResult.treeDept;
            const list = (0, ag_grid_community_1._getColumnsFromTree)(tree);
            const map = {};
            this.pivotResultCols = { tree, treeDepth, list, map };
            this.pivotResultCols.list.forEach((col) => (this.pivotResultCols.map[col.getId()] = col));
            const hasPreviousCols = !!this.previousPivotResultCols;
            this.previousPivotResultCols = null;
            this.colModel.refreshCols(!hasPreviousCols);
        }
        else {
            this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null;
            this.pivotResultCols = null;
            this.colModel.refreshCols(false);
        }
        this.visibleCols.refresh(source);
    }
    processPivotResultColDef(colDefs) {
        const columnCallback = this.gos.get('processPivotResultColDef');
        const groupCallback = this.gos.get('processPivotResultColGroupDef');
        if (!columnCallback && !groupCallback) {
            return undefined;
        }
        const searchForColDefs = (colDefs2) => {
            colDefs2.forEach((abstractColDef) => {
                const isGroup = (0, ag_grid_community_1._exists)(abstractColDef.children);
                if (isGroup) {
                    const colGroupDef = abstractColDef;
                    if (groupCallback) {
                        groupCallback(colGroupDef);
                    }
                    searchForColDefs(colGroupDef.children);
                }
                else {
                    const colDef = abstractColDef;
                    if (columnCallback) {
                        columnCallback(colDef);
                    }
                }
            });
        };
        if (colDefs) {
            searchForColDefs(colDefs);
        }
    }
}
exports.PivotResultColsService = PivotResultColsService;


/***/ }),

/***/ 5374:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotStage = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const EXCEEDED_MAX_UNIQUE_VALUES = 'Exceeded maximum allowed pivot column count.';
class PivotStage extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pivotStage';
        this.refreshProps = new Set([
            'removePivotHeaderRowWhenSingleValueColumn',
            'pivotRowTotals',
            'pivotColumnGroupTotals',
            'suppressExpandablePivotGroups',
        ]);
        this.step = 'pivot';
        this.uniqueValues = {};
        this.lastTimeFailed = false;
        this.maxUniqueValues = -1;
        this.currentUniqueCount = 0;
    }
    wireBeans(beans) {
        this.valueSvc = beans.valueSvc;
        this.colModel = beans.colModel;
        this.pivotResultCols = beans.pivotResultCols;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.valueColsSvc = beans.valueColsSvc;
        this.pivotColsSvc = beans.pivotColsSvc;
        this.pivotColDefSvc = beans.pivotColDefSvc;
    }
    execute(params) {
        const changedPath = params.changedPath;
        if (this.colModel.isPivotActive()) {
            this.executePivotOn(changedPath);
        }
        else {
            this.executePivotOff(changedPath);
        }
    }
    executePivotOff(changedPath) {
        this.aggregationColumnsHashLastTime = null;
        this.uniqueValues = {};
        if (this.pivotResultCols.isPivotResultColsPresent()) {
            this.pivotResultCols.setPivotResultCols(null, 'rowModelUpdated');
            if (changedPath) {
                changedPath.active = false;
            }
        }
    }
    executePivotOn(changedPath) {
        const numberOfAggregationColumns = this.valueColsSvc?.columns.length ?? 1;
        // As unique values creates one column per aggregation column, divide max columns by number of aggregation columns
        // to get the max number of unique values.
        const configuredMaxCols = this.gos.get('pivotMaxGeneratedColumns');
        this.maxUniqueValues = configuredMaxCols === -1 ? -1 : configuredMaxCols / numberOfAggregationColumns;
        let uniqueValues;
        try {
            // try catch is used to force execution to stop when the max count is exceeded.
            uniqueValues = this.bucketUpRowNodes(changedPath);
        }
        catch (e) {
            // message is checked rather than inheritance as the build seems to break instanceof
            if (e.message === EXCEEDED_MAX_UNIQUE_VALUES) {
                this.pivotResultCols.setPivotResultCols([], 'rowModelUpdated');
                this.eventSvc.dispatchEvent({
                    type: 'pivotMaxColumnsExceeded',
                    message: e.message,
                });
                this.lastTimeFailed = true;
                return;
            }
            throw e;
        }
        const uniqueValuesChanged = this.setUniqueValues(uniqueValues);
        const aggregationColumns = this.valueColsSvc?.columns ?? [];
        const aggregationColumnsHash = aggregationColumns
            .map((column) => `${column.getId()}-${column.getColDef().headerName}`)
            .join('#');
        const aggregationFuncsHash = aggregationColumns.map((column) => column.getAggFunc().toString()).join('#');
        const aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;
        const aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;
        this.aggregationColumnsHashLastTime = aggregationColumnsHash;
        this.aggregationFuncsHashLastTime = aggregationFuncsHash;
        const groupColumnsHash = (this.rowGroupColsSvc?.columns ?? []).map((column) => column.getId()).join('#');
        const groupColumnsChanged = groupColumnsHash !== this.groupColumnsHashLastTime;
        this.groupColumnsHashLastTime = groupColumnsHash;
        const pivotRowTotals = this.gos.get('pivotRowTotals');
        const pivotColumnGroupTotals = this.gos.get('pivotColumnGroupTotals');
        const suppressExpandablePivotGroups = this.gos.get('suppressExpandablePivotGroups');
        const removePivotHeaderRowWhenSingleValueColumn = this.gos.get('removePivotHeaderRowWhenSingleValueColumn');
        const anyGridOptionsChanged = pivotRowTotals !== this.pivotRowTotalsLastTime ||
            pivotColumnGroupTotals !== this.pivotColumnGroupTotalsLastTime ||
            suppressExpandablePivotGroups !== this.suppressExpandablePivotGroupsLastTime ||
            removePivotHeaderRowWhenSingleValueColumn !== this.removePivotHeaderRowWhenSingleValueColumnLastTime;
        this.pivotRowTotalsLastTime = pivotRowTotals;
        this.pivotColumnGroupTotalsLastTime = pivotColumnGroupTotals;
        this.suppressExpandablePivotGroupsLastTime = suppressExpandablePivotGroups;
        this.removePivotHeaderRowWhenSingleValueColumnLastTime = removePivotHeaderRowWhenSingleValueColumn;
        if (this.lastTimeFailed ||
            uniqueValuesChanged ||
            aggregationColumnsChanged ||
            groupColumnsChanged ||
            aggregationFuncsChanged ||
            anyGridOptionsChanged) {
            const { pivotColumnGroupDefs, pivotColumnDefs } = this.pivotColDefSvc.createPivotColumnDefs(this.uniqueValues);
            this.pivotColumnDefs = pivotColumnDefs;
            this.pivotResultCols.setPivotResultCols(pivotColumnGroupDefs, 'rowModelUpdated');
            // because the secondary columns have changed, then the aggregation needs to visit the whole
            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.
            if (changedPath) {
                changedPath.active = false;
            }
        }
        this.lastTimeFailed = false;
    }
    setUniqueValues(newValues) {
        const json1 = JSON.stringify(newValues);
        const json2 = JSON.stringify(this.uniqueValues);
        const uniqueValuesChanged = json1 !== json2;
        // we only continue the below if the unique values are different, as otherwise
        // the result will be the same as the last time we did it
        if (uniqueValuesChanged) {
            this.uniqueValues = newValues;
            return true;
        }
        else {
            return false;
        }
    }
    bucketUpRowNodes(changedPath) {
        this.currentUniqueCount = 0;
        // accessed from inside inner function
        const uniqueValues = {};
        // ensure childrenMapped is cleared, as if a node has been filtered out it should not have mapped children.
        changedPath.forEachChangedNodeDepthFirst((node) => {
            if (node.leafGroup) {
                node.childrenMapped = null;
            }
        });
        const recursivelyBucketFilteredChildren = (node) => {
            if (node.leafGroup) {
                this.bucketRowNode(node, uniqueValues);
            }
            else {
                node.childrenAfterFilter?.forEach(recursivelyBucketFilteredChildren);
            }
        };
        changedPath.executeFromRootNode(recursivelyBucketFilteredChildren);
        return uniqueValues;
    }
    bucketRowNode(rowNode, uniqueValues) {
        const pivotColumns = this.pivotColsSvc?.columns;
        if (pivotColumns?.length === 0) {
            rowNode.childrenMapped = null;
        }
        else {
            rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);
        }
        if (rowNode.sibling) {
            rowNode.sibling.childrenMapped = rowNode.childrenMapped;
        }
    }
    bucketChildren(children, pivotColumns = [], pivotIndex, uniqueValues) {
        const mappedChildren = {};
        const pivotColumn = pivotColumns[pivotIndex];
        // map the children out based on the pivot column
        children.forEach((child) => {
            let key = this.valueSvc.getKeyForNode(pivotColumn, child);
            if ((0, ag_grid_community_1._missing)(key)) {
                key = '';
            }
            if (!uniqueValues[key]) {
                this.currentUniqueCount += 1;
                uniqueValues[key] = {};
                const doesGeneratedColMaxExist = this.maxUniqueValues !== -1;
                const hasExceededColMax = this.currentUniqueCount > this.maxUniqueValues;
                if (doesGeneratedColMaxExist && hasExceededColMax) {
                    // throw an error to prevent all additional execution and escape the loops.
                    throw Error(EXCEEDED_MAX_UNIQUE_VALUES);
                }
            }
            if (!mappedChildren[key]) {
                mappedChildren[key] = [];
            }
            mappedChildren[key].push(child);
        });
        // if it's the last pivot column, return as is, otherwise go one level further in the map
        if (pivotIndex === pivotColumns.length - 1) {
            return mappedChildren;
        }
        else {
            const result = {};
            for (const [key, value] of Object.entries(mappedChildren)) {
                result[key] = this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);
            }
            return result;
        }
    }
    getPivotColumnDefs() {
        return this.pivotColumnDefs;
    }
}
exports.PivotStage = PivotStage;


/***/ }),

/***/ 1037:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractSelectionHandle = exports.SelectionHandleType = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
var SelectionHandleType;
(function (SelectionHandleType) {
    SelectionHandleType[SelectionHandleType["FILL"] = 0] = "FILL";
    SelectionHandleType[SelectionHandleType["RANGE"] = 1] = "RANGE";
})(SelectionHandleType || (exports.SelectionHandleType = SelectionHandleType = {}));
class AbstractSelectionHandle extends ag_grid_community_1.Component {
    constructor() {
        super(...arguments);
        this.changedCalculatedValues = false;
        this.dragging = false;
        this.shouldDestroyOnEndDragging = false;
    }
    postConstruct() {
        const { dragSvc, rangeSvc } = this.beans;
        dragSvc.addDragSource({
            dragStartPixels: 0,
            eElement: this.getGui(),
            onDragStart: this.onDragStart.bind(this),
            onDragging: (e) => {
                this.dragging = true;
                rangeSvc.autoScrollService.check(e);
                if (this.changedCalculatedValues) {
                    this.onDrag(e);
                    this.changedCalculatedValues = false;
                }
            },
            onDragStop: (e) => {
                this.dragging = false;
                this.onDragEnd(e);
                this.clearDragProperties();
                if (this.shouldDestroyOnEndDragging) {
                    this.destroy();
                }
            },
            onDragCancel: () => {
                this.dragging = false;
                this.onDragCancel();
                this.clearDragProperties();
            },
        });
        this.addManagedElementListeners(this.getGui(), { mousedown: this.preventRangeExtension.bind(this) });
    }
    getLastCellHovered() {
        return this.lastCellHovered;
    }
    preventRangeExtension(e) {
        e.stopPropagation();
    }
    onDragStart(_) {
        [this.cellHoverListener] = this.addManagedElementListeners(this.beans.ctrlsSvc.get('gridCtrl').getGui(), {
            mousemove: this.updateValuesOnMove.bind(this),
        });
        document.body.classList.add(this.getDraggingCssClass());
    }
    getDraggingCssClass() {
        return `ag-dragging-${this.type === SelectionHandleType.FILL ? 'fill' : 'range'}-handle`;
    }
    updateValuesOnMove(e) {
        const cell = (0, ag_grid_community_1._getCellPositionForEvent)(this.gos, e);
        if (!cell || (this.lastCellHovered && (0, ag_grid_community_1._areCellsEqual)(cell, this.lastCellHovered))) {
            return;
        }
        this.lastCellHovered = cell;
        this.changedCalculatedValues = true;
    }
    clearDragProperties() {
        this.clearValues();
        this.beans.rangeSvc.autoScrollService.ensureCleared();
        // TODO: this causes a bug where if there are multiple grids in the same page, all of them will
        // be affected by a drag on any. Move it to the root element.
        document.body.classList.remove(this.getDraggingCssClass());
    }
    getType() {
        return this.type;
    }
    refresh(cellCtrl) {
        const oldCellComp = this.cellCtrl;
        const eGui = this.getGui();
        const cellRange = (0, ag_grid_community_1._last)(this.beans.rangeSvc.getCellRanges());
        const start = cellRange.startRow;
        const end = cellRange.endRow;
        if (start && end) {
            const isBefore = (0, ag_grid_community_1._isRowBefore)(end, start);
            if (isBefore) {
                this.rangeStartRow = end;
                this.rangeEndRow = start;
            }
            else {
                this.rangeStartRow = start;
                this.rangeEndRow = end;
            }
        }
        if (oldCellComp !== cellCtrl || !(0, ag_grid_community_1._isVisible)(eGui)) {
            this.cellCtrl = cellCtrl;
            const eParentOfValue = cellCtrl.comp.getParentOfValue();
            if (eParentOfValue) {
                eParentOfValue.appendChild(eGui);
            }
        }
        this.cellRange = cellRange;
    }
    clearValues() {
        this.lastCellHovered = undefined;
        this.removeListeners();
    }
    removeListeners() {
        const cellHoverListener = this.cellHoverListener;
        if (cellHoverListener) {
            cellHoverListener();
            this.cellHoverListener = undefined;
        }
    }
    destroy() {
        if (!this.shouldDestroyOnEndDragging && this.dragging) {
            (0, ag_grid_community_1._setDisplayed)(this.getGui(), false);
            this.shouldDestroyOnEndDragging = true;
            return;
        }
        this.shouldDestroyOnEndDragging = false;
        super.destroy();
        this.removeListeners();
        const eGui = this.getGui();
        eGui.parentElement?.removeChild(eGui);
    }
}
exports.AbstractSelectionHandle = AbstractSelectionHandle;


/***/ }),

/***/ 9236:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgFillHandle = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const abstractSelectionHandle_1 = __webpack_require__(1037);
const utils_1 = __webpack_require__(3978);
class AgFillHandle extends abstractSelectionHandle_1.AbstractSelectionHandle {
    constructor() {
        super(/* html */ `<div class="ag-fill-handle"></div>`);
        this.markedCells = [];
        this.cellValues = [];
        this.isUp = false;
        this.isLeft = false;
        this.isReduce = false;
        this.type = abstractSelectionHandle_1.SelectionHandleType.FILL;
    }
    updateValuesOnMove(e) {
        super.updateValuesOnMove(e);
        if (!this.initialXY) {
            this.initialXY = (0, ag_grid_community_1._getNormalisedMousePosition)(this.beans, e);
        }
        const { x, y } = this.initialXY;
        const { x: newX, y: newY } = (0, ag_grid_community_1._getNormalisedMousePosition)(this.beans, e);
        const diffX = Math.abs(x - newX);
        const diffY = Math.abs(y - newY);
        const allowedDirection = this.getFillHandleDirection();
        let direction;
        if (allowedDirection === 'xy') {
            direction = diffX > diffY ? 'x' : 'y';
        }
        else {
            direction = allowedDirection;
        }
        if (direction !== this.dragAxis) {
            this.dragAxis = direction;
            this.changedCalculatedValues = true;
        }
    }
    onDrag(_) {
        if (!this.initialPosition) {
            const cellCtrl = this.cellCtrl;
            if (!cellCtrl) {
                return;
            }
            this.initialPosition = cellCtrl.cellPosition;
        }
        const lastCellHovered = this.getLastCellHovered();
        if (lastCellHovered) {
            this.markPathFrom(this.initialPosition, lastCellHovered);
        }
    }
    onDragEnd(e) {
        this.initialXY = null;
        if (!this.markedCells.length) {
            return;
        }
        const isX = this.dragAxis === 'x';
        const { cellRange: initialRange, rangeStartRow, rangeEndRow, beans } = this;
        const colLen = initialRange.columns.length;
        let finalRange;
        const { rangeSvc, eventSvc } = beans;
        if (!this.isUp && !this.isLeft) {
            finalRange = rangeSvc.createCellRangeFromCellRangeParams({
                rowStartIndex: rangeStartRow.rowIndex,
                rowStartPinned: rangeStartRow.rowPinned,
                columnStart: initialRange.columns[0],
                rowEndIndex: isX ? rangeEndRow.rowIndex : this.lastCellMarked.rowIndex,
                rowEndPinned: isX ? rangeEndRow.rowPinned : this.lastCellMarked.rowPinned,
                columnEnd: isX ? this.lastCellMarked.column : initialRange.columns[colLen - 1],
            });
        }
        else {
            const startRow = isX ? rangeStartRow : this.lastCellMarked;
            finalRange = rangeSvc.createCellRangeFromCellRangeParams({
                rowStartIndex: startRow.rowIndex,
                rowStartPinned: startRow.rowPinned,
                columnStart: isX ? this.lastCellMarked.column : initialRange.columns[0],
                rowEndIndex: rangeEndRow.rowIndex,
                rowEndPinned: rangeEndRow.rowPinned,
                columnEnd: initialRange.columns[colLen - 1],
            });
        }
        if (finalRange) {
            // raising fill events for undo / redo
            eventSvc.dispatchEvent({
                type: 'fillStart',
            });
            this.handleValueChanged(initialRange, finalRange, e);
            rangeSvc.setCellRanges([finalRange]);
            eventSvc.dispatchEvent({
                type: 'fillEnd',
                initialRange: initialRange,
                finalRange: finalRange,
            });
        }
    }
    onDragCancel() {
        this.initialXY = null;
        if (!this.markedCells.length) {
            return;
        }
        this.clearMarkedPath();
    }
    getFillHandleDirection() {
        const direction = (0, ag_grid_community_1._getFillHandle)(this.gos)?.direction;
        if (!direction) {
            return 'xy';
        }
        if (direction !== 'x' && direction !== 'y' && direction !== 'xy') {
            (0, ag_grid_community_1._warn)(177);
            return 'xy';
        }
        return direction;
    }
    handleValueChanged(initialRange, finalRange, e) {
        const { rangeSvc, gos, cellNavigation, valueSvc } = this.beans;
        const initialRangeEndRow = rangeSvc.getRangeEndRow(initialRange);
        const initialRangeStartRow = rangeSvc.getRangeStartRow(initialRange);
        const finalRangeEndRow = rangeSvc.getRangeEndRow(finalRange);
        const finalRangeStartRow = rangeSvc.getRangeStartRow(finalRange);
        const isVertical = this.dragAxis === 'y';
        // if the range is being reduced in size, all we need to do is
        // clear the cells that are no longer part of the range
        if (this.isReduce && !(0, ag_grid_community_1._getFillHandle)(gos)?.suppressClearOnFillReduction) {
            const columns = (isVertical
                ? initialRange.columns
                : initialRange.columns.filter((col) => finalRange.columns.indexOf(col) < 0));
            const startRow = isVertical ? cellNavigation.getRowBelow(finalRangeEndRow) : finalRangeStartRow;
            if (startRow) {
                this.clearCellsInRange(startRow, initialRangeEndRow, columns);
            }
            return;
        }
        const values = [];
        const initialValues = [];
        const initialNonAggregatedValues = [];
        const initialFormattedValues = [];
        let withinInitialRange = true;
        let idx = 0;
        const resetValues = () => {
            values.length = 0;
            initialValues.length = 0;
            initialNonAggregatedValues.length = 0;
            initialFormattedValues.length = 0;
            idx = 0;
        };
        const iterateAcrossCells = (column, columns) => {
            let currentRow = this.isUp ? initialRangeEndRow : initialRangeStartRow;
            let finished = false;
            if (isVertical) {
                withinInitialRange = true;
                resetValues();
            }
            while (!finished && currentRow) {
                const rowNode = (0, ag_grid_community_1._getRowNode)(this.beans, currentRow);
                if (!rowNode) {
                    break;
                }
                if (isVertical && column) {
                    fillValues(values, column, rowNode, () => !(0, ag_grid_community_1._isSameRow)(currentRow, this.isUp ? initialRangeStartRow : initialRangeEndRow));
                }
                else if (columns) {
                    withinInitialRange = true;
                    resetValues();
                    columns.forEach((col) => fillValues(values, col, rowNode, () => col !== (this.isLeft ? initialRange.columns[0] : (0, ag_grid_community_1._last)(initialRange.columns))));
                }
                finished = (0, ag_grid_community_1._isSameRow)(currentRow, this.isUp ? finalRangeStartRow : finalRangeEndRow);
                currentRow = this.isUp
                    ? cellNavigation.getRowAbove(currentRow)
                    : cellNavigation.getRowBelow(currentRow);
            }
        };
        const fillValues = (currentValues, col, rowNode, updateInitialSet) => {
            let currentValue;
            let skipValue = false;
            if (withinInitialRange) {
                currentValue = valueSvc.getValue(col, rowNode);
                initialValues.push(currentValue);
                initialNonAggregatedValues.push(valueSvc.getValue(col, rowNode, true));
                initialFormattedValues.push(valueSvc.formatValue(col, rowNode, currentValue));
                withinInitialRange = updateInitialSet();
            }
            else {
                const { value, fromUserFunction, sourceCol, sourceRowNode } = this.processValues({
                    event: e,
                    values: currentValues,
                    initialValues,
                    initialNonAggregatedValues,
                    initialFormattedValues,
                    col,
                    rowNode,
                    idx: idx++,
                });
                currentValue = value;
                if (col.isCellEditable(rowNode)) {
                    const cellValue = valueSvc.getValue(col, rowNode);
                    if (!fromUserFunction) {
                        if (sourceCol) {
                            const sourceColDef = sourceCol.getColDef();
                            if (sourceColDef.useValueFormatterForExport !== false && sourceColDef.valueFormatter) {
                                const formattedValue = valueSvc.formatValue(sourceCol, sourceRowNode, currentValue);
                                if (formattedValue != null) {
                                    currentValue = formattedValue;
                                }
                            }
                        }
                        if (col.getColDef().useValueParserForImport !== false) {
                            currentValue = valueSvc.parseValue(col, rowNode, 
                            // if no sourceCol, then currentValue is a number
                            sourceCol ? currentValue : (0, ag_grid_community_1._toStringOrNull)(currentValue), cellValue);
                        }
                    }
                    if (!fromUserFunction || cellValue !== currentValue) {
                        rowNode.setDataValue(col, currentValue, 'rangeSvc');
                    }
                    else {
                        skipValue = true;
                    }
                }
            }
            if (!skipValue) {
                currentValues.push({
                    value: currentValue,
                    column: col,
                    rowNode,
                });
            }
        };
        if (isVertical) {
            initialRange.columns.forEach((col) => {
                iterateAcrossCells(col);
            });
        }
        else {
            const columns = (this.isLeft ? [...finalRange.columns].reverse() : finalRange.columns);
            iterateAcrossCells(undefined, columns);
        }
    }
    clearCellsInRange(startRow, endRow, columns) {
        const cellRange = {
            startRow,
            endRow,
            columns,
            startColumn: columns[0],
        };
        this.beans.rangeSvc.clearCellRangeCellValues({ cellRanges: [cellRange] });
    }
    processValues(params) {
        const { event, values, initialValues, initialNonAggregatedValues, initialFormattedValues, col, rowNode, idx } = params;
        const userFillOperation = (0, ag_grid_community_1._getFillHandle)(this.gos)?.setFillValue;
        const isVertical = this.dragAxis === 'y';
        let direction;
        if (isVertical) {
            direction = this.isUp ? 'up' : 'down';
        }
        else {
            direction = this.isLeft ? 'left' : 'right';
        }
        if (userFillOperation) {
            const params = this.gos.addGridCommonParams({
                event,
                values: values.map(({ value }) => value),
                initialValues,
                initialNonAggregatedValues,
                initialFormattedValues,
                currentIndex: idx,
                currentCellValue: this.beans.valueSvc.getValue(col, rowNode),
                direction,
                column: col,
                rowNode: rowNode,
            });
            const userResult = userFillOperation(params);
            if (userResult !== false) {
                return { value: userResult, fromUserFunction: true };
            }
        }
        const allNumbers = !values.some(({ value }) => {
            const asFloat = parseFloat(value);
            return isNaN(asFloat) || asFloat.toString() !== value.toString();
        });
        // values should be copied in order if the alt key is pressed
        // or if the values contain strings and numbers
        // However, if we only have one initial value selected, and that
        // value is a number and we are also pressing alt, then we should
        // increment or decrement the value by 1 based on direction.
        if (event.altKey || !allNumbers) {
            if (allNumbers && initialValues.length === 1) {
                const multiplier = this.isUp || this.isLeft ? -1 : 1;
                return { value: parseFloat((0, ag_grid_community_1._last)(values).value) + 1 * multiplier, fromUserFunction: false };
            }
            const { value, column: sourceCol, rowNode: sourceRowNode } = values[idx % values.length];
            return { value, fromUserFunction: false, sourceCol, sourceRowNode };
        }
        return {
            value: (0, ag_grid_community_1._last)((0, utils_1.findLineByLeastSquares)(values.map(({ value }) => Number(value)))),
            fromUserFunction: false,
        };
    }
    clearValues() {
        this.clearMarkedPath();
        this.clearCellValues();
        this.lastCellMarked = undefined;
        super.clearValues();
    }
    clearMarkedPath() {
        this.markedCells.forEach((cell) => {
            if (!cell.isAlive()) {
                return;
            }
            const { comp } = cell;
            comp.addOrRemoveCssClass('ag-selection-fill-top', false);
            comp.addOrRemoveCssClass('ag-selection-fill-right', false);
            comp.addOrRemoveCssClass('ag-selection-fill-bottom', false);
            comp.addOrRemoveCssClass('ag-selection-fill-left', false);
        });
        this.markedCells.length = 0;
        this.isUp = false;
        this.isLeft = false;
        this.isReduce = false;
    }
    clearCellValues() {
        this.cellValues.length = 0;
    }
    markPathFrom(initialPosition, currentPosition) {
        this.clearMarkedPath();
        this.clearCellValues();
        if (this.dragAxis === 'y') {
            if ((0, ag_grid_community_1._isSameRow)(currentPosition, initialPosition)) {
                return;
            }
            const isBefore = (0, ag_grid_community_1._isRowBefore)(currentPosition, initialPosition);
            const { rangeStartRow, rangeEndRow } = this;
            if (isBefore &&
                ((currentPosition.rowPinned == rangeStartRow.rowPinned &&
                    currentPosition.rowIndex >= rangeStartRow.rowIndex) ||
                    (rangeStartRow.rowPinned != rangeEndRow.rowPinned &&
                        currentPosition.rowPinned == rangeEndRow.rowPinned &&
                        currentPosition.rowIndex <= rangeEndRow.rowIndex))) {
                this.reduceVertical(initialPosition, currentPosition);
                this.isReduce = true;
            }
            else {
                this.extendVertical(initialPosition, currentPosition, isBefore);
                this.isReduce = false;
            }
        }
        else {
            const initialColumn = initialPosition.column;
            const currentColumn = currentPosition.column;
            if (initialColumn === currentColumn) {
                return;
            }
            const displayedColumns = this.beans.visibleCols.allCols;
            const initialIndex = displayedColumns.indexOf(initialColumn);
            const currentIndex = displayedColumns.indexOf(currentColumn);
            if (currentIndex <= initialIndex &&
                currentIndex >= displayedColumns.indexOf(this.cellRange.columns[0])) {
                this.reduceHorizontal(initialPosition, currentPosition);
                this.isReduce = true;
            }
            else {
                this.extendHorizontal(initialPosition, currentPosition, currentIndex < initialIndex);
                this.isReduce = false;
            }
        }
        this.lastCellMarked = currentPosition;
    }
    extendVertical(initialPosition, endPosition, isMovingUp) {
        const beans = this.beans;
        const { rangeSvc, cellNavigation } = beans;
        let row = initialPosition;
        do {
            const cellRange = this.cellRange;
            const colLen = cellRange.columns.length;
            for (let i = 0; i < colLen; i++) {
                const column = cellRange.columns[i];
                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };
                const cellPos = { ...rowPos, column };
                const cellInRange = rangeSvc.isCellInSpecificRange(cellPos, cellRange);
                const isInitialRow = (0, ag_grid_community_1._isSameRow)(row, initialPosition);
                if (isMovingUp) {
                    this.isUp = true;
                }
                if (!isInitialRow) {
                    const cell = (0, ag_grid_community_1._getCellByPosition)(beans, cellPos);
                    if (cell) {
                        this.markedCells.push(cell);
                        const cellComp = cell.comp;
                        if (!cellInRange) {
                            cellComp.addOrRemoveCssClass('ag-selection-fill-left', i === 0);
                            cellComp.addOrRemoveCssClass('ag-selection-fill-right', i === colLen - 1);
                        }
                        cellComp.addOrRemoveCssClass(isMovingUp ? 'ag-selection-fill-top' : 'ag-selection-fill-bottom', (0, ag_grid_community_1._isSameRow)(row, endPosition));
                    }
                }
            }
            if ((0, ag_grid_community_1._isSameRow)(row, endPosition)) {
                break;
            }
        } while (
        // tslint:disable-next-line
        (row = isMovingUp ? cellNavigation.getRowAbove(row) : cellNavigation.getRowBelow(row)));
    }
    reduceVertical(initialPosition, endPosition) {
        let row = initialPosition;
        const beans = this.beans;
        const cellNavigation = beans.cellNavigation;
        do {
            const cellRange = this.cellRange;
            const colLen = cellRange.columns.length;
            const isLastRow = (0, ag_grid_community_1._isSameRow)(row, endPosition);
            for (let i = 0; i < colLen; i++) {
                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };
                const celPos = { ...rowPos, column: cellRange.columns[i] };
                const cell = (0, ag_grid_community_1._getCellByPosition)(beans, celPos);
                if (cell) {
                    this.markedCells.push(cell);
                    cell.comp.addOrRemoveCssClass('ag-selection-fill-bottom', (0, ag_grid_community_1._isSameRow)(row, endPosition));
                }
            }
            if (isLastRow) {
                break;
            }
            // tslint:disable-next-line
        } while ((row = cellNavigation.getRowAbove(row)));
    }
    extendHorizontal(initialPosition, endPosition, isMovingLeft) {
        const beans = this.beans;
        const { visibleCols, cellNavigation } = beans;
        const allCols = visibleCols.allCols;
        const startCol = allCols.indexOf((isMovingLeft ? endPosition.column : initialPosition.column));
        const endCol = allCols.indexOf((isMovingLeft ? this.cellRange.columns[0] : endPosition.column));
        const offset = isMovingLeft ? 0 : 1;
        const colsToMark = allCols.slice(startCol + offset, endCol + offset);
        const { rangeStartRow, rangeEndRow } = this;
        colsToMark.forEach((column) => {
            let row = rangeStartRow;
            let isLastRow = false;
            do {
                isLastRow = (0, ag_grid_community_1._isSameRow)(row, rangeEndRow);
                const cell = (0, ag_grid_community_1._getCellByPosition)(beans, {
                    rowIndex: row.rowIndex,
                    rowPinned: row.rowPinned,
                    column: column,
                });
                if (cell) {
                    this.markedCells.push(cell);
                    const cellComp = cell.comp;
                    cellComp.addOrRemoveCssClass('ag-selection-fill-top', (0, ag_grid_community_1._isSameRow)(row, rangeStartRow));
                    cellComp.addOrRemoveCssClass('ag-selection-fill-bottom', (0, ag_grid_community_1._isSameRow)(row, rangeEndRow));
                    if (isMovingLeft) {
                        this.isLeft = true;
                        cellComp.addOrRemoveCssClass('ag-selection-fill-left', column === colsToMark[0]);
                    }
                    else {
                        cellComp.addOrRemoveCssClass('ag-selection-fill-right', column === (0, ag_grid_community_1._last)(colsToMark));
                    }
                }
                row = cellNavigation.getRowBelow(row);
            } while (!isLastRow);
        });
    }
    reduceHorizontal(initialPosition, endPosition) {
        const beans = this.beans;
        const { visibleCols, cellNavigation } = beans;
        const allCols = visibleCols.allCols;
        const startCol = allCols.indexOf(endPosition.column);
        const endCol = allCols.indexOf(initialPosition.column);
        const colsToMark = allCols.slice(startCol, endCol);
        const { rangeStartRow, rangeEndRow } = this;
        colsToMark.forEach((column) => {
            let row = rangeStartRow;
            let isLastRow = false;
            do {
                isLastRow = (0, ag_grid_community_1._isSameRow)(row, rangeEndRow);
                const cell = (0, ag_grid_community_1._getCellByPosition)(this.beans, {
                    rowIndex: row.rowIndex,
                    rowPinned: row.rowPinned,
                    column: column,
                });
                if (cell) {
                    this.markedCells.push(cell);
                    cell.comp.addOrRemoveCssClass('ag-selection-fill-right', column === colsToMark[0]);
                }
                row = cellNavigation.getRowBelow(row);
            } while (!isLastRow);
        });
    }
    refresh(cellCtrl) {
        const cellRange = this.beans.rangeSvc.getCellRanges()[0];
        const isColumnRange = !cellRange.startRow || !cellRange.endRow;
        if (isColumnRange) {
            this.destroy();
            return;
        }
        super.refresh(cellCtrl);
    }
}
exports.AgFillHandle = AgFillHandle;


/***/ }),

/***/ 7724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgRangeHandle = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const abstractSelectionHandle_1 = __webpack_require__(1037);
class AgRangeHandle extends abstractSelectionHandle_1.AbstractSelectionHandle {
    constructor() {
        super(/* html */ `<div class="ag-range-handle"></div>`);
        this.type = abstractSelectionHandle_1.SelectionHandleType.RANGE;
        this.rangeFixed = false;
    }
    onDrag(_) {
        const lastCellHovered = this.getLastCellHovered();
        if (!lastCellHovered) {
            return;
        }
        const rangeSvc = this.beans.rangeSvc;
        const cellRanges = rangeSvc.getCellRanges();
        const lastRange = (0, ag_grid_community_1._last)(cellRanges);
        if (!this.rangeFixed) {
            this.fixRangeStartEnd(lastRange);
            this.rangeFixed = true;
        }
        this.endPosition = {
            rowIndex: lastCellHovered.rowIndex,
            rowPinned: lastCellHovered.rowPinned,
            column: lastCellHovered.column,
        };
        // check if the cell ranges are for a chart
        if (cellRanges.length === 2 &&
            cellRanges[0].type === ag_grid_community_1.CellRangeType.DIMENSION &&
            lastRange.type === ag_grid_community_1.CellRangeType.VALUE) {
            const rowChanged = !(0, ag_grid_community_1._isSameRow)(this.endPosition, rangeSvc.getRangeEndRow(lastRange));
            if (rowChanged) {
                // ensure the dimension range is kept in sync with the value range (which has the handle)
                rangeSvc.updateRangeEnd(cellRanges[0], {
                    ...this.endPosition,
                    column: cellRanges[0].columns[0],
                }, true);
            }
        }
        rangeSvc.extendLatestRangeToCell(this.endPosition);
    }
    onDragEnd(_) {
        const cellRange = (0, ag_grid_community_1._last)(this.beans.rangeSvc.getCellRanges());
        this.fixRangeStartEnd(cellRange);
        this.rangeFixed = false;
    }
    onDragCancel() {
        this.rangeFixed = false;
    }
    fixRangeStartEnd(cellRange) {
        const rangeSvc = this.beans.rangeSvc;
        const startRow = rangeSvc.getRangeStartRow(cellRange);
        const endRow = rangeSvc.getRangeEndRow(cellRange);
        const column = cellRange.columns[0];
        cellRange.startRow = startRow;
        cellRange.endRow = endRow;
        cellRange.startColumn = column;
    }
}
exports.AgRangeHandle = AgRangeHandle;


/***/ }),

/***/ 4870:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellRangeFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const abstractSelectionHandle_1 = __webpack_require__(1037);
const CSS_CELL_RANGE_SELECTED = 'ag-cell-range-selected';
const CSS_CELL_RANGE_CHART = 'ag-cell-range-chart';
const CSS_CELL_RANGE_SINGLE_CELL = 'ag-cell-range-single-cell';
const CSS_CELL_RANGE_CHART_CATEGORY = 'ag-cell-range-chart-category';
const CSS_CELL_RANGE_HANDLE = 'ag-cell-range-handle';
const CSS_CELL_RANGE_TOP = 'ag-cell-range-top';
const CSS_CELL_RANGE_RIGHT = 'ag-cell-range-right';
const CSS_CELL_RANGE_BOTTOM = 'ag-cell-range-bottom';
const CSS_CELL_RANGE_LEFT = 'ag-cell-range-left';
function _isRangeHandleEnabled(gos) {
    const selection = gos.get('cellSelection');
    const useNewAPI = selection !== undefined;
    if (!useNewAPI) {
        return gos.get('enableRangeHandle');
    }
    return typeof selection !== 'boolean' ? selection.handle?.mode === 'range' : false;
}
function _isFillHandleEnabled(gos) {
    const selection = gos.get('cellSelection');
    const useNewAPI = selection !== undefined;
    if (!useNewAPI) {
        return gos.get('enableFillHandle');
    }
    return typeof selection !== 'boolean' ? selection.handle?.mode === 'fill' : false;
}
class CellRangeFeature {
    constructor(beans, cellCtrl) {
        this.beans = beans;
        this.cellCtrl = cellCtrl;
        // We know these are defined otherwise the feature wouldn't be registered
        this.rangeSvc = beans.rangeSvc;
    }
    setComp(cellComp, eGui) {
        this.cellComp = cellComp;
        this.eGui = eGui;
        this.onCellSelectionChanged();
    }
    onCellSelectionChanged() {
        const cellComp = this.cellComp;
        // when using reactUi, given UI is async, it's possible this method is called before the comp is registered
        if (!cellComp) {
            return;
        }
        const { rangeSvc, cellCtrl, eGui } = this;
        const rangeCount = rangeSvc.getCellRangeCount(cellCtrl.cellPosition);
        this.rangeCount = rangeCount;
        const hasChartRange = this.getHasChartRange();
        this.hasChartRange = hasChartRange;
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SELECTED, rangeCount !== 0);
        cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-1`, rangeCount === 1);
        cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-2`, rangeCount === 2);
        cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-3`, rangeCount === 3);
        cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-4`, rangeCount >= 4);
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART, hasChartRange);
        (0, ag_grid_community_1._setAriaSelected)(eGui, rangeCount > 0 ? true : undefined);
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SINGLE_CELL, this.isSingleCell());
        this.updateRangeBorders();
        this.refreshHandle();
    }
    updateRangeBorders() {
        const rangeBorders = this.getRangeBorders();
        const isSingleCell = this.isSingleCell();
        const isTop = !isSingleCell && rangeBorders.top;
        const isRight = !isSingleCell && rangeBorders.right;
        const isBottom = !isSingleCell && rangeBorders.bottom;
        const isLeft = !isSingleCell && rangeBorders.left;
        const cellComp = this.cellComp;
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_TOP, isTop);
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_RIGHT, isRight);
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_BOTTOM, isBottom);
        cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_LEFT, isLeft);
    }
    isSingleCell() {
        const { rangeSvc } = this;
        return this.rangeCount === 1 && !!rangeSvc && !rangeSvc.isMoreThanOneCell();
    }
    getHasChartRange() {
        const { rangeSvc } = this;
        if (!this.rangeCount || !rangeSvc) {
            return false;
        }
        const cellRanges = rangeSvc.getCellRanges();
        return (cellRanges.length > 0 &&
            cellRanges.every((range) => [ag_grid_community_1.CellRangeType.DIMENSION, ag_grid_community_1.CellRangeType.VALUE].includes(range.type)));
    }
    updateRangeBordersIfRangeCount() {
        // we only need to update range borders if we are in a range
        if (this.rangeCount > 0) {
            this.updateRangeBorders();
            this.refreshHandle();
        }
    }
    getRangeBorders() {
        const isRtl = this.beans.gos.get('enableRtl');
        let top = false;
        let right = false;
        let bottom = false;
        let left = false;
        const { rangeSvc, beans: { visibleCols }, cellCtrl: { cellPosition }, } = this;
        const thisCol = cellPosition.column;
        let leftCol;
        let rightCol;
        if (isRtl) {
            leftCol = visibleCols.getColAfter(thisCol);
            rightCol = visibleCols.getColBefore(thisCol);
        }
        else {
            leftCol = visibleCols.getColBefore(thisCol);
            rightCol = visibleCols.getColAfter(thisCol);
        }
        const ranges = rangeSvc.getCellRanges().filter((range) => rangeSvc.isCellInSpecificRange(cellPosition, range));
        // this means we are the first column in the grid
        if (!leftCol) {
            left = true;
        }
        // this means we are the last column in the grid
        if (!rightCol) {
            right = true;
        }
        for (let i = 0; i < ranges.length; i++) {
            if (top && right && bottom && left) {
                break;
            }
            const range = ranges[i];
            const startRow = rangeSvc.getRangeStartRow(range);
            const endRow = rangeSvc.getRangeEndRow(range);
            if (!top && (0, ag_grid_community_1._isSameRow)(startRow, cellPosition)) {
                top = true;
            }
            if (!bottom && (0, ag_grid_community_1._isSameRow)(endRow, cellPosition)) {
                bottom = true;
            }
            if (!left && leftCol && range.columns.indexOf(leftCol) < 0) {
                left = true;
            }
            if (!right && rightCol && range.columns.indexOf(rightCol) < 0) {
                right = true;
            }
        }
        return { top, right, bottom, left };
    }
    refreshHandle() {
        if (this.beans.context.isDestroyed()) {
            return;
        }
        const shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();
        if (this.selectionHandle && !shouldHaveSelectionHandle) {
            this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
        }
        if (shouldHaveSelectionHandle) {
            this.addSelectionHandle();
        }
        this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_HANDLE, !!this.selectionHandle);
    }
    shouldHaveSelectionHandle() {
        const gos = this.beans.gos;
        const rangeSvc = this.rangeSvc;
        const cellRanges = rangeSvc.getCellRanges();
        const rangesLen = cellRanges.length;
        if (this.rangeCount < 1 || rangesLen < 1) {
            return false;
        }
        const cellRange = (0, ag_grid_community_1._last)(cellRanges);
        const { cellPosition } = this.cellCtrl;
        const isFillHandleAvailable = _isFillHandleEnabled(gos) && !this.cellCtrl.column.isSuppressFillHandle();
        const isRangeHandleAvailable = _isRangeHandleEnabled(gos);
        let handleIsAvailable = rangesLen === 1 && !this.cellCtrl.editing && (isFillHandleAvailable || isRangeHandleAvailable);
        if (this.hasChartRange) {
            const hasCategoryRange = cellRanges[0].type === ag_grid_community_1.CellRangeType.DIMENSION;
            const isCategoryCell = hasCategoryRange && rangeSvc.isCellInSpecificRange(cellPosition, cellRanges[0]);
            this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART_CATEGORY, isCategoryCell);
            handleIsAvailable = cellRange.type === ag_grid_community_1.CellRangeType.VALUE;
        }
        return (handleIsAvailable &&
            cellRange.endRow != null &&
            rangeSvc.isContiguousRange(cellRange) &&
            rangeSvc.isBottomRightCell(cellRange, cellPosition));
    }
    addSelectionHandle() {
        const { beans, rangeSvc } = this;
        const cellRangeType = (0, ag_grid_community_1._last)(rangeSvc.getCellRanges()).type;
        const selectionHandleFill = _isFillHandleEnabled(beans.gos) && (0, ag_grid_community_1._missing)(cellRangeType);
        const type = selectionHandleFill ? abstractSelectionHandle_1.SelectionHandleType.FILL : abstractSelectionHandle_1.SelectionHandleType.RANGE;
        if (this.selectionHandle && this.selectionHandle.getType() !== type) {
            this.selectionHandle = beans.context.destroyBean(this.selectionHandle);
        }
        if (!this.selectionHandle) {
            const selectionHandle = beans.registry.createDynamicBean(type === abstractSelectionHandle_1.SelectionHandleType.FILL ? 'fillHandle' : 'rangeHandle', false);
            if (selectionHandle) {
                this.selectionHandle = beans.context.createBean(selectionHandle);
            }
        }
        this.selectionHandle?.refresh(this.cellCtrl);
    }
    destroy() {
        this.beans.context.destroyBean(this.selectionHandle);
    }
}
exports.CellRangeFeature = CellRangeFeature;


/***/ }),

/***/ 6527:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragListenerFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class DragListenerFeature extends ag_grid_community_1.BeanStub {
    constructor(eContainer) {
        super();
        this.eContainer = eContainer;
    }
    postConstruct() {
        const { beans, gos, eContainer } = this;
        const rangeSvc = beans.rangeSvc;
        const params = {
            eElement: eContainer,
            onDragStart: rangeSvc.onDragStart.bind(rangeSvc),
            onDragStop: rangeSvc.onDragStop.bind(rangeSvc),
            onDragging: rangeSvc.onDragging.bind(rangeSvc),
        };
        const dragSvc = beans.dragSvc;
        const enableFeature = dragSvc.addDragSource.bind(dragSvc, params);
        const disableFeature = dragSvc.removeDragSource.bind(dragSvc, params);
        this.addManagedPropertyListeners(['enableRangeSelection', 'cellSelection'], () => {
            if ((0, ag_grid_community_1._isCellSelectionEnabled)(gos)) {
                enableFeature();
            }
            else {
                disableFeature();
            }
        });
        this.addDestroyFunc(disableFeature);
        if ((0, ag_grid_community_1._isCellSelectionEnabled)(gos)) {
            enableFeature();
        }
    }
}
exports.DragListenerFeature = DragListenerFeature;


/***/ }),

/***/ 3799:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rangeSelectionCSS = void 0;
exports.rangeSelectionCSS = `.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing),.ag-cell-range-selected.ag-cell-range-chart,.ag-cell-range-selected:not(.ag-cell-focus){background-color:var(--ag-range-selection-background-color);&.ag-cell-range-chart{background-color:var(--ag-range-selection-chart-background-color)!important;&.ag-cell-range-chart-category{background-color:var(--ag-range-selection-chart-category-background-color)!important}}}.ag-cell-range-selected-1.ag-cell-range-chart,.ag-cell-range-selected-1:not(.ag-cell-focus),.ag-root:not(.ag-context-menu-open) .ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-1:not(.ag-cell-inline-editing){background-color:var(--ag-range-selection-background-color)}.ag-cell-range-selected-2.ag-cell-range-chart,.ag-cell-range-selected-2:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-3.ag-cell-range-chart,.ag-cell-range-selected-3:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-4.ag-cell-range-chart,.ag-cell-range-selected-4:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell){&.ag-cell-range-top{border-top-color:var(--ag-range-selection-border-color);border-top-style:var(--ag-range-selection-border-style)}&.ag-cell-range-right{border-right-color:var(--ag-range-selection-border-color);border-right-style:var(--ag-range-selection-border-style)}&.ag-cell-range-bottom{border-bottom-color:var(--ag-range-selection-border-color);border-bottom-style:var(--ag-range-selection-border-style)}&.ag-cell-range-left{border-left-color:var(--ag-range-selection-border-color);border-left-style:var(--ag-range-selection-border-style)}}.ag-cell.ag-selection-fill-top,.ag-cell.ag-selection-fill-top.ag-cell-range-selected{border-top:1px dashed;border-top-color:var(--ag-range-selection-border-color)}:where(.ag-ltr) .ag-cell.ag-selection-fill-right,:where(.ag-ltr) .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}:where(.ag-rtl) .ag-cell.ag-selection-fill-right,:where(.ag-rtl) .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}.ag-cell.ag-selection-fill-bottom,.ag-cell.ag-selection-fill-bottom.ag-cell-range-selected{border-bottom:1px dashed;border-bottom-color:var(--ag-range-selection-border-color)}:where(.ag-ltr) .ag-cell.ag-selection-fill-left,:where(.ag-ltr) .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}:where(.ag-rtl) .ag-cell.ag-selection-fill-left,:where(.ag-rtl) .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}.ag-fill-handle,.ag-range-handle{background-color:var(--ag-range-selection-border-color);bottom:-1px;height:6px;position:absolute;width:6px}:where(.ag-ltr) .ag-fill-handle,:where(.ag-ltr) .ag-range-handle{right:-1px}:where(.ag-rtl) .ag-fill-handle,:where(.ag-rtl) .ag-range-handle{left:-1px}.ag-fill-handle{cursor:cell}:where(.ag-ltr) .ag-range-handle{cursor:nwse-resize}:where(.ag-rtl) .ag-range-handle{cursor:nesw-resize}`;


/***/ }),

/***/ 7876:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearRangeSelection = exports.addCellRange = exports.getCellRanges = void 0;
function getCellRanges(beans) {
    return beans.rangeSvc?.getCellRanges() ?? null;
}
exports.getCellRanges = getCellRanges;
function addCellRange(beans, params) {
    beans.rangeSvc?.addCellRange(params);
}
exports.addCellRange = addCellRange;
function clearRangeSelection(beans) {
    beans.rangeSvc?.removeAllCellRanges();
}
exports.clearRangeSelection = clearRangeSelection;


/***/ }),

/***/ 266:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeSelectionModule = exports.CellSelectionModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const agFillHandle_1 = __webpack_require__(9236);
const agRangeHandle_1 = __webpack_require__(7724);
const rangeSelection_css_GENERATED_1 = __webpack_require__(3799);
const rangeSelectionApi_1 = __webpack_require__(7876);
const rangeService_1 = __webpack_require__(1455);
/**
 * @feature Selection -> Cell Selection
 * @gridOption cellSelection
 */
exports.CellSelectionModule = {
    moduleName: 'CellSelection',
    version: version_1.VERSION,
    beans: [rangeService_1.RangeService],
    dynamicBeans: { fillHandle: agFillHandle_1.AgFillHandle, rangeHandle: agRangeHandle_1.AgRangeHandle },
    apiFunctions: {
        getCellRanges: rangeSelectionApi_1.getCellRanges,
        addCellRange: rangeSelectionApi_1.addCellRange,
        clearRangeSelection: rangeSelectionApi_1.clearRangeSelection,
        clearCellSelection: rangeSelectionApi_1.clearRangeSelection,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._KeyboardNavigationModule, ag_grid_community_1._DragModule],
    css: [rangeSelection_css_GENERATED_1.rangeSelectionCSS],
};
/**
 * @deprecated v33 Use `CellSelectionModule` instead
 */
exports.RangeSelectionModule = {
    moduleName: 'RangeSelection',
    version: version_1.VERSION,
    dependsOn: [exports.CellSelectionModule],
};


/***/ }),

/***/ 1455:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const cellRangeFeature_1 = __webpack_require__(4870);
const dragListenerFeature_1 = __webpack_require__(6527);
class RangeService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rangeSvc';
        this.cellRanges = [];
        this.bodyScrollListener = this.onBodyScroll.bind(this);
        this.dragging = false;
        this.intersectionRange = false; // When dragging ends, the current range will be used to intersect all other ranges
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.dragSvc = beans.dragSvc;
        this.colModel = beans.colModel;
        this.visibleCols = beans.visibleCols;
        this.cellNavigation = beans.cellNavigation;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.ctrlsSvc = beans.ctrlsSvc;
    }
    postConstruct() {
        const onColumnsChanged = this.onColumnsChanged.bind(this);
        const removeAllCellRanges = () => this.removeAllCellRanges();
        const refreshLastRangeStart = this.refreshLastRangeStart.bind(this);
        this.addManagedEventListeners({
            newColumnsLoaded: onColumnsChanged,
            columnVisible: onColumnsChanged,
            columnValueChanged: onColumnsChanged,
            columnPivotModeChanged: removeAllCellRanges,
            columnRowGroupChanged: removeAllCellRanges,
            columnPivotChanged: removeAllCellRanges,
            columnGroupOpened: refreshLastRangeStart,
            columnMoved: refreshLastRangeStart,
            columnPinned: refreshLastRangeStart,
        });
        this.ctrlsSvc.whenReady(this, (p) => {
            const gridBodyCtrl = p.gridBodyCtrl;
            this.autoScrollService = new ag_grid_community_1.AutoScrollService({
                scrollContainer: gridBodyCtrl.eBodyViewport,
                scrollAxis: 'xy',
                getVerticalPosition: () => gridBodyCtrl.scrollFeature.getVScrollPosition().top,
                setVerticalPosition: (position) => gridBodyCtrl.scrollFeature.setVerticalScrollPosition(position),
                getHorizontalPosition: () => gridBodyCtrl.scrollFeature.getHScrollPosition().left,
                setHorizontalPosition: (position) => gridBodyCtrl.scrollFeature.setHorizontalScrollPosition(position),
                shouldSkipVerticalScroll: () => !(0, ag_grid_community_1._isDomLayout)(this.gos, 'normal'),
                shouldSkipHorizontalScroll: () => !gridBodyCtrl.scrollFeature.isHorizontalScrollShowing(),
            });
        });
    }
    // Called for both columns loaded & column visibility events
    onColumnsChanged() {
        // first move start column in last cell range (i.e. series chart range)
        this.refreshLastRangeStart();
        const allColumns = this.visibleCols.allCols;
        // check that the columns in each range still exist and are visible
        this.cellRanges.forEach((cellRange) => {
            const beforeCols = cellRange.columns;
            // remove hidden or removed cols from cell range
            cellRange.columns = cellRange.columns.filter((col) => col.isVisible() && allColumns.indexOf(col) !== -1);
            const colsInRangeChanged = !(0, ag_grid_community_1._areEqual)(beforeCols, cellRange.columns);
            if (colsInRangeChanged) {
                // notify users and other parts of grid (i.e. status panel) that range has changed
                this.dispatchChangedEvent(false, true, cellRange.id);
            }
        });
        // Remove empty cell ranges
        const countBefore = this.cellRanges.length;
        this.cellRanges = this.cellRanges.filter((range) => range.columns.length > 0);
        if (countBefore > this.cellRanges.length) {
            this.dispatchChangedEvent(false, true);
        }
    }
    refreshLastRangeStart() {
        const lastRange = (0, ag_grid_community_1._last)(this.cellRanges);
        if (!lastRange) {
            return;
        }
        this.refreshRangeStart(lastRange);
    }
    isContiguousRange(cellRange) {
        const rangeColumns = cellRange.columns;
        if (!rangeColumns.length) {
            return false;
        }
        const allColumns = this.visibleCols.allCols;
        const allPositions = rangeColumns.map((c) => allColumns.indexOf(c)).sort((a, b) => a - b);
        return (0, ag_grid_community_1._last)(allPositions) - allPositions[0] + 1 === rangeColumns.length;
    }
    getRangeStartRow(cellRange) {
        if (cellRange.startRow && cellRange.endRow) {
            return (0, ag_grid_community_1._isRowBefore)(cellRange.startRow, cellRange.endRow) ? cellRange.startRow : cellRange.endRow;
        }
        const pinnedTopRowCount = this.pinnedRowModel?.getPinnedTopRowCount() ?? 0;
        const rowPinned = pinnedTopRowCount > 0 ? 'top' : null;
        return { rowIndex: 0, rowPinned };
    }
    getRangeEndRow(cellRange) {
        if (cellRange.startRow && cellRange.endRow) {
            return (0, ag_grid_community_1._isRowBefore)(cellRange.startRow, cellRange.endRow) ? cellRange.endRow : cellRange.startRow;
        }
        const pinnedBottomRowCount = this.pinnedRowModel?.getPinnedBottomRowCount() ?? 0;
        const pinnedBottom = pinnedBottomRowCount > 0;
        if (pinnedBottom) {
            return {
                rowIndex: pinnedBottomRowCount - 1,
                rowPinned: 'bottom',
            };
        }
        return {
            rowIndex: this.rowModel.getRowCount() - 1,
            rowPinned: null,
        };
    }
    setRangeToCell(cell, appendRange = false) {
        if (!(0, ag_grid_community_1._isCellSelectionEnabled)(this.gos)) {
            return;
        }
        const columns = this.calculateColumnsBetween(cell.column, cell.column);
        if (!columns) {
            return;
        }
        const suppressMultiRangeSelections = (0, ag_grid_community_1._getSuppressMultiRanges)(this.gos);
        // if not appending, then clear previous range selections
        if (suppressMultiRangeSelections || !appendRange || (0, ag_grid_community_1._missing)(this.cellRanges)) {
            this.removeAllCellRanges(true);
        }
        const rowForCell = {
            rowIndex: cell.rowIndex,
            rowPinned: cell.rowPinned,
        };
        const cellRange = {
            startRow: rowForCell,
            endRow: rowForCell,
            columns,
            startColumn: cell.column,
        };
        this.cellRanges.push(cellRange);
        this.setNewestRangeStartCell(cell);
        this.onDragStop();
        this.dispatchChangedEvent(true, true);
    }
    extendLatestRangeToCell(cellPosition) {
        if (this.isEmpty() || !this.newestRangeStartCell) {
            return;
        }
        const cellRange = (0, ag_grid_community_1._last)(this.cellRanges);
        this.updateRangeEnd(cellRange, cellPosition);
    }
    updateRangeEnd(cellRange, cellPosition, silent = false) {
        const endColumn = cellPosition.column;
        const colsToAdd = this.calculateColumnsBetween(cellRange.startColumn, endColumn);
        if (!colsToAdd || this.isLastCellOfRange(cellRange, cellPosition)) {
            return;
        }
        cellRange.columns = colsToAdd;
        cellRange.endRow = { rowIndex: cellPosition.rowIndex, rowPinned: cellPosition.rowPinned };
        if (!silent) {
            this.dispatchChangedEvent(true, true, cellRange.id);
        }
    }
    refreshRangeStart(cellRange) {
        const { startColumn, columns } = cellRange;
        const moveColInCellRange = (colToMove, moveToFront) => {
            const otherCols = cellRange.columns.filter((col) => col !== colToMove);
            if (colToMove) {
                cellRange.startColumn = colToMove;
                cellRange.columns = moveToFront ? [colToMove, ...otherCols] : [...otherCols, colToMove];
            }
            else {
                cellRange.columns = otherCols;
            }
        };
        const { left, right } = this.getRangeEdgeColumns(cellRange);
        const shouldMoveLeftCol = startColumn === columns[0] && startColumn !== left;
        if (shouldMoveLeftCol) {
            moveColInCellRange(left, true);
            return;
        }
        const shouldMoveRightCol = startColumn === (0, ag_grid_community_1._last)(columns) && startColumn === right;
        if (shouldMoveRightCol) {
            moveColInCellRange(right, false);
            return;
        }
    }
    getRangeEdgeColumns(cellRange) {
        const allColumns = this.visibleCols.allCols;
        const allIndices = cellRange.columns
            .map((c) => allColumns.indexOf(c))
            .filter((i) => i > -1)
            .sort((a, b) => a - b);
        return {
            left: allColumns[allIndices[0]],
            right: allColumns[(0, ag_grid_community_1._last)(allIndices)],
        };
    }
    // returns true if successful, false if not successful
    extendLatestRangeInDirection(event) {
        if (this.isEmpty() || !this.newestRangeStartCell) {
            return;
        }
        const key = event.key;
        const ctrlKey = event.ctrlKey || event.metaKey;
        const lastRange = (0, ag_grid_community_1._last)(this.cellRanges);
        const startCell = this.newestRangeStartCell;
        const firstCol = lastRange.columns[0];
        const lastCol = (0, ag_grid_community_1._last)(lastRange.columns);
        // find the cell that is at the furthest away corner from the starting cell
        const endCellIndex = lastRange.endRow.rowIndex;
        const endCellFloating = lastRange.endRow.rowPinned;
        const endCellColumn = startCell.column === firstCol ? lastCol : firstCol;
        const endCell = { column: endCellColumn, rowIndex: endCellIndex, rowPinned: endCellFloating };
        const newEndCell = this.cellNavigation.getNextCellToFocus(key, endCell, ctrlKey);
        // if user is at end of grid, so no cell to extend to, we return false
        if (!newEndCell) {
            return;
        }
        this.setCellRange({
            rowStartIndex: startCell.rowIndex,
            rowStartPinned: startCell.rowPinned,
            rowEndIndex: newEndCell.rowIndex,
            rowEndPinned: newEndCell.rowPinned,
            columnStart: startCell.column,
            columnEnd: newEndCell.column,
        });
        return newEndCell;
    }
    setCellRange(params) {
        if (!(0, ag_grid_community_1._isCellSelectionEnabled)(this.gos)) {
            return;
        }
        this.removeAllCellRanges(true);
        this.addCellRange(params);
    }
    setCellRanges(cellRanges) {
        if ((0, ag_grid_community_1._areEqual)(this.cellRanges, cellRanges)) {
            return;
        }
        if (!this.verifyCellRanges(this.gos)) {
            return;
        }
        this.removeAllCellRanges(true);
        cellRanges.forEach((newRange) => {
            if (newRange.columns && newRange.startRow) {
                this.setNewestRangeStartCell({
                    rowIndex: newRange.startRow.rowIndex,
                    rowPinned: newRange.startRow.rowPinned,
                    column: newRange.columns[0],
                });
            }
            this.cellRanges.push(newRange);
        });
        this.dispatchChangedEvent(false, true);
    }
    setNewestRangeStartCell(position) {
        this.newestRangeStartCell = position;
    }
    clearCellRangeCellValues(params) {
        let { cellRanges } = params;
        const { cellEventSource = 'rangeSvc', dispatchWrapperEvents, wrapperEventSource = 'deleteKey' } = params;
        if (dispatchWrapperEvents) {
            this.eventSvc.dispatchEvent({
                type: 'cellSelectionDeleteStart',
                source: wrapperEventSource,
            });
            this.eventSvc.dispatchEvent({
                type: 'rangeDeleteStart',
                source: wrapperEventSource,
            });
        }
        if (!cellRanges) {
            cellRanges = this.cellRanges;
        }
        cellRanges.forEach((cellRange) => {
            this.forEachRowInRange(cellRange, (rowPosition) => {
                const rowNode = (0, ag_grid_community_1._getRowNode)(this.beans, rowPosition);
                if (!rowNode) {
                    return;
                }
                for (let i = 0; i < cellRange.columns.length; i++) {
                    const column = this.colModel.getCol(cellRange.columns[i]);
                    if (!column || !column.isCellEditable(rowNode)) {
                        continue;
                    }
                    const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
                    rowNode.setDataValue(column, emptyValue, cellEventSource);
                }
            });
        });
        if (dispatchWrapperEvents) {
            this.eventSvc.dispatchEvent({
                type: 'cellSelectionDeleteEnd',
                source: wrapperEventSource,
            });
            this.eventSvc.dispatchEvent({
                type: 'rangeDeleteEnd',
                source: wrapperEventSource,
            });
        }
    }
    createCellRangeFromCellRangeParams(params) {
        return this.createPartialCellRangeFromRangeParams(params, false);
    }
    // Range service can't normally support a range without columns, but charts can
    createPartialCellRangeFromRangeParams(params, allowEmptyColumns) {
        let columns;
        let startsOnTheRight = false;
        if (params.columns) {
            columns = params.columns.map((c) => this.colModel.getCol(c)).filter((c) => c);
        }
        else {
            const columnStart = this.colModel.getCol(params.columnStart);
            const columnEnd = this.colModel.getCol(params.columnEnd);
            if (!columnStart || !columnEnd) {
                return;
            }
            columns = this.calculateColumnsBetween(columnStart, columnEnd);
            if (columns && columns.length) {
                startsOnTheRight = columns[0] !== columnStart;
            }
        }
        if (!columns || (!allowEmptyColumns && columns.length === 0)) {
            return;
        }
        const startRow = params.rowStartIndex != null
            ? {
                rowIndex: params.rowStartIndex,
                rowPinned: params.rowStartPinned || null,
            }
            : undefined;
        const endRow = params.rowEndIndex != null
            ? {
                rowIndex: params.rowEndIndex,
                rowPinned: params.rowEndPinned || null,
            }
            : undefined;
        return {
            startRow,
            endRow,
            columns,
            startColumn: startsOnTheRight ? (0, ag_grid_community_1._last)(columns) : columns[0],
        };
    }
    verifyCellRanges(gos) {
        const invalid = (0, ag_grid_community_1._isUsingNewCellSelectionAPI)(gos) && (0, ag_grid_community_1._getSuppressMultiRanges)(gos) && this.cellRanges.length > 0;
        if (invalid) {
            (0, ag_grid_community_1._warn)(93);
        }
        return !invalid;
    }
    addCellRange(params) {
        const gos = this.gos;
        if (!(0, ag_grid_community_1._isCellSelectionEnabled)(gos) || !this.verifyCellRanges(gos)) {
            return;
        }
        const newRange = this.createCellRangeFromCellRangeParams(params);
        if (newRange) {
            if (newRange.startRow) {
                this.setNewestRangeStartCell({
                    rowIndex: newRange.startRow.rowIndex,
                    rowPinned: newRange.startRow.rowPinned,
                    column: newRange.startColumn,
                });
            }
            this.cellRanges.push(newRange);
            this.dispatchChangedEvent(false, true, newRange.id);
        }
    }
    getCellRanges() {
        return this.cellRanges;
    }
    isEmpty() {
        return this.cellRanges.length === 0;
    }
    isMoreThanOneCell() {
        const len = this.cellRanges.length;
        if (len === 0) {
            return false;
        }
        if (len > 1) {
            return true; // Assumes a cell range must contain at least one cell
        }
        // only one range, return true if range has more than one
        const range = this.cellRanges[0];
        const startRow = this.getRangeStartRow(range);
        const endRow = this.getRangeEndRow(range);
        return (startRow.rowPinned !== endRow.rowPinned ||
            startRow.rowIndex !== endRow.rowIndex ||
            range.columns.length !== 1);
    }
    areAllRangesAbleToMerge() {
        const rowToColumnMap = new Map();
        const len = this.cellRanges.length;
        if (len <= 1)
            return true;
        this.cellRanges.forEach((range) => {
            this.forEachRowInRange(range, (row) => {
                const rowName = `${row.rowPinned || 'normal'}_${row.rowIndex}`;
                const columns = rowToColumnMap.get(rowName);
                const currentRangeColIds = range.columns.map((col) => col.getId());
                if (columns) {
                    const filteredColumns = currentRangeColIds.filter((col) => columns.indexOf(col) === -1);
                    columns.push(...filteredColumns);
                }
                else {
                    rowToColumnMap.set(rowName, currentRangeColIds);
                }
            });
        });
        let columnsString;
        for (const val of rowToColumnMap.values()) {
            const currentValString = val.sort().join();
            if (columnsString === undefined) {
                columnsString = currentValString;
                continue;
            }
            if (columnsString !== currentValString) {
                return false;
            }
        }
        return true;
    }
    forEachRowInRange(cellRange, callback) {
        const topRow = this.getRangeStartRow(cellRange);
        const bottomRow = this.getRangeEndRow(cellRange);
        let currentRow = topRow;
        while (currentRow) {
            callback(currentRow);
            if ((0, ag_grid_community_1._isSameRow)(currentRow, bottomRow)) {
                break;
            }
            currentRow = this.cellNavigation.getRowBelow(currentRow);
        }
    }
    removeAllCellRanges(silent) {
        if (this.isEmpty()) {
            return;
        }
        this.onDragStop();
        this.cellRanges.length = 0;
        if (!silent) {
            this.dispatchChangedEvent(false, true);
        }
    }
    // as the user is dragging outside of the panel, the div starts to scroll, which in turn
    // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate
    // the selection my mimicking a new mouse event
    onBodyScroll() {
        if (this.dragging && this.lastMouseEvent) {
            this.onDragging(this.lastMouseEvent);
        }
    }
    isCellInAnyRange(cell) {
        return this.getCellRangeCount(cell) > 0;
    }
    isCellInSpecificRange(cell, range) {
        const columnInRange = range.columns !== null && range.columns.includes(cell.column);
        const rowInRange = this.isRowInRange(cell.rowIndex, cell.rowPinned, range);
        return columnInRange && rowInRange;
    }
    isLastCellOfRange(cellRange, cell) {
        const { startRow, endRow } = cellRange;
        const lastRow = (0, ag_grid_community_1._isRowBefore)(startRow, endRow) ? endRow : startRow;
        const isLastRow = cell.rowIndex === lastRow.rowIndex && cell.rowPinned === lastRow.rowPinned;
        const rangeFirstIndexColumn = cellRange.columns[0];
        const rangeLastIndexColumn = (0, ag_grid_community_1._last)(cellRange.columns);
        const lastRangeColumn = cellRange.startColumn === rangeFirstIndexColumn ? rangeLastIndexColumn : rangeFirstIndexColumn;
        const isLastColumn = cell.column === lastRangeColumn;
        return isLastColumn && isLastRow;
    }
    isBottomRightCell(cellRange, cell) {
        const allColumns = this.visibleCols.allCols;
        const allPositions = cellRange.columns.map((c) => allColumns.indexOf(c)).sort((a, b) => a - b);
        const { startRow, endRow } = cellRange;
        const lastRow = (0, ag_grid_community_1._isRowBefore)(startRow, endRow) ? endRow : startRow;
        const isRightColumn = allColumns.indexOf(cell.column) === (0, ag_grid_community_1._last)(allPositions);
        const isLastRow = cell.rowIndex === lastRow.rowIndex && (0, ag_grid_community_1._makeNull)(cell.rowPinned) === (0, ag_grid_community_1._makeNull)(lastRow.rowPinned);
        return isRightColumn && isLastRow;
    }
    // returns the number of ranges this cell is in
    getCellRangeCount(cell) {
        if (this.isEmpty()) {
            return 0;
        }
        return this.cellRanges.filter((cellRange) => this.isCellInSpecificRange(cell, cellRange)).length;
    }
    isRowInRange(rowIndex, rowPinned, cellRange) {
        const firstRow = this.getRangeStartRow(cellRange);
        const lastRow = this.getRangeEndRow(cellRange);
        const thisRow = { rowIndex, rowPinned: rowPinned || null };
        // compare rowPinned with == instead of === because it can be `null` or `undefined`
        const equalsFirstRow = thisRow.rowIndex === firstRow.rowIndex && thisRow.rowPinned == firstRow.rowPinned;
        const equalsLastRow = thisRow.rowIndex === lastRow.rowIndex && thisRow.rowPinned == lastRow.rowPinned;
        if (equalsFirstRow || equalsLastRow) {
            return true;
        }
        const afterFirstRow = !(0, ag_grid_community_1._isRowBefore)(thisRow, firstRow);
        const beforeLastRow = (0, ag_grid_community_1._isRowBefore)(thisRow, lastRow);
        return afterFirstRow && beforeLastRow;
    }
    getDraggingRange() {
        return this.draggingRange;
    }
    onDragStart(mouseEvent) {
        if (!(0, ag_grid_community_1._isCellSelectionEnabled)(this.gos)) {
            return;
        }
        const { ctrlKey, metaKey, shiftKey } = mouseEvent;
        // ctrlKey for windows, metaKey for Apple
        const isMultiKey = ctrlKey || metaKey;
        const allowMulti = !(0, ag_grid_community_1._getSuppressMultiRanges)(this.gos);
        const isMultiSelect = allowMulti ? isMultiKey : false;
        const extendRange = shiftKey && !!this.cellRanges?.length;
        if (!isMultiSelect && (!extendRange || (0, ag_grid_community_1._exists)((0, ag_grid_community_1._last)(this.cellRanges).type))) {
            this.removeAllCellRanges(true);
        }
        // The browser changes the Event target of cached events when working with the ShadowDOM
        // so we need to retrieve the initial DragStartTarget.
        const startTarget = this.dragSvc.startTarget;
        if (startTarget) {
            this.updateValuesOnMove(startTarget);
        }
        if (!this.lastCellHovered) {
            return;
        }
        this.dragging = true;
        this.lastMouseEvent = mouseEvent;
        this.intersectionRange = isMultiSelect && this.getCellRangeCount(this.lastCellHovered) > 1;
        if (!extendRange) {
            this.setNewestRangeStartCell(this.lastCellHovered);
        }
        // if we didn't clear the ranges, then dragging means the user clicked, and when the
        // user clicks it means a range of one cell was created. we need to extend this range
        // rather than creating another range. otherwise we end up with two distinct ranges
        // from a drag operation (one from click, and one from drag).
        if (this.cellRanges.length > 0) {
            this.draggingRange = (0, ag_grid_community_1._last)(this.cellRanges);
        }
        else {
            const mouseRowPosition = {
                rowIndex: this.lastCellHovered.rowIndex,
                rowPinned: this.lastCellHovered.rowPinned,
            };
            this.draggingRange = {
                startRow: mouseRowPosition,
                endRow: mouseRowPosition,
                columns: [this.lastCellHovered.column],
                startColumn: this.newestRangeStartCell.column,
            };
            this.cellRanges.push(this.draggingRange);
        }
        this.ctrlsSvc
            .getGridBodyCtrl()
            .eBodyViewport.addEventListener('scroll', this.bodyScrollListener, { passive: true });
        this.dispatchChangedEvent(true, false, this.draggingRange.id);
    }
    intersectLastRange(fromMouseClick) {
        // when ranges are created due to a mouse click without drag (happens in cellMouseListener)
        // this method will be called with `fromMouseClick=true`.
        if (fromMouseClick && this.dragging) {
            return;
        }
        if ((0, ag_grid_community_1._getSuppressMultiRanges)(this.gos)) {
            return;
        }
        if (this.isEmpty()) {
            return;
        }
        const lastRange = (0, ag_grid_community_1._last)(this.cellRanges);
        const intersectionStartRow = this.getRangeStartRow(lastRange);
        const intersectionEndRow = this.getRangeEndRow(lastRange);
        const newRanges = [];
        this.cellRanges.slice(0, -1).forEach((range) => {
            const startRow = this.getRangeStartRow(range);
            const endRow = this.getRangeEndRow(range);
            const cols = range.columns;
            const intersectCols = cols.filter((col) => lastRange.columns.indexOf(col) === -1);
            if (intersectCols.length === cols.length) {
                // No overlapping columns, retain previous range
                newRanges.push(range);
                return;
            }
            if ((0, ag_grid_community_1._isRowBefore)(intersectionEndRow, startRow) || (0, ag_grid_community_1._isRowBefore)(endRow, intersectionStartRow)) {
                // No overlapping rows, retain previous range
                newRanges.push(range);
                return;
            }
            const rangeCountBefore = newRanges.length;
            // Top
            if ((0, ag_grid_community_1._isRowBefore)(startRow, intersectionStartRow)) {
                const top = {
                    columns: [...cols],
                    startColumn: lastRange.startColumn,
                    startRow: { ...startRow },
                    endRow: this.cellNavigation.getRowAbove(intersectionStartRow),
                };
                newRanges.push(top);
            }
            // Left & Right (not contiguous with columns)
            if (intersectCols.length > 0) {
                const middle = {
                    columns: intersectCols,
                    startColumn: intersectCols.includes(lastRange.startColumn)
                        ? lastRange.startColumn
                        : intersectCols[0],
                    startRow: this.rowMax([{ ...intersectionStartRow }, { ...startRow }]),
                    endRow: this.rowMin([{ ...intersectionEndRow }, { ...endRow }]),
                };
                newRanges.push(middle);
            }
            // Bottom
            if ((0, ag_grid_community_1._isRowBefore)(intersectionEndRow, endRow)) {
                newRanges.push({
                    columns: [...cols],
                    startColumn: lastRange.startColumn,
                    startRow: this.cellNavigation.getRowBelow(intersectionEndRow),
                    endRow: { ...endRow },
                });
            }
            if (newRanges.length - rangeCountBefore === 1) {
                // Only one range result from the intersection.
                // Copy the source range's id, since essentially we just reduced it's size
                newRanges[newRanges.length - 1].id = range.id;
            }
        });
        this.cellRanges = newRanges;
        // when this is called because of a clickEvent and the ranges were changed
        // we need to force a dragEnd event to update the UI.
        if (fromMouseClick) {
            this.dispatchChangedEvent(false, true);
        }
    }
    rowMax(rows) {
        let max;
        rows.forEach((row) => {
            if (max === undefined || (0, ag_grid_community_1._isRowBefore)(max, row)) {
                max = row;
            }
        });
        return max;
    }
    rowMin(rows) {
        let min;
        rows.forEach((row) => {
            if (min === undefined || (0, ag_grid_community_1._isRowBefore)(row, min)) {
                min = row;
            }
        });
        return min;
    }
    updateValuesOnMove(eventTarget) {
        const cellCtrl = (0, ag_grid_community_1._getCellCtrlForEventTarget)(this.gos, eventTarget);
        const cell = cellCtrl?.cellPosition;
        this.cellHasChanged = false;
        if (!cell || (this.lastCellHovered && (0, ag_grid_community_1._areCellsEqual)(cell, this.lastCellHovered))) {
            return;
        }
        if (cellCtrl?.editing) {
            this.dragSvc.cancelDrag(eventTarget);
            return;
        }
        if (this.lastCellHovered) {
            this.cellHasChanged = true;
        }
        this.lastCellHovered = cell;
    }
    onDragging(mouseEvent) {
        if (!this.dragging || !mouseEvent) {
            return;
        }
        this.updateValuesOnMove(mouseEvent.target);
        this.lastMouseEvent = mouseEvent;
        const cellPosition = this.lastCellHovered;
        const isMouseAndStartInPinned = (position) => cellPosition && cellPosition.rowPinned === position && this.newestRangeStartCell.rowPinned === position;
        const skipVerticalScroll = isMouseAndStartInPinned('top') || isMouseAndStartInPinned('bottom');
        this.autoScrollService.check(mouseEvent, skipVerticalScroll);
        if (!this.cellHasChanged) {
            return;
        }
        const columns = this.calculateColumnsBetween(this.newestRangeStartCell.column, cellPosition.column);
        if (!columns) {
            return;
        }
        this.draggingRange.endRow = {
            rowIndex: cellPosition.rowIndex,
            rowPinned: cellPosition.rowPinned,
        };
        this.draggingRange.columns = columns;
        this.dispatchChangedEvent(false, false, this.draggingRange.id);
    }
    onDragStop() {
        if (!this.dragging) {
            return;
        }
        const { id } = this.draggingRange;
        this.autoScrollService.ensureCleared();
        this.ctrlsSvc.getGridBodyCtrl().eBodyViewport.removeEventListener('scroll', this.bodyScrollListener);
        this.lastMouseEvent = null;
        this.dragging = false;
        this.draggingRange = undefined;
        this.lastCellHovered = undefined;
        if (this.intersectionRange) {
            this.intersectionRange = false;
            this.intersectLastRange();
        }
        this.dispatchChangedEvent(false, true, id);
    }
    dispatchChangedEvent(started, finished, id) {
        this.eventSvc.dispatchEvent({
            type: 'cellSelectionChanged',
            started,
            finished,
            id,
        });
        this.eventSvc.dispatchEvent({
            type: 'rangeSelectionChanged',
            started,
            finished,
            id,
        });
    }
    calculateColumnsBetween(columnFrom, columnTo) {
        const allColumns = this.visibleCols.allCols;
        const isSameColumn = columnFrom === columnTo;
        const fromIndex = allColumns.indexOf(columnFrom);
        if (fromIndex < 0) {
            (0, ag_grid_community_1._warn)(178, { colId: columnFrom.getId() });
            return;
        }
        const toIndex = isSameColumn ? fromIndex : allColumns.indexOf(columnTo);
        if (toIndex < 0) {
            (0, ag_grid_community_1._warn)(178, { colId: columnTo.getId() });
            return;
        }
        if (isSameColumn) {
            return [columnFrom];
        }
        const firstIndex = Math.min(fromIndex, toIndex);
        const lastIndex = firstIndex === fromIndex ? toIndex : fromIndex;
        const columns = [];
        for (let i = firstIndex; i <= lastIndex; i++) {
            columns.push(allColumns[i]);
        }
        return columns;
    }
    createDragListenerFeature(eContainer) {
        return new dragListenerFeature_1.DragListenerFeature(eContainer);
    }
    createCellRangeFeature(beans, ctrl) {
        return new cellRangeFeature_1.CellRangeFeature(beans, ctrl);
    }
}
exports.RangeService = RangeService;


/***/ }),

/***/ 3978:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findLineByLeastSquares = void 0;
function findLineByLeastSquares(values) {
    const len = values.length;
    let maxDecimals = 0;
    if (len <= 1) {
        return values;
    }
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        const splitExponent = value.toString().split('e-');
        if (splitExponent.length > 1) {
            maxDecimals = Math.max(maxDecimals, parseInt(splitExponent[1], 10));
            continue;
        }
        if (Math.floor(value) === value) {
            continue;
        }
        maxDecimals = Math.max(maxDecimals, value.toString().split('.')[1].length);
    }
    let sum_x = 0;
    let sum_y = 0;
    let sum_xy = 0;
    let sum_xx = 0;
    let y = 0;
    for (let x = 0; x < len; x++) {
        y = values[x];
        sum_x += x;
        sum_y += y;
        sum_xx += x * x;
        sum_xy += x * y;
    }
    const m = (len * sum_xy - sum_x * sum_y) / (len * sum_xx - sum_x * sum_x);
    const b = sum_y / len - (m * sum_x) / len;
    const result = [];
    for (let x = 0; x <= len; x++) {
        result.push(parseFloat((x * m + b).toFixed(maxDecimals)));
    }
    return result;
}
exports.findLineByLeastSquares = findLineByLeastSquares;


/***/ }),

/***/ 9617:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RichSelectCellEditor = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agRichSelect_1 = __webpack_require__(2005);
class RichSelectCellEditor extends ag_grid_community_1.PopupComponent {
    constructor() {
        super(/* html */ `<div class="ag-cell-edit-wrapper"></div>`);
    }
    init(params) {
        this.params = params;
        const { cellStartedEdit, values } = params;
        if ((0, ag_grid_community_1._missing)(values)) {
            (0, ag_grid_community_1._warn)(180);
        }
        const { params: richSelectParams, valuesPromise } = this.buildRichSelectParams();
        const richSelect = this.createManagedBean(new agRichSelect_1.AgRichSelect(richSelectParams));
        this.richSelect = richSelect;
        richSelect.addCssClass('ag-cell-editor');
        this.appendChild(richSelect);
        if (valuesPromise) {
            valuesPromise.then((values) => {
                richSelect.setValueList({ valueList: values, refresh: true });
                const searchStringCallback = this.getSearchStringCallback(values);
                if (searchStringCallback) {
                    richSelect.setSearchStringCreator(searchStringCallback);
                }
            });
        }
        this.addManagedListeners(richSelect, {
            fieldPickerValueSelected: this.onEditorPickerValueSelected.bind(this),
        });
        this.focusAfterAttached = cellStartedEdit;
    }
    onEditorPickerValueSelected(e) {
        // there is an issue with focus handling when we call `stopEditing` while the
        // picker list is still collapsing, so we make this call async to guarantee that.
        setTimeout(() => this.params.stopEditing(!e.fromEnterKey));
    }
    buildRichSelectParams() {
        const params = this.params;
        const { cellRenderer, cellHeight, value, values, formatValue, searchDebounceDelay, valueListGap, valueListMaxHeight, valueListMaxWidth, allowTyping, filterList, searchType, highlightMatch, valuePlaceholder, eventKey, multiSelect, suppressDeselectAll, suppressMultiSelectPillRenderer, } = params;
        const ret = {
            value: value,
            cellRenderer,
            cellRowHeight: cellHeight,
            searchDebounceDelay,
            valueFormatter: formatValue,
            pickerAriaLabelKey: 'ariaLabelRichSelectField',
            pickerAriaLabelValue: 'Rich Select Field',
            pickerType: 'virtual-list',
            pickerGap: valueListGap,
            allowTyping,
            filterList,
            searchType,
            highlightMatch,
            maxPickerHeight: valueListMaxHeight,
            maxPickerWidth: valueListMaxWidth,
            placeholder: valuePlaceholder,
            initialInputValue: eventKey?.length === 1 ? eventKey : undefined,
            multiSelect,
            suppressDeselectAll,
            suppressMultiSelectPillRenderer,
        };
        let valuesResult;
        let valuesPromise;
        if (typeof values === 'function') {
            valuesResult = values(params);
        }
        else {
            valuesResult = values ?? [];
        }
        if (Array.isArray(valuesResult)) {
            ret.valueList = valuesResult;
            ret.searchStringCreator = this.getSearchStringCallback(valuesResult);
        }
        else {
            valuesPromise = valuesResult;
        }
        if (multiSelect && allowTyping) {
            params.allowTyping = ret.allowTyping = false;
            (0, ag_grid_community_1._warn)(181);
        }
        return { params: ret, valuesPromise };
    }
    getSearchStringCallback(values) {
        const params = this.params;
        const { colDef } = params;
        if (typeof values[0] !== 'object' || !colDef.keyCreator) {
            return;
        }
        const { column, node, data } = params;
        return (values) => values.map((value) => {
            const keyParams = this.gos.addGridCommonParams({
                value,
                colDef,
                column,
                node,
                data,
            });
            return colDef.keyCreator(keyParams);
        });
    }
    // we need to have the gui attached before we can draw the virtual rows, as the
    // virtual row logic needs info about the gui state
    afterGuiAttached() {
        const { focusAfterAttached, params } = this;
        setTimeout(() => {
            if (!this.isAlive()) {
                return;
            }
            const richSelect = this.richSelect;
            if (focusAfterAttached) {
                const focusableEl = richSelect.getFocusableElement();
                focusableEl.focus();
                const { allowTyping, eventKey } = this.params;
                if (allowTyping && (!eventKey || eventKey.length !== 1)) {
                    focusableEl.select();
                }
            }
            richSelect.showPicker();
            const { eventKey } = params;
            if (eventKey) {
                if (eventKey?.length === 1) {
                    richSelect.searchTextFromString(eventKey);
                }
            }
        });
    }
    focusIn() {
        this.richSelect.getFocusableElement().focus();
    }
    getValue() {
        return this.richSelect.getValue();
    }
    isPopup() {
        return false;
    }
}
exports.RichSelectCellEditor = RichSelectCellEditor;


/***/ }),

/***/ 9327:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RichSelectModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const richSelectCellEditor_1 = __webpack_require__(9617);
/**
 * @feature Editing -> Rich Select Editor
 */
exports.RichSelectModule = {
    moduleName: 'RichSelect',
    version: version_1.VERSION,
    beans: [],
    userComponents: { agRichSelect: richSelectCellEditor_1.RichSelectCellEditor, agRichSelectCellEditor: richSelectCellEditor_1.RichSelectCellEditor },
    icons: {
        // open icon for rich select editor
        richSelectOpen: 'small-down',
        // remove for rich select editor pills
        richSelectRemove: 'cancel',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._EditCoreModule],
};


/***/ }),

/***/ 9449:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgGridHeaderDropZonesSelector = exports.AgGridHeaderDropZones = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pivotDropZonePanel_1 = __webpack_require__(6491);
const rowGroupDropZonePanel_1 = __webpack_require__(4552);
class AgGridHeaderDropZones extends ag_grid_community_1.Component {
    constructor() {
        super();
    }
    postConstruct() {
        this.setGui(this.createNorthPanel());
        const onRowGroupChanged = this.onRowGroupChanged.bind(this);
        this.addManagedEventListeners({
            columnRowGroupChanged: onRowGroupChanged,
            newColumnsLoaded: onRowGroupChanged,
        });
        this.addManagedPropertyListener('rowGroupPanelShow', onRowGroupChanged);
        this.addManagedPropertyListener('pivotPanelShow', () => this.onPivotPanelShow());
        this.onRowGroupChanged();
    }
    createNorthPanel() {
        const topPanelGui = document.createElement('div');
        topPanelGui.classList.add('ag-column-drop-wrapper');
        (0, ag_grid_community_1._setAriaRole)(topPanelGui, 'presentation');
        const rowGroupComp = new rowGroupDropZonePanel_1.RowGroupDropZonePanel(true);
        this.rowGroupComp = this.createManagedBean(rowGroupComp);
        const pivotComp = new pivotDropZonePanel_1.PivotDropZonePanel(true);
        this.pivotComp = this.createManagedBean(pivotComp);
        topPanelGui.appendChild(rowGroupComp.getGui());
        topPanelGui.appendChild(pivotComp.getGui());
        const listener = this.onDropPanelVisible.bind(this);
        this.addManagedListeners(rowGroupComp, {
            displayChanged: listener,
        });
        this.addManagedListeners(pivotComp, {
            displayChanged: listener,
        });
        this.onDropPanelVisible();
        return topPanelGui;
    }
    onDropPanelVisible() {
        const { rowGroupComp, pivotComp } = this;
        const bothDisplayed = rowGroupComp.isDisplayed() && pivotComp.isDisplayed();
        const classStr = 'ag-column-drop-horizontal-half-width';
        rowGroupComp.addOrRemoveCssClass(classStr, bothDisplayed);
        pivotComp.addOrRemoveCssClass(classStr, bothDisplayed);
    }
    onRowGroupChanged() {
        const rowGroupComp = this.rowGroupComp;
        if (!rowGroupComp) {
            return;
        }
        const rowGroupPanelShow = this.gos.get('rowGroupPanelShow');
        if (rowGroupPanelShow === 'always') {
            rowGroupComp.setDisplayed(true);
        }
        else if (rowGroupPanelShow === 'onlyWhenGrouping') {
            const grouping = this.beans.rowGroupColsSvc?.columns?.length !== 0;
            rowGroupComp.setDisplayed(grouping);
        }
        else {
            rowGroupComp.setDisplayed(false);
        }
    }
    onPivotPanelShow() {
        const pivotComp = this.pivotComp;
        if (!pivotComp) {
            return;
        }
        const pivotPanelShow = this.gos.get('pivotPanelShow');
        if (pivotPanelShow === 'always') {
            pivotComp.setDisplayed(true);
        }
        else if (pivotPanelShow === 'onlyWhenPivoting') {
            const pivoting = this.beans.colModel.isPivotActive();
            pivotComp.setDisplayed(pivoting);
        }
        else {
            pivotComp.setDisplayed(false);
        }
    }
}
exports.AgGridHeaderDropZones = AgGridHeaderDropZones;
exports.AgGridHeaderDropZonesSelector = {
    selector: 'AG-GRID-HEADER-DROP-ZONES',
    component: AgGridHeaderDropZones,
};


/***/ }),

/***/ 8322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseDropZonePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pillDropZonePanel_1 = __webpack_require__(9733);
const dropZoneColumnComp_1 = __webpack_require__(3154);
class BaseDropZonePanel extends pillDropZonePanel_1.PillDropZonePanel {
    constructor(horizontal, dropZonePurpose) {
        super(horizontal);
        this.dropZonePurpose = dropZonePurpose;
        this.addElementClasses(this.getGui(), this.dropZonePurpose.toLowerCase());
    }
    init(params) {
        super.init(params);
        this.addManagedEventListeners({ newColumnsLoaded: this.refreshGui.bind(this) });
        this.addManagedPropertyListeners(['functionsReadOnly', 'rowGroupPanelSuppressSort', 'groupLockGroupColumns'], this.refreshGui.bind(this));
    }
    getItems(dragItem) {
        return dragItem.columns ?? [];
    }
    isInterestedIn(type) {
        // not interested in row drags
        return type === ag_grid_community_1.DragSourceType.HeaderCell || type === ag_grid_community_1.DragSourceType.ToolPanel;
    }
    minimumAllowedNewInsertIndex() {
        const { gos, rowGroupColsSvc } = this.beans;
        const numberOfLockedCols = gos.get('groupLockGroupColumns');
        const numberOfGroupCols = rowGroupColsSvc?.columns.length ?? 0;
        if (numberOfLockedCols === -1) {
            return numberOfGroupCols;
        }
        return Math.min(numberOfLockedCols, numberOfGroupCols);
    }
    showOrHideColumnOnExit(draggingEvent) {
        return (this.isRowGroupPanel() && (0, ag_grid_community_1._shouldUpdateColVisibilityAfterGroup)(this.gos, true) && !draggingEvent.fromNudge);
    }
    handleDragEnterEnd(draggingEvent) {
        const hideColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);
        if (hideColumnOnExit) {
            const dragItem = draggingEvent.dragSource.getDragItem();
            const columns = dragItem.columns;
            this.setColumnsVisible(columns, false, 'uiColumnDragged');
        }
    }
    handleDragLeaveEnd(draggingEvent) {
        const showColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);
        if (showColumnOnExit) {
            const dragItem = draggingEvent.dragSource.getDragItem();
            this.setColumnsVisible(dragItem.columns, true, 'uiColumnDragged');
        }
    }
    setColumnsVisible(columns, visible, source) {
        if (columns) {
            const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
            this.beans.colModel.setColsVisible(allowedCols, visible, source);
        }
    }
    isRowGroupPanel() {
        return this.dropZonePurpose === 'rowGroup';
    }
    createPillComponent(column, dropTarget, ghost, horizontal) {
        return new dropZoneColumnComp_1.DropZoneColumnComp(column, dropTarget, ghost, this.dropZonePurpose, horizontal);
    }
}
exports.BaseDropZonePanel = BaseDropZonePanel;


/***/ }),

/***/ 3154:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DropZoneColumnComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pillDragComp_1 = __webpack_require__(3173);
const virtualList_1 = __webpack_require__(7904);
const rowGroupingUtils_1 = __webpack_require__(8105);
class DropZoneColumnComp extends pillDragComp_1.PillDragComp {
    constructor(column, dragSourceDropTarget, ghost, dropZonePurpose, horizontal) {
        super(dragSourceDropTarget, ghost, horizontal);
        this.column = column;
        this.dropZonePurpose = dropZonePurpose;
        this.eSortIndicator = ag_grid_community_1.RefPlaceholder;
        this.popupShowing = false;
    }
    postConstruct() {
        const { sortSvc, colNames } = this.beans;
        this.template = /* html */ `
            <span role="option">
                <span data-ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
                <span data-ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
                ${sortSvc ? '<ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>' : ''}
                <span data-ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
            </span>
        `;
        if (sortSvc) {
            this.agComponents = [sortSvc.getSortIndicatorSelector()];
        }
        this.displayName = colNames.getDisplayNameForColumn(this.column, 'columnDrop');
        super.postConstruct();
        if (sortSvc) {
            this.setupSort();
            this.addManagedEventListeners({
                sortChanged: () => {
                    this.setupAria();
                },
            });
        }
        if (this.isGroupingZone()) {
            this.addManagedPropertyListener('groupLockGroupColumns', () => {
                this.refreshRemove();
                this.refreshDraggable();
                this.setupAria();
            });
        }
    }
    getItem() {
        return this.column;
    }
    getDisplayName() {
        return this.displayName;
    }
    getTooltip() {
        return this.column.getColDef().headerTooltip;
    }
    addAdditionalAriaInstructions(ariaInstructions, translate) {
        const isSortSuppressed = this.gos.get('rowGroupPanelSuppressSort');
        const isFunctionsReadOnly = this.gos.get('functionsReadOnly');
        if (this.isAggregationZone() && !isFunctionsReadOnly) {
            const aggregationMenuAria = translate('ariaDropZoneColumnValueItemDescription', 'Press ENTER to change the aggregation type');
            ariaInstructions.push(aggregationMenuAria);
        }
        if (this.isGroupingZone() && this.column.isSortable() && !isSortSuppressed) {
            const sortProgressAria = translate('ariaDropZoneColumnGroupItemDescription', 'Press ENTER to sort');
            ariaInstructions.push(sortProgressAria);
        }
        super.addAdditionalAriaInstructions(ariaInstructions, translate);
    }
    isDraggable() {
        return this.isReadOnly();
    }
    isRemovable() {
        return this.isReadOnly();
    }
    isReadOnly() {
        return !this.isGroupingAndLocked() && !this.gos.get('functionsReadOnly');
    }
    getAriaDisplayName() {
        const translate = this.getLocaleTextFunc();
        const { name, aggFuncName } = this.getColumnAndAggFuncName();
        const aggSeparator = translate('ariaDropZoneColumnComponentAggFuncSeparator', ' of ');
        const sortDirection = {
            asc: translate('ariaDropZoneColumnComponentSortAscending', 'ascending'),
            desc: translate('ariaDropZoneColumnComponentSortDescending', 'descending'),
        };
        const columnSort = this.column.getSort();
        const isSortSuppressed = this.gos.get('rowGroupPanelSuppressSort');
        return [
            aggFuncName && `${aggFuncName}${aggSeparator}`,
            name,
            this.isGroupingZone() && !isSortSuppressed && columnSort && `, ${sortDirection[columnSort]}`,
        ]
            .filter((part) => !!part)
            .join('');
    }
    getColumnAndAggFuncName() {
        const name = this.displayName;
        let aggFuncName = '';
        if (this.isAggregationZone()) {
            const aggFunc = this.column.getAggFunc();
            // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'
            const aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';
            const localeTextFunc = this.getLocaleTextFunc();
            aggFuncName = localeTextFunc(aggFuncString, aggFuncString);
        }
        return { name, aggFuncName };
    }
    setupSort() {
        if (!this.column.isSortable() || !this.isGroupingZone()) {
            return;
        }
        if (!this.gos.get('rowGroupPanelSuppressSort')) {
            this.eSortIndicator.setupSort(this.column, true);
            const performSort = (event) => {
                event.preventDefault();
                this.beans.sortSvc.progressSortFromEvent(this.column, event);
            };
            this.addGuiEventListener('click', performSort);
            this.addGuiEventListener('keydown', (e) => {
                const isEnter = e.key === ag_grid_community_1.KeyCode.ENTER;
                if (isEnter && this.isGroupingZone()) {
                    performSort(e);
                }
            });
        }
    }
    getDefaultIconName() {
        return 'hide';
    }
    createGetDragItem() {
        const { column } = this;
        return () => {
            const visibleState = {};
            visibleState[column.getId()] = column.isVisible();
            return {
                columns: [column],
                visibleState: visibleState,
            };
        };
    }
    setupComponents() {
        super.setupComponents();
        if (this.isAggregationZone() && !this.gos.get('functionsReadOnly')) {
            this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));
        }
    }
    onKeyDown(e) {
        super.onKeyDown(e);
        const isEnter = e.key === ag_grid_community_1.KeyCode.ENTER;
        if (isEnter && this.isAggregationZone() && !this.gos.get('functionsReadOnly')) {
            e.preventDefault();
            this.onShowAggFuncSelection();
        }
    }
    getDisplayValue() {
        const { name, aggFuncName } = this.getColumnAndAggFuncName();
        return this.isAggregationZone() ? `${aggFuncName}(${name})` : name;
    }
    onShowAggFuncSelection() {
        if (this.popupShowing) {
            return;
        }
        this.popupShowing = true;
        const { aggFuncSvc, popupSvc } = this.beans;
        const virtualList = new virtualList_1.VirtualList({ cssIdentifier: 'select-agg-func' });
        const rows = aggFuncSvc.getFuncNames(this.column);
        const eGui = this.getGui();
        const virtualListGui = virtualList.getGui();
        virtualList.setModel({
            getRow: function (index) {
                return rows[index];
            },
            getRowCount: function () {
                return rows.length;
            },
        });
        this.createBean(virtualList);
        const ePopup = (0, ag_grid_community_1._loadTemplate)(/* html*/ `<div class="ag-select-agg-func-popup"></div>`);
        ePopup.style.top = '0px';
        ePopup.style.left = '0px';
        ePopup.appendChild(virtualListGui);
        ePopup.style.width = `${eGui.clientWidth}px`;
        const [focusoutListener] = this.addManagedElementListeners(ePopup, {
            focusout: (e) => {
                if (!ePopup.contains(e.relatedTarget) && addPopupRes) {
                    addPopupRes.hideFunc();
                }
            },
        });
        const popupHiddenFunc = (callbackEvent) => {
            this.destroyBean(virtualList);
            this.popupShowing = false;
            if (callbackEvent?.key === 'Escape') {
                eGui.focus();
            }
            if (focusoutListener) {
                focusoutListener();
            }
        };
        const translate = this.getLocaleTextFunc();
        const addPopupRes = popupSvc.addPopup({
            modal: true,
            eChild: ePopup,
            closeOnEsc: true,
            closedCallback: popupHiddenFunc,
            ariaLabel: translate('ariaLabelAggregationFunction', 'Aggregation Function'),
        });
        if (addPopupRes) {
            virtualList.setComponentCreator(this.createAggSelect.bind(this, addPopupRes.hideFunc));
        }
        virtualList.addGuiEventListener('keydown', (e) => {
            if (e.key === ag_grid_community_1.KeyCode.ENTER || e.key === ag_grid_community_1.KeyCode.SPACE) {
                const row = virtualList.getLastFocusedRow();
                if (row == null) {
                    return;
                }
                const comp = virtualList.getComponentAt(row);
                if (comp) {
                    comp.selectItem();
                }
            }
        });
        popupSvc.positionPopupByComponent({
            type: 'aggFuncSelect',
            eventSource: eGui,
            ePopup: ePopup,
            keepWithinBounds: true,
            column: this.column,
            position: 'under',
        });
        virtualList.refresh();
        let rowToFocus = rows.findIndex((r) => r === this.column.getAggFunc());
        if (rowToFocus === -1) {
            rowToFocus = 0;
        }
        virtualList.focusRow(rowToFocus);
    }
    createAggSelect(hidePopup, value) {
        const itemSelected = () => {
            hidePopup();
            this.getGui().focus();
            this.beans.valueColsSvc?.setColumnAggFunc?.(this.column, value, 'toolPanelDragAndDrop');
        };
        const localeTextFunc = this.getLocaleTextFunc();
        const aggFuncString = value.toString();
        const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
        const comp = new AggItemComp(itemSelected, aggFuncStringTranslated);
        return comp;
    }
    isGroupingAndLocked() {
        return this.isGroupingZone() && (0, rowGroupingUtils_1.isRowGroupColLocked)(this.column, this.beans);
    }
    isAggregationZone() {
        return this.dropZonePurpose === 'aggregation';
    }
    isGroupingZone() {
        return this.dropZonePurpose === 'rowGroup';
    }
    getDragSourceType() {
        return ag_grid_community_1.DragSourceType.ToolPanel;
    }
    destroy() {
        super.destroy();
        this.column = null;
    }
}
exports.DropZoneColumnComp = DropZoneColumnComp;
class AggItemComp extends ag_grid_community_1.Component {
    constructor(itemSelected, value) {
        super(/* html */ `<div class="ag-select-agg-func-item"/>`);
        this.selectItem = itemSelected;
        this.getGui().innerText = value;
        this.addGuiEventListener('click', this.selectItem);
    }
}


/***/ }),

/***/ 6491:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PivotDropZonePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const baseDropZonePanel_1 = __webpack_require__(8322);
class PivotDropZonePanel extends baseDropZonePanel_1.BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'pivot');
    }
    postConstruct() {
        const localeTextFunc = this.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to set column labels');
        const title = localeTextFunc('pivots', 'Column Labels');
        super.init({
            icon: (0, ag_grid_community_1._createIconNoSpan)('pivotPanel', this.beans, null),
            emptyMessage: emptyMessage,
            title: title,
        });
        this.addManagedEventListeners({
            newColumnsLoaded: this.refresh.bind(this),
            columnPivotChanged: this.refresh.bind(this),
            columnPivotModeChanged: this.checkVisibility.bind(this),
        });
        this.refresh();
    }
    getAriaLabel() {
        const translate = this.getLocaleTextFunc();
        const label = translate('ariaPivotDropZonePanelLabel', 'Column Labels');
        return label;
    }
    refresh() {
        this.checkVisibility();
        this.refreshGui();
    }
    checkVisibility() {
        const colModel = this.beans.colModel;
        const pivotMode = colModel.isPivotMode();
        if (this.horizontal) {
            // what we do for horizontal (ie the pivot panel at the top) depends
            // on the user property as well as pivotMode.
            switch (this.gos.get('pivotPanelShow')) {
                case 'always':
                    this.setDisplayed(pivotMode);
                    break;
                case 'onlyWhenPivoting': {
                    const pivotActive = colModel.isPivotActive();
                    this.setDisplayed(pivotMode && pivotActive);
                    break;
                }
                default:
                    // never show it
                    this.setDisplayed(false);
                    break;
            }
        }
        else {
            // in toolPanel, the pivot panel is always shown when pivot mode is on
            this.setDisplayed(pivotMode);
        }
    }
    isItemDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowPivot() && (!column.isPivotActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateItems(columns) {
        this.beans.pivotColsSvc?.setColumns(columns, 'toolPanelUi');
    }
    getIconName() {
        return this.isPotentialDndItems() ? 'pivot' : 'notAllowed';
    }
    getExistingItems() {
        return this.beans.pivotColsSvc?.columns ?? [];
    }
}
exports.PivotDropZonePanel = PivotDropZonePanel;


/***/ }),

/***/ 4552:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowGroupDropZonePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const baseDropZonePanel_1 = __webpack_require__(8322);
class RowGroupDropZonePanel extends baseDropZonePanel_1.BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'rowGroup');
    }
    postConstruct() {
        const localeTextFunc = this.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to set row groups');
        const title = localeTextFunc('groups', 'Row Groups');
        super.init({
            icon: (0, ag_grid_community_1._createIconNoSpan)('rowGroupPanel', this.beans, null),
            emptyMessage: emptyMessage,
            title,
        });
        this.addManagedEventListeners({ columnRowGroupChanged: this.refreshGui.bind(this) });
    }
    getAriaLabel() {
        const translate = this.getLocaleTextFunc();
        const label = translate('ariaRowGroupDropZonePanelLabel', 'Row Groups');
        return label;
    }
    isItemDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowRowGroup() && (!column.isRowGroupActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateItems(columns) {
        this.beans.rowGroupColsSvc?.setColumns(columns, 'toolPanelUi');
    }
    getIconName() {
        return this.isPotentialDndItems() ? 'group' : 'notAllowed';
    }
    getExistingItems() {
        return this.beans.rowGroupColsSvc?.columns ?? [];
    }
}
exports.RowGroupDropZonePanel = RowGroupDropZonePanel;


/***/ }),

/***/ 3392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValuesDropZonePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const baseDropZonePanel_1 = __webpack_require__(8322);
class ValuesDropZonePanel extends baseDropZonePanel_1.BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'aggregation');
    }
    postConstruct() {
        const localeTextFunc = this.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('valueColumnsEmptyMessage', 'Drag here to aggregate');
        const title = localeTextFunc('values', 'Values');
        super.init({
            icon: (0, ag_grid_community_1._createIconNoSpan)('valuePanel', this.beans, null),
            emptyMessage: emptyMessage,
            title: title,
        });
        this.addManagedEventListeners({ columnValueChanged: this.refreshGui.bind(this) });
    }
    getAriaLabel() {
        const translate = this.getLocaleTextFunc();
        const label = translate('ariaValuesDropZonePanelLabel', 'Values');
        return label;
    }
    getIconName() {
        return this.isPotentialDndItems() ? 'aggregate' : 'notAllowed';
    }
    isItemDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowValue() && (!column.isValueActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateItems(columns) {
        this.beans.valueColsSvc?.setColumns(columns, 'toolPanelUi');
    }
    getExistingItems() {
        return this.beans.valueColsSvc?.columns ?? [];
    }
}
exports.ValuesDropZonePanel = ValuesDropZonePanel;


/***/ }),

/***/ 4700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupFilter = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class GroupFilter extends ag_grid_community_1.TabGuardComp {
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
        this.showRowGroupCols = beans.showRowGroupCols;
    }
    constructor() {
        super(/* html */ `
            <div class="ag-group-filter">
                <div data-ref="eGroupField"></div>
                <div data-ref="eUnderlyingFilter"></div>
            </div>
        `);
        this.eGroupField = ag_grid_community_1.RefPlaceholder;
        this.eUnderlyingFilter = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.initialiseTabGuard({});
    }
    init(params) {
        return this.updateParams(params).then(() => {
            this.addManagedEventListeners({
                columnRowGroupChanged: () => this.onColumnRowGroupChanged(),
                filterDestroyed: (event) => this.onFilterDestroyed(event),
            });
        });
    }
    refresh(params) {
        this.updateParams(params);
        return true;
    }
    updateParams(params) {
        this.params = params;
        this.validateParams();
        return this.updateGroups();
    }
    validateParams() {
        const { colDef } = this.params;
        if (colDef.field) {
            (0, ag_grid_community_1._warn)(234);
        }
        if (colDef.filterValueGetter) {
            (0, ag_grid_community_1._warn)(235);
        }
        if (colDef.filterParams) {
            (0, ag_grid_community_1._warn)(236);
        }
    }
    updateGroups() {
        const sourceColumns = this.updateGroupField();
        return this.getUnderlyingFilters(sourceColumns);
    }
    getSourceColumns() {
        this.groupColumn = this.params.column;
        if (this.gos.get('treeData')) {
            (0, ag_grid_community_1._warn)(237);
            return [];
        }
        const sourceColumns = this.showRowGroupCols?.getSourceColumnsForGroupColumn(this.groupColumn);
        if (!sourceColumns) {
            (0, ag_grid_community_1._warn)(183);
            return [];
        }
        return sourceColumns;
    }
    updateGroupField() {
        const eGroupField = this.eGroupField;
        (0, ag_grid_community_1._clearElement)(eGroupField);
        if (this.eGroupFieldSelect) {
            this.destroyBean(this.eGroupFieldSelect);
        }
        const allSourceColumns = this.getSourceColumns();
        const sourceColumns = allSourceColumns.filter((sourceColumn) => sourceColumn.isFilterAllowed());
        if (!sourceColumns.length) {
            this.selectedColumn = undefined;
            (0, ag_grid_community_1._setDisplayed)(eGroupField, false);
            return null;
        }
        if (allSourceColumns.length === 1) {
            // we only want to hide the group field element if there's only one group column.
            // If there's one group column that has a filter, but multiple columns in total,
            // we should still show the select so the user knows which column it's for.
            this.selectedColumn = sourceColumns[0];
            (0, ag_grid_community_1._setDisplayed)(eGroupField, false);
        }
        else {
            // keep the old selected column if it's still valid
            if (!this.selectedColumn ||
                !sourceColumns.some((column) => column.getId() === this.selectedColumn.getId())) {
                this.selectedColumn = sourceColumns[0];
            }
            this.createGroupFieldSelectElement(sourceColumns);
            eGroupField.appendChild(this.eGroupFieldSelect.getGui());
            eGroupField.appendChild((0, ag_grid_community_1._loadTemplate)(/* html */ `<div class="ag-filter-separator"></div>`));
            (0, ag_grid_community_1._setDisplayed)(eGroupField, true);
        }
        return sourceColumns;
    }
    createGroupFieldSelectElement(sourceColumns) {
        const eGroupFieldSelect = this.createManagedBean(new ag_grid_community_1.AgSelect());
        this.eGroupFieldSelect = eGroupFieldSelect;
        const localeTextFunc = this.getLocaleTextFunc();
        eGroupFieldSelect.setLabel(localeTextFunc('groupFilterSelect', 'Select field:'));
        eGroupFieldSelect.setLabelAlignment('top');
        eGroupFieldSelect.addOptions(sourceColumns.map((sourceColumn) => ({
            value: sourceColumn.getId(),
            text: this.beans.colNames.getDisplayNameForColumn(sourceColumn, 'groupFilter', false) ?? undefined,
        })));
        eGroupFieldSelect.setValue(this.selectedColumn.getId());
        eGroupFieldSelect.onValueChange((newValue) => this.updateSelectedColumn(newValue));
        eGroupFieldSelect.addCssClass('ag-group-filter-field-select-wrapper');
        if (sourceColumns.length === 1) {
            eGroupFieldSelect.setDisabled(true);
        }
    }
    getUnderlyingFilters(sourceColumns) {
        if (!sourceColumns) {
            this.filterColumnPairs = undefined;
            this.selectedFilter = undefined;
            this.beans.colFilter?.setColFilterActive(this.groupColumn, false, 'columnRowGroupChanged');
            return ag_grid_community_1.AgPromise.resolve();
        }
        const filterPromises = [];
        const filterColumnPairs = [];
        sourceColumns.forEach((column) => {
            const filterWrapper = this.filterManager.getOrCreateFilterWrapper(column);
            if (filterWrapper?.filterPromise) {
                filterPromises.push(filterWrapper.filterPromise.then((filter) => {
                    if (filter) {
                        filterColumnPairs.push({
                            filter,
                            column,
                        });
                    }
                    if (column.getId() === this.selectedColumn.getId()) {
                        this.selectedFilter = filter ?? undefined;
                    }
                    return filter;
                }));
            }
        });
        return ag_grid_community_1.AgPromise.all(filterPromises).then(() => {
            this.filterColumnPairs = filterColumnPairs;
            this.beans.colFilter?.setColFilterActive(this.groupColumn, this.isFilterActive(), 'columnRowGroupChanged');
        });
    }
    addUnderlyingFilterElement() {
        (0, ag_grid_community_1._clearElement)(this.eUnderlyingFilter);
        if (!this.selectedColumn) {
            return ag_grid_community_1.AgPromise.resolve();
        }
        const comp = this.createManagedBean(new ag_grid_community_1.FilterWrapperComp(this.selectedColumn, 'COLUMN_MENU'));
        this.filterWrapperComp = comp;
        if (!comp.hasFilter()) {
            return ag_grid_community_1.AgPromise.resolve();
        }
        this.eUnderlyingFilter.appendChild(comp.getGui());
        return (comp.getFilter()?.then(() => {
            comp.afterGuiAttached?.(this.afterGuiAttachedParams);
            if (!this.afterGuiAttachedParams?.suppressFocus &&
                this.eGroupFieldSelect &&
                !this.eGroupFieldSelect.isDisabled()) {
                this.eGroupFieldSelect.getFocusableElement().focus();
            }
        }) ?? ag_grid_community_1.AgPromise.resolve());
    }
    updateSelectedColumn(columnId) {
        if (!columnId) {
            return;
        }
        this.filterWrapperComp?.afterGuiDetached();
        this.destroyBean(this.filterWrapperComp);
        const selectedFilterColumnPair = this.getFilterColumnPair(columnId);
        this.selectedColumn = selectedFilterColumnPair?.column;
        this.selectedFilter = selectedFilterColumnPair?.filter;
        this.dispatchLocalEvent({
            type: 'selectedColumnChanged',
        });
        this.addUnderlyingFilterElement();
    }
    isFilterActive() {
        return !!this.filterColumnPairs?.some(({ filter }) => filter.isFilterActive());
    }
    doesFilterPass() {
        return true;
    }
    getModel() {
        return null;
    }
    setModel() {
        return ag_grid_community_1.AgPromise.resolve();
    }
    afterGuiAttached(params) {
        this.afterGuiAttachedParams = params;
        this.addUnderlyingFilterElement();
    }
    afterGuiDetached() {
        (0, ag_grid_community_1._clearElement)(this.eUnderlyingFilter);
        this.selectedFilter?.afterGuiDetached?.();
    }
    onColumnRowGroupChanged() {
        this.updateGroups().then(() => {
            this.dispatchLocalEvent({
                type: 'columnRowGroupChanged',
            });
        });
    }
    onFilterDestroyed({ column: eventColumn, source }) {
        if (source === 'gridDestroyed') {
            return;
        }
        const colId = eventColumn.getColId();
        if (this.filterColumnPairs?.some(({ column }) => column.getColId() === colId)) {
            // filter may already be getting recreated, so wait before updating
            setTimeout(() => {
                if (this.isAlive()) {
                    this.updateGroups();
                }
            });
        }
    }
    getFilterColumnPair(columnId) {
        if (!columnId) {
            return undefined;
        }
        return this.filterColumnPairs?.find(({ column }) => column.getId() === columnId);
    }
    getSelectedFilter() {
        return this.selectedFilter;
    }
    getSelectedColumn() {
        return this.selectedColumn;
    }
    isFilterAllowed() {
        return !!this.selectedColumn;
    }
}
exports.GroupFilter = GroupFilter;


/***/ }),

/***/ 7250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupFloatingFilterComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class GroupFloatingFilterComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    constructor() {
        super(/* html */ `
            <div data-ref="eFloatingFilter" class="ag-group-floating-filter ag-floating-filter-input" role="presentation"></div>
        `);
        this.eFloatingFilter = ag_grid_community_1.RefPlaceholder;
        this.haveAddedColumnListeners = false;
    }
    init(params) {
        this.params = params;
        // we only support showing the underlying floating filter for multiple group columns
        const canShowUnderlyingFloatingFilter = this.gos.get('groupDisplayType') === 'multipleColumns';
        return new ag_grid_community_1.AgPromise((resolve) => {
            this.params.parentFilterInstance((parentFilterInstance) => {
                this.parentFilterInstance = parentFilterInstance;
                if (canShowUnderlyingFloatingFilter) {
                    this.setupUnderlyingFloatingFilterElement().then(() => resolve());
                }
                else {
                    this.setupReadOnlyFloatingFilterElement();
                    resolve();
                }
            });
        }).then(() => {
            const onColChange = this.onColChange.bind(this);
            this.addManagedListeners(this.parentFilterInstance, {
                selectedColumnChanged: onColChange,
                columnRowGroupChanged: onColChange,
            });
        });
    }
    refresh(params) {
        this.params = params;
        this.setParams();
    }
    setParams() {
        const displayName = this.beans.colNames.getDisplayNameForColumn(this.params.column, 'header', true);
        const translate = this.getLocaleTextFunc();
        this.eFloatingFilterText?.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);
    }
    setupReadOnlyFloatingFilterElement() {
        if (!this.eFloatingFilterText) {
            this.eFloatingFilterText = this.createManagedBean(new ag_grid_community_1.AgInputTextField());
            this.eFloatingFilterText
                .setDisabled(true)
                .addGuiEventListener('click', () => this.params.showParentFilter());
            this.setParams();
        }
        this.updateDisplayedValue();
        this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());
    }
    setupUnderlyingFloatingFilterElement() {
        this.showingUnderlyingFloatingFilter = false;
        this.underlyingFloatingFilter = undefined;
        (0, ag_grid_community_1._clearElement)(this.eFloatingFilter);
        const column = this.parentFilterInstance.getSelectedColumn();
        // we can only show the underlying filter if there is one instance (e.g. the underlying column is not visible)
        if (column && !column.isVisible()) {
            const compDetails = this.filterManager.getFloatingFilterCompDetails(column, this.params.showParentFilter);
            if (compDetails) {
                if (!this.haveAddedColumnListeners) {
                    this.haveAddedColumnListeners = true;
                    this.addManagedListeners(column, {
                        visibleChanged: this.onColumnVisibleChanged.bind(this),
                        colDefChanged: this.onColDefChanged.bind(this),
                    });
                }
                return compDetails.newAgStackInstance().then((floatingFilter) => {
                    this.underlyingFloatingFilter = floatingFilter;
                    this.underlyingFloatingFilter?.onParentModelChanged(this.parentFilterInstance.getSelectedFilter()?.getModel());
                    this.appendChild(floatingFilter.getGui());
                    this.showingUnderlyingFloatingFilter = true;
                });
            }
        }
        // fallback to the read-only version
        this.setupReadOnlyFloatingFilterElement();
        return ag_grid_community_1.AgPromise.resolve();
    }
    onColumnVisibleChanged() {
        this.setupUnderlyingFloatingFilterElement();
    }
    onColDefChanged(event) {
        if (!event.column) {
            return;
        }
        const compDetails = this.filterManager.getFloatingFilterCompDetails(event.column, this.params.showParentFilter);
        if (compDetails) {
            this.underlyingFloatingFilter?.refresh?.(compDetails.params);
        }
    }
    onParentModelChanged(_model, event) {
        if (this.showingUnderlyingFloatingFilter) {
            this.underlyingFloatingFilter?.onParentModelChanged(this.parentFilterInstance.getSelectedFilter()?.getModel(), event);
        }
        else {
            this.updateDisplayedValue();
        }
    }
    updateDisplayedValue() {
        const { eFloatingFilterText, parentFilterInstance } = this;
        if (!parentFilterInstance || !eFloatingFilterText) {
            return;
        }
        const selectedFilter = parentFilterInstance.getSelectedFilter();
        if (!selectedFilter) {
            eFloatingFilterText.setValue('');
            eFloatingFilterText.setDisplayed(false);
            return;
        }
        eFloatingFilterText.setDisplayed(true);
        if (selectedFilter.getModelAsString) {
            const filterModel = selectedFilter.getModel();
            eFloatingFilterText.setValue(filterModel == null ? '' : selectedFilter.getModelAsString(filterModel));
        }
        else {
            eFloatingFilterText.setValue('');
        }
    }
    onColChange() {
        if (!this.showingUnderlyingFloatingFilter) {
            this.updateDisplayedValue();
        }
    }
}
exports.GroupFloatingFilterComp = GroupFloatingFilterComp;


/***/ }),

/***/ 8628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupHideOpenParentsService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
class GroupHideOpenParentsService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'groupHideOpenParentsSvc';
    }
    updateGroupDataForHideOpenParents(changedPath) {
        if (!this.gos.get('groupHideOpenParents') || this.gos.get('treeData')) {
            return;
        }
        // recurse breadth first over group nodes after sort to 'pull down' group data to child groups
        const callback = (rowNode) => {
            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);
            rowNode.childrenAfterSort.forEach((child) => {
                if (child.hasChildren()) {
                    callback(child);
                }
            });
        };
        if (changedPath) {
            changedPath.executeFromRootNode((rowNode) => callback(rowNode));
        }
    }
    pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {
        if (!this.gos.get('groupHideOpenParents') || (0, ag_grid_community_1._missing)(rowNodes)) {
            return;
        }
        const { colModel, showRowGroupCols } = this.beans;
        rowNodes.forEach((childRowNode) => {
            const groupDisplayCols = showRowGroupCols?.getShowRowGroupCols() ?? [];
            groupDisplayCols.forEach((groupDisplayCol) => {
                const showRowGroup = groupDisplayCol.getColDef().showRowGroup;
                if (typeof showRowGroup !== 'string') {
                    (0, ag_grid_community_1._error)(110);
                    return;
                }
                const displayingGroupKey = showRowGroup;
                const rowGroupColumn = colModel.getColDefCol(displayingGroupKey);
                const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;
                if (thisRowNodeMatches) {
                    return;
                }
                if (clearOperation) {
                    // if doing a clear operation, we clear down the value for every possible group column
                    (0, rowGroupingUtils_1.setRowNodeGroupValue)(childRowNode, colModel, groupDisplayCol.getId(), undefined);
                }
                else {
                    // if doing a set operation, we set only where the pull down is to occur
                    const parentToStealFrom = this.getFirstChildOfFirstChild(childRowNode, rowGroupColumn);
                    if (parentToStealFrom) {
                        (0, rowGroupingUtils_1.setRowNodeGroupValue)(childRowNode, colModel, groupDisplayCol.getId(), parentToStealFrom.key);
                    }
                }
            });
        });
    }
    isShowingValueForOpenedParent(rowNode, column) {
        // note - this code depends on updateGroupDataForHideOpenParents, where group data
        // is updated to reflect the dragged down parents
        if (!this.gos.get('groupHideOpenParents')) {
            return false;
        }
        // hideOpenParents means rowNode.groupData can have data for the group this column is displaying, even though
        // this rowNode isn't grouping by the column we are displaying
        // if no groupData at all, we are not showing a parent value
        if (!rowNode.groupData) {
            return false;
        }
        // this is the normal case, in that we are showing a group for which this column is configured. note that
        // this means the Row Group is closed (if it was open, we would not be displaying it)
        const showingGroupNode = rowNode.rowGroupColumn != null;
        if (showingGroupNode) {
            const keyOfGroupingColumn = rowNode.rowGroupColumn.getId();
            const configuredToShowThisGroupLevel = column.isRowGroupDisplayed(keyOfGroupingColumn);
            // if showing group as normal, we didn't take group info from parent
            if (configuredToShowThisGroupLevel) {
                return false;
            }
        }
        // see if we are showing a Group Value for the Displayed Group. if we are showing a group value, and this Row Node
        // is not grouping by this Displayed Group, we must of gotten the value from a parent node
        return rowNode.groupData[column.getId()] != null;
    }
    getFirstChildOfFirstChild(node, rowGroupColumn) {
        let currentRowNode = node;
        // if we are hiding groups, then if we are the first child, of the first child,
        // all the way up to the column we are interested in, then we show the group cell.
        while (currentRowNode) {
            const parentRowNode = currentRowNode.parent;
            if (parentRowNode?.childrenAfterSort && currentRowNode === parentRowNode.childrenAfterSort[0]) {
                if (parentRowNode.rowGroupColumn === rowGroupColumn) {
                    return parentRowNode;
                }
            }
            else {
                return null;
            }
            currentRowNode = parentRowNode;
        }
        return null;
    }
}
exports.GroupHideOpenParentsService = GroupHideOpenParentsService;


/***/ }),

/***/ 1645:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchRemover = void 0;
class BatchRemover {
    constructor() {
        this.allSets = {};
        this.allParents = [];
    }
    removeFromChildrenAfterGroup(parent, child) {
        const set = this.getSet(parent);
        set.removeFromChildrenAfterGroup[child.id] = true;
    }
    isRemoveFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        return !!set.removeFromAllLeafChildren[child.id];
    }
    preventRemoveFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        delete set.removeFromAllLeafChildren[child.id];
    }
    removeFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        set.removeFromAllLeafChildren[child.id] = true;
    }
    getSet(parent) {
        if (!this.allSets[parent.id]) {
            this.allSets[parent.id] = {
                removeFromAllLeafChildren: {},
                removeFromChildrenAfterGroup: {},
            };
            this.allParents.push(parent);
        }
        return this.allSets[parent.id];
    }
    getAllParents() {
        return this.allParents;
    }
    flush() {
        this.allParents.forEach((parent) => {
            const nodeDetails = this.allSets[parent.id];
            parent.childrenAfterGroup = parent.childrenAfterGroup.filter((child) => !nodeDetails.removeFromChildrenAfterGroup[child.id]);
            parent.allLeafChildren =
                parent.allLeafChildren?.filter((child) => !nodeDetails.removeFromAllLeafChildren[child.id]) ?? null;
            parent.updateHasChildren();
            const sibling = parent.sibling;
            if (sibling) {
                sibling.childrenAfterGroup = parent.childrenAfterGroup;
                sibling.allLeafChildren = parent.allLeafChildren;
            }
        });
        this.allSets = {};
        this.allParents.length = 0;
    }
}
exports.BatchRemover = BatchRemover;


/***/ }),

/***/ 4216:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupStage = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
const batchRemover_1 = __webpack_require__(1645);
const sortGroupChildren_1 = __webpack_require__(4831);
class GroupStage extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'groupStage';
        this.refreshProps = new Set([
            'groupDefaultExpanded',
            'groupAllowUnbalanced',
            'initialGroupOrderComparator',
            'groupHideOpenParents',
            'groupDisplayType',
        ]);
        this.step = 'group';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.valueSvc = beans.valueSvc;
        this.selectionSvc = beans.selectionSvc;
        this.showRowGroupCols = beans.showRowGroupCols;
    }
    execute(params) {
        const details = this.createGroupingDetails(params);
        if (details.transactions) {
            this.handleTransaction(details);
        }
        else {
            const afterColsChanged = params.afterColumnsChanged === true;
            this.shotgunResetEverything(details, afterColsChanged);
        }
        const changedPath = params.changedPath;
        this.positionLeafsAndGroups(changedPath);
        this.orderGroups(details);
        this.selectionSvc?.updateSelectableAfterGrouping(changedPath);
    }
    positionLeafsAndGroups(changedPath) {
        changedPath.forEachChangedNodeDepthFirst((group) => {
            if (group.childrenAfterGroup) {
                const leafNodes = [];
                const groupNodes = [];
                let unbalancedNode;
                group.childrenAfterGroup.forEach((row) => {
                    if (!row.childrenAfterGroup?.length) {
                        leafNodes.push(row);
                    }
                    else {
                        if (row.key === '' && !unbalancedNode) {
                            unbalancedNode = row;
                        }
                        else {
                            groupNodes.push(row);
                        }
                    }
                });
                if (unbalancedNode) {
                    groupNodes.push(unbalancedNode);
                }
                group.childrenAfterGroup = [...leafNodes, ...groupNodes];
            }
        }, false);
    }
    createGroupingDetails(params) {
        const { rowNode, changedPath, rowNodeTransactions, rowNodesOrderChanged } = params;
        const groupedCols = this.rowGroupColsSvc?.columns;
        const details = {
            expandByDefault: this.gos.get('groupDefaultExpanded'),
            groupedCols: groupedCols,
            rootNode: rowNode,
            pivotMode: this.colModel.isPivotMode(),
            groupedColCount: groupedCols?.length ?? 0,
            transactions: rowNodeTransactions,
            rowNodesOrderChanged: !!rowNodesOrderChanged,
            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway
            changedPath: changedPath,
            groupAllowUnbalanced: this.gos.get('groupAllowUnbalanced'),
            isGroupOpenByDefault: this.gos.getCallback('isGroupOpenByDefault'),
            initialGroupOrderComparator: this.gos.getCallback('initialGroupOrderComparator'),
            keyCreators: groupedCols?.map((column) => column.getColDef().keyCreator) ?? [],
        };
        return details;
    }
    handleTransaction(details) {
        details.transactions.forEach((tran) => {
            const batchRemover = new batchRemover_1.BatchRemover();
            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,
            // as the order is important when a record with the same id is added and removed in the same
            // transaction.
            if (tran.remove?.length) {
                this.removeNodes(tran.remove, details, batchRemover);
            }
            if (tran.update?.length) {
                this.moveNodesInWrongPath(tran.update, details, batchRemover);
            }
            if (tran.add?.length) {
                this.insertNodes(tran.add, details);
            }
            // must flush here, and not allow another transaction to be applied,
            // as each transaction must finish leaving the data in a consistent state.
            const parentsWithChildrenRemoved = batchRemover.getAllParents().slice();
            batchRemover.flush();
            this.removeEmptyGroups(parentsWithChildrenRemoved, details);
        });
        if (details.rowNodesOrderChanged) {
            this.sortChildren(details);
        }
    }
    // this is used when doing delta updates, eg Redux, keeps nodes in right order
    sortChildren(details) {
        details.changedPath.forEachChangedNodeDepthFirst((node) => {
            const didSort = (0, sortGroupChildren_1.sortGroupChildren)(node.childrenAfterGroup);
            if (didSort) {
                details.changedPath.addParentNode(node);
            }
        }, false, true);
    }
    orderGroups(details) {
        const comparator = details.initialGroupOrderComparator;
        if ((0, ag_grid_community_1._exists)(comparator)) {
            recursiveSort(details.rootNode);
        }
        function recursiveSort(rowNode) {
            const doSort = (0, ag_grid_community_1._exists)(rowNode.childrenAfterGroup) &&
                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
                !rowNode.leafGroup;
            if (doSort) {
                rowNode.childrenAfterGroup.sort((nodeA, nodeB) => comparator({ nodeA, nodeB }));
                rowNode.childrenAfterGroup.forEach((childNode) => recursiveSort(childNode));
            }
        }
    }
    getExistingPathForNode(node, details) {
        const res = [];
        // the node is not part of the path so we start with the parent.
        let pointer = node.parent;
        while (pointer && pointer !== details.rootNode) {
            res.push({
                key: pointer.key,
                rowGroupColumn: pointer.rowGroupColumn,
                field: pointer.field,
            });
            pointer = pointer.parent;
        }
        res.reverse();
        return res;
    }
    moveNodesInWrongPath(childNodes, details, batchRemover) {
        childNodes.forEach((childNode) => {
            // we add node, even if parent has not changed, as the data could have
            // changed, hence aggregations will be wrong
            if (details.changedPath.active) {
                details.changedPath.addParentNode(childNode.parent);
            }
            const infoToKeyMapper = (item) => item.key;
            const oldPath = this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);
            const newPath = this.getGroupInfo(childNode, details).map(infoToKeyMapper);
            const nodeInCorrectPath = (0, ag_grid_community_1._areEqual)(oldPath, newPath);
            if (!nodeInCorrectPath) {
                this.moveNode(childNode, details, batchRemover);
            }
        });
    }
    moveNode(childNode, details, batchRemover) {
        this.removeNodesFromParents([childNode], details, batchRemover);
        this.insertOneNode(childNode, details, batchRemover);
        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get
        // refreshed into the gui.
        // this is needed to kick off the event that rowComp listens to for refresh. this in turn
        // then will get each cell in the row to refresh - which is what we need as we don't know which
        // columns will be displaying the rowNode.key info.
        childNode.setData(childNode.data);
        // we add both old and new parents to changed path, as both will need to be refreshed.
        // we already added the old parent (in calling method), so just add the new parent here
        if (details.changedPath.active) {
            const newParent = childNode.parent;
            details.changedPath.addParentNode(newParent);
        }
    }
    removeNodes(leafRowNodes, details, batchRemover) {
        this.removeNodesFromParents(leafRowNodes, details, batchRemover);
        if (details.changedPath.active) {
            leafRowNodes.forEach((rowNode) => details.changedPath.addParentNode(rowNode.parent));
        }
    }
    forEachParentGroup(details, group, callback) {
        let pointer = group;
        while (pointer && pointer !== details.rootNode) {
            callback(pointer);
            pointer = pointer.parent;
        }
    }
    removeNodesFromParents(nodesToRemove, details, provided) {
        // this method can be called with BatchRemover as optional. if it is missed, we created a local version
        // and flush it at the end. if one is provided, we add to the provided one and it gets flushed elsewhere.
        const batchRemoverIsLocal = provided == null;
        const batchRemoverToUse = provided ? provided : new batchRemover_1.BatchRemover();
        nodesToRemove.forEach((nodeToRemove) => {
            this.removeFromParent(nodeToRemove, batchRemoverToUse);
            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as
            // the ClientSideNodeManager is responsible for the Root Node.
            this.forEachParentGroup(details, nodeToRemove.parent, (parentNode) => {
                batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);
            });
        });
        if (batchRemoverIsLocal) {
            batchRemoverToUse.flush();
        }
    }
    removeEmptyGroups(possibleEmptyGroups, details) {
        // we do this multiple times, as when we remove groups, that means the parent of just removed
        // group can then be empty. to get around this, if we remove, then we check everything again for
        // newly emptied groups. the max number of times this will execute is the depth of the group tree.
        let checkAgain = true;
        const groupShouldBeRemoved = (rowNode) => {
            // because of the while loop below, it's possible we already moved the node,
            // so double check before trying to remove again.
            const mapKey = this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);
            const parentRowNode = rowNode.parent;
            const groupAlreadyRemoved = parentRowNode?.childrenMapped ? !parentRowNode.childrenMapped[mapKey] : true;
            if (groupAlreadyRemoved) {
                // if not linked, then group was already removed
                return false;
            }
            // if still not removed, then we remove if this group is empty
            return !!rowNode.group && (rowNode.childrenAfterGroup?.length ?? 0) === 0;
        };
        while (checkAgain) {
            checkAgain = false;
            const batchRemover = new batchRemover_1.BatchRemover();
            possibleEmptyGroups.forEach((possibleEmptyGroup) => {
                // remove empty groups
                this.forEachParentGroup(details, possibleEmptyGroup, (rowNode) => {
                    if (groupShouldBeRemoved(rowNode)) {
                        checkAgain = true;
                        this.removeFromParent(rowNode, batchRemover);
                        // we remove selection on filler nodes here, as the selection would not be removed
                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager
                        this.selectionSvc?.setNodesSelected({
                            nodes: [rowNode],
                            newValue: false,
                            source: 'rowGroupChanged',
                        });
                    }
                });
            });
            batchRemover.flush();
        }
    }
    // removes the node from the parent by:
    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
    // b) removing from childrenMapped (immediately)
    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
    // d) setRowIndex(null) - as the rowNode will no longer be displayed.
    removeFromParent(child, batchRemover) {
        if (child.parent) {
            if (batchRemover) {
                batchRemover.removeFromChildrenAfterGroup(child.parent, child);
            }
            else {
                (0, ag_grid_community_1._removeFromArray)(child.parent.childrenAfterGroup, child);
                child.parent.updateHasChildren();
            }
        }
        const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
        if (child.parent?.childrenMapped) {
            delete child.parent.childrenMapped[mapKey];
        }
        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and
        // remove, if rowTop is still present, the rowComp thinks it's just moved position.
        child.setRowTop(null);
        child.setRowIndex(null);
    }
    /**
     * This is idempotent, but relies on the `key` field being the same throughout a RowNode's lifetime
     */
    addToParent(child, parent) {
        const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
        if (parent?.childrenMapped) {
            if (parent.childrenMapped[mapKey] !== child) {
                parent.childrenMapped[mapKey] = child;
                parent.childrenAfterGroup.push(child);
                (0, rowGroupingUtils_1.setRowNodeGroup)(parent, this.beans, true); // calls `.updateHasChildren` internally
            }
        }
    }
    areGroupColsEqual(d1, d2) {
        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {
            return false;
        }
        return (0, ag_grid_community_1._areEqual)(d1.groupedCols, d2.groupedCols) && (0, ag_grid_community_1._areEqual)(d1.keyCreators, d2.keyCreators);
    }
    checkAllGroupDataAfterColsChanged(details) {
        const recurse = (rowNodes) => {
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach((rowNode) => {
                const isLeafNode = !rowNode.group;
                if (isLeafNode) {
                    return;
                }
                const groupInfo = {
                    field: rowNode.field,
                    key: rowNode.key,
                    rowGroupColumn: rowNode.rowGroupColumn,
                    leafNode: rowNode.allLeafChildren?.[0],
                };
                this.setGroupData(rowNode, groupInfo);
                recurse(rowNode.childrenAfterGroup);
            });
        };
        recurse(details.rootNode.childrenAfterGroup);
    }
    shotgunResetEverything(details, afterColumnsChanged) {
        if (this.noChangeInGroupingColumns(details, afterColumnsChanged)) {
            return;
        }
        // groups are about to get disposed, so need to deselect any that are selected
        this.selectionSvc?.filterFromSelection?.((node) => !node.group);
        const { groupedCols } = details;
        const rootNode = details.rootNode;
        // because we are not creating the root node each time, we have the logic
        // here to change leafGroup once.
        rootNode.leafGroup = groupedCols.length === 0;
        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode
        rootNode.childrenAfterGroup = [];
        rootNode.childrenMapped = {};
        rootNode.updateHasChildren();
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
            sibling.childrenMapped = rootNode.childrenMapped;
        }
        this.insertNodes(rootNode.allLeafChildren, details);
    }
    noChangeInGroupingColumns(details, afterColumnsChanged) {
        let noFurtherProcessingNeeded = false;
        const groupDisplayColumns = this.showRowGroupCols.getShowRowGroupCols();
        const newGroupDisplayColIds = groupDisplayColumns ? groupDisplayColumns.map((c) => c.getId()).join('-') : '';
        if (afterColumnsChanged) {
            // we only need to redo grouping if doing normal grouping (ie not tree data)
            // and the group cols have changed.
            noFurtherProcessingNeeded = this.areGroupColsEqual(details, this.oldGroupingDetails);
            // if the group display cols have changed, then we need to update rowNode.groupData
            // (regardless of tree data or row grouping)
            if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {
                this.checkAllGroupDataAfterColsChanged(details);
            }
        }
        this.oldGroupingDetails = details;
        this.oldGroupDisplayColIds = newGroupDisplayColIds;
        return noFurtherProcessingNeeded;
    }
    insertNodes(newRowNodes, details) {
        newRowNodes.forEach((rowNode) => {
            this.insertOneNode(rowNode, details);
            if (details.changedPath.active) {
                details.changedPath.addParentNode(rowNode.parent);
            }
        });
    }
    insertOneNode(childNode, details, batchRemover) {
        const path = this.getGroupInfo(childNode, details);
        const parentGroup = this.findParentForNode(childNode, path, details, batchRemover);
        if (!parentGroup.group) {
            (0, ag_grid_community_1._warn)(184, { parentGroupData: parentGroup.data, childNodeData: childNode.data });
        }
        childNode.parent = parentGroup;
        childNode.level = path.length;
        parentGroup.childrenAfterGroup.push(childNode);
        parentGroup.updateHasChildren();
    }
    findParentForNode(childNode, path, details, batchRemover) {
        let nextNode = details.rootNode;
        path.forEach((groupInfo, level) => {
            nextNode = this.getOrCreateNextNode(nextNode, groupInfo, level, details);
            // node gets added to all group nodes.
            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes
            if (!batchRemover?.isRemoveFromAllLeafChildren(nextNode, childNode)) {
                nextNode.allLeafChildren.push(childNode);
            }
            else {
                // if this node is about to be removed, prevent that
                batchRemover?.preventRemoveFromAllLeafChildren(nextNode, childNode);
            }
        });
        return nextNode;
    }
    getOrCreateNextNode(parentGroup, groupInfo, level, details) {
        const key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);
        let nextNode = parentGroup?.childrenMapped?.[key];
        if (!nextNode) {
            nextNode = this.createGroup(groupInfo, parentGroup, level, details);
            // attach the new group to the parent
            this.addToParent(nextNode, parentGroup);
        }
        return nextNode;
    }
    createGroup(groupInfo, parent, level, details) {
        const groupNode = new ag_grid_community_1.RowNode(this.beans);
        groupNode.group = true;
        groupNode.field = groupInfo.field;
        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;
        this.setGroupData(groupNode, groupInfo);
        groupNode.key = groupInfo.key;
        groupNode.id = this.createGroupId(groupNode, parent, level);
        groupNode.level = level;
        groupNode.leafGroup = level === details.groupedColCount - 1;
        groupNode.allLeafChildren = [];
        // why is this done here? we are not updating the children count as we go,
        // i suspect this is updated in the filter stage
        groupNode.setAllChildrenCount(0);
        groupNode.rowGroupIndex = level;
        groupNode.childrenAfterGroup = [];
        groupNode.childrenMapped = {};
        groupNode.updateHasChildren();
        groupNode.parent = parent;
        this.setExpandedInitialValue(details, groupNode);
        return groupNode;
    }
    createGroupId(node, parent, level) {
        const createGroupId = (node, parent) => {
            if (!node.rowGroupColumn) {
                return null;
            } // root node
            const parentId = parent ? createGroupId(parent, parent.parent, 0) : null;
            return `${parentId == null ? '' : parentId + '-'}${node.rowGroupColumn.getColId()}-${node.key}`;
        };
        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'
        // for top pinned and bottom pinned rows.
        return ag_grid_community_1._ROW_ID_PREFIX_ROW_GROUP + createGroupId(node, parent, level);
    }
    setGroupData(groupNode, groupInfo) {
        groupNode.groupData = {};
        const groupDisplayCols = this.showRowGroupCols.getShowRowGroupCols();
        groupDisplayCols.forEach((col) => {
            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column
            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so
            const groupColumn = groupNode.rowGroupColumn;
            const isRowGroupDisplayed = groupColumn !== null && col.isRowGroupDisplayed(groupColumn.getId());
            if (isRowGroupDisplayed) {
                // if maintain group value type, get the value from any leaf node.
                groupNode.groupData[col.getColId()] = this.valueSvc.getValue(groupColumn, groupInfo.leafNode);
            }
        });
    }
    getChildrenMappedKey(key, rowGroupColumn) {
        // grouping by columns
        return rowGroupColumn ? rowGroupColumn.getId() + '-' + key : key;
    }
    setExpandedInitialValue(details, groupNode) {
        // if pivoting the leaf group is never expanded as we do not show leaf rows
        if (details.pivotMode && groupNode.leafGroup) {
            groupNode.expanded = false;
            return;
        }
        // use callback if exists
        const userCallback = details.isGroupOpenByDefault;
        if (userCallback) {
            const params = {
                rowNode: groupNode,
                field: groupNode.field,
                key: groupNode.key,
                level: groupNode.level,
                rowGroupColumn: groupNode.rowGroupColumn,
            };
            groupNode.expanded = userCallback(params) == true;
            return;
        }
        // use expandByDefault if exists
        if (details.expandByDefault === -1) {
            groupNode.expanded = true;
            return;
        }
        // otherwise
        groupNode.expanded = groupNode.level < details.expandByDefault;
    }
    getGroupInfo(rowNode, details) {
        const res = [];
        details.groupedCols.forEach((groupCol) => {
            let key = this.valueSvc.getKeyForNode(groupCol, rowNode);
            let keyExists = key !== null && key !== undefined && key !== '';
            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make
            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.
            // this keeps the tree balanced and hence can be represented as a group.
            const createGroupForEmpty = details.pivotMode || !details.groupAllowUnbalanced;
            if (createGroupForEmpty && !keyExists) {
                key = '';
                keyExists = true;
            }
            if (keyExists) {
                const item = {
                    key: key,
                    field: groupCol.getColDef().field,
                    rowGroupColumn: groupCol,
                    leafNode: rowNode,
                };
                res.push(item);
            }
        });
        return res;
    }
}
exports.GroupStage = GroupStage;


/***/ }),

/***/ 4831:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sortGroupChildren = void 0;
function sortGroupChildren(rowNodes) {
    if (!rowNodes) {
        return false;
    }
    const length = rowNodes.length;
    if (length < 2) {
        return false;
    }
    let atLeastOneOutOfOrder = false;
    for (let i = 1; i < length; i++) {
        if (compareGroupChildren(rowNodes[i - 1], rowNodes[i]) > 0) {
            atLeastOneOutOfOrder = true;
            break;
        }
    }
    if (!atLeastOneOutOfOrder) {
        return false;
    }
    rowNodes.sort(compareGroupChildren);
    return true;
}
exports.sortGroupChildren = sortGroupChildren;
function compareGroupChildren(nodeA, nodeB) {
    const positionA = nodeA.sourceRowIndex;
    const positionB = nodeB.sourceRowIndex;
    const aHasIndex = positionA >= 0;
    const bHasIndex = positionB >= 0;
    const bothNodesAreUserNodes = aHasIndex && bHasIndex;
    const bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;
    if (bothNodesAreUserNodes) {
        // when comparing two nodes the user has provided, they always
        // have indexes
        return positionA - positionB;
    }
    if (bothNodesAreFillerNodes) {
        // when comparing two filler nodes, we have no index to compare them
        // against, however we want this sorting to be deterministic, so that
        // the rows don't jump around as the user does delta updates. so we
        // want the same sort result. so we use the __objectId - which doesn't make sense
        // from a sorting point of view, but does give consistent behaviour between
        // calls. otherwise groups jump around as delta updates are done.
        // note: previously here we used nodeId, however this gave a strange order
        // as string ordering of numbers is wrong, so using id based on creation order
        // as least gives better looking order.
        return nodeA.__objectId - nodeB.__objectId;
    }
    if (aHasIndex) {
        return 1;
    }
    return -1;
}


/***/ }),

/***/ 4357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowGroupColsSvc = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class RowGroupColsSvc extends ag_grid_community_1.BaseColsService {
    constructor() {
        super(...arguments);
        this.beanName = 'rowGroupColsSvc';
        this.eventName = 'columnRowGroupChanged';
        this.columnProcessors = {
            set: (column, added, source) => this.setActive(added, column, source),
            add: (column, added, source) => this.setActive(true, column, source),
            remove: (column, added, source) => this.setActive(false, column, source),
        };
        this.columnOrdering = {
            enableProp: 'rowGroup',
            initialEnableProp: 'initialRowGroup',
            indexProp: 'rowGroupIndex',
            initialIndexProp: 'initialRowGroupIndex',
        };
        this.columnExtractors = {
            setFlagFunc: (col, flag, source) => this.setColRowGroupActive(col, flag, source),
            getIndexFunc: (colDef) => colDef.rowGroupIndex,
            getInitialIndexFunc: (colDef) => colDef.initialRowGroupIndex,
            getValueFunc: (colDef) => colDef.rowGroup,
            getInitialValueFunc: (colDef) => colDef.initialRowGroup,
        };
        this.modifyColumnsNoEventsCallbacks = {
            addCol: (column) => this.columns.push(column),
            removeCol: (column) => (0, ag_grid_community_1._removeFromArray)(this.columns, column),
        };
    }
    moveColumn(fromIndex, toIndex, source) {
        if (this.columns.length === 0) {
            return;
        }
        const column = this.columns[fromIndex];
        const impactedColumns = this.columns.slice(fromIndex, toIndex);
        this.columns.splice(fromIndex, 1);
        this.columns.splice(toIndex, 0, column);
        this.eventSvc.dispatchEvent({
            type: this.eventName,
            columns: impactedColumns,
            column: impactedColumns.length === 1 ? impactedColumns[0] : null,
            source,
        });
    }
    syncColumnWithState(column, source, getValue, rowIndex) {
        const { value1: rowGroup, value2: rowGroupIndex } = getValue('rowGroup', 'rowGroupIndex');
        if (rowGroup !== undefined || rowGroupIndex !== undefined) {
            if (typeof rowGroupIndex === 'number' || rowGroup) {
                if (!column.isRowGroupActive()) {
                    this.setColRowGroupActive(column, true, source);
                    this.modifyColumnsNoEventsCallbacks.addCol(column);
                }
                if (rowIndex && typeof rowGroupIndex === 'number') {
                    rowIndex[column.getId()] = rowGroupIndex;
                }
            }
            else {
                if (column.isRowGroupActive()) {
                    this.setColRowGroupActive(column, false, source);
                    this.modifyColumnsNoEventsCallbacks.removeCol(column);
                }
            }
        }
    }
    setActive(active, column, source) {
        if (active === column.isRowGroupActive()) {
            return;
        }
        this.setColRowGroupActive(column, active, source);
        if ((0, ag_grid_community_1._shouldUpdateColVisibilityAfterGroup)(this.gos, active)) {
            this.colModel.setColsVisible([column], !active, source);
        }
    }
    setColRowGroupActive(column, rowGroup, source) {
        if (column.rowGroupActive !== rowGroup) {
            column.rowGroupActive = rowGroup;
            column.dispatchColEvent('columnRowGroupChanged', source);
        }
        column.dispatchStateUpdatedEvent('rowGroup');
    }
}
exports.RowGroupColsSvc = RowGroupColsSvc;


/***/ }),

/***/ 3516:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRowGroupColumns = exports.moveRowGroupColumn = exports.addRowGroupColumns = exports.removeRowGroupColumns = exports.setRowGroupColumns = void 0;
function setRowGroupColumns(beans, colKeys) {
    beans.rowGroupColsSvc?.setColumns(colKeys, 'api');
}
exports.setRowGroupColumns = setRowGroupColumns;
function removeRowGroupColumns(beans, colKeys) {
    beans.rowGroupColsSvc?.removeColumns(colKeys, 'api');
}
exports.removeRowGroupColumns = removeRowGroupColumns;
function addRowGroupColumns(beans, colKeys) {
    beans.rowGroupColsSvc?.addColumns(colKeys, 'api');
}
exports.addRowGroupColumns = addRowGroupColumns;
function moveRowGroupColumn(beans, fromIndex, toIndex) {
    beans.rowGroupColsSvc?.moveColumn?.(fromIndex, toIndex, 'api');
}
exports.moveRowGroupColumn = moveRowGroupColumn;
function getRowGroupColumns(beans) {
    return beans.rowGroupColsSvc?.columns ?? [];
}
exports.getRowGroupColumns = getRowGroupColumns;


/***/ }),

/***/ 1442:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupFilterModule = exports.RowGroupingPanelModule = exports.RowGroupingModule = exports.SharedRowGroupingModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const aggregationModule_1 = __webpack_require__(7032);
const rowHierarchyModule_1 = __webpack_require__(6858);
const version_1 = __webpack_require__(7205);
const agGridHeaderDropZones_1 = __webpack_require__(9449);
const groupFilter_1 = __webpack_require__(4700);
const groupFloatingFilter_1 = __webpack_require__(7250);
const groupHideOpenParentsService_1 = __webpack_require__(8628);
const groupStage_1 = __webpack_require__(4216);
const rowGroupingApi_1 = __webpack_require__(3516);
/**
 * @internal
 */
exports.SharedRowGroupingModule = {
    moduleName: 'SharedRowGrouping',
    version: version_1.VERSION,
    beans: [groupHideOpenParentsService_1.GroupHideOpenParentsService],
    apiFunctions: {
        setRowGroupColumns: rowGroupingApi_1.setRowGroupColumns,
        removeRowGroupColumns: rowGroupingApi_1.removeRowGroupColumns,
        addRowGroupColumns: rowGroupingApi_1.addRowGroupColumns,
        getRowGroupColumns: rowGroupingApi_1.getRowGroupColumns,
        moveRowGroupColumn: rowGroupingApi_1.moveRowGroupColumn,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, aggregationModule_1.SharedAggregationModule, rowHierarchyModule_1.GroupColumnModule, rowHierarchyModule_1.StickyRowModule],
};
/**
 * @feature Row Grouping
 * @colDef enableRowGroup, rowGroup, rowGroupIndex
 */
exports.RowGroupingModule = {
    moduleName: 'RowGrouping',
    version: version_1.VERSION,
    beans: [groupStage_1.GroupStage],
    rowModels: ['clientSide'],
    dependsOn: [exports.SharedRowGroupingModule, aggregationModule_1.AggregationModule, rowHierarchyModule_1.ClientSideRowModelHierarchyModule],
};
/**
 * @feature Row Grouping -> Row Group Panel
 */
exports.RowGroupingPanelModule = {
    moduleName: 'RowGroupingPanel',
    version: version_1.VERSION,
    selectors: [agGridHeaderDropZones_1.AgGridHeaderDropZonesSelector],
    icons: {
        // identifies the pivot drop zone
        pivotPanel: 'pivot',
        // "Row groups" drop zone in column tool panel
        rowGroupPanel: 'group',
        // separator between column 'pills' when you add multiple columns to the header drop zone
        panelDelimiter: 'small-right',
        // version of panelDelimiter used in RTL mode
        panelDelimiterRtl: 'small-left',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._PopupModule],
};
/**
 * @feature Row Grouping -> Filtering
 */
exports.GroupFilterModule = {
    moduleName: 'GroupFilter',
    version: version_1.VERSION,
    userComponents: { agGroupColumnFilter: groupFilter_1.GroupFilter, agGroupColumnFloatingFilter: groupFloatingFilter_1.GroupFloatingFilterComp },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._ColumnFilterModule],
};


/***/ }),

/***/ 8105:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isRowGroupColLocked = exports.setRowNodeGroup = exports.setRowNodeGroupValue = void 0;
function setRowNodeGroupValue(rowNode, colModel, colKey, newValue) {
    const column = colModel.getCol(colKey);
    if (!rowNode.groupData) {
        rowNode.groupData = {};
    }
    const columnId = column.getColId();
    const oldValue = rowNode.groupData[columnId];
    if (oldValue === newValue) {
        return;
    }
    rowNode.groupData[columnId] = newValue;
    rowNode.dispatchCellChangedEvent(column, newValue, oldValue);
}
exports.setRowNodeGroupValue = setRowNodeGroupValue;
function setRowNodeGroup(rowNode, beans, group) {
    if (rowNode.group === group) {
        return;
    }
    // if we used to be a group, and no longer, then close the node
    if (rowNode.group && !group) {
        rowNode.expanded = false;
    }
    rowNode.group = group;
    rowNode.updateHasChildren();
    beans.selectionSvc?.updateRowSelectable(rowNode);
    rowNode.dispatchRowEvent('groupChanged');
}
exports.setRowNodeGroup = setRowNodeGroup;
function isRowGroupColLocked(column, beans) {
    const { gos, rowGroupColsSvc } = beans;
    if (!rowGroupColsSvc || !column) {
        return false;
    }
    const groupLockGroupColumns = gos.get('groupLockGroupColumns');
    if (!column.isRowGroupActive() || groupLockGroupColumns === 0) {
        return false;
    }
    if (groupLockGroupColumns === -1) {
        return true;
    }
    const colIndex = rowGroupColsSvc.columns.findIndex((groupCol) => groupCol.getColId() === column.getColId());
    return groupLockGroupColumns > colIndex;
}
exports.isRowGroupColLocked = isRowGroupColLocked;


/***/ }),

/***/ 5995:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoColService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AutoColService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'autoColSvc';
    }
    postConstruct() {
        this.addManagedPropertyListener('autoGroupColumnDef', (event) => this.onAutoGroupColumnDefChanged((0, ag_grid_community_1._convertColumnEventSourceType)(event.source)));
    }
    addAutoCols(cols) {
        if (this.autoCols == null) {
            return;
        }
        cols.list = this.autoCols.list.concat(cols.list);
        cols.tree = this.autoCols.tree.concat(cols.tree);
        (0, ag_grid_community_1._updateColsMap)(cols);
    }
    createAutoCols(cols, updateOrders) {
        const beans = this.beans;
        const { colModel, gos, rowGroupColsSvc, colGroupSvc } = beans;
        const isPivotMode = colModel.isPivotMode();
        const groupFullWidthRow = (0, ag_grid_community_1._isGroupUseEntireRow)(gos, isPivotMode);
        // we need to allow suppressing auto-column separately for group and pivot as the normal situation
        // is CSRM and user provides group column themselves for normal view, but when they go into pivot the
        // columns are generated by the grid so no opportunity for user to provide group column. so need a way
        // to suppress auto-col for grouping only, and not pivot.
        // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control
        // of the group column in this instance.
        const suppressAutoColumn = isPivotMode ? gos.get('pivotSuppressAutoColumn') : this.isSuppressAutoCol();
        const rowGroupCols = rowGroupColsSvc?.columns;
        const groupingActive = (rowGroupCols && rowGroupCols.length > 0) || gos.get('treeData');
        const noAutoCols = !groupingActive || suppressAutoColumn || groupFullWidthRow;
        const destroyPrevious = () => {
            if (this.autoCols) {
                (0, ag_grid_community_1._destroyColumnTree)(beans, this.autoCols.tree);
                this.autoCols = null;
            }
        };
        // function
        if (noAutoCols) {
            destroyPrevious();
            return;
        }
        const list = this.generateAutoCols(rowGroupCols);
        const autoColsSame = (0, ag_grid_community_1._areColIdsEqual)(list, this.autoCols?.list || null);
        // the new tree dept will equal the current tree dept of cols
        const newTreeDepth = cols.treeDepth;
        const oldTreeDepth = this.autoCols ? this.autoCols.treeDepth : -1;
        const treeDeptSame = oldTreeDepth == newTreeDepth;
        if (autoColsSame && treeDeptSame) {
            return;
        }
        destroyPrevious();
        const treeDepth = colGroupSvc?.findDepth(cols.tree) ?? 0;
        const tree = colGroupSvc?.balanceTreeForAutoCols(list, treeDepth) ?? [];
        this.autoCols = {
            list,
            tree,
            treeDepth,
            map: {},
        };
        const putAutoColsFirstInList = (cols) => {
            if (!cols) {
                return null;
            }
            // we use colId, and not instance, to remove old autoGroupCols
            const colsFiltered = cols.filter((col) => !(0, ag_grid_community_1.isColumnGroupAutoCol)(col));
            return [...list, ...colsFiltered];
        };
        updateOrders(putAutoColsFirstInList);
    }
    getAutoCol(key) {
        return this.autoCols?.list.find((groupCol) => (0, ag_grid_community_1._columnsMatch)(groupCol, key)) ?? null;
    }
    getAutoCols() {
        return this.autoCols?.list ?? null;
    }
    generateAutoCols(rowGroupCols = []) {
        const autoCols = [];
        const doingTreeData = this.gos.get('treeData');
        let doingMultiAutoColumn = (0, ag_grid_community_1._isGroupMultiAutoColumn)(this.gos);
        if (doingTreeData && doingMultiAutoColumn) {
            (0, ag_grid_community_1._warn)(182);
            doingMultiAutoColumn = false;
        }
        // if doing groupDisplayType = "multipleColumns", then we call the method multiple times, once
        // for each column we are grouping by
        if (doingMultiAutoColumn) {
            rowGroupCols.forEach((rowGroupCol, index) => {
                autoCols.push(this.createOneAutoCol(rowGroupCol, index));
            });
        }
        else {
            autoCols.push(this.createOneAutoCol());
        }
        return autoCols;
    }
    updateAutoCols(source) {
        this.autoCols?.list.forEach((col, index) => this.updateOneAutoCol(col, index, source));
    }
    isSuppressAutoCol() {
        const gos = this.gos;
        const groupDisplayType = gos.get('groupDisplayType');
        const isCustomRowGroups = groupDisplayType === 'custom';
        if (isCustomRowGroups) {
            return true;
        }
        const treeDataDisplayType = gos.get('treeDataDisplayType');
        return treeDataDisplayType === 'custom';
    }
    // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
    createOneAutoCol(rowGroupCol, index) {
        // if doing multi, set the field
        let colId;
        if (rowGroupCol) {
            colId = `${ag_grid_community_1.GROUP_AUTO_COLUMN_ID}-${rowGroupCol.getId()}`;
        }
        else {
            colId = ag_grid_community_1.GROUP_AUTO_COLUMN_ID;
        }
        const colDef = this.createAutoColDef(colId, rowGroupCol, index);
        colDef.colId = colId;
        const newCol = new ag_grid_community_1.AgColumn(colDef, null, colId, true);
        this.createBean(newCol);
        return newCol;
    }
    /**
     * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef
     */
    updateOneAutoCol(colToUpdate, index, source) {
        const oldColDef = colToUpdate.getColDef();
        const underlyingColId = typeof oldColDef.showRowGroup == 'string' ? oldColDef.showRowGroup : undefined;
        const beans = this.beans;
        const underlyingColumn = underlyingColId != null ? beans.colModel.getColDefCol(underlyingColId) : undefined;
        const colDef = this.createAutoColDef(colToUpdate.getId(), underlyingColumn ?? undefined, index);
        colToUpdate.setColDef(colDef, null, source);
        (0, ag_grid_community_1._updateColumnState)(beans, colToUpdate, colDef, source);
    }
    createAutoColDef(colId, underlyingColumn, index) {
        // if one provided by user, use it, otherwise create one
        let res = this.createBaseColDef(underlyingColumn);
        const autoGroupColumnDef = this.gos.get('autoGroupColumnDef');
        (0, ag_grid_community_1._mergeDeep)(res, autoGroupColumnDef);
        res = (0, ag_grid_community_1._addColumnDefaultAndTypes)(this.beans, res, colId, true);
        // For tree data the filter is always allowed
        if (!this.gos.get('treeData')) {
            // we would only allow filter if the user has provided field or value getter. otherwise the filter
            // would not be able to work.
            const noFieldOrValueGetter = (0, ag_grid_community_1._missing)(res.field) &&
                (0, ag_grid_community_1._missing)(res.valueGetter) &&
                (0, ag_grid_community_1._missing)(res.filterValueGetter) &&
                res.filter !== 'agGroupColumnFilter';
            if (noFieldOrValueGetter) {
                res.filter = false;
            }
        }
        // if showing many cols, we don't want to show more than one with a checkbox for selection
        if (index && index > 0) {
            res.headerCheckboxSelection = false;
        }
        const isSortingCoupled = (0, ag_grid_community_1._isColumnsSortingCoupledToGroup)(this.gos);
        const hasOwnData = res.valueGetter || res.field != null;
        if (isSortingCoupled && !hasOwnData) {
            // if col is coupled sorting, and has sort attribute, we want to ignore this
            // because we only accept the sort on creation of the col
            res.sortIndex = undefined;
            res.initialSort = undefined;
        }
        return res;
    }
    createBaseColDef(rowGroupCol) {
        const userDef = this.gos.get('autoGroupColumnDef');
        const localeTextFunc = this.getLocaleTextFunc();
        const res = {
            headerName: localeTextFunc('group', 'Group'),
        };
        const userHasProvidedGroupCellRenderer = userDef && (userDef.cellRenderer || userDef.cellRendererSelector);
        // only add the default group cell renderer if user hasn't provided one
        if (!userHasProvidedGroupCellRenderer) {
            res.cellRenderer = 'agGroupCellRenderer';
        }
        if (rowGroupCol) {
            const colDef = rowGroupCol.getColDef();
            Object.assign(res, {
                headerName: this.beans.colNames.getDisplayNameForColumn(rowGroupCol, 'header'),
                headerValueGetter: colDef.headerValueGetter,
            });
            if (colDef.cellRenderer) {
                Object.assign(res, {
                    cellRendererParams: {
                        innerRenderer: colDef.cellRenderer,
                        innerRendererParams: colDef.cellRendererParams,
                    },
                });
            }
            res.showRowGroup = rowGroupCol.getColId();
        }
        else {
            res.showRowGroup = true;
        }
        return res;
    }
    onAutoGroupColumnDefChanged(source) {
        this.updateAutoCols(source);
    }
    destroy() {
        (0, ag_grid_community_1._destroyColumnTree)(this.beans, this.autoCols?.tree);
        super.destroy();
    }
}
exports.AutoColService = AutoColService;


/***/ }),

/***/ 2560:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseExpansionService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class BaseExpansionService extends ag_grid_community_1.BeanStub {
    addExpandedCss(classes, rowNode) {
        if (rowNode.isExpandable()) {
            classes.push('ag-row-group');
            classes.push(rowNode.expanded ? 'ag-row-group-expanded' : 'ag-row-group-contracted');
        }
    }
    getRowExpandedListeners(rowCtrl) {
        const { rowNode } = rowCtrl;
        const updateExpandedCss = this.updateExpandedCss.bind(this, rowCtrl, rowNode);
        return {
            expandedChanged: updateExpandedCss,
            hasChildrenChanged: updateExpandedCss,
        };
    }
    setExpanded(rowNode, expanded, e, forceSync) {
        if (rowNode.expanded === expanded) {
            return;
        }
        rowNode.expanded = expanded;
        rowNode.dispatchRowEvent('expandedChanged');
        const event = { ...(0, ag_grid_community_1._createGlobalRowEvent)(rowNode, this.gos, 'rowGroupOpened'), expanded, event: e || null };
        this.dispatchExpandedEvent(event, forceSync);
        // when using footers we need to refresh the group row, as the aggregation
        // values jump between group and footer, because the footer can be callback
        // we refresh regardless as the output of the callback could be a moving target
        this.beans.rowRenderer.refreshCells({ rowNodes: [rowNode] });
    }
    isExpandable(rowNode) {
        if (rowNode.footer) {
            return false;
        }
        if (this.beans.colModel.isPivotMode()) {
            // master detail and leaf groups aren't expandable in pivot mode.
            return rowNode.hasChildren() && !rowNode.leafGroup;
        }
        return rowNode.hasChildren() || rowNode.master;
    }
    updateExpandedCss(rowCtrl, rowNode) {
        const expandable = rowNode.isExpandable();
        const expanded = rowNode.expanded == true;
        rowCtrl.forEachGui(undefined, (gui) => {
            const rowComp = gui.rowComp;
            rowComp.addOrRemoveCssClass('ag-row-group', expandable);
            rowComp.addOrRemoveCssClass('ag-row-group-expanded', expandable && expanded);
            rowComp.addOrRemoveCssClass('ag-row-group-contracted', expandable && !expanded);
            (0, ag_grid_community_1._setAriaExpanded)(gui.element, expandable && expanded);
        });
    }
}
exports.BaseExpansionService = BaseExpansionService;


/***/ }),

/***/ 4449:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideExpansionService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const baseExpansionService_1 = __webpack_require__(2560);
class ClientSideExpansionService extends baseExpansionService_1.BaseExpansionService {
    constructor() {
        super(...arguments);
        this.beanName = 'expansionSvc';
        this.events = [];
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    expandRows(rowIds) {
        const rowIdSet = new Set(rowIds);
        this.rowModel.forEachNode((node) => {
            if (node.id && rowIdSet.has(node.id)) {
                node.expanded = true;
            }
        });
        this.onGroupExpandedOrCollapsed();
    }
    expandAll(expand) {
        const { gos, colModel, eventSvc } = this.beans;
        const rowModel = this.rowModel;
        const usingTreeData = gos.get('treeData');
        const usingPivotMode = colModel.isPivotActive();
        const recursiveExpandOrCollapse = (rowNodes) => {
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach((rowNode) => {
                const actionRow = () => {
                    rowNode.expanded = expand;
                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
                };
                if (usingTreeData) {
                    const hasChildren = (0, ag_grid_community_1._exists)(rowNode.childrenAfterGroup);
                    if (hasChildren) {
                        actionRow();
                    }
                    return;
                }
                if (usingPivotMode) {
                    const notLeafGroup = !rowNode.leafGroup;
                    if (notLeafGroup) {
                        actionRow();
                    }
                    return;
                }
                const isRowGroup = rowNode.group;
                if (isRowGroup) {
                    actionRow();
                }
            });
        };
        const rootNode = rowModel.rootNode;
        if (rootNode) {
            recursiveExpandOrCollapse(rootNode.childrenAfterGroup);
        }
        rowModel.refreshModel({ step: 'map' });
        eventSvc.dispatchEvent({
            type: 'expandOrCollapseAll',
            source: expand ? 'expandAll' : 'collapseAll',
        });
    }
    onGroupExpandedOrCollapsed() {
        // we don't really want the user calling this if only one rowNode was expanded, instead they should be
        // calling rowNode.setExpanded(boolean) - this way we do a 'keepRenderedRows=false' so that the whole
        // grid gets refreshed again - otherwise the row with the rowNodes that were changed won't get updated,
        // and thus the expand icon in the group cell won't get 'opened' or 'closed'.
        this.rowModel.refreshModel({ step: 'map' });
    }
    // because the user can call rowNode.setExpanded() many times in one VM turn,
    // we throttle the calls to ClientSideRowModel using animationFrameSvc. this means for 100
    // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
    // CSRM has updated.
    //
    // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
    // to re-render 100+ times, which would be a performance lag.
    //
    // we use animationFrameService
    // rather than debounce() so this will get done if anyone flushes the animationFrameService
    // (eg user calls api.ensureRowVisible(), which in turn flushes ).
    dispatchExpandedEvent(event, forceSync) {
        this.events.push(event);
        const func = () => {
            this.rowModel.onRowGroupOpened();
            this.events.forEach((e) => this.eventSvc.dispatchEvent(e));
            this.events = [];
        };
        if (forceSync) {
            func();
        }
        else {
            if (this.dispatchExpandedDebounced == null) {
                this.dispatchExpandedDebounced = this.debounce(func);
            }
            this.dispatchExpandedDebounced();
        }
    }
    // the advantage over normal debounce is the client can call flushAllFrames()
    // to make sure all rendering is complete. we don't wait any milliseconds,
    // as this is intended to batch calls in one VM turn.
    debounce(func) {
        const animationFrameSvc = this.beans.animationFrameSvc;
        if (!animationFrameSvc) {
            return () => window.setTimeout(func, 0);
        }
        let pending = false;
        return () => {
            if (!animationFrameSvc.active) {
                window.setTimeout(func, 0);
                return;
            }
            if (pending) {
                return;
            }
            pending = true;
            animationFrameSvc.addDestroyTask(() => {
                pending = false;
                func();
            });
        };
    }
}
exports.ClientSideExpansionService = ClientSideExpansionService;


/***/ }),

/***/ 257:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlattenStage = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const footerUtils_1 = __webpack_require__(6432);
class FlattenStage extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'flattenStage';
        this.refreshProps = new Set([
            'groupHideParentOfSingleChild',
            'groupRemoveSingleChildren',
            'groupRemoveLowestSingleChildren',
            'groupTotalRow',
            'masterDetail',
        ]);
        this.step = 'map';
    }
    execute(params) {
        const rootNode = params.rowNode;
        // even if not doing grouping, we do the mapping, as the client might
        // of passed in data that already has a grouping in it somewhere
        const result = [];
        const skipLeafNodes = this.beans.colModel.isPivotMode();
        // if we are reducing, and not grouping, then we want to show the root node, as that
        // is where the pivot values are
        const showRootNode = skipLeafNodes && rootNode.leafGroup;
        const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
        const details = this.getFlattenDetails();
        this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);
        // we do not want the footer total if the gris is empty
        const atLeastOneRowPresent = result.length > 0;
        const includeGrandTotalRow = !showRootNode &&
            // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
            atLeastOneRowPresent &&
            details.grandTotalRow;
        if (includeGrandTotalRow) {
            (0, footerUtils_1._createRowNodeFooter)(rootNode, this.beans);
            const addToTop = details.grandTotalRow === 'top';
            this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);
        }
        return result;
    }
    getFlattenDetails() {
        let groupHideParentOfSingleChild = this.gos.get('groupHideParentOfSingleChild');
        if (!groupHideParentOfSingleChild) {
            groupHideParentOfSingleChild = this.gos.get('groupRemoveSingleChildren');
            if (!groupHideParentOfSingleChild && this.gos.get('groupRemoveLowestSingleChildren')) {
                groupHideParentOfSingleChild = 'leafGroupsOnly';
            }
        }
        return {
            groupHideParentOfSingleChild,
            isGroupMultiAutoColumn: (0, ag_grid_community_1._isGroupMultiAutoColumn)(this.gos),
            hideOpenParents: this.gos.get('groupHideOpenParents'),
            grandTotalRow: (0, ag_grid_community_1._getGrandTotalRow)(this.gos),
            groupTotalRow: (0, ag_grid_community_1._getGroupTotalRowCallback)(this.gos),
        };
    }
    recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {
        if (!rowsToFlatten?.length) {
            return;
        }
        for (let i = 0; i < rowsToFlatten.length; i++) {
            const rowNode = rowsToFlatten[i];
            // check all these cases, for working out if this row should be included in the final mapped list
            const isParent = rowNode.hasChildren();
            const isSkippedLeafNode = skipLeafNodes && !isParent;
            const isRemovedSingleChildrenGroup = details.groupHideParentOfSingleChild === true && isParent && rowNode.childrenAfterGroup.length === 1;
            const isRemovedLowestSingleChildrenGroup = details.groupHideParentOfSingleChild === 'leafGroupsOnly' &&
                isParent &&
                rowNode.leafGroup &&
                rowNode.childrenAfterGroup.length === 1;
            // hide open parents means when group is open, we don't show it. we also need to make sure the
            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).
            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all row groups')
            const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;
            const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;
            const thisRowShouldBeRendered = !isSkippedLeafNode &&
                !isHiddenOpenParent &&
                !isRemovedSingleChildrenGroup &&
                !isRemovedLowestSingleChildrenGroup;
            if (thisRowShouldBeRendered) {
                this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);
            }
            // if we are pivoting, we never map below the leaf group
            if (skipLeafNodes && rowNode.leafGroup) {
                continue;
            }
            if (isParent) {
                const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;
                // we traverse the group if it is expended, however we always traverse if the parent node
                // was removed (as the group will never be opened if it is not displayed, we show the children instead)
                if (rowNode.expanded || excludedParent) {
                    const doesRowShowFooter = details.groupTotalRow({ node: rowNode });
                    if (!doesRowShowFooter) {
                        (0, footerUtils_1._destroyRowNodeFooter)(rowNode);
                    }
                    // if the parent was excluded, then ui level is that of the parent
                    const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;
                    if (doesRowShowFooter === 'top') {
                        (0, footerUtils_1._createRowNodeFooter)(rowNode, this.beans);
                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
                    }
                    this.recursivelyAddToRowsToDisplay(details, rowNode.childrenAfterSort, result, skipLeafNodes, uiLevelForChildren);
                    if (doesRowShowFooter === 'bottom') {
                        (0, footerUtils_1._createRowNodeFooter)(rowNode, this.beans);
                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
                    }
                }
            }
            else {
                const detailNode = this.beans.masterDetailSvc?.getDetail(rowNode);
                if (detailNode) {
                    this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);
                }
            }
        }
    }
    // duplicated method, it's also in floatingRowModel
    addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel, addToTop) {
        if (addToTop) {
            result.unshift(rowNode);
        }
        else {
            result.push(rowNode);
        }
        rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);
    }
}
exports.FlattenStage = FlattenStage;


/***/ }),

/***/ 1982:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupCellRenderer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const groupCellRendererCtrl_1 = __webpack_require__(5471);
const groupTemplate = 
/* html */
`<span class="ag-cell-wrapper">
        <span class="ag-group-expanded" data-ref="eExpanded"></span>
        <span class="ag-group-contracted" data-ref="eContracted"></span>
        <span class="ag-group-checkbox ag-invisible" data-ref="eCheckbox"></span>
        <span class="ag-group-value" data-ref="eValue"></span>
        <span class="ag-group-child-count" data-ref="eChildCount"></span>
    </span>`;
class GroupCellRenderer extends ag_grid_community_1.Component {
    constructor() {
        super(groupTemplate);
        this.eExpanded = ag_grid_community_1.RefPlaceholder;
        this.eContracted = ag_grid_community_1.RefPlaceholder;
        this.eCheckbox = ag_grid_community_1.RefPlaceholder;
        this.eValue = ag_grid_community_1.RefPlaceholder;
        this.eChildCount = ag_grid_community_1.RefPlaceholder;
    }
    init(params) {
        const compProxy = {
            setInnerRenderer: (compDetails, valueToDisplay) => this.setRenderDetails(compDetails, valueToDisplay),
            setChildCount: (count) => (this.eChildCount.textContent = count),
            addOrRemoveCssClass: (cssClass, value) => this.addOrRemoveCssClass(cssClass, value),
            setContractedDisplayed: (expanded) => (0, ag_grid_community_1._setDisplayed)(this.eContracted, expanded),
            setExpandedDisplayed: (expanded) => (0, ag_grid_community_1._setDisplayed)(this.eExpanded, expanded),
            setCheckboxVisible: (visible) => this.eCheckbox.classList.toggle('ag-invisible', !visible),
        };
        const ctrl = this.createManagedBean(new groupCellRendererCtrl_1.GroupCellRendererCtrl());
        const fullWidth = !params.colDef;
        const eGui = this.getGui();
        ctrl.init(compProxy, eGui, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, params);
        if (fullWidth) {
            (0, ag_grid_community_1._setAriaRole)(eGui, ctrl.getCellAriaRole());
        }
    }
    setRenderDetails(compDetails, valueToDisplay) {
        if (compDetails) {
            compDetails.newAgStackInstance().then((comp) => {
                if (!comp) {
                    return;
                }
                const destroyComp = () => this.destroyBean(comp);
                if (this.isAlive()) {
                    this.eValue.appendChild(comp.getGui());
                    this.addDestroyFunc(destroyComp);
                }
                else {
                    destroyComp();
                }
            });
        }
        else {
            this.eValue.innerText = valueToDisplay;
        }
    }
    destroy() {
        this.destroyBean(this.innerCellRenderer);
        super.destroy();
    }
    refresh() {
        return false;
    }
}
exports.GroupCellRenderer = GroupCellRenderer;


/***/ }),

/***/ 5471:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupCellRendererCtrl = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class GroupCellRendererCtrl extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.expressionSvc = beans.expressionSvc;
        this.valueSvc = beans.valueSvc;
        this.colModel = beans.colModel;
        this.visibleCols = beans.visibleCols;
        this.userCompFactory = beans.userCompFactory;
        this.ctrlsSvc = beans.ctrlsSvc;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.selectionSvc = beans.selectionSvc;
        this.groupHideOpenParentsSvc = beans.groupHideOpenParentsSvc;
    }
    init(comp, eGui, eCheckbox, eExpanded, eContracted, compClass, params) {
        this.params = params;
        this.eGui = eGui;
        this.eCheckbox = eCheckbox;
        this.eExpanded = eExpanded;
        this.eContracted = eContracted;
        this.comp = comp;
        this.compClass = compClass;
        const { node, colDef } = params;
        const topLevelFooter = this.isTopLevelFooter();
        // logic for skipping cells follows, never skip top level footer cell.
        if (!topLevelFooter) {
            const embeddedRowMismatch = this.isEmbeddedRowMismatch();
            if (embeddedRowMismatch) {
                return;
            }
            // this footer should only be non-top level.
            // as we won't have footer rows in that instance.
            if (node.footer && this.gos.get('groupHideOpenParents')) {
                const showRowGroup = colDef?.showRowGroup;
                const rowGroupColumnId = node.rowGroupColumn?.getColId();
                // if the groupCellRenderer is inside of a footer and groupHideOpenParents is true
                // we should only display the groupCellRenderer if the current column is the rowGroupedColumn
                if (showRowGroup !== rowGroupColumnId) {
                    return;
                }
            }
        }
        this.setupShowingValueForOpenedParent();
        this.findDisplayedGroupNode();
        if (!topLevelFooter) {
            const showingFooterTotal = this.rowGroupColsSvc &&
                node.footer &&
                node.rowGroupIndex ===
                    this.rowGroupColsSvc.columns.findIndex((c) => c.getColId() === colDef?.showRowGroup);
            // if we're always showing a group value
            const isAlwaysShowing = this.gos.get('groupDisplayType') != 'multipleColumns' || this.gos.get('treeData');
            // if the cell is populated with a parent value due to `showOpenedGroup`
            const showOpenGroupValue = isAlwaysShowing ||
                (this.gos.get('showOpenedGroup') &&
                    this.rowGroupColsSvc &&
                    !node.footer &&
                    (!node.group ||
                        (node.rowGroupIndex != null &&
                            node.rowGroupIndex >
                                this.rowGroupColsSvc?.columns.findIndex((c) => c.getColId() === colDef?.showRowGroup))));
            // not showing a leaf value (field/valueGetter)
            const leafWithValues = !node.group && (colDef?.field || colDef?.valueGetter);
            // doesn't have expand/collapse chevron
            const isExpandable = this.isExpandable();
            // is showing pivot leaf cell
            const showPivotModeLeafValue = this.colModel.isPivotMode() &&
                node.leafGroup &&
                node.rowGroupColumn?.getColId() === colDef?.showRowGroup;
            // if not showing any values or chevron, skip cell.
            const canSkipRenderingCell = !this.showingValueForOpenedParent &&
                !isExpandable &&
                !leafWithValues &&
                !showOpenGroupValue &&
                !showingFooterTotal &&
                !showPivotModeLeafValue;
            if (canSkipRenderingCell) {
                return;
            }
        }
        this.addExpandAndContract();
        this.addFullWidthRowDraggerIfNeeded();
        this.addCheckboxIfNeeded();
        this.addValueElement();
        this.setupIndent();
        this.refreshAriaExpanded();
        this.addManagedPropertyListener('rowSelection', ({ currentValue, previousValue }) => {
            const curr = typeof currentValue === 'object' ? currentValue : undefined;
            const prev = typeof previousValue === 'object' ? previousValue : undefined;
            if (curr?.checkboxLocation !== prev?.checkboxLocation) {
                this.refreshCheckbox();
            }
        });
    }
    getCellAriaRole() {
        const colDefAriaRole = this.params.colDef?.cellAriaRole;
        const columnColDefAriaRole = this.params.column?.getColDef().cellAriaRole;
        return colDefAriaRole || columnColDefAriaRole || 'gridcell';
    }
    destroy() {
        super.destroy();
        // property cleanup to avoid memory leaks
        this.expandListener = null;
        this.destroyCheckbox();
    }
    refreshAriaExpanded() {
        const { node, eGridCell } = this.params;
        if (this.expandListener) {
            this.expandListener = this.expandListener();
        }
        if (!this.isExpandable()) {
            (0, ag_grid_community_1._removeAriaExpanded)(eGridCell);
            return;
        }
        const listener = () => {
            // for react, we don't use JSX, as setting attributes via jsx is slower
            (0, ag_grid_community_1._setAriaExpanded)(eGridCell, this.showingValueForOpenedParent || !!node.expanded);
        };
        [this.expandListener] = this.addManagedListeners(node, { expandedChanged: listener }) || null;
        listener();
    }
    isTopLevelFooter() {
        const totalRow = (0, ag_grid_community_1._getGrandTotalRow)(this.gos);
        if (!totalRow) {
            return false;
        }
        if (this.params.value != null || this.params.node.level != -1) {
            return false;
        }
        // at this point, we know it's the root node and there is no value present, so it's a footer cell.
        // the only thing to work out is if we are displaying groups  across multiple
        // columns (groupDisplayType: 'multipleColumns'), we only want 'total' to appear in the first column.
        const colDef = this.params.colDef;
        const doingFullWidth = colDef == null;
        if (doingFullWidth) {
            return true;
        }
        if (colDef.showRowGroup === true) {
            return true;
        }
        const rowGroupCols = this.rowGroupColsSvc?.columns;
        // this is a sanity check, rowGroupCols should always be present
        if (!rowGroupCols || rowGroupCols.length === 0) {
            return true;
        }
        return rowGroupCols[0].getId() === colDef.showRowGroup;
    }
    // if we are doing embedded full width rows, we only show the renderer when
    // in the body, or if pinning in the pinned section, or if pinning and RTL,
    // in the right section. otherwise we would have the cell repeated in each section.
    isEmbeddedRowMismatch() {
        if (!this.params.fullWidth || !this.gos.get('embedFullWidthRows')) {
            return false;
        }
        const pinnedLeftCell = this.params.pinned === 'left';
        const pinnedRightCell = this.params.pinned === 'right';
        const bodyCell = !pinnedLeftCell && !pinnedRightCell;
        if (this.gos.get('enableRtl')) {
            if (this.visibleCols.isPinningLeft()) {
                return !pinnedRightCell;
            }
            return !bodyCell;
        }
        if (this.visibleCols.isPinningLeft()) {
            return !pinnedLeftCell;
        }
        return !bodyCell;
    }
    findDisplayedGroupNode() {
        const column = this.params.column;
        const rowNode = this.params.node;
        if (this.showingValueForOpenedParent) {
            let pointer = rowNode.parent;
            while (pointer != null) {
                if (pointer.rowGroupColumn && column.isRowGroupDisplayed(pointer.rowGroupColumn.getId())) {
                    this.displayedGroupNode = pointer;
                    break;
                }
                pointer = pointer.parent;
            }
        }
        // if we didn't find a displayed group, set it to the row node
        if ((0, ag_grid_community_1._missing)(this.displayedGroupNode)) {
            this.displayedGroupNode = rowNode;
        }
    }
    setupShowingValueForOpenedParent() {
        this.showingValueForOpenedParent =
            this.groupHideOpenParentsSvc?.isShowingValueForOpenedParent(this.params.node, this.params.column) ?? false;
    }
    addValueElement() {
        if (this.displayedGroupNode.footer) {
            this.addFooterValue();
        }
        else {
            this.addGroupValue();
            this.addChildCount();
        }
    }
    addGroupValue() {
        // we try and use the cellRenderer of the column used for the grouping if we can
        const paramsAdjusted = this.adjustParamsWithDetailsFromRelatedColumn();
        const innerCompDetails = this.getInnerCompDetails(paramsAdjusted);
        const { valueFormatted, value } = paramsAdjusted;
        let valueWhenNoRenderer = valueFormatted;
        if (valueWhenNoRenderer == null) {
            const isGroupColForNode = this.displayedGroupNode.rowGroupColumn &&
                this.params.column?.isRowGroupDisplayed(this.displayedGroupNode.rowGroupColumn.getId());
            if (this.displayedGroupNode.key === '' && this.displayedGroupNode.group && isGroupColForNode) {
                const localeTextFunc = this.getLocaleTextFunc();
                valueWhenNoRenderer = localeTextFunc('blanks', '(Blanks)');
            }
            else {
                valueWhenNoRenderer = value ?? null;
            }
        }
        this.comp.setInnerRenderer(innerCompDetails, valueWhenNoRenderer);
    }
    adjustParamsWithDetailsFromRelatedColumn() {
        const relatedColumn = this.displayedGroupNode.rowGroupColumn;
        const column = this.params.column;
        if (!relatedColumn) {
            return this.params;
        }
        const notFullWidth = column != null;
        if (notFullWidth) {
            const showingThisRowGroup = column.isRowGroupDisplayed(relatedColumn.getId());
            if (!showingThisRowGroup) {
                return this.params;
            }
        }
        const params = this.params;
        const { value, node } = this.params;
        const valueFormatted = this.valueSvc.formatValue(relatedColumn, node, value);
        // we don't update the original params, as they could of come through React,
        // as react has RowGroupCellRenderer, which means the params could be props which
        // would be read only
        const paramsAdjusted = {
            ...params,
            valueFormatted: valueFormatted,
        };
        return paramsAdjusted;
    }
    addFooterValue() {
        const totalValueGetter = this.params.totalValueGetter;
        let footerValue = '';
        if (totalValueGetter) {
            // params is same as we were given, except we set the value as the item to display
            const paramsClone = {
                ...this.params,
                value: this.params.value,
            };
            if (typeof totalValueGetter === 'function') {
                footerValue = totalValueGetter(paramsClone);
            }
            else if (typeof totalValueGetter === 'string') {
                footerValue = this.expressionSvc ? this.expressionSvc.evaluate(totalValueGetter, paramsClone) : '';
            }
            else {
                (0, ag_grid_community_1._warn)(179);
            }
        }
        else {
            const localeTextFunc = this.getLocaleTextFunc();
            const footerTotalPrefix = localeTextFunc('footerTotal', 'Total');
            footerValue = footerTotalPrefix + ' ' + (this.params.value != null ? this.params.value : '');
        }
        const innerCompDetails = this.getInnerCompDetails(this.params);
        this.comp.setInnerRenderer(innerCompDetails, footerValue);
    }
    getInnerCompDetails(params) {
        // for full width rows, we don't do any of the below
        if (params.fullWidth) {
            return (0, ag_grid_community_1._getInnerCellRendererDetails)(this.userCompFactory, this.gos.get('groupRowRendererParams'), params);
        }
        // when grouping, the normal case is we use the cell renderer of the grouped column. eg if grouping by country
        // and then rating, we will use the country cell renderer for each country group row and likewise the rating
        // cell renderer for each rating group row.
        //
        // however if the user has innerCellRenderer defined, this gets preference and we don't use cell renderers
        // of the grouped columns.
        //
        // so we check and use in the following order:
        //
        // 1) thisColDef.cellRendererParams.innerRenderer of the column showing the groups (eg auto group column)
        // 2) groupedColDef.cellRenderer of the grouped column
        // 3) groupedColDef.cellRendererParams.innerRenderer
        // we check if cell renderer provided for the group cell renderer, eg colDef.cellRendererParams.innerRenderer
        const innerCompDetails = (0, ag_grid_community_1._getInnerCellRendererDetails)(this.userCompFactory, params, params);
        // avoid using GroupCellRenderer again, otherwise stack overflow, as we insert same renderer again and again.
        // this covers off chance user is grouping by a column that is also configured with GroupCellRenderer
        const isGroupRowRenderer = (details) => details && details.componentClass == this.compClass;
        if (innerCompDetails && !isGroupRowRenderer(innerCompDetails)) {
            // use the renderer defined in cellRendererParams.innerRenderer
            return innerCompDetails;
        }
        const relatedColumn = this.displayedGroupNode.rowGroupColumn;
        const relatedColDef = relatedColumn?.getColDef();
        if (!relatedColDef) {
            return;
        }
        // otherwise see if we can use the cellRenderer of the column we are grouping by
        const relatedCompDetails = (0, ag_grid_community_1._getCellRendererDetails)(this.userCompFactory, relatedColDef, params);
        if (relatedCompDetails && !isGroupRowRenderer(relatedCompDetails)) {
            // Only if the original column is using a specific renderer, it it is a using a DEFAULT one ignore it
            return relatedCompDetails;
        }
        if (isGroupRowRenderer(relatedCompDetails) &&
            relatedColDef.cellRendererParams &&
            relatedColDef.cellRendererParams.innerRenderer) {
            // edge case - this comes from a column which has been grouped dynamically, that has a renderer 'group'
            // and has an inner cell renderer
            return (0, ag_grid_community_1._getInnerCellRendererDetails)(this.userCompFactory, relatedColDef.cellRendererParams, params);
        }
    }
    addChildCount() {
        // only include the child count if it's included, eg if user doing custom aggregation,
        // then this could be left out, or set to -1, ie no child count
        if (this.params.suppressCount) {
            return;
        }
        this.addManagedListeners(this.displayedGroupNode, {
            allChildrenCountChanged: this.updateChildCount.bind(this),
        });
        // filtering changes the child count, so need to cater for it
        this.updateChildCount();
    }
    updateChildCount() {
        const allChildrenCount = this.displayedGroupNode.allChildrenCount;
        const showingGroupForThisNode = this.isShowRowGroupForThisRow();
        const showCount = showingGroupForThisNode && allChildrenCount != null && allChildrenCount >= 0;
        const countString = showCount ? `(${allChildrenCount})` : ``;
        this.comp.setChildCount(countString);
    }
    isShowRowGroupForThisRow() {
        if (this.gos.get('treeData')) {
            return true;
        }
        const rowGroupColumn = this.displayedGroupNode.rowGroupColumn;
        if (!rowGroupColumn) {
            return false;
        }
        // column is null for fullWidthRows
        const column = this.params.column;
        const thisColumnIsInterested = column == null || column.isRowGroupDisplayed(rowGroupColumn.getId());
        return thisColumnIsInterested;
    }
    addExpandAndContract() {
        const params = this.params;
        const setupIcon = (iconName, element) => {
            const icon = (0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans, null);
            if (icon) {
                element.appendChild(icon);
                this.addDestroyFunc(() => element.removeChild(icon));
            }
        };
        setupIcon('groupExpanded', this.eExpanded);
        setupIcon('groupContracted', this.eContracted);
        const eGroupCell = params.eGridCell;
        // if editing groups, then double click is to start editing
        const isDoubleClickEdit = this.params.column?.isCellEditable(params.node) && this.gos.get('enableGroupEdit');
        if (!isDoubleClickEdit && this.isExpandable() && !params.suppressDoubleClickExpand) {
            this.addManagedListeners(eGroupCell, { dblclick: this.onCellDblClicked.bind(this) });
        }
        this.addManagedListeners(this.eExpanded, { click: this.onExpandClicked.bind(this) });
        this.addManagedListeners(this.eContracted, { click: this.onExpandClicked.bind(this) });
        // expand / contract as the user hits enter
        this.addManagedListeners(eGroupCell, { keydown: this.onKeyDown.bind(this) });
        this.addManagedListeners(params.node, { expandedChanged: this.showExpandAndContractIcons.bind(this) });
        this.showExpandAndContractIcons();
        // because we don't show the expand / contract when there are no children, we need to check every time
        // the number of children change.
        const expandableChangedListener = this.onRowNodeIsExpandableChanged.bind(this);
        this.addManagedListeners(this.displayedGroupNode, {
            allChildrenCountChanged: expandableChangedListener,
            masterChanged: expandableChangedListener,
            groupChanged: expandableChangedListener,
            hasChildrenChanged: expandableChangedListener,
        });
    }
    onExpandClicked(mouseEvent) {
        if ((0, ag_grid_community_1._isStopPropagationForAgGrid)(mouseEvent)) {
            return;
        }
        // so if we expand a node, it does not also get selected.
        (0, ag_grid_community_1._stopPropagationForAgGrid)(mouseEvent);
        this.onExpandOrContract(mouseEvent);
    }
    onExpandOrContract(e) {
        // must use the displayedGroup, so if data was dragged down, we expand the parent, not this row
        const rowNode = this.displayedGroupNode;
        const nextExpandState = !rowNode.expanded;
        if (!nextExpandState && rowNode.sticky) {
            this.scrollToStickyNode(rowNode);
        }
        rowNode.setExpanded(nextExpandState, e);
    }
    scrollToStickyNode(rowNode) {
        this.ctrlsSvc.getScrollFeature().setVerticalScrollPosition(rowNode.rowTop - rowNode.stickyRowTop);
    }
    isExpandable() {
        if (this.showingValueForOpenedParent) {
            return true;
        }
        const rowNode = this.displayedGroupNode;
        const reducedLeafNode = this.colModel.isPivotMode() && rowNode.leafGroup;
        const expandableGroup = rowNode.isExpandable() && !rowNode.footer && !reducedLeafNode;
        if (!expandableGroup) {
            return false;
        }
        // column is null for fullWidthRows
        const column = this.params.column;
        const displayingForOneColumnOnly = column != null && typeof column.getColDef().showRowGroup === 'string';
        if (displayingForOneColumnOnly) {
            const showing = this.isShowRowGroupForThisRow();
            return showing;
        }
        return true;
    }
    showExpandAndContractIcons() {
        const { params, displayedGroupNode: displayedGroup, colModel } = this;
        const { node } = params;
        const isExpandable = this.isExpandable();
        if (isExpandable) {
            // if expandable, show one based on expand state.
            // if we were dragged down, means our parent is always expanded
            const expanded = this.showingValueForOpenedParent ? true : node.expanded;
            this.comp.setExpandedDisplayed(expanded);
            this.comp.setContractedDisplayed(!expanded);
        }
        else {
            // it not expandable, show neither
            this.comp.setExpandedDisplayed(false);
            this.comp.setContractedDisplayed(false);
        }
        // compensation padding for leaf nodes, so there is blank space instead of the expand icon
        const pivotMode = colModel.isPivotMode();
        const pivotModeAndLeafGroup = pivotMode && displayedGroup.leafGroup;
        const addExpandableCss = isExpandable && !pivotModeAndLeafGroup;
        const isTotalFooterNode = node.footer && node.level === -1;
        this.comp.addOrRemoveCssClass('ag-cell-expandable', addExpandableCss);
        this.comp.addOrRemoveCssClass('ag-row-group', addExpandableCss);
        if (pivotMode) {
            this.comp.addOrRemoveCssClass('ag-pivot-leaf-group', !!pivotModeAndLeafGroup);
        }
        else if (!isTotalFooterNode) {
            this.comp.addOrRemoveCssClass('ag-row-group-leaf-indent', !addExpandableCss);
        }
    }
    onRowNodeIsExpandableChanged() {
        // maybe if no children now, we should hide the expand / contract icons
        this.showExpandAndContractIcons();
        // if we have no children, this impacts the indent
        this.setIndent();
        this.refreshAriaExpanded();
    }
    setupIndent() {
        // only do this if an indent - as this overwrites the padding that
        // the theme set, which will make things look 'not aligned' for the
        // first group level.
        const node = this.params.node;
        const suppressPadding = this.params.suppressPadding;
        if (!suppressPadding) {
            this.addManagedListeners(node, { uiLevelChanged: this.setIndent.bind(this) });
            this.setIndent();
        }
    }
    setIndent() {
        if (this.gos.get('groupHideOpenParents')) {
            return;
        }
        const params = this.params;
        const rowNode = params.node;
        // if we are only showing one group column, we don't want to be indenting based on level
        const fullWithRow = !!params.colDef;
        const treeData = this.gos.get('treeData');
        const manyDimensionThisColumn = !fullWithRow || treeData || params.colDef.showRowGroup === true;
        const paddingCount = manyDimensionThisColumn ? rowNode.uiLevel : 0;
        if (this.indentClass) {
            this.comp.addOrRemoveCssClass(this.indentClass, false);
        }
        this.indentClass = 'ag-row-group-indent-' + paddingCount;
        this.comp.addOrRemoveCssClass(this.indentClass, true);
        this.eGui.style.setProperty('--ag-indentation-level', String(paddingCount));
    }
    addFullWidthRowDraggerIfNeeded() {
        if (!this.params.fullWidth || !this.params.rowDrag || !this.rowDragSvc) {
            return;
        }
        const rowDragComp = this.rowDragSvc.createRowDragComp(() => this.params.value, this.params.node);
        this.createManagedBean(rowDragComp);
        this.eGui.insertAdjacentElement('afterbegin', rowDragComp.getGui());
    }
    addCheckboxIfNeeded() {
        const rowNode = this.displayedGroupNode;
        const rowSelection = this.gos.get('rowSelection');
        const checkboxLocation = (0, ag_grid_community_1._getCheckboxLocation)(rowSelection);
        const checkboxes = typeof rowSelection === 'object'
            ? checkboxLocation === 'autoGroupColumn' && (0, ag_grid_community_1._getCheckboxes)(rowSelection)
            : this.params.checkbox;
        const userWantsSelected = typeof checkboxes === 'function' || checkboxes === true;
        const checkboxNeeded = userWantsSelected &&
            // footers cannot be selected
            !rowNode.footer &&
            // pinned rows cannot be selected
            !rowNode.rowPinned &&
            // details cannot be selected
            !rowNode.detail &&
            !!this.selectionSvc &&
            (0, ag_grid_community_1._isRowSelection)(this.gos);
        if (checkboxNeeded) {
            const cbSelectionComponent = this.selectionSvc.createCheckboxSelectionComponent();
            this.cbComp = cbSelectionComponent;
            this.createBean(cbSelectionComponent);
            cbSelectionComponent.init({
                rowNode: this.params.node,
                column: this.params.column,
                overrides: {
                    isVisible: checkboxes,
                    callbackParams: this.params,
                    removeHidden: true,
                },
            });
            this.eCheckbox.appendChild(cbSelectionComponent.getGui());
        }
        this.comp.setCheckboxVisible(checkboxNeeded);
    }
    destroyCheckbox() {
        this.cbComp && this.eCheckbox.removeChild(this.cbComp.getGui());
        this.cbComp = this.destroyBean(this.cbComp);
    }
    refreshCheckbox() {
        this.destroyCheckbox();
        this.addCheckboxIfNeeded();
    }
    onKeyDown(event) {
        const isEnterKey = event.key === ag_grid_community_1.KeyCode.ENTER;
        if (!isEnterKey || this.params.suppressEnterExpand) {
            return;
        }
        const cellEditable = this.params.column && this.params.column.isCellEditable(this.params.node);
        if (cellEditable) {
            return;
        }
        this.onExpandOrContract(event);
    }
    onCellDblClicked(mouseEvent) {
        if ((0, ag_grid_community_1._isStopPropagationForAgGrid)(mouseEvent)) {
            return;
        }
        // we want to avoid acting on double click events on the expand / contract icon,
        // as that icons already has expand / collapse functionality on it. otherwise if
        // the icon was double clicked, we would get 'click', 'click', 'dblclick' which
        // is open->close->open, however double click should be open->close only.
        const targetIsExpandIcon = (0, ag_grid_community_1._isElementInEventPath)(this.eExpanded, mouseEvent) || (0, ag_grid_community_1._isElementInEventPath)(this.eContracted, mouseEvent);
        if (!targetIsExpandIcon) {
            this.onExpandOrContract(mouseEvent);
        }
    }
}
exports.GroupCellRendererCtrl = GroupCellRendererCtrl;


/***/ }),

/***/ 6858:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StickyRowModule = exports.ClientSideRowModelHierarchyModule = exports.GroupColumnModule = exports.GroupCellRendererModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const valueColsSvc_1 = __webpack_require__(7926);
const pivotColsSvc_1 = __webpack_require__(3227);
const rowGroupColsSvc_1 = __webpack_require__(4357);
const version_1 = __webpack_require__(7205);
const autoColService_1 = __webpack_require__(5995);
const clientSideExpansionService_1 = __webpack_require__(4449);
const flattenStage_1 = __webpack_require__(257);
const groupCellRenderer_1 = __webpack_require__(1982);
const groupCellRendererCtrl_1 = __webpack_require__(5471);
const showRowGroupColsService_1 = __webpack_require__(4685);
const stickyRowService_1 = __webpack_require__(1998);
/**
 * @internal
 */
exports.GroupCellRendererModule = {
    moduleName: 'GroupCellRenderer',
    version: version_1.VERSION,
    userComponents: {
        agGroupRowRenderer: groupCellRenderer_1.GroupCellRenderer,
        agGroupCellRenderer: groupCellRenderer_1.GroupCellRenderer,
    },
    dynamicBeans: { groupCellRendererCtrl: groupCellRendererCtrl_1.GroupCellRendererCtrl },
    icons: {
        // shown on row group when contracted (click to expand)
        groupContracted: 'tree-closed',
        // shown on row group when expanded (click to contract)
        groupExpanded: 'tree-open',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};
/**
 * Shared between row grouping and tree data
 * @internal
 */
exports.GroupColumnModule = {
    moduleName: 'GroupColumn',
    version: version_1.VERSION,
    beans: [autoColService_1.AutoColService, showRowGroupColsService_1.ShowRowGroupColsService, rowGroupColsSvc_1.RowGroupColsSvc, pivotColsSvc_1.PivotColsSvc, valueColsSvc_1.ValueColsSvc],
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, exports.GroupCellRendererModule],
};
/**
 * @internal
 */
exports.ClientSideRowModelHierarchyModule = {
    moduleName: 'ClientSideRowModelHierarchy',
    version: version_1.VERSION,
    rowModels: ['clientSide'],
    beans: [flattenStage_1.FlattenStage, clientSideExpansionService_1.ClientSideExpansionService],
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};
/**
 * @internal
 */
exports.StickyRowModule = {
    moduleName: 'StickyRow',
    version: version_1.VERSION,
    beans: [stickyRowService_1.StickyRowService],
};


/***/ }),

/***/ 4685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowRowGroupColsService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ShowRowGroupColsService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'showRowGroupCols';
    }
    refresh() {
        this.showRowGroupCols = [];
        this.showRowGroupColsMap = {};
        const { colModel, rowGroupColsSvc } = this.beans;
        colModel.getCols().forEach((col) => {
            const colDef = col.getColDef();
            const showRowGroup = colDef.showRowGroup;
            const isString = typeof showRowGroup === 'string';
            const isTrue = showRowGroup === true;
            if (!isString && !isTrue) {
                return;
            }
            this.showRowGroupCols.push(col);
            if (isString) {
                this.showRowGroupColsMap[showRowGroup] = col;
            }
            else if (rowGroupColsSvc) {
                rowGroupColsSvc.columns.forEach((rowGroupCol) => {
                    this.showRowGroupColsMap[rowGroupCol.getId()] = col;
                });
            }
        });
    }
    getShowRowGroupCols() {
        return this.showRowGroupCols;
    }
    getShowRowGroupCol(id) {
        return this.showRowGroupColsMap[id];
    }
    getSourceColumnsForGroupColumn(groupCol) {
        const sourceColumnId = groupCol.getColDef().showRowGroup;
        if (!sourceColumnId) {
            return null;
        }
        const { rowGroupColsSvc, colModel } = this.beans;
        if (sourceColumnId === true && rowGroupColsSvc) {
            return rowGroupColsSvc.columns.slice(0);
        }
        const column = colModel.getColDefCol(sourceColumnId);
        return column ? [column] : null;
    }
    isRowGroupDisplayed(column, colId) {
        const { colDef } = column;
        if (colDef?.showRowGroup == null) {
            return false;
        }
        const showingAllGroups = colDef.showRowGroup === true;
        const showingThisGroup = colDef.showRowGroup === colId;
        return showingAllGroups || showingThisGroup;
    }
}
exports.ShowRowGroupColsService = ShowRowGroupColsService;


/***/ }),

/***/ 80:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StickyRowFeature = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class StickyRowFeature extends ag_grid_community_1.BeanStub {
    constructor(createRowCon, destroyRowCtrls) {
        super();
        this.createRowCon = createRowCon;
        this.destroyRowCtrls = destroyRowCtrls;
        this.stickyTopRowCtrls = [];
        this.stickyBottomRowCtrls = [];
        // sticky rows pulls in extra rows from other pages which impacts row position
        this.extraTopHeight = 0;
        this.extraBottomHeight = 0;
    }
    postConstruct() {
        this.isClientSide = (0, ag_grid_community_1._isClientSideRowModel)(this.gos);
        this.beans.ctrlsSvc.whenReady(this, (params) => {
            this.gridBodyCtrl = params.gridBodyCtrl;
        });
        this.resetStickyContainers();
    }
    setOffsetTop(offset) {
        if (this.extraTopHeight === offset) {
            return;
        }
        this.extraTopHeight = offset;
        this.eventSvc.dispatchEvent({
            type: 'stickyTopOffsetChanged',
            offset,
        });
    }
    setOffsetBottom(offset) {
        if (this.extraBottomHeight === offset) {
            return;
        }
        this.extraBottomHeight = offset;
    }
    resetOffsets() {
        this.setOffsetBottom(0);
        this.setOffsetTop(0);
    }
    /**
     * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
     */
    getLastPixelOfGroup(row) {
        return this.isClientSide ? getClientSideLastPixelOfGroup(row) : getServerSideLastPixelOfGroup(row);
    }
    /**
     * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
     */
    getFirstPixelOfGroup(row) {
        if (row.footer) {
            return row.sibling.rowTop + row.sibling.rowHeight - 1;
        }
        if (row.hasChildren()) {
            return row.rowTop - 1;
        }
        // only footer nodes stick bottom, so shouldn't reach this.
        return 0;
    }
    updateStickyRows(container) {
        const isTop = container === 'top';
        let newStickyContainerHeight = 0;
        if (!this.canRowsBeSticky()) {
            return this.refreshNodesAndContainerHeight(container, new Set(), newStickyContainerHeight);
        }
        const { rowModel, rowRenderer } = this.beans;
        const pixelAtContainerBoundary = isTop
            ? rowRenderer.firstVisibleVPixel - this.extraTopHeight
            : rowRenderer.lastVisibleVPixel - this.extraTopHeight;
        const newStickyRows = new Set();
        const addStickyRow = (stickyRow) => {
            newStickyRows.add(stickyRow);
            if (isTop) {
                // get the pixel which stops this node being sticky.
                const lastChildBottom = this.getLastPixelOfGroup(stickyRow);
                const stickRowBottom = pixelAtContainerBoundary + newStickyContainerHeight + stickyRow.rowHeight;
                if (lastChildBottom < stickRowBottom) {
                    stickyRow.stickyRowTop = newStickyContainerHeight + (lastChildBottom - stickRowBottom);
                }
                else {
                    stickyRow.stickyRowTop = newStickyContainerHeight;
                }
            }
            else {
                // get the pixel which stops this node being sticky.
                const lastChildBottom = this.getFirstPixelOfGroup(stickyRow);
                const stickRowTop = pixelAtContainerBoundary - (newStickyContainerHeight + stickyRow.rowHeight);
                if (lastChildBottom > stickRowTop) {
                    stickyRow.stickyRowTop = newStickyContainerHeight - (lastChildBottom - stickRowTop);
                }
                else {
                    stickyRow.stickyRowTop = newStickyContainerHeight;
                }
            }
            // have to recalculate height after each row has been added, to allow
            // calculating the next sticky row
            newStickyContainerHeight = 0;
            newStickyRows.forEach((rowNode) => {
                const thisRowLastPx = rowNode.stickyRowTop + rowNode.rowHeight;
                if (newStickyContainerHeight < thisRowLastPx) {
                    newStickyContainerHeight = thisRowLastPx;
                }
            });
        };
        const suppressFootersSticky = this.areFooterRowsStickySuppressed();
        const suppressGroupsSticky = this.gos.get('suppressGroupRowsSticky');
        const isRowSticky = (row) => {
            if (!row.displayed) {
                return false;
            }
            if (row.footer) {
                if (suppressFootersSticky === true) {
                    return false;
                }
                if (suppressFootersSticky === 'grand' && row.level === -1) {
                    return false;
                }
                if (suppressFootersSticky === 'group' && row.level > -1) {
                    return false;
                }
                const isFooterFirstRowInGroup = row.sibling.rowIndex
                    ? row.sibling.rowIndex + 1 === row.rowIndex
                    : false;
                if (container === 'bottom' && isFooterFirstRowInGroup) {
                    return false;
                }
                const alreadySticking = newStickyRows.has(row);
                return !alreadySticking;
            }
            if (row.isExpandable()) {
                if (suppressGroupsSticky === true) {
                    return false;
                }
                if (container === 'bottom') {
                    // Group rows should never stick to the bottom of the viewport
                    return false;
                }
                const alreadySticking = newStickyRows.has(row);
                return !alreadySticking && row.expanded;
            }
            return false;
        };
        // arbitrary counter to prevent infinite loop break out of the loop when the row calculation
        // changes while rows are becoming sticky (happens with auto height)
        for (let i = 0; i < 100; i++) {
            let firstPixelAfterStickyRows = pixelAtContainerBoundary + newStickyContainerHeight;
            if (!isTop) {
                firstPixelAfterStickyRows = pixelAtContainerBoundary - newStickyContainerHeight;
            }
            const firstIndex = rowModel.getRowIndexAtPixel(firstPixelAfterStickyRows);
            const firstRow = rowModel.getRow(firstIndex);
            if (firstRow == null) {
                break;
            }
            const ancestors = this.getStickyAncestors(firstRow);
            const firstMissingParent = ancestors.find((parent) => (isTop ? parent.rowIndex < firstIndex : parent.rowIndex > firstIndex) && isRowSticky(parent));
            if (firstMissingParent) {
                addStickyRow(firstMissingParent);
                continue;
            }
            const isFirstRowOutsideViewport = isTop
                ? firstRow.rowTop < firstPixelAfterStickyRows
                : firstRow.rowTop + firstRow.rowHeight > firstPixelAfterStickyRows;
            // if first row is an open group, and partially shown, it needs
            // to be stuck
            if (isFirstRowOutsideViewport && isRowSticky(firstRow)) {
                addStickyRow(firstRow);
                continue;
            }
            break;
        }
        if (!isTop) {
            // Because sticky bottom rows are calculated inverted, we need to invert the top position
            newStickyRows.forEach((rowNode) => {
                rowNode.stickyRowTop = newStickyContainerHeight - (rowNode.stickyRowTop + rowNode.rowHeight);
            });
        }
        return this.refreshNodesAndContainerHeight(container, newStickyRows, newStickyContainerHeight);
    }
    areFooterRowsStickySuppressed() {
        const suppressFootersSticky = this.gos.get('suppressStickyTotalRow');
        if (suppressFootersSticky === true) {
            return true;
        }
        const suppressGroupRows = suppressFootersSticky === 'group';
        const suppressGrandRows = suppressFootersSticky === 'grand';
        if (suppressGroupRows && suppressGrandRows) {
            return true;
        }
        if (suppressGrandRows) {
            return 'grand';
        }
        if (suppressGroupRows) {
            return 'group';
        }
        return false;
    }
    canRowsBeSticky() {
        const isStickyEnabled = (0, ag_grid_community_1._isGroupRowsSticky)(this.gos);
        const suppressFootersSticky = this.areFooterRowsStickySuppressed();
        const suppressGroupsSticky = this.gos.get('suppressGroupRowsSticky');
        return isStickyEnabled && (!suppressFootersSticky || !suppressGroupsSticky);
    }
    getStickyAncestors(rowNode) {
        const ancestors = [];
        let p = rowNode.footer ? rowNode.sibling : rowNode.parent;
        while (p) {
            if (p.sibling) {
                ancestors.push(p.sibling);
            }
            ancestors.push(p);
            p = p.parent;
        }
        return ancestors.reverse();
    }
    checkStickyRows() {
        const hasTopUpdated = this.updateStickyRows('top');
        const hasBottomUpdated = this.updateStickyRows('bottom');
        return hasTopUpdated || hasBottomUpdated;
    }
    destroyStickyCtrls() {
        this.resetStickyContainers();
    }
    resetStickyContainers() {
        this.refreshNodesAndContainerHeight('top', new Set(), 0);
        this.refreshNodesAndContainerHeight('bottom', new Set(), 0);
    }
    refreshStickyNode(stickRowNode) {
        const allStickyNodes = new Set();
        if (this.stickyTopRowCtrls.some((ctrl) => ctrl.rowNode === stickRowNode)) {
            for (let i = 0; i < this.stickyTopRowCtrls.length; i++) {
                const currentNode = this.stickyTopRowCtrls[i].rowNode;
                if (currentNode !== stickRowNode) {
                    allStickyNodes.add(currentNode);
                }
            }
            if (this.refreshNodesAndContainerHeight('top', allStickyNodes, this.topContainerHeight)) {
                this.checkStickyRows();
            }
            return;
        }
        for (let i = 0; i < this.stickyBottomRowCtrls.length; i++) {
            const currentNode = this.stickyBottomRowCtrls[i].rowNode;
            if (currentNode !== stickRowNode) {
                allStickyNodes.add(currentNode);
            }
        }
        if (this.refreshNodesAndContainerHeight('bottom', allStickyNodes, this.bottomContainerHeight)) {
            this.checkStickyRows();
        }
    }
    /**
     * Destroy old ctrls and create new ctrls where necessary.
     */
    refreshNodesAndContainerHeight(container, newStickyNodes, height) {
        const isTop = container === 'top';
        const previousCtrls = isTop ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls;
        // find removed ctrls and remaining ctrls
        const removedCtrlsMap = {};
        const remainingCtrls = [];
        for (let i = 0; i < previousCtrls.length; i++) {
            const node = previousCtrls[i].rowNode;
            const hasBeenRemoved = !newStickyNodes.has(node);
            if (hasBeenRemoved) {
                removedCtrlsMap[node.id] = previousCtrls[i];
                // if no longer sticky, remove sticky flag.
                node.sticky = false;
                continue;
            }
            remainingCtrls.push(previousCtrls[i]);
        }
        // get set of existing nodes for quick lookup
        const existingNodes = new Set();
        for (let i = 0; i < remainingCtrls.length; i++) {
            existingNodes.add(remainingCtrls[i].rowNode);
        }
        // find the new ctrls to add
        const newCtrls = [];
        newStickyNodes.forEach((node) => {
            if (existingNodes.has(node)) {
                return;
            }
            // ensure new node is set to sticky and create the new ctrl
            node.sticky = true;
            newCtrls.push(this.createRowCon(node, false, false));
        });
        // check if anything has changed
        let hasSomethingChanged = !!newCtrls.length || remainingCtrls.length !== previousCtrls.length;
        if (isTop) {
            if (this.topContainerHeight !== height) {
                this.topContainerHeight = height;
                this.gridBodyCtrl.setStickyTopHeight(height);
                hasSomethingChanged = true;
            }
        }
        else {
            if (this.bottomContainerHeight !== height) {
                this.bottomContainerHeight = height;
                this.gridBodyCtrl.setStickyBottomHeight(height);
                hasSomethingChanged = true;
            }
        }
        // clean up removed ctrls
        this.destroyRowCtrls(removedCtrlsMap, false);
        // set up new ctrls list
        const newCtrlsList = [...remainingCtrls, ...newCtrls];
        newCtrlsList.sort((a, b) => b.rowNode.rowIndex - a.rowNode.rowIndex);
        if (!isTop) {
            newCtrlsList.reverse();
        }
        newCtrlsList.forEach((ctrl) => ctrl.setRowTop(ctrl.rowNode.stickyRowTop));
        const pageBounds = this.beans.pageBounds;
        let extraHeight = 0;
        if (isTop) {
            newStickyNodes.forEach((node) => {
                if (node.rowIndex < pageBounds.getFirstRow()) {
                    extraHeight += node.rowHeight;
                }
            });
            if (extraHeight > this.topContainerHeight) {
                extraHeight = this.topContainerHeight;
            }
            this.setOffsetTop(extraHeight);
        }
        else {
            newStickyNodes.forEach((node) => {
                if (node.rowIndex > pageBounds.getLastRow()) {
                    extraHeight += node.rowHeight;
                }
            });
            if (extraHeight > this.bottomContainerHeight) {
                extraHeight = this.bottomContainerHeight;
            }
            this.setOffsetBottom(extraHeight);
        }
        if (!hasSomethingChanged) {
            return false;
        }
        if (isTop) {
            this.stickyTopRowCtrls = newCtrlsList;
        }
        else {
            this.stickyBottomRowCtrls = newCtrlsList;
        }
        return true;
    }
    ensureRowHeightsValid() {
        let anyChange = false;
        const updateRowHeight = (ctrl) => {
            const rowNode = ctrl.rowNode;
            if (rowNode.rowHeightEstimated) {
                const rowHeight = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, rowNode);
                rowNode.setRowHeight(rowHeight.height);
                anyChange = true;
            }
        };
        this.stickyTopRowCtrls.forEach(updateRowHeight);
        this.stickyBottomRowCtrls.forEach(updateRowHeight);
        return anyChange;
    }
}
exports.StickyRowFeature = StickyRowFeature;
function getServerSideLastPixelOfGroup(row) {
    if (row.isExpandable() || row.footer) {
        if (row.master) {
            return row.detailNode.rowTop + row.detailNode.rowHeight;
        }
        const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
        if (noOrContiguousSiblings) {
            let storeBounds = row.childStore?.getStoreBounds();
            if (row.footer) {
                storeBounds = row.sibling.childStore?.getStoreBounds();
            }
            return (storeBounds?.heightPx ?? 0) + (storeBounds?.topPx ?? 0);
        }
        if (row.footer) {
            return row.rowTop + row.rowHeight;
        }
        return row.sibling.rowTop + row.sibling.rowHeight;
    }
    // if not a group, then this row shouldn't be sticky currently.
    return Number.MAX_SAFE_INTEGER;
}
function getClientSideLastPixelOfGroup(row) {
    if (row.isExpandable() || row.footer) {
        // grand total row at top, nothing can push it out of sticky.
        const grandTotalAtTop = row.footer && row.rowIndex === 0;
        if (grandTotalAtTop) {
            return Number.MAX_SAFE_INTEGER;
        }
        // if no siblings, we search the children for the last displayed row, to get last px.
        // equally, if sibling but sibling is contiguous ('top') then sibling cannot be used
        // to find last px
        const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
        if (noOrContiguousSiblings) {
            let lastAncestor = row.footer ? row.sibling : row;
            while (lastAncestor.isExpandable() && lastAncestor.expanded) {
                if (lastAncestor.master) {
                    lastAncestor = lastAncestor.detailNode;
                }
                else if (lastAncestor.childrenAfterSort) {
                    // Tree Data will have `childrenAfterSort` without any nodes, but
                    // the current node will still be marked as expansible.
                    if (lastAncestor.childrenAfterSort.length === 0) {
                        break;
                    }
                    lastAncestor = (0, ag_grid_community_1._last)(lastAncestor.childrenAfterSort);
                }
            }
            return lastAncestor.rowTop + lastAncestor.rowHeight;
        }
        // if siblings not contiguous, footer is last row and easiest way for last px
        if (row.footer) {
            return row.rowTop + row.rowHeight;
        }
        return row.sibling.rowTop + row.sibling.rowHeight;
    }
    // if not expandable, then this row shouldn't be sticky currently.
    return Number.MAX_SAFE_INTEGER;
}


/***/ }),

/***/ 1998:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StickyRowService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const stickyRowFeature_1 = __webpack_require__(80);
class StickyRowService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'stickyRowSvc';
    }
    createStickyRowFeature(ctrl, createRowCon, destroyRowCtrls) {
        const gos = this.gos;
        if (((0, ag_grid_community_1._isGroupRowsSticky)(gos) && (0, ag_grid_community_1._isClientSideRowModel)(gos)) || (0, ag_grid_community_1._isServerSideRowModel)(gos)) {
            return ctrl.createManagedBean(new stickyRowFeature_1.StickyRowFeature(createRowCon, destroyRowCtrls));
        }
        return undefined;
    }
}
exports.StickyRowService = StickyRowService;


/***/ }),

/***/ 1538:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlockUtils = exports.GROUP_MISSING_KEY_ID = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const footerUtils_1 = __webpack_require__(6432);
exports.GROUP_MISSING_KEY_ID = 'ag-Grid-MissingKey';
class BlockUtils extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmBlockUtils';
    }
    wireBeans(beans) {
        this.valueSvc = beans.valueSvc;
        this.showRowGroupCols = beans.showRowGroupCols;
        this.nodeManager = beans.ssrmNodeManager;
        this.expansionSvc = beans.expansionSvc;
        this.serverSideRowModel = beans.rowModel;
        this.storeFactory = beans.ssrmStoreFactory;
    }
    createRowNode(params) {
        const rowNode = new ag_grid_community_1.RowNode(this.beans);
        const rowHeight = params.rowHeight != null ? params.rowHeight : (0, ag_grid_community_1._getRowHeightAsNumber)(this.beans);
        rowNode.setRowHeight(rowHeight);
        rowNode.group = params.group;
        rowNode.leafGroup = params.leafGroup;
        rowNode.level = params.level;
        rowNode.uiLevel = params.level;
        rowNode.parent = params.parent;
        // stub gets set to true here, and then false when this rowNode gets it's data
        rowNode.stub = true;
        rowNode.__needsRefreshWhenVisible = false;
        if (rowNode.group) {
            rowNode.expanded = false;
            rowNode.field = params.field;
            rowNode.rowGroupColumn = params.rowGroupColumn;
        }
        return rowNode;
    }
    destroyRowNode(rowNode, preserveStore = false) {
        if (rowNode.childStore && !preserveStore) {
            this.destroyBean(rowNode.childStore);
            rowNode.childStore = null;
        }
        // if this has a footer, destroy that too
        if (rowNode.sibling && !rowNode.footer) {
            this.destroyRowNode(rowNode.sibling, false);
        }
        // this is needed, so row render knows to fade out the row, otherwise it
        // sees row top is present, and thinks the row should be shown. maybe
        // rowNode should have a flag on whether it is visible???
        rowNode.clearRowTopAndRowIndex();
        if (rowNode.id != null) {
            this.nodeManager.removeNode(rowNode);
        }
    }
    setTreeGroupInfo(rowNode) {
        rowNode.updateHasChildren();
        const getKeyFunc = this.gos.get('getServerSideGroupKey');
        const hasChildren = rowNode.hasChildren();
        if (hasChildren && getKeyFunc != null) {
            rowNode.key = getKeyFunc(rowNode.data);
        }
        if (!hasChildren && rowNode.childStore != null) {
            this.destroyBean(rowNode.childStore);
            rowNode.childStore = null;
            rowNode.expanded = false;
        }
    }
    setRowGroupInfo(rowNode) {
        rowNode.key = this.valueSvc.getValue(rowNode.rowGroupColumn, rowNode);
        if (rowNode.key === null || rowNode.key === undefined) {
            (0, ag_grid_community_1._doOnce)(() => {
                (0, ag_grid_community_1._warn)(190, { rowGroupId: rowNode.rowGroupColumn?.getId(), data: rowNode.data });
            }, 'SSBlock-BadKey');
        }
        const isUnbalancedGroup = this.gos.get('groupAllowUnbalanced') && rowNode.key === '';
        if (isUnbalancedGroup) {
            const storeParams = this.serverSideRowModel.getParams();
            rowNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, rowNode));
        }
        const getGroupIncludeFooter = (0, ag_grid_community_1._getGroupTotalRowCallback)(this.beans.gos);
        const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });
        if (doesRowShowFooter) {
            (0, footerUtils_1._createRowNodeFooter)(rowNode, this.beans);
            if (rowNode.sibling) {
                rowNode.sibling.uiLevel = rowNode.uiLevel + 1;
            }
        }
    }
    setMasterDetailInfo(rowNode) {
        const isMasterFunc = this.gos.get('isRowMaster');
        if (isMasterFunc != null) {
            rowNode.master = isMasterFunc(rowNode.data);
        }
        else {
            rowNode.master = true;
        }
    }
    updateDataIntoRowNode(rowNode, data) {
        rowNode.updateData(data);
        if (this.gos.get('treeData')) {
            this.setTreeGroupInfo(rowNode);
            this.setChildCountIntoRowNode(rowNode);
        }
        else if (rowNode.group) {
            this.setChildCountIntoRowNode(rowNode);
            if (!rowNode.footer) {
                const getGroupIncludeFooter = (0, ag_grid_community_1._getGroupTotalRowCallback)(this.beans.gos);
                const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });
                if (doesRowShowFooter) {
                    if (rowNode.sibling) {
                        rowNode.sibling.updateData(data);
                    }
                    else {
                        (0, footerUtils_1._createRowNodeFooter)(rowNode, this.beans);
                    }
                }
                else if (rowNode.sibling) {
                    (0, footerUtils_1._destroyRowNodeFooter)(rowNode);
                }
            }
            // it's not possible for a node to change whether it's a group or not
            // when doing row grouping (as only rows at certain levels are groups),
            // so nothing to do here
        }
        else if (this.gos.get('masterDetail')) {
            // this should be implemented, however it's not the use case i'm currently
            // programming, so leaving for another day. to test this, create an example
            // where whether a master row is expandable or not is dynamic
        }
    }
    setDataIntoRowNode(rowNode, data, defaultId, cachedRowHeight) {
        rowNode.stub = false;
        const treeData = this.gos.get('treeData');
        rowNode.setDataAndId(data, defaultId);
        if (treeData) {
            this.setTreeGroupInfo(rowNode);
        }
        else if (rowNode.group) {
            this.setRowGroupInfo(rowNode);
        }
        else if (this.gos.get('masterDetail')) {
            this.setMasterDetailInfo(rowNode);
        }
        if (treeData || rowNode.group) {
            this.setGroupDataIntoRowNode(rowNode);
            this.setChildCountIntoRowNode(rowNode);
        }
        // this needs to be done AFTER setGroupDataIntoRowNode(), as the height can depend on the group data
        // getting set, if it's a group node and colDef.autoHeight=true
        if ((0, ag_grid_community_1._exists)(data)) {
            rowNode.setRowHeight((0, ag_grid_community_1._getRowHeightForNode)(this.beans, rowNode, false, cachedRowHeight).height);
            rowNode.sibling?.setRowHeight((0, ag_grid_community_1._getRowHeightForNode)(this.beans, rowNode.sibling, false, cachedRowHeight).height);
        }
    }
    setChildCountIntoRowNode(rowNode) {
        const getChildCount = this.gos.get('getChildCount');
        if (getChildCount) {
            rowNode.setAllChildrenCount(getChildCount(rowNode.data));
        }
    }
    setGroupDataIntoRowNode(rowNode) {
        const groupDisplayCols = this.showRowGroupCols?.getShowRowGroupCols() ?? [];
        const usingTreeData = this.gos.get('treeData');
        groupDisplayCols.forEach((col) => {
            if (rowNode.groupData == null) {
                rowNode.groupData = {};
            }
            if (usingTreeData) {
                rowNode.groupData[col.getColId()] = rowNode.key;
            }
            else if (col.isRowGroupDisplayed(rowNode.rowGroupColumn.getId())) {
                const groupValue = this.valueSvc.getValue(rowNode.rowGroupColumn, rowNode);
                rowNode.groupData[col.getColId()] = groupValue;
            }
        });
    }
    clearDisplayIndex(rowNode) {
        rowNode.clearRowTopAndRowIndex();
        const hasChildStore = rowNode.hasChildren() && !!rowNode.childStore;
        if (hasChildStore) {
            rowNode.childStore?.clearDisplayIndexes();
        }
        const hasDetailNode = rowNode.master && rowNode.detailNode;
        if (hasDetailNode) {
            rowNode.detailNode.clearRowTopAndRowIndex();
        }
    }
    setDisplayIndex(rowNode, displayIndexSeq, nextRowTop, uiLevel) {
        const isUnbalancedGroup = this.gos.get('groupAllowUnbalanced') && rowNode.group && rowNode.key === '';
        const isHiddenOpenGroup = this.gos.get('groupHideOpenParents') && rowNode.group && rowNode.expanded;
        if (isHiddenOpenGroup || isUnbalancedGroup) {
            rowNode.setRowIndex(null);
            rowNode.setRowTop(null);
        }
        else {
            // set this row
            rowNode.setRowIndex(displayIndexSeq.value++);
            rowNode.setRowTop(nextRowTop.value);
            nextRowTop.value += rowNode.rowHeight;
        }
        rowNode.setUiLevel(uiLevel);
        if (rowNode.footer) {
            return;
        }
        // set child for master / detail
        const hasDetailRow = rowNode.master;
        if (hasDetailRow) {
            if (rowNode.expanded && rowNode.detailNode) {
                rowNode.detailNode.setRowIndex(displayIndexSeq.value++);
                rowNode.detailNode.setRowTop(nextRowTop.value);
                nextRowTop.value += rowNode.detailNode.rowHeight;
            }
            else if (rowNode.detailNode) {
                rowNode.detailNode.clearRowTopAndRowIndex();
            }
        }
        // set children for SSRM child rows
        const hasChildStore = rowNode.hasChildren() && !!rowNode.childStore;
        if (hasChildStore) {
            const childStore = rowNode.childStore;
            // unbalanced group always behaves as if it was expanded
            if (rowNode.expanded || isUnbalancedGroup) {
                childStore.setDisplayIndexes(displayIndexSeq, nextRowTop, isUnbalancedGroup ? uiLevel : uiLevel + 1);
            }
            else {
                // we need to clear the row tops, as the row renderer depends on
                // this to know if the row should be faded out
                childStore.clearDisplayIndexes();
            }
        }
    }
    extractRowBounds(rowNode, index) {
        const extractRowBounds = (currentRowNode) => ({
            rowHeight: currentRowNode.rowHeight,
            rowTop: currentRowNode.rowTop,
        });
        if (rowNode.rowIndex === index) {
            return extractRowBounds(rowNode);
        }
        if (rowNode.hasChildren() && rowNode.expanded && !!rowNode.childStore) {
            const childStore = rowNode.childStore;
            if (childStore.isDisplayIndexInStore(index)) {
                return childStore.getRowBounds(index);
            }
        }
        else if (rowNode.master && rowNode.expanded && rowNode.detailNode) {
            if (rowNode.detailNode.rowIndex === index) {
                return extractRowBounds(rowNode.detailNode);
            }
        }
    }
    isPixelInNodeRange(node, pixel) {
        if (!(0, ag_grid_community_1._exists)(node.rowTop) || !(0, ag_grid_community_1._exists)(node.rowHeight)) {
            return false;
        }
        return pixel >= node.rowTop && pixel < node.rowTop + node.rowHeight;
    }
    getIndexAtPixel(rowNode, pixel) {
        // first check if pixel is in range of current row
        if (this.isPixelInNodeRange(rowNode, pixel)) {
            return rowNode.rowIndex;
        }
        // then check if current row contains a detail row with pixel in range
        const expandedMasterRow = rowNode.master && rowNode.expanded;
        const detailNode = rowNode.detailNode;
        if (expandedMasterRow && detailNode && this.isPixelInNodeRange(detailNode, pixel)) {
            return rowNode.detailNode.rowIndex;
        }
        // then check if it's a group row with a child cache with pixel in range
        if (rowNode.hasChildren() && rowNode.expanded && !!rowNode.childStore) {
            const childStore = rowNode.childStore;
            if (childStore.isPixelInRange(pixel)) {
                return childStore.getRowIndexAtPixel(pixel);
            }
        }
        return null;
        // pixel is not within this row node or it's children / detail, so return undefined
    }
    createNodeIdPrefix(parentRowNode) {
        const parts = [];
        let rowNode = parentRowNode;
        // pull keys from all parent nodes, but do not include the root node
        while (rowNode && rowNode.level >= 0) {
            if (rowNode.key === '') {
                parts.push(exports.GROUP_MISSING_KEY_ID);
            }
            else {
                parts.push(rowNode.key);
            }
            rowNode = rowNode.parent;
        }
        if (parts.length > 0) {
            return parts.reverse().join('-');
        }
        // no prefix, so node id's are left as they are
        return undefined;
    }
    checkOpenByDefault(rowNode) {
        return this.expansionSvc?.checkOpenByDefault(rowNode);
    }
}
exports.BlockUtils = BlockUtils;


/***/ }),

/***/ 8089:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpandListener = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ExpandListener extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmExpandListener';
    }
    wireBeans(beans) {
        this.serverSideRowModel = beans.rowModel;
        this.storeFactory = beans.ssrmStoreFactory;
    }
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!(0, ag_grid_community_1._isServerSideRowModel)(this.gos)) {
            return;
        }
        this.addManagedEventListeners({ rowGroupOpened: this.onRowGroupOpened.bind(this) });
    }
    onRowGroupOpened(event) {
        const rowNode = event.node;
        if (rowNode.expanded) {
            if (rowNode.master) {
                this.createDetailNode(rowNode);
            }
            else if ((0, ag_grid_community_1._missing)(rowNode.childStore)) {
                const storeParams = this.serverSideRowModel.getParams();
                rowNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, rowNode));
            }
        }
        else if (this.gos.get('purgeClosedRowNodes') && (0, ag_grid_community_1._exists)(rowNode.childStore)) {
            rowNode.childStore = this.destroyBean(rowNode.childStore);
        }
        this.eventSvc.dispatchEvent({ type: 'storeUpdated' });
    }
    createDetailNode(masterNode) {
        if ((0, ag_grid_community_1._exists)(masterNode.detailNode)) {
            return masterNode.detailNode;
        }
        const detailNode = new ag_grid_community_1.RowNode(this.beans);
        detailNode.detail = true;
        detailNode.selectable = false;
        detailNode.parent = masterNode;
        if ((0, ag_grid_community_1._exists)(masterNode.id)) {
            detailNode.id = 'detail_' + masterNode.id;
        }
        detailNode.data = masterNode.data;
        detailNode.level = masterNode.level + 1;
        const defaultDetailRowHeight = 200;
        const rowHeight = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, detailNode).height;
        detailNode.rowHeight = rowHeight ? rowHeight : defaultDetailRowHeight;
        masterNode.detailNode = detailNode;
        return detailNode;
    }
}
exports.ExpandListener = ExpandListener;


/***/ }),

/***/ 1999:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterListener = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class FilterListener extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmFilterListener';
    }
    wireBeans(beans) {
        this.serverSideRowModel = beans.rowModel;
        this.filterManager = beans.filterManager;
        this.listenerUtils = beans.ssrmListenerUtils;
    }
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!(0, ag_grid_community_1._isServerSideRowModel)(this.gos)) {
            return;
        }
        this.addManagedEventListeners({
            advancedFilterEnabledChanged: () => this.onFilterChanged(true),
            filterChanged: () => this.onFilterChanged(),
        });
    }
    onFilterChanged(advancedFilterEnabledChanged) {
        const storeParams = this.serverSideRowModel.getParams();
        if (!storeParams) {
            return;
        } // params is undefined if no datasource set
        const oldModel = storeParams.filterModel;
        let newModel;
        let changedColumns;
        if (this.filterManager?.isAdvFilterEnabled()) {
            newModel = this.filterManager.getAdvFilterModel();
            // if advancedFilterEnabledChanged, old model is of type `FilterModel`
            const oldColumns = advancedFilterEnabledChanged
                ? Object.keys(oldModel ?? {})
                : this.getAdvancedFilterColumns(oldModel);
            const newColumns = this.getAdvancedFilterColumns(newModel);
            oldColumns.forEach((column) => newColumns.add(column));
            changedColumns = Array.from(newColumns);
        }
        else {
            newModel = this.filterManager?.getFilterModel() ?? {};
            if (advancedFilterEnabledChanged) {
                // old model is of type `AdvancedFilterModel | null`
                const oldColumns = this.getAdvancedFilterColumns(oldModel);
                Object.keys(newModel).forEach((column) => oldColumns.add(column));
                changedColumns = Array.from(oldColumns);
            }
            else {
                changedColumns = this.findChangedColumns(oldModel, newModel);
            }
        }
        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);
        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);
        const params = {
            valueColChanged,
            secondaryColChanged,
            changedColumns,
        };
        this.serverSideRowModel.refreshAfterFilter(newModel, params);
    }
    findChangedColumns(oldModel, newModel) {
        const allColKeysMap = {};
        Object.keys(oldModel).forEach((key) => (allColKeysMap[key] = true));
        Object.keys(newModel).forEach((key) => (allColKeysMap[key] = true));
        const res = [];
        Object.keys(allColKeysMap).forEach((key) => {
            const oldJson = JSON.stringify(oldModel[key]);
            const newJson = JSON.stringify(newModel[key]);
            const filterChanged = oldJson != newJson;
            if (filterChanged) {
                res.push(key);
            }
        });
        return res;
    }
    getAdvancedFilterColumns(model) {
        const columns = new Set();
        if (!model) {
            return columns;
        }
        const processAdvancedFilterModel = (filterModel) => {
            if (filterModel.filterType === 'join') {
                filterModel.conditions.forEach((condition) => processAdvancedFilterModel(condition));
            }
            else {
                columns.add(filterModel.colId);
            }
        };
        processAdvancedFilterModel(model);
        return columns;
    }
}
exports.FilterListener = FilterListener;


/***/ }),

/***/ 5956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListenerUtils = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ListenerUtils extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmListenerUtils';
    }
    wireBeans(beans) {
        this.pivotResultCols = beans.pivotResultCols;
        this.valueColsSvc = beans.valueColsSvc;
    }
    isSortingWithValueColumn(changedColumnsInSort) {
        const valueColIds = (this.valueColsSvc?.columns ?? []).map((col) => col.getColId());
        for (let i = 0; i < changedColumnsInSort.length; i++) {
            if (valueColIds.indexOf(changedColumnsInSort[i]) > -1) {
                return true;
            }
        }
        return false;
    }
    isSortingWithSecondaryColumn(changedColumnsInSort) {
        const pivotResultCols = this.pivotResultCols?.getPivotResultCols();
        if (!pivotResultCols) {
            return false;
        }
        const secondaryColIds = pivotResultCols.list.map((col) => col.getColId());
        for (let i = 0; i < changedColumnsInSort.length; i++) {
            if (secondaryColIds.indexOf(changedColumnsInSort[i]) > -1) {
                return true;
            }
        }
        return false;
    }
}
exports.ListenerUtils = ListenerUtils;


/***/ }),

/***/ 6533:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortListener = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class SortListener extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmSortSvc';
    }
    wireBeans(beans) {
        this.sortSvc = beans.sortSvc;
        this.serverSideRowModel = beans.rowModel;
        this.listenerUtils = beans.ssrmListenerUtils;
    }
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!(0, ag_grid_community_1._isServerSideRowModel)(this.gos)) {
            return;
        }
        this.addManagedEventListeners({ sortChanged: this.onSortChanged.bind(this) });
    }
    onSortChanged() {
        const storeParams = this.serverSideRowModel.getParams();
        if (!storeParams) {
            return;
        } // params is undefined if no datasource set
        const newSortModel = this.sortSvc.getSortModel();
        const oldSortModel = storeParams.sortModel;
        const changedColumns = this.findChangedColumnsInSort(newSortModel, oldSortModel);
        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);
        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);
        const params = {
            valueColChanged,
            secondaryColChanged,
            changedColumns,
        };
        this.serverSideRowModel.refreshAfterSort(newSortModel, params);
    }
    // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,
    // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache
    // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache
    // was previously sorted by A and then the A sort now needs to be cleared.
    findChangedColumnsInSort(newSortModel, oldSortModel) {
        let allColsInBothSorts = [];
        [newSortModel, oldSortModel].forEach((sortModel) => {
            if (sortModel) {
                const ids = sortModel.map((sm) => sm.colId);
                allColsInBothSorts = allColsInBothSorts.concat(ids);
            }
        });
        const differentSorts = (oldSortItem, newSortItem) => {
            const oldSort = oldSortItem ? oldSortItem.sort : null;
            const newSort = newSortItem ? newSortItem.sort : null;
            return oldSort !== newSort;
        };
        const differentIndexes = (oldSortItem, newSortItem) => {
            const oldIndex = oldSortItem ? oldSortModel.indexOf(oldSortItem) : -1;
            const newIndex = newSortItem ? newSortModel.indexOf(newSortItem) : -1;
            return oldIndex !== newIndex;
        };
        return allColsInBothSorts.filter((colId) => {
            const oldSortItem = oldSortModel.find((sm) => sm.colId === colId);
            const newSortItem = newSortModel.find((sm) => sm.colId === colId);
            return differentSorts(oldSortItem, newSortItem) || differentIndexes(oldSortItem, newSortItem);
        });
    }
}
exports.SortListener = SortListener;


/***/ }),

/***/ 9140:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class NodeManager extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmNodeManager';
        this.rowNodes = {};
    }
    addRowNode(rowNode) {
        const id = rowNode.id;
        if (this.rowNodes[id]) {
            (0, ag_grid_community_1._warn)(187, {
                rowId: id,
                firstData: this.rowNodes[id].data,
                secondData: rowNode.data,
            });
        }
        this.rowNodes[id] = rowNode;
    }
    removeNode(rowNode) {
        const id = rowNode.id;
        if (this.rowNodes[id]) {
            this.rowNodes[id] = undefined;
        }
    }
    destroy() {
        this.clear();
        super.destroy();
    }
    clear() {
        this.rowNodes = {};
        super.destroy();
    }
}
exports.NodeManager = NodeManager;


/***/ }),

/***/ 8646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSideRowModel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ServerSideRowModel extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowModel';
        this.onRowHeightChanged_debounced = (0, ag_grid_community_1._debounce)(this, this.onRowHeightChanged.bind(this), 100);
        this.pauseStoreUpdateListening = false;
        this.started = false;
        this.managingPivotResultColumns = false;
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.colNames = beans.colNames;
        this.pivotResultCols = beans.pivotResultCols;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.pivotColsSvc = beans.pivotColsSvc;
        this.valueColsSvc = beans.valueColsSvc;
        this.filterManager = beans.filterManager;
        this.sortSvc = beans.sortSvc;
        this.rowRenderer = beans.rowRenderer;
        this.nodeManager = beans.ssrmNodeManager;
        this.storeFactory = beans.ssrmStoreFactory;
        this.pivotColDefSvc = beans.pivotColDefSvc;
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid() {
        return false;
    }
    start() {
        this.started = true;
        this.updateDatasource();
    }
    destroyDatasource() {
        if (!this.datasource) {
            return;
        }
        if (this.datasource.destroy) {
            this.datasource.destroy();
        }
        this.rowRenderer.datasourceChanged();
        this.datasource = undefined;
    }
    postConstruct() {
        const resetListener = this.resetRootStore.bind(this);
        this.addManagedEventListeners({
            newColumnsLoaded: this.onColumnEverything.bind(this),
            storeUpdated: this.onStoreUpdated.bind(this),
            columnValueChanged: resetListener,
            columnPivotChanged: resetListener,
            columnRowGroupChanged: resetListener,
            columnPivotModeChanged: resetListener,
        });
        this.addManagedPropertyListeners([
            /**
             * Following properties omitted as they are likely to come with undesired  side effects.
             * 'getRowId', 'isRowMaster', 'getRowHeight', 'isServerSideGroup', 'getServerSideGroupKey',
             * */
            'masterDetail',
            'treeData',
            'removePivotHeaderRowWhenSingleValueColumn',
            'cacheBlockSize',
        ], resetListener);
        this.addManagedPropertyListener('groupAllowUnbalanced', () => this.onStoreUpdated());
        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());
        this.verifyProps();
        this.addManagedPropertyListener('serverSideDatasource', () => this.updateDatasource());
    }
    updateDatasource() {
        const datasource = this.gos.get('serverSideDatasource');
        if (datasource) {
            this.setDatasource(datasource);
        }
    }
    verifyProps() {
        if ((0, ag_grid_community_1._isRowSelection)(this.gos) && !this.gos.exists('getRowId')) {
            (0, ag_grid_community_1._warn)(188);
        }
    }
    setDatasource(datasource) {
        // sometimes React, due to async, can call gridApi.setDatasource() before we have started.
        // this happens when React app does this:
        //      useEffect(() => setDatasource(ds), []);
        // thus if we set the datasource before the grid UI has finished initialising, we do not set it,
        // and the ssrm.start() method will set the datasoure when the grid is ready.
        if (!this.started) {
            return;
        }
        this.destroyDatasource();
        this.datasource = datasource;
        this.resetRootStore();
    }
    applyRowData(rowDataParams, startRow, route) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        const storeToExecuteOn = rootStore.getChildStore(route);
        if (!storeToExecuteOn) {
            return;
        }
        storeToExecuteOn.applyRowData(rowDataParams, startRow, rowDataParams.rowData.length);
    }
    isLastRowIndexKnown() {
        const cache = this.getRootStore();
        if (!cache) {
            return false;
        }
        return cache.isLastRowIndexKnown();
    }
    onColumnEverything() {
        // if first time, always reset
        if (!this.storeParams) {
            this.resetRootStore();
            return;
        }
        // check if anything pertaining to fetching data has changed, and if it has, reset, but if
        // it has not, don't reset
        const rowGroupColumnVos = this.columnsToValueObjects(this.rowGroupColsSvc?.columns);
        const valueColumnVos = this.columnsToValueObjects(this.valueColsSvc?.columns);
        const pivotColumnVos = this.columnsToValueObjects(this.pivotColsSvc?.columns);
        // compares two sets of columns, ensuring no columns have been added or removed (unless specified via allowRemovedColumns)
        // if the columns are found, also ensures the field and aggFunc properties have not been changed.
        const areColsSame = (params) => {
            const oldColsMap = {};
            params.oldCols.forEach((col) => (oldColsMap[col.id] = col));
            const allColsUnchanged = params.newCols.every((col) => {
                const equivalentCol = oldColsMap[col.id];
                if (equivalentCol) {
                    delete oldColsMap[col.id];
                }
                return equivalentCol && equivalentCol.field === col.field && equivalentCol.aggFunc === col.aggFunc;
            });
            const missingCols = !params.allowRemovedColumns && !!Object.values(oldColsMap).length;
            return allColsUnchanged && !missingCols;
        };
        const sortModelDifferent = !(0, ag_grid_community_1._jsonEquals)(this.storeParams.sortModel, this.sortSvc?.getSortModel() ?? []);
        const rowGroupDifferent = !areColsSame({
            oldCols: this.storeParams.rowGroupCols,
            newCols: rowGroupColumnVos,
        });
        const pivotDifferent = !areColsSame({
            oldCols: this.storeParams.pivotCols,
            newCols: pivotColumnVos,
        });
        const valuesDifferent = !!rowGroupColumnVos?.length &&
            !areColsSame({
                oldCols: this.storeParams.valueCols,
                newCols: valueColumnVos,
                allowRemovedColumns: true,
            });
        const resetRequired = sortModelDifferent || rowGroupDifferent || pivotDifferent || valuesDifferent;
        if (resetRequired) {
            this.resetRootStore();
        }
        else {
            // cols may have changed even if we didn't do a reset. storeParams ref will be provided when getRows
            // is called, so it's important to keep it up to date.
            const newParams = this.createStoreParams();
            this.storeParams.rowGroupCols = newParams.rowGroupCols;
            this.storeParams.pivotCols = newParams.pivotCols;
            this.storeParams.valueCols = newParams.valueCols;
        }
    }
    destroyRootStore() {
        if (!this.rootNode || !this.rootNode.childStore) {
            return;
        }
        this.rootNode.childStore = this.destroyBean(this.rootNode.childStore);
        this.nodeManager.clear();
    }
    refreshAfterSort(newSortModel, params) {
        if (this.storeParams) {
            this.storeParams.sortModel = newSortModel;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.refreshAfterSort(params);
        this.onStoreUpdated();
    }
    generateSecondaryColumns(pivotFields) {
        if (!this.pivotColDefSvc) {
            this.gos.assertModuleRegistered('SharedPivot', 2);
            return;
        }
        const pivotColumnGroupDefs = this.pivotColDefSvc.createColDefsFromFields(pivotFields);
        this.managingPivotResultColumns = true;
        this.pivotResultCols?.setPivotResultCols(pivotColumnGroupDefs, 'rowModelUpdated');
    }
    resetRowHeights() {
        const atLeastOne = this.resetRowHeightsForAllRowNodes();
        const rootNodeHeight = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, this.rootNode);
        this.rootNode.setRowHeight(rootNodeHeight.height, rootNodeHeight.estimated);
        if (this.rootNode.sibling) {
            const rootNodeSibling = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, this.rootNode.sibling);
            this.rootNode.sibling.setRowHeight(rootNodeSibling.height, rootNodeSibling.estimated);
        }
        // when pivotMode but pivot not active, root node is displayed on its own
        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required
        if (atLeastOne) {
            this.onRowHeightChanged();
        }
    }
    resetRowHeightsForAllRowNodes() {
        let atLeastOne = false;
        this.forEachNode((rowNode) => {
            const rowHeightForNode = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, rowNode);
            rowNode.setRowHeight(rowHeightForNode.height, rowHeightForNode.estimated);
            // we keep the height each row is at, however we set estimated=true rather than clear the height.
            // this means the grid will not reset the row heights back to defaults, rather it will re-calc
            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.
            const detailNode = rowNode.detailNode;
            if (detailNode) {
                const detailRowHeight = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, detailNode);
                detailNode.setRowHeight(detailRowHeight.height, detailRowHeight.estimated);
            }
            if (rowNode.sibling) {
                const siblingRowHeight = (0, ag_grid_community_1._getRowHeightForNode)(this.beans, rowNode.sibling);
                detailNode.setRowHeight(siblingRowHeight.height, siblingRowHeight.estimated);
            }
            atLeastOne = true;
        });
        return atLeastOne;
    }
    resetRootStore() {
        this.destroyRootStore();
        this.rootNode = new ag_grid_community_1.RowNode(this.beans);
        this.rootNode.group = true;
        this.rootNode.level = -1;
        if (this.datasource) {
            this.storeParams = this.createStoreParams();
            this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode));
            this.updateRowIndexesAndBounds();
        }
        if (this.managingPivotResultColumns) {
            // if managing pivot columns, also reset secondary columns.
            this.pivotResultCols?.setPivotResultCols(null, 'api');
            this.managingPivotResultColumns = false;
        }
        // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).
        // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer
        // to treat the rows as new rows, as it's all new data
        this.dispatchModelUpdated(true);
    }
    columnsToValueObjects(columns = []) {
        return columns.map((col) => ({
            id: col.getId(),
            aggFunc: col.getAggFunc(),
            displayName: this.colNames.getDisplayNameForColumn(col, 'model'),
            field: col.getColDef().field,
        }));
    }
    createStoreParams() {
        const rowGroupColumnVos = this.columnsToValueObjects(this.rowGroupColsSvc?.columns);
        const valueColumnVos = this.columnsToValueObjects(this.valueColsSvc?.columns);
        const pivotColumnVos = this.columnsToValueObjects(this.pivotColsSvc?.columns);
        const dynamicRowHeight = (0, ag_grid_community_1._isGetRowHeightFunction)(this.gos);
        const params = {
            // the columns the user has grouped and aggregated by
            valueCols: valueColumnVos,
            rowGroupCols: rowGroupColumnVos,
            pivotCols: pivotColumnVos,
            pivotMode: this.colModel.isPivotMode(),
            // sort and filter model
            filterModel: this.filterManager?.isAdvFilterEnabled()
                ? this.filterManager?.getAdvFilterModel()
                : this.filterManager?.getFilterModel() ?? {},
            sortModel: this.sortSvc?.getSortModel() ?? [],
            datasource: this.datasource,
            lastAccessedSequence: { value: 0 },
            // blockSize: blockSize == null ? 100 : blockSize,
            dynamicRowHeight: dynamicRowHeight,
        };
        return params;
    }
    getParams() {
        return this.storeParams;
    }
    dispatchModelUpdated(reset = false) {
        this.eventSvc.dispatchEvent({
            type: 'modelUpdated',
            animate: !reset,
            keepRenderedRows: !reset,
            newPage: false,
            newData: false,
        });
    }
    onStoreUpdated() {
        // sometimes if doing a batch update, we do the batch first,
        // then call onStoreUpdated manually. eg expandAll() method.
        if (this.pauseStoreUpdateListening) {
            return;
        }
        this.updateRowIndexesAndBounds();
        this.dispatchModelUpdated();
    }
    /** This method is debounced. It is used for row auto-height. If we don't debounce,
     * then the Row Models will end up recalculating each row position
     * for each row height change and result in the Row Renderer laying out rows.
     * This is particularly bad if using print layout, and showing eg 1,000 rows,
     * each row will change it's height, causing Row Model to update 1,000 times.
     */
    onRowHeightChangedDebounced() {
        this.onRowHeightChanged_debounced();
    }
    onRowHeightChanged() {
        this.updateRowIndexesAndBounds();
        this.dispatchModelUpdated();
    }
    updateRowIndexesAndBounds() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.setDisplayIndexes({ value: 0 }, { value: 0 }, 0);
    }
    retryLoads() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.retryLoads();
        this.onStoreUpdated();
    }
    getRow(index) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return undefined;
        }
        return rootStore.getRowUsingDisplayIndex(index);
    }
    /**
     * Pauses the store, to prevent it updating the UI. This is used when doing batch updates to the store.
     */
    setPaused(paused) {
        this.pauseStoreUpdateListening = paused;
    }
    expandAll(value) {
        // if we don't pause store updating, we are needlessly
        // recalculating row-indexes etc, and also getting rendering
        // engine to re-render (listens on ModelUpdated event)
        this.pauseStoreUpdateListening = true;
        this.forEachNode((node) => {
            if (node.stub) {
                return;
            }
            if (node.hasChildren()) {
                node.setExpanded(value);
            }
        });
        this.pauseStoreUpdateListening = false;
        this.onStoreUpdated();
    }
    refreshAfterFilter(newFilterModel, params) {
        if (this.storeParams) {
            this.storeParams.filterModel = newFilterModel;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.refreshAfterFilter(params);
        this.onStoreUpdated();
    }
    getRootStore() {
        return this.rootNode?.childStore;
    }
    getRowCount() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return 0;
        }
        return rootStore.getDisplayIndexEnd();
    }
    getTopLevelRowCount() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return 1;
        }
        return rootStore.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return topLevelIndex;
        }
        return rootStore.getTopLevelRowDisplayedIndex(topLevelIndex);
    }
    getRowBounds(index) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            const rowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(this.beans);
            return {
                rowTop: 0,
                rowHeight: rowHeight,
            };
        }
        return rootStore.getRowBounds(index);
    }
    getBlockStates() {
        const root = this.getRootStore();
        if (!root) {
            return undefined;
        }
        const states = {};
        root.forEachStoreDeep((store) => {
            Object.entries(store.getBlockStates()).forEach(([block, state]) => {
                states[block] = state;
            });
        });
        return states;
    }
    getRowIndexAtPixel(pixel) {
        const rootStore = this.getRootStore();
        if (pixel <= 0 || !rootStore) {
            return 0;
        }
        return rootStore.getRowIndexAtPixel(pixel);
    }
    isEmpty() {
        return false;
    }
    isRowsToRender() {
        return this.getRootStore() != null && this.getRowCount() > 0;
    }
    getType() {
        return 'serverSide';
    }
    forEachNode(callback) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.forEachNodeDeep(callback);
    }
    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.forEachNodeDeepAfterFilterAndSort(callback, undefined, includeFooterNodes);
    }
    /** @return false if store hasn't started */
    executeOnStore(route, callback) {
        if (!this.started) {
            return false;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return true;
        }
        const storeToExecuteOn = rootStore.getChildStore(route);
        if (storeToExecuteOn) {
            callback(storeToExecuteOn);
        }
        return true;
    }
    refreshStore(params = {}) {
        const route = params.route ? params.route : [];
        this.executeOnStore(route, (store) => store.refreshStore(params.purge == true));
    }
    getStoreState() {
        const res = [];
        const rootStore = this.getRootStore();
        if (rootStore) {
            rootStore.addStoreStates(res);
        }
        return res;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        const startIndex = firstInRange.rowIndex;
        const endIndex = lastInRange.rowIndex;
        if (startIndex === null && endIndex === null) {
            return [];
        }
        if (endIndex === null) {
            return firstInRange ? [firstInRange] : [];
        }
        if (startIndex === null) {
            return [lastInRange];
        }
        const nodeRange = [];
        const [firstIndex, lastIndex] = [startIndex, endIndex].sort((a, b) => a - b);
        this.forEachNode((node) => {
            const thisRowIndex = node.rowIndex;
            if (thisRowIndex == null || node.stub) {
                return;
            }
            if (thisRowIndex >= firstIndex && thisRowIndex <= lastIndex) {
                nodeRange.push(node);
            }
        });
        // don't allow range selection if we don't have the full range of rows
        if (nodeRange.length !== lastIndex - firstIndex + 1) {
            return null;
        }
        return nodeRange;
    }
    getRowNode(id) {
        let result;
        this.forEachNode((rowNode) => {
            if (rowNode.id === id) {
                result = rowNode;
            }
            if (rowNode.detailNode && rowNode.detailNode.id === id) {
                result = rowNode.detailNode;
            }
        });
        return result;
    }
    isRowPresent(rowNode) {
        const foundRowNode = this.getRowNode(rowNode.id);
        return !!foundRowNode;
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.setRowCount(rowCount, lastRowIndexKnown);
    }
    destroy() {
        this.destroyDatasource();
        this.destroyRootStore();
        super.destroy();
    }
}
exports.ServerSideRowModel = ServerSideRowModel;


/***/ }),

/***/ 5868:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getServerSideGroupLevelState = exports.refreshServerSide = exports.flushServerSideAsyncTransactions = exports.retryServerSideLoads = exports.applyServerSideTransactionAsync = exports.applyServerSideRowData = exports.applyServerSideTransaction = exports.setServerSideSelectionState = exports.getServerSideSelectionState = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function getServerSideSelectionState(beans) {
    return (beans.selectionSvc?.getSelectionState() ?? null);
}
exports.getServerSideSelectionState = getServerSideSelectionState;
function setServerSideSelectionState(beans, state) {
    beans.selectionSvc?.setSelectionState(state, 'api');
}
exports.setServerSideSelectionState = setServerSideSelectionState;
function applyServerSideTransaction(beans, transaction) {
    return beans.ssrmTxnManager?.applyTransaction(transaction);
}
exports.applyServerSideTransaction = applyServerSideTransaction;
function applyServerSideRowData(beans, params) {
    const startRow = params.startRow ?? 0;
    const route = params.route ?? [];
    if (startRow < 0) {
        (0, ag_grid_community_1._warn)(189, { startRow });
        return;
    }
    (0, ag_grid_community_1._getServerSideRowModel)(beans)?.applyRowData(params.successParams, startRow, route);
}
exports.applyServerSideRowData = applyServerSideRowData;
function applyServerSideTransactionAsync(beans, transaction, callback) {
    return beans.ssrmTxnManager?.applyTransactionAsync(transaction, callback);
}
exports.applyServerSideTransactionAsync = applyServerSideTransactionAsync;
function retryServerSideLoads(beans) {
    (0, ag_grid_community_1._getServerSideRowModel)(beans)?.retryLoads();
}
exports.retryServerSideLoads = retryServerSideLoads;
function flushServerSideAsyncTransactions(beans) {
    return beans.ssrmTxnManager?.flushAsyncTransactions();
}
exports.flushServerSideAsyncTransactions = flushServerSideAsyncTransactions;
function refreshServerSide(beans, params) {
    (0, ag_grid_community_1._getServerSideRowModel)(beans)?.refreshStore(params);
}
exports.refreshServerSide = refreshServerSide;
function getServerSideGroupLevelState(beans) {
    return (0, ag_grid_community_1._getServerSideRowModel)(beans)?.getStoreState() ?? [];
}
exports.getServerSideGroupLevelState = getServerSideGroupLevelState;


/***/ }),

/***/ 9074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSideRowModelApiModule = exports.ServerSideRowModelModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const enterpriseCellRendererModule_1 = __webpack_require__(7672);
const pivotModule_1 = __webpack_require__(5470);
const treeDataModule_1 = __webpack_require__(9428);
const version_1 = __webpack_require__(7205);
const blockUtils_1 = __webpack_require__(1538);
const expandListener_1 = __webpack_require__(8089);
const filterListener_1 = __webpack_require__(1999);
const listenerUtils_1 = __webpack_require__(5956);
const sortListener_1 = __webpack_require__(6533);
const nodeManager_1 = __webpack_require__(9140);
const serverSideRowModel_1 = __webpack_require__(8646);
const serverSideRowModelApi_1 = __webpack_require__(5868);
const serverSideExpansionService_1 = __webpack_require__(2758);
const serverSideSelectionService_1 = __webpack_require__(8299);
const ssrmRowChildrenService_1 = __webpack_require__(3803);
const lazyBlockLoadingService_1 = __webpack_require__(8865);
const storeFactory_1 = __webpack_require__(2697);
const storeUtils_1 = __webpack_require__(2234);
const transactionManager_1 = __webpack_require__(7332);
/**
 * @feature Server-Side Row Model
 */
exports.ServerSideRowModelModule = {
    moduleName: 'ServerSideRowModel',
    version: version_1.VERSION,
    rowModels: ['serverSide'],
    beans: [
        serverSideRowModel_1.ServerSideRowModel,
        expandListener_1.ExpandListener,
        storeUtils_1.StoreUtils,
        blockUtils_1.BlockUtils,
        nodeManager_1.NodeManager,
        transactionManager_1.TransactionManager,
        filterListener_1.FilterListener,
        storeFactory_1.StoreFactory,
        listenerUtils_1.ListenerUtils,
        serverSideSelectionService_1.ServerSideSelectionService,
        lazyBlockLoadingService_1.LazyBlockLoadingService,
        ssrmRowChildrenService_1.SsrmRowChildrenService,
        serverSideExpansionService_1.ServerSideExpansionService,
        sortListener_1.SortListener,
    ],
    dependsOn: [
        agGridEnterpriseModule_1.EnterpriseCoreModule,
        ag_grid_community_1._SortModule,
        ag_grid_community_1._SharedRowSelectionModule,
        pivotModule_1.SharedPivotModule,
        treeDataModule_1.SharedTreeDataModule,
        enterpriseCellRendererModule_1.LoadingCellRendererModule,
        enterpriseCellRendererModule_1.SkeletonCellRendererModule,
    ],
};
/**
 * @feature Server-Side Row Model
 */
exports.ServerSideRowModelApiModule = {
    moduleName: 'ServerSideRowModelApi',
    version: version_1.VERSION,
    rowModels: ['serverSide'],
    apiFunctions: {
        getServerSideSelectionState: serverSideRowModelApi_1.getServerSideSelectionState,
        setServerSideSelectionState: serverSideRowModelApi_1.setServerSideSelectionState,
        applyServerSideTransaction: serverSideRowModelApi_1.applyServerSideTransaction,
        applyServerSideTransactionAsync: serverSideRowModelApi_1.applyServerSideTransactionAsync,
        applyServerSideRowData: serverSideRowModelApi_1.applyServerSideRowData,
        retryServerSideLoads: serverSideRowModelApi_1.retryServerSideLoads,
        flushServerSideAsyncTransactions: serverSideRowModelApi_1.flushServerSideAsyncTransactions,
        refreshServerSide: serverSideRowModelApi_1.refreshServerSide,
        getServerSideGroupLevelState: serverSideRowModelApi_1.getServerSideGroupLevelState,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._CsrmSsrmSharedApiModule, ag_grid_community_1._SsrmInfiniteSharedApiModule],
};


/***/ }),

/***/ 2147:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultStrategy = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class DefaultStrategy extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.selectedState = { selectAll: false, toggledNodes: new Set() };
        this.selectAllUsed = false;
        // this is to prevent regressions, default selectionSvc retains reference of clicked nodes.
        this.selectedNodes = {};
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.selectionSvc = beans.selectionSvc;
    }
    getSelectedState() {
        return {
            selectAll: this.selectedState.selectAll,
            toggledNodes: [...this.selectedState.toggledNodes],
        };
    }
    setSelectedState(state) {
        if (typeof state !== 'object') {
            // The provided selection state should be an object
            (0, ag_grid_community_1._error)(115);
            return;
        }
        if (!('selectAll' in state)) {
            //'Invalid selection state. The state must conform to `IServerSideSelectionState`.'
            (0, ag_grid_community_1._error)(116);
            return;
        }
        if (typeof state.selectAll !== 'boolean') {
            //selectAll must be of boolean type.
            (0, ag_grid_community_1._error)(117);
            return;
        }
        if (!('toggledNodes' in state) || !Array.isArray(state.toggledNodes)) {
            return (0, ag_grid_community_1._warn)(197);
        }
        const newState = {
            selectAll: state.selectAll,
            toggledNodes: new Set(),
        };
        state.toggledNodes.forEach((key) => {
            if (typeof key === 'string') {
                newState.toggledNodes.add(key);
            }
            else {
                (0, ag_grid_community_1._warn)(196, { key });
            }
        });
        const isSelectingMultipleRows = newState.selectAll || newState.toggledNodes.size > 1;
        if ((0, ag_grid_community_1._isUsingNewRowSelectionAPI)(this.gos) && !(0, ag_grid_community_1._isMultiRowSelection)(this.gos) && isSelectingMultipleRows) {
            (0, ag_grid_community_1._warn)(198);
            return;
        }
        this.selectedState = newState;
    }
    deleteSelectionStateFromParent(parentPath, removedNodeIds) {
        if (this.selectedState.toggledNodes.size === 0) {
            return false;
        }
        let anyNodesToggled = false;
        removedNodeIds.forEach((id) => {
            if (this.selectedState.toggledNodes.delete(id)) {
                anyNodesToggled = true;
            }
        });
        return anyNodesToggled;
    }
    setNodesSelected(params) {
        const { nodes, clearSelection, newValue } = params;
        if (nodes.length === 0)
            return 0;
        const onlyThisNode = clearSelection && newValue;
        if (!(0, ag_grid_community_1._isMultiRowSelection)(this.gos) || onlyThisNode) {
            if (nodes.length > 1) {
                (0, ag_grid_community_1._error)(241);
                return 0;
            }
            const rowNode = nodes[0];
            const node = rowNode.footer ? rowNode.sibling : rowNode;
            if (newValue && node.selectable) {
                this.selectedNodes = { [node.id]: node };
                this.selectedState = {
                    selectAll: false,
                    toggledNodes: new Set([node.id]),
                };
            }
            else {
                this.selectedNodes = {};
                this.selectedState = {
                    selectAll: false,
                    toggledNodes: new Set(),
                };
            }
            return 1;
        }
        const updateNodeState = (rowNode, value = newValue) => {
            const node = rowNode.footer ? rowNode.sibling : rowNode;
            if (value && node.selectable) {
                this.selectedNodes[node.id] = node;
            }
            else {
                delete this.selectedNodes[node.id];
            }
            const doesNodeConform = value === this.selectedState.selectAll;
            if (doesNodeConform || !node.selectable) {
                this.selectedState.toggledNodes.delete(node.id);
            }
            else {
                this.selectedState.toggledNodes.add(node.id);
            }
        };
        nodes.forEach((node) => updateNodeState(node));
        return 1;
    }
    processNewRow(node) {
        if (this.selectedNodes[node.id]) {
            this.selectedNodes[node.id] = node;
        }
    }
    isNodeSelected(node) {
        const isToggled = this.selectedState.toggledNodes.has(node.id);
        return this.selectedState.selectAll ? !isToggled : isToggled;
    }
    getSelectedNodes() {
        if (this.selectAllUsed) {
            (0, ag_grid_community_1._warn)(199);
        }
        return Object.values(this.selectedNodes);
    }
    getSelectedRows() {
        return this.getSelectedNodes().map((node) => node.data);
    }
    getSelectionCount() {
        if (this.selectedState.selectAll) {
            return -1;
        }
        return this.selectedState.toggledNodes.size;
    }
    isEmpty() {
        return !this.selectedState.selectAll && !this.selectedState.toggledNodes?.size;
    }
    selectAllRowNodes() {
        this.selectedState = { selectAll: true, toggledNodes: new Set() };
        this.selectedNodes = {};
        this.selectAllUsed = true;
    }
    deselectAllRowNodes() {
        this.selectedState = { selectAll: false, toggledNodes: new Set() };
        this.selectedNodes = {};
    }
    getSelectAllState() {
        if (this.selectedState.selectAll) {
            if (this.selectedState.toggledNodes.size > 0) {
                return null;
            }
            return true;
        }
        if (this.selectedState.toggledNodes.size > 0) {
            return null;
        }
        return false;
    }
}
exports.DefaultStrategy = DefaultStrategy;


/***/ }),

/***/ 9149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupSelectsChildrenStrategy = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class GroupSelectsChildrenStrategy extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.selectedState = { selectAllChildren: false, toggledNodes: new Map() };
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.filterManager = beans.filterManager;
        this.selectionSvc = beans.selectionSvc;
    }
    postConstruct() {
        this.addManagedEventListeners({
            // if model has updated, a store may now be fully loaded to clean up indeterminate states
            modelUpdated: () => this.removeRedundantState(),
            // when the grouping changes, the state no longer makes sense, so reset the state.
            columnRowGroupChanged: () => this.selectionSvc.reset('rowGroupChanged'),
        });
    }
    getSelectedState() {
        const treeData = this.gos.get('treeData');
        const recursivelySerializeState = (state, level, nodeId) => {
            const normalisedState = {
                nodeId,
            };
            if (treeData || (this.rowGroupColsSvc && level <= this.rowGroupColsSvc?.columns.length)) {
                normalisedState.selectAllChildren = state.selectAllChildren;
            }
            // omit toggledNodes if empty
            if (state.toggledNodes.size) {
                const toggledNodes = [];
                state.toggledNodes.forEach((value, key) => {
                    const newState = recursivelySerializeState(value, level + 1, key);
                    toggledNodes.push(newState);
                });
                normalisedState.toggledNodes = toggledNodes;
            }
            return normalisedState;
        };
        return recursivelySerializeState(this.selectedState, 0);
    }
    setSelectedState(state) {
        if ('selectAll' in state) {
            // 'Invalid selection state. When `groupSelectsChildren` is enabled, the state must conform to `IServerSideGroupSelectionState`.'
            (0, ag_grid_community_1._error)(111);
            return;
        }
        const recursivelyDeserializeState = (normalisedState, parentSelected) => {
            if (typeof normalisedState !== 'object') {
                (0, ag_grid_community_1._error)(243);
                throw new Error();
            }
            if ('selectAllChildren' in normalisedState && typeof normalisedState.selectAllChildren !== 'boolean') {
                (0, ag_grid_community_1._error)(244);
                throw new Error();
            }
            if ('toggledNodes' in normalisedState) {
                if (!Array.isArray(normalisedState.toggledNodes)) {
                    (0, ag_grid_community_1._error)(245);
                    throw new Error();
                }
                const allHaveIds = normalisedState.toggledNodes.every((innerState) => typeof innerState === 'object' &&
                    'nodeId' in innerState &&
                    typeof innerState.nodeId === 'string');
                if (!allHaveIds) {
                    (0, ag_grid_community_1._error)(246);
                    throw new Error();
                }
            }
            const isThisNodeSelected = normalisedState.selectAllChildren ?? !parentSelected;
            const convertedChildren = normalisedState.toggledNodes?.map((innerState) => [
                innerState.nodeId,
                recursivelyDeserializeState(innerState, isThisNodeSelected),
            ]);
            const doesRedundantStateExist = convertedChildren?.some(([, innerState]) => isThisNodeSelected === innerState.selectAllChildren && innerState.toggledNodes.size === 0);
            if (doesRedundantStateExist) {
                (0, ag_grid_community_1._error)(247);
                throw new Error();
            }
            return {
                selectAllChildren: isThisNodeSelected,
                toggledNodes: new Map(convertedChildren),
            };
        };
        try {
            this.selectedState = recursivelyDeserializeState(state, !!state.selectAllChildren);
        }
        catch (e) {
            // do nothing - error already logged
        }
    }
    deleteSelectionStateFromParent(parentRoute, removedNodeIds) {
        let parentState = this.selectedState;
        const remainingRoute = [...parentRoute];
        while (parentState && remainingRoute.length) {
            parentState = parentState.toggledNodes.get(remainingRoute.pop());
        }
        // parent has no explicit state, nothing to remove
        if (!parentState) {
            return false;
        }
        let anyStateChanged = false;
        removedNodeIds.forEach((id) => {
            if (parentState?.toggledNodes.delete(id)) {
                anyStateChanged = true;
            }
        });
        if (anyStateChanged) {
            this.removeRedundantState();
        }
        return anyStateChanged;
    }
    setNodesSelected({ nodes, newValue, clearSelection }) {
        if (nodes.length === 0)
            return 0;
        const onlyThisNode = clearSelection && newValue;
        if (!(0, ag_grid_community_1._isMultiRowSelection)(this.gos) || onlyThisNode) {
            if (nodes.length > 1) {
                (0, ag_grid_community_1._error)(241);
                return 0;
            }
            this.deselectAllRowNodes();
        }
        nodes.forEach((rowNode) => {
            const node = rowNode.footer ? rowNode.sibling : rowNode;
            const idPathToNode = this.getRouteToNode(node);
            this.recursivelySelectNode(idPathToNode, this.selectedState, newValue);
        });
        this.removeRedundantState();
        return 1;
    }
    isNodeSelected(node) {
        const path = this.getRouteToNode(node);
        return this.isNodePathSelected(path, this.selectedState);
    }
    isNodePathSelected([nextNode, ...nodes], state) {
        if (nodes.length === 0) {
            const isToggled = state.toggledNodes.has(nextNode.id);
            if (nextNode.hasChildren()) {
                const groupState = state.toggledNodes.get(nextNode.id);
                if (groupState && groupState.toggledNodes.size) {
                    return undefined;
                }
            }
            return state.selectAllChildren ? !isToggled : isToggled;
        }
        // if there's a deeper level, check recursively
        if (state.toggledNodes.has(nextNode.id)) {
            const nextState = state.toggledNodes.get(nextNode.id);
            if (nextState) {
                return this.isNodePathSelected(nodes, nextState);
            }
        }
        // no deeper custom state, respect the closest default
        return state.selectAllChildren;
    }
    getRouteToNode(node) {
        const pathToNode = [];
        let tempNode = node;
        while (tempNode.parent) {
            pathToNode.push(tempNode);
            tempNode = tempNode.parent;
        }
        return pathToNode.reverse();
    }
    removeRedundantState() {
        if (this.filterManager?.isAnyFilterPresent()) {
            return;
        }
        const forEachNodeStateDepthFirst = (state = this.selectedState, thisKey, parentState) => {
            // clean up lowest level state first in order to calculate this levels state
            // from updated child state
            state.toggledNodes.forEach((value, key) => {
                forEachNodeStateDepthFirst(value, key, state);
            });
            if (thisKey) {
                const thisRow = this.rowModel.getRowNode(thisKey);
                const thisRowStore = thisRow?.childStore;
                const isStoreSizeKnown = thisRowStore?.isLastRowIndexKnown();
                if (isStoreSizeKnown) {
                    // have to check greater than, as we may have stale state still, if so all visible rows may not be
                    // toggled
                    const possibleAllNodesToggled = state.toggledNodes.size >= thisRowStore.getRowCount();
                    if (possibleAllNodesToggled) {
                        // more complex checks nested for performance
                        for (const childState of state.toggledNodes.entries()) {
                            const [key, value] = childState;
                            // if any child has toggled rows, then this row is indeterminate
                            // and the state is relevant.
                            if (value.toggledNodes.size > 0) {
                                return;
                            }
                            const rowDoesNotExist = !this.rowModel.getRowNode(key);
                            if (rowDoesNotExist) {
                                // if row doesn't exist, it's not toggled.
                                return;
                            }
                        }
                        // no indeterminate rows, and all rows are toggled, flip this row state
                        // and clear child states.
                        state.selectAllChildren = !state.selectAllChildren;
                        state.toggledNodes.clear();
                    }
                }
            }
            // if this has no toggled rows, and is identical to parent state, it's redundant and can be removed.
            const hasNoToggledRows = state.toggledNodes.size === 0;
            const isIdenticalToParent = parentState?.selectAllChildren === state.selectAllChildren;
            if (hasNoToggledRows && isIdenticalToParent) {
                parentState?.toggledNodes.delete(thisKey);
            }
        };
        forEachNodeStateDepthFirst();
    }
    recursivelySelectNode([nextNode, ...nodes], selectedState, newValue) {
        if (!nextNode) {
            return;
        }
        // if this is the last node, hard add/remove based on its selectAllChildren state
        const isLastNode = !nodes.length;
        if (isLastNode) {
            // if the node is not selectable, we should never have it in selection state
            const isNodeSelectable = nextNode.selectable;
            const doesNodeConform = selectedState.selectAllChildren === newValue;
            if (doesNodeConform || !isNodeSelectable) {
                selectedState.toggledNodes.delete(nextNode.id);
                return;
            }
            const newState = {
                selectAllChildren: newValue,
                toggledNodes: new Map(),
            };
            selectedState.toggledNodes.set(nextNode.id, newState);
            return;
        }
        const doesStateAlreadyExist = selectedState.toggledNodes.has(nextNode.id);
        const childState = selectedState.toggledNodes.get(nextNode.id) ?? {
            selectAllChildren: selectedState.selectAllChildren,
            toggledNodes: new Map(),
        };
        if (!doesStateAlreadyExist) {
            selectedState.toggledNodes.set(nextNode.id, childState);
        }
        this.recursivelySelectNode(nodes, childState, newValue);
        // cleans out groups which have no toggled nodes and an equivalent default to its parent
        if (selectedState.selectAllChildren === childState.selectAllChildren && childState.toggledNodes.size === 0) {
            selectedState.toggledNodes.delete(nextNode.id);
        }
    }
    getSelectedNodes() {
        (0, ag_grid_community_1._warn)(202);
        const selectedNodes = [];
        this.rowModel.forEachNode((node) => {
            if (node.isSelected()) {
                selectedNodes.push(node);
            }
        });
        return selectedNodes;
    }
    processNewRow() {
        // This is used for updating outdated node refs, as this model entirely uses ids it's irrelevant
    }
    getSelectedRows() {
        return this.getSelectedNodes().map((node) => node.data);
    }
    getSelectionCount() {
        return -1;
    }
    isEmpty() {
        return !this.selectedState.selectAllChildren && !this.selectedState.toggledNodes?.size;
    }
    selectAllRowNodes() {
        this.selectedState = { selectAllChildren: true, toggledNodes: new Map() };
    }
    deselectAllRowNodes() {
        this.selectedState = { selectAllChildren: false, toggledNodes: new Map() };
    }
    getSelectAllState() {
        if (this.selectedState.selectAllChildren) {
            if (this.selectedState.toggledNodes.size > 0) {
                return null;
            }
            return true;
        }
        if (this.selectedState.toggledNodes.size > 0) {
            return null;
        }
        return false;
    }
}
exports.GroupSelectsChildrenStrategy = GroupSelectsChildrenStrategy;


/***/ }),

/***/ 2758:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSideExpansionService = void 0;
const baseExpansionService_1 = __webpack_require__(2560);
class ServerSideExpansionService extends baseExpansionService_1.BaseExpansionService {
    constructor() {
        super(...arguments);
        this.beanName = 'expansionSvc';
        this.queuedRowIds = new Set();
    }
    wireBeans(beans) {
        this.serverSideRowModel = beans.rowModel;
    }
    postConstruct() {
        this.addManagedEventListeners({
            columnRowGroupChanged: () => {
                this.queuedRowIds.clear();
            },
        });
    }
    checkOpenByDefault(rowNode) {
        if (!rowNode.isExpandable()) {
            return;
        }
        if (this.queuedRowIds.has(rowNode.id)) {
            this.queuedRowIds.delete(rowNode.id);
            rowNode.setExpanded(true);
            return;
        }
        const userFunc = this.gos.getCallback('isServerSideGroupOpenByDefault');
        if (!userFunc) {
            return;
        }
        const params = {
            data: rowNode.data,
            rowNode,
        };
        const userFuncRes = userFunc(params);
        if (userFuncRes) {
            rowNode.setExpanded(true);
        }
    }
    expandRows(rowIds) {
        rowIds.forEach((rowId) => {
            const rowNode = this.serverSideRowModel.getRowNode(rowId);
            if (rowNode) {
                rowNode.setExpanded(true);
            }
            else {
                this.queuedRowIds.add(rowId);
            }
        });
    }
    expandAll(value) {
        this.serverSideRowModel.expandAll(value);
    }
    onGroupExpandedOrCollapsed() {
        // do nothing
    }
    dispatchExpandedEvent(event) {
        this.eventSvc.dispatchEvent(event);
    }
}
exports.ServerSideExpansionService = ServerSideExpansionService;


/***/ }),

/***/ 8299:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSideSelectionService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const defaultStrategy_1 = __webpack_require__(2147);
const groupSelectsChildrenStrategy_1 = __webpack_require__(9149);
class ServerSideSelectionService extends ag_grid_community_1.BaseSelectionService {
    constructor() {
        super(...arguments);
        this.beanName = 'selectionSvc';
    }
    postConstruct() {
        super.postConstruct();
        this.addManagedPropertyListeners(['groupSelectsChildren', 'rowSelection'], () => {
            const groupSelectsChildren = (0, ag_grid_community_1._getGroupSelectsDescendants)(this.gos);
            // Only switch strategies when value of groupSelectsChildren actually changes, not just any part of selection options
            const Strategy = groupSelectsChildren && this.selectionStrategy instanceof defaultStrategy_1.DefaultStrategy
                ? groupSelectsChildrenStrategy_1.GroupSelectsChildrenStrategy
                : !groupSelectsChildren && this.selectionStrategy instanceof groupSelectsChildrenStrategy_1.GroupSelectsChildrenStrategy
                    ? defaultStrategy_1.DefaultStrategy
                    : undefined;
            if (Strategy) {
                this.destroyBean(this.selectionStrategy);
                this.selectionStrategy = this.createManagedBean(new Strategy());
                this.shotgunResetNodeSelectionState();
                this.dispatchSelectionChanged('api');
            }
        });
        this.addManagedPropertyListeners(['rowSelection'], () => {
            // Only reset selection when selection mode changes, not just any part of selection options
            const rowSelection = (0, ag_grid_community_1._getRowSelectionMode)(this.gos);
            if (rowSelection !== this.selectionMode) {
                this.selectionMode = rowSelection;
                this.deselectAllRowNodes({ source: 'api' });
            }
        });
        this.selectionMode = (0, ag_grid_community_1._getRowSelectionMode)(this.gos);
        const groupSelectsChildren = (0, ag_grid_community_1._getGroupSelectsDescendants)(this.gos);
        const Strategy = !groupSelectsChildren ? defaultStrategy_1.DefaultStrategy : groupSelectsChildrenStrategy_1.GroupSelectsChildrenStrategy;
        this.selectionStrategy = this.createManagedBean(new Strategy());
    }
    handleSelectionEvent(event, rowNode, source) {
        if (this.isRowSelectionBlocked(rowNode))
            return 0;
        let updatedRows = 0;
        const selection = this.inferNodeSelections(rowNode, event.shiftKey, event.metaKey || event.ctrlKey, source);
        if (selection == null) {
            return 0;
        }
        if ('select' in selection) {
            if (selection.reset) {
                this.selectionStrategy.deselectAllRowNodes({ source: 'api' });
            }
            else {
                this.selectionStrategy.setNodesSelected({ nodes: selection.deselect, newValue: false, source });
            }
            updatedRows = this.selectionStrategy.setNodesSelected({ nodes: selection.select, newValue: true, source });
        }
        else {
            updatedRows = this.selectionStrategy.setNodesSelected({
                nodes: [selection.node],
                newValue: selection.newValue,
                clearSelection: selection.clearSelection,
                event,
                source,
            });
        }
        this.shotgunResetNodeSelectionState();
        this.dispatchSelectionChanged(source);
        return updatedRows;
    }
    getSelectionState() {
        return this.selectionStrategy.getSelectedState();
    }
    setSelectionState(state, source) {
        if (!(0, ag_grid_community_1._isRowSelection)(this.gos)) {
            (0, ag_grid_community_1._warn)(132);
            return;
        }
        if (Array.isArray(state)) {
            return;
        }
        this.selectionStrategy.setSelectedState(state);
        this.shotgunResetNodeSelectionState();
        this.dispatchSelectionChanged(source);
    }
    setNodesSelected(params) {
        if (!(0, ag_grid_community_1._isRowSelection)(this.gos) && params.newValue) {
            (0, ag_grid_community_1._warn)(132);
            return 0;
        }
        const { nodes, ...otherParams } = params;
        if (nodes.length > 1 && this.selectionMode !== 'multiRow') {
            (0, ag_grid_community_1._warn)(130);
            return 0;
        }
        const adjustedParams = {
            nodes: nodes.filter((node) => node.selectable),
            ...otherParams,
        };
        // if no selectable nodes, then return 0
        if (!adjustedParams.nodes.length) {
            return 0;
        }
        const changedNodes = this.selectionStrategy.setNodesSelected(adjustedParams);
        this.shotgunResetNodeSelectionState(adjustedParams.source);
        this.dispatchSelectionChanged(adjustedParams.source);
        return changedNodes;
    }
    /**
     * Deletes the selection state for a set of nodes, for use after deleting nodes via
     * transaction. As this is designed for transactions, all nodes should belong to the same group.
     */
    deleteSelectionStateFromParent(storeRoute, removedNodeIds) {
        const stateChanged = this.selectionStrategy.deleteSelectionStateFromParent(storeRoute, removedNodeIds);
        if (!stateChanged) {
            return;
        }
        this.shotgunResetNodeSelectionState();
        this.dispatchSelectionChanged('api');
    }
    shotgunResetNodeSelectionState(source) {
        this.beans.rowModel.forEachNode((node) => {
            if (node.stub) {
                return;
            }
            const isNodeSelected = this.selectionStrategy.isNodeSelected(node);
            if (isNodeSelected !== node.isSelected()) {
                this.selectRowNode(node, isNodeSelected, undefined, source);
            }
        });
    }
    getSelectedNodes() {
        return this.selectionStrategy.getSelectedNodes();
    }
    getSelectedRows() {
        return this.selectionStrategy.getSelectedRows();
    }
    getSelectionCount() {
        return this.selectionStrategy.getSelectionCount();
    }
    syncInRowNode(rowNode) {
        // update any refs being held in the strategies
        this.selectionStrategy.processNewRow(rowNode);
        const isNodeSelected = this.selectionStrategy.isNodeSelected(rowNode);
        // if the node was selected but node is not selectable, we deselect the node.
        // (could be due to user applying selected state directly, or a change in selectable)
        if (isNodeSelected != false && !rowNode.selectable) {
            this.selectionStrategy.setNodesSelected({
                nodes: [rowNode],
                newValue: false,
                source: 'api',
            });
            // we need to shotgun reset here as if this was hierarchical, some group nodes
            // may be changing from indeterminate to unchecked.
            this.shotgunResetNodeSelectionState();
            this.dispatchSelectionChanged('api');
            return;
        }
        rowNode.__selected = isNodeSelected;
    }
    reset() {
        this.selectionStrategy.deselectAllRowNodes({ source: 'api' });
        this.selectionCtx.reset();
    }
    isEmpty() {
        return this.selectionStrategy.isEmpty();
    }
    hasNodesToSelect() {
        return true;
    }
    selectAllRowNodes(params) {
        if (!(0, ag_grid_community_1._isRowSelection)(this.gos)) {
            (0, ag_grid_community_1._warn)(132);
            return;
        }
        validateSelectionParameters(params);
        if ((0, ag_grid_community_1._isUsingNewRowSelectionAPI)(this.gos) && !(0, ag_grid_community_1._isMultiRowSelection)(this.gos)) {
            return (0, ag_grid_community_1._warn)(130);
        }
        this.selectionStrategy.selectAllRowNodes(params);
        this.selectionCtx.reset();
        this.beans.rowModel.forEachNode((node) => {
            if (node.stub) {
                return;
            }
            this.selectRowNode(node, true, undefined, params.source);
        });
        this.dispatchSelectionChanged(params.source);
    }
    deselectAllRowNodes(params) {
        validateSelectionParameters(params);
        this.selectionStrategy.deselectAllRowNodes(params);
        this.selectionCtx.reset();
        this.beans.rowModel.forEachNode((node) => {
            if (node.stub) {
                return;
            }
            this.selectRowNode(node, false, undefined, params.source);
        });
        this.dispatchSelectionChanged(params.source);
    }
    getSelectAllState(selectAll) {
        return this.selectionStrategy.getSelectAllState(selectAll);
    }
    // used by CSRM
    getBestCostNodeSelection() {
        return (0, ag_grid_community_1._warn)(194, { method: 'getBestCostNodeSelection' });
    }
    /**
     * Updates the selectable state for a node by invoking isRowSelectable callback.
     * If the node is not selectable, it will be deselected.
     *
     * Callers:
     *  - property isRowSelectable changed
     *  - after grouping / treeData
     */
    updateSelectable() {
        if (!(0, ag_grid_community_1._isRowSelection)(this.gos)) {
            return;
        }
        const nodesToDeselect = [];
        this.beans.rowModel.forEachNode((node) => {
            const rowSelectable = this.updateRowSelectable(node, true);
            if (!rowSelectable && node.isSelected()) {
                nodesToDeselect.push(node);
            }
        });
        if (nodesToDeselect.length) {
            this.setNodesSelected({
                nodes: nodesToDeselect,
                newValue: false,
                source: 'selectableChanged',
            });
        }
    }
    updateSelectableAfterGrouping() {
        return (0, ag_grid_community_1._error)(194, { method: 'updateSelectableAfterGrouping' });
    }
}
exports.ServerSideSelectionService = ServerSideSelectionService;
function validateSelectionParameters({ selectAll }) {
    if (selectAll === 'filtered' || selectAll === 'currentPage') {
        (0, ag_grid_community_1._warn)(195, { justCurrentPage: selectAll === 'currentPage' });
    }
}


/***/ }),

/***/ 3803:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SsrmRowChildrenService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
/** handles row grouping and tree data logic */
class SsrmRowChildrenService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowChildrenSvc';
    }
    getHasChildrenValue(rowNode) {
        const isTreeData = this.gos.get('treeData');
        const isGroupFunc = this.gos.get('isServerSideGroup');
        // stubs and footers can never have children, as they're grid rows. if tree data the presence of children
        // is determined by the isServerSideGroup callback, if not tree data then the rows group property will be set.
        return (!rowNode.stub &&
            !rowNode.footer &&
            (isTreeData ? !!isGroupFunc && isGroupFunc(rowNode.data) : !!rowNode.group));
    }
}
exports.SsrmRowChildrenService = SsrmRowChildrenService;


/***/ }),

/***/ 8865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyBlockLoadingService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class LazyBlockLoadingService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'lazyBlockLoadingSvc';
        this.outboundRequests = 0;
        // a map of caches to loading nodes
        this.cacheLoadingNodesMap = new Map();
        // if a check is queued to happen this cycle
        this.isCheckQueued = false;
        // this is cached for blockLoadDebounce
        this.nextBlockToLoad = undefined;
    }
    wireBeans(beans) {
        this.rowRenderer = beans.rowRenderer;
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        this.maxOutboundRequests = (0, ag_grid_community_1._getMaxConcurrentDatasourceRequests)(this.gos);
    }
    subscribe(cache) {
        this.cacheLoadingNodesMap.set(cache, new Set());
    }
    unsubscribe(cache) {
        this.cacheLoadingNodesMap.delete(cache);
    }
    /**
     * Queues a microtask to check if any blocks need to be loaded.
     */
    queueLoadCheck() {
        if (this.isCheckQueued) {
            return;
        }
        this.isCheckQueued = true;
        window.queueMicrotask(() => {
            this.queueLoadAction();
            this.isCheckQueued = false;
        });
    }
    onLoadComplete() {
        this.outboundRequests -= 1;
        this.queueLoadCheck();
    }
    hasAvailableLoadBandwidth() {
        if (this.maxOutboundRequests === undefined) {
            return true;
        }
        return this.outboundRequests < this.maxOutboundRequests;
    }
    queueLoadAction() {
        const nextBlockToLoad = this.getBlockToLoad();
        if (!nextBlockToLoad) {
            return;
        }
        // for blockLoadDebounceMillis, if the next block to load is the same as the last block to load, ignore
        // otherwise cancel existing timeout and requeue
        const isSameBlock = this.nextBlockToLoad &&
            this.nextBlockToLoad.cache === nextBlockToLoad.cache &&
            this.nextBlockToLoad.index === nextBlockToLoad.index;
        if (isSameBlock) {
            return;
        }
        if (!this.nextBlockToLoad || !isSameBlock) {
            this.nextBlockToLoad = nextBlockToLoad;
            window.clearTimeout(this.loaderTimeout);
            const startRow = Number(this.nextBlockToLoad.index);
            const cache = this.nextBlockToLoad.cache;
            const endRow = nextBlockToLoad.index + nextBlockToLoad.cache.getBlockSize();
            this.loaderTimeout = window.setTimeout(() => {
                if (!cache.isAlive()) {
                    return;
                }
                this.loaderTimeout = undefined;
                this.attemptLoad(cache, startRow, endRow);
                this.nextBlockToLoad = undefined;
            }, this.gos.get('blockLoadDebounceMillis'));
        }
    }
    attemptLoad(cache, start, end) {
        const hasBandwidth = this.hasAvailableLoadBandwidth();
        // too many loads already, ignore the request as a successful request will requeue itself anyway
        if (!hasBandwidth) {
            return;
        }
        this.executeLoad(cache, start, end);
        // requeue a load action before waiting for a response, this is to enable
        // more than one block to load simultaneously due to maxConcurrentDatasourceRequests
        this.queueLoadCheck();
    }
    executeLoad(cache, startRow, endRow) {
        const ssrmParams = cache.getSsrmParams();
        const request = {
            startRow,
            endRow,
            rowGroupCols: ssrmParams.rowGroupCols,
            valueCols: ssrmParams.valueCols,
            pivotCols: ssrmParams.pivotCols,
            pivotMode: ssrmParams.pivotMode,
            groupKeys: cache.store.getParentNode().getRoute() ?? [],
            filterModel: ssrmParams.filterModel,
            sortModel: ssrmParams.sortModel,
        };
        const loadingNodes = this.cacheLoadingNodesMap.get(cache);
        const removeNodesFromLoadingMap = () => {
            for (let i = 0; i < endRow - startRow; i++) {
                loadingNodes.delete(startRow + i);
            }
        };
        const addNodesToLoadingMap = () => {
            for (let i = 0; i < endRow - startRow; i++) {
                loadingNodes.add(startRow + i);
            }
        };
        const success = (params) => {
            this.onLoadComplete();
            cache.onLoadSuccess(startRow, endRow - startRow, params);
            removeNodesFromLoadingMap();
        };
        const fail = () => {
            this.onLoadComplete();
            cache.onLoadFailed(startRow, endRow - startRow);
            removeNodesFromLoadingMap();
        };
        const params = this.gos.addGridCommonParams({
            request,
            success,
            fail,
            parentNode: cache.store.getParentNode(),
        });
        addNodesToLoadingMap();
        this.outboundRequests += 1;
        cache.getSsrmParams().datasource?.getRows(params);
    }
    getBlockToLoad() {
        const firstRowInViewport = this.rowRenderer.firstRenderedRow;
        const lastRowInViewport = this.rowRenderer.lastRenderedRow;
        // quick look-up for priority rows needing loading in viewport.
        for (let i = firstRowInViewport; i <= lastRowInViewport; i++) {
            const row = this.rowModel.getRow(i);
            if (!row) {
                continue;
            }
            const store = row.parent?.childStore;
            if (!store) {
                continue;
            }
            const cache = store.getCache();
            const lazyNode = cache.getNodes().getBy('node', row);
            if (!lazyNode) {
                continue;
            }
            const loadingNodes = this.cacheLoadingNodesMap.get(cache);
            if (loadingNodes?.has(lazyNode.index)) {
                continue;
            }
            if (row.__needsRefreshWhenVisible || (row.stub && !row.failedLoad)) {
                return {
                    cache: cache,
                    index: cache.getBlockStartIndex(lazyNode.index),
                };
            }
        }
        let cacheToRefresh = null;
        let nodeToRefresh = null;
        let nodeToRefreshDist = Number.MAX_SAFE_INTEGER;
        for (const cache of this.cacheLoadingNodesMap.keys()) {
            const nodesToRefresh = cache.getNodesToRefresh();
            nodesToRefresh.forEach((node) => {
                if (node.rowIndex == null) {
                    nodeToRefresh = node;
                    cacheToRefresh = cache;
                    return;
                }
                const lazyNode = cache.getNodes().getBy('node', node);
                if (!lazyNode) {
                    return;
                }
                const loadingNodes = this.cacheLoadingNodesMap.get(cache);
                if (loadingNodes?.has(lazyNode.index)) {
                    return;
                }
                const distToViewportTop = Math.abs(firstRowInViewport - node.rowIndex);
                const distToViewportBottom = Math.abs(node.rowIndex - lastRowInViewport);
                if (distToViewportTop < nodeToRefreshDist) {
                    nodeToRefresh = node;
                    nodeToRefreshDist = distToViewportTop;
                    cacheToRefresh = cache;
                }
                if (distToViewportBottom < nodeToRefreshDist) {
                    nodeToRefresh = node;
                    nodeToRefreshDist = distToViewportBottom;
                    cacheToRefresh = cache;
                }
            });
        }
        if (!cacheToRefresh) {
            return undefined;
        }
        const lazyCache = cacheToRefresh;
        const lazyIndex = lazyCache.getNodes().getBy('node', nodeToRefresh)?.index;
        return lazyIndex == null
            ? undefined
            : {
                cache: lazyCache,
                index: lazyCache.getBlockStartIndex(lazyIndex),
            };
    }
    isRowLoading(cache, index) {
        return this.cacheLoadingNodesMap.get(cache)?.has(index) ?? false;
    }
}
exports.LazyBlockLoadingService = LazyBlockLoadingService;


/***/ }),

/***/ 4905:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyCache = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
const multiIndexMap_1 = __webpack_require__(2314);
const DEFAULT_BLOCK_SIZE = 100;
class LazyCache extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.rowRenderer = beans.rowRenderer;
        this.blockUtils = beans.ssrmBlockUtils;
        this.focusSvc = beans.focusSvc;
        this.nodeManager = beans.ssrmNodeManager;
        this.serverSideRowModel = beans.rowModel;
        this.rowNodeSorter = beans.rowNodeSorter;
        this.sortSvc = beans.sortSvc;
        this.lazyBlockLoadingSvc = beans.lazyBlockLoadingSvc;
        this.colModel = beans.colModel;
    }
    constructor(store, numberOfRows, isLastRowKnown, storeParams) {
        super();
        /**
         * Indicates whether this is still the live dataset for this store (used for ignoring old requests after purge)
         */
        this.live = true;
        /**
         * A cache of removed group nodes, this is retained for preserving group
         * state when the node moves in and out of the cache. Generally caused by
         * rows moving blocks.
         */
        this.removedNodeCache = new Map();
        this.store = store;
        this.numberOfRows = numberOfRows;
        this.isLastRowKnown = isLastRowKnown;
        this.storeParams = storeParams;
    }
    postConstruct() {
        this.lazyBlockLoadingSvc.subscribe(this);
        // initiate the node map to be indexed at 'index', 'id' and 'node' for quick look-up.
        // it's important id isn't first, as stub nodes overwrite each-other, and the first index is
        // used for iteration.
        this.nodeMap = new multiIndexMap_1.MultiIndexMap('index', 'id', 'node');
        this.nodeDisplayIndexMap = new Map();
        this.nodesToRefresh = new Set();
        this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());
        this.getRowIdFunc = (0, ag_grid_community_1._getRowIdCallback)(this.gos);
        this.isMasterDetail = this.gos.get('masterDetail');
    }
    destroy() {
        this.lazyBlockLoadingSvc.unsubscribe(this);
        this.numberOfRows = 0;
        this.nodeMap.forEach((node) => this.blockUtils.destroyRowNode(node.node));
        this.nodeMap.clear();
        this.nodeDisplayIndexMap.clear();
        this.nodesToRefresh.clear();
        this.live = false;
        super.destroy();
    }
    /**
     * Get the row node for a specific display index from this store
     * @param displayIndex the display index of the node to find
     * @returns undefined if the node is not in the store bounds, otherwise will always return a node
     */
    getRowByDisplayIndex(displayIndex) {
        // if index isn't in store, nothing to return
        if (!this.store.isDisplayIndexInStore(displayIndex)) {
            return undefined;
        }
        // first try to directly look this node up in the display index map
        const node = this.nodeDisplayIndexMap.get(displayIndex);
        if (node) {
            // if we have the node, check if it needs refreshed when rendered
            if (node.stub || node.__needsRefreshWhenVisible) {
                this.lazyBlockLoadingSvc.queueLoadCheck();
            }
            return node;
        }
        const hideOpenGroups = this.gos.get('groupHideOpenParents') || this.gos.get('groupAllowUnbalanced');
        if (hideOpenGroups) {
            // if hiding open groups, the first node in this expanded store may not be
            // the first displayed node, as it could be hidden, so need to DFS first.
            const nextParent = this.nodeMap.find((lazyNode) => !!lazyNode.node.childStore?.isDisplayIndexInStore(displayIndex));
            // if belongs to child store, search that first
            if (nextParent) {
                return nextParent.node.childStore?.getRowUsingDisplayIndex(displayIndex);
            }
        }
        // next check if this is the first row, if so return a stub node
        // this is a performance optimisation, as it is the most common scenario
        // and enables the node - 1 check to kick in more often.
        if (displayIndex === this.store.getDisplayIndexStart()) {
            return this.createStubNode(0, displayIndex);
        }
        // check if the row immediately prior is available in the store
        const contiguouslyPreviousNode = this.nodeDisplayIndexMap.get(displayIndex - 1);
        if (contiguouslyPreviousNode) {
            // if previous row is master detail, and expanded, this node must be detail
            if (this.isMasterDetail && contiguouslyPreviousNode.master && contiguouslyPreviousNode.expanded) {
                return contiguouslyPreviousNode.detailNode;
            }
            // if previous row is expanded group, this node will belong to that group.
            if (contiguouslyPreviousNode.expanded &&
                contiguouslyPreviousNode.childStore?.isDisplayIndexInStore(displayIndex)) {
                return contiguouslyPreviousNode.childStore?.getRowUsingDisplayIndex(displayIndex);
            }
            // otherwise, row must be a stub node
            const lazyCacheNode = this.nodeMap.getBy('node', contiguouslyPreviousNode);
            return this.createStubNode(lazyCacheNode.index + 1, displayIndex);
        }
        const adjacentNodes = this.getSurroundingNodesByDisplayIndex(displayIndex);
        // if no bounds skipped includes this, calculate from end index
        if (adjacentNodes == null) {
            const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - displayIndex);
            return this.createStubNode(storeIndexFromEndIndex, displayIndex);
        }
        const { previousNode, nextNode } = adjacentNodes;
        // if the node before this node is expanded, this node might be a child of that node
        if (previousNode &&
            previousNode.node.expanded &&
            previousNode.node.childStore?.isDisplayIndexInStore(displayIndex)) {
            return previousNode.node.childStore?.getRowUsingDisplayIndex(displayIndex);
        }
        // if we have the node after this node, we can calculate the store index of this node by the difference
        // in display indexes between the two nodes.
        if (nextNode) {
            const displayIndexDiff = nextNode.node.rowIndex - displayIndex;
            const newStoreIndex = nextNode.index - displayIndexDiff;
            return this.createStubNode(newStoreIndex, displayIndex);
        }
        // if no next node, calculate from end index of this store
        const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - displayIndex);
        return this.createStubNode(storeIndexFromEndIndex, displayIndex);
    }
    /**
     * Used for creating and positioning a stub node without firing a store updated event
     */
    createStubNode(storeIndex, displayIndex) {
        // bounds are acquired before creating the node, as otherwise it'll use it's own empty self to calculate
        const rowBounds = this.store.getRowBounds(displayIndex);
        const newNode = this.createRowAtIndex(storeIndex, null, (node) => {
            node.setRowIndex(displayIndex);
            node.setRowTop(rowBounds.rowTop);
            this.nodeDisplayIndexMap.set(displayIndex, node);
        });
        // if group hide open parents we need to populate with the parent group data for the first stub node
        if (storeIndex === 0 && this.gos.get('groupHideOpenParents')) {
            const parentGroupData = this.store.getParentNode().groupData;
            if (parentGroupData) {
                for (const key of Object.keys(parentGroupData)) {
                    (0, rowGroupingUtils_1.setRowNodeGroupValue)(newNode, this.colModel, key, parentGroupData[key]);
                }
            }
        }
        this.lazyBlockLoadingSvc.queueLoadCheck();
        return newNode;
    }
    /**
     * @param index The row index relative to this store
     * @returns A rowNode at the given store index
     */
    getRowByStoreIndex(index) {
        return this.nodeMap.getBy('index', index)?.node;
    }
    /**
     * Given a number of rows, skips through the given sequence & row top reference (using default row height)
     * @param numberOfRowsToSkip number of rows to skip over in the given sequence
     * @param displayIndexSeq the sequence in which to skip
     * @param nextRowTop the row top reference in which to skip
     */
    skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop) {
        if (numberOfRowsToSkip === 0) {
            return;
        }
        const defaultRowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(this.beans);
        displayIndexSeq.value += numberOfRowsToSkip;
        nextRowTop.value += numberOfRowsToSkip * defaultRowHeight;
    }
    /**
     * @param displayIndexSeq the number sequence for generating the display index of each row
     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
     */
    setDisplayIndexes(displayIndexSeq, nextRowTop, uiLevel) {
        // Create a map of display index nodes for access speed
        this.nodeDisplayIndexMap.clear();
        // create an object indexed by store index, as this will sort all of the nodes when we iterate
        // the object
        const orderedMap = {};
        this.nodeMap.forEach((lazyNode) => {
            orderedMap[lazyNode.index] = lazyNode.node;
        });
        let lastIndex = -1;
        // iterate over the nodes in order, setting the display index on each node.
        for (const stringIndex of Object.keys(orderedMap)) {
            const node = orderedMap[stringIndex];
            const numericIndex = Number(stringIndex);
            // if any nodes aren't currently in the store, skip the display indexes too
            const numberOfRowsToSkip = numericIndex - 1 - lastIndex;
            this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);
            const isFirstChild = numericIndex === 0;
            node.setFirstChild(isFirstChild);
            // if hiding open parents, then the first node should inherit the group values
            if (isFirstChild && this.gos.get('groupHideOpenParents')) {
                const parentGroupData = this.store.getParentNode().groupData;
                if (parentGroupData) {
                    for (const key of Object.keys(parentGroupData)) {
                        (0, rowGroupingUtils_1.setRowNodeGroupValue)(node, this.colModel, key, isFirstChild ? parentGroupData[key] : undefined);
                    }
                }
            }
            // set this nodes index and row top
            this.blockUtils.setDisplayIndex(node, displayIndexSeq, nextRowTop, uiLevel);
            if (node.rowIndex != null) {
                this.nodeDisplayIndexMap.set(node.rowIndex, node);
            }
            // store this index for skipping after this
            lastIndex = numericIndex;
        }
        // need to skip rows until the end of this store
        const numberOfRowsToSkip = this.numberOfRows - 1 - lastIndex;
        this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);
        // this is not terribly efficient, and could probs be improved
        this.purgeExcessRows();
    }
    getRowCount() {
        return this.numberOfRows;
    }
    setRowCount(rowCount, isLastRowIndexKnown) {
        this.numberOfRows = rowCount;
        if (isLastRowIndexKnown != null) {
            this.isLastRowKnown = isLastRowIndexKnown;
            if (isLastRowIndexKnown === false) {
                this.numberOfRows += 1;
            }
        }
        this.fireStoreUpdatedEvent();
    }
    getNodes() {
        return this.nodeMap;
    }
    getNodeCachedByDisplayIndex(displayIndex) {
        return this.nodeDisplayIndexMap.get(displayIndex) ?? null;
    }
    getNodesToRefresh() {
        return this.nodesToRefresh;
    }
    /**
     * @returns the previous and next loaded row nodes surrounding the given display index
     */
    getSurroundingNodesByDisplayIndex(displayIndex) {
        let nextNode;
        let previousNode;
        this.nodeMap.forEach((lazyNode) => {
            // previous node
            if (displayIndex > lazyNode.node.rowIndex) {
                // get the largest previous node
                if (previousNode == null || previousNode.node.rowIndex < lazyNode.node.rowIndex) {
                    previousNode = lazyNode;
                }
                return;
            }
            // next node
            // get the smallest next node
            if (nextNode == null || nextNode.node.rowIndex > lazyNode.node.rowIndex) {
                nextNode = lazyNode;
                return;
            }
        });
        if (!previousNode && !nextNode)
            return null;
        return { previousNode, nextNode };
    }
    /**
     * Get or calculate the display index for a given store index
     * @param storeIndex the rows index within this store
     * @returns the rows visible display index relative to the grid
     */
    getDisplayIndexFromStoreIndex(storeIndex) {
        const nodeAtIndex = this.nodeMap.getBy('index', storeIndex);
        if (nodeAtIndex) {
            return nodeAtIndex.node.rowIndex;
        }
        let nextNode;
        let previousNode;
        this.nodeMap.forEach((lazyNode) => {
            // previous node
            if (storeIndex > lazyNode.index) {
                // get the largest previous node
                if (previousNode == null || previousNode.index < lazyNode.index) {
                    previousNode = lazyNode;
                }
                return;
            }
            // next node
            // get the smallest next node
            if (nextNode == null || nextNode.index > lazyNode.index) {
                nextNode = lazyNode;
                return;
            }
        });
        if (!nextNode) {
            return this.store.getDisplayIndexEnd() - (this.numberOfRows - storeIndex);
        }
        if (!previousNode) {
            return this.store.getDisplayIndexStart() + storeIndex;
        }
        const storeIndexDiff = storeIndex - previousNode.index;
        const previousDisplayIndex = previousNode.node.childStore?.getDisplayIndexEnd() ??
            previousNode.node.rowIndex;
        return previousDisplayIndex + storeIndexDiff;
    }
    /**
     * Creates a new row and inserts it at the given index
     * @param atStoreIndex the node index relative to this store
     * @param data the data object to populate the node with
     * @returns the new row node
     */
    createRowAtIndex(atStoreIndex, data, createNodeCallback) {
        // make sure an existing node isn't being overwritten
        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);
        // if node already exists, update it or destroy it
        if (lazyNode) {
            const { node } = lazyNode;
            node.__needsRefreshWhenVisible = false;
            // if the node is the same, just update the content
            if (this.doesNodeMatch(data, node)) {
                this.blockUtils.updateDataIntoRowNode(node, data);
                this.nodesToRefresh.delete(node);
                return node;
            }
            // if there's no id and this is an open group, protect this node from changes
            // hasChildren also checks for tree data and master detail
            if (this.getRowIdFunc == null && node.hasChildren() && node.expanded) {
                this.nodesToRefresh.delete(node);
                return node;
            }
            // destroy the old node, might be worth caching state here
            this.destroyRowAtIndex(atStoreIndex);
        }
        // if the node already exists elsewhere, update it and move it to the new location
        if (data && this.getRowIdFunc != null) {
            const id = this.getRowId(data);
            // the node was deleted at some point, but as we're refreshing
            // it's been cached and we can retrieve it for reuse.
            const deletedNode = id && this.removedNodeCache?.get(id);
            if (deletedNode) {
                this.removedNodeCache?.delete(id);
                this.blockUtils.updateDataIntoRowNode(deletedNode, data);
                this.nodeMap.set({
                    id: deletedNode.id,
                    node: deletedNode,
                    index: atStoreIndex,
                });
                this.nodesToRefresh.delete(deletedNode);
                deletedNode.__needsRefreshWhenVisible = false;
                return deletedNode;
            }
            const lazyNode = this.nodeMap.getBy('id', id);
            if (lazyNode) {
                // delete old lazy node so we can insert it at different location
                this.nodeMap.delete(lazyNode);
                const { node, index } = lazyNode;
                this.blockUtils.updateDataIntoRowNode(node, data);
                this.nodeMap.set({
                    id: node.id,
                    node,
                    index: atStoreIndex,
                });
                this.nodesToRefresh.delete(node);
                node.__needsRefreshWhenVisible = false;
                if (this.getBlockStartIndex(index) === this.getBlockStartIndex(atStoreIndex)) {
                    // if the block hasn't changed and we have a nodes map, we don't need to refresh the original block, as this block
                    // has just been refreshed.
                    return node;
                }
                // mark all of the old block as needsVerify to trigger it for a refresh, as nodes
                // should not be out of place
                this.markBlockForVerify(index);
                return node;
            }
        }
        // node doesn't exist, create a new one
        const newNode = this.blockUtils.createRowNode(this.store.getRowDetails());
        if (data != null) {
            const defaultId = this.getPrefixedId(this.store.getIdSequence().value++);
            this.blockUtils.setDataIntoRowNode(newNode, data, defaultId, undefined);
            // don't allow the SSRM to listen to the dispatched row event, as it will
            // compute extra unnecessary row updates
            this.serverSideRowModel.setPaused(true);
            this.blockUtils.checkOpenByDefault(newNode);
            this.serverSideRowModel.setPaused(false);
            this.nodeManager.addRowNode(newNode);
        }
        // add the new node to the store, has to be done after the display index is calculated so it doesn't take itself into account
        this.nodeMap.set({
            id: newNode.id,
            node: newNode,
            index: atStoreIndex,
        });
        if (createNodeCallback) {
            createNodeCallback(newNode);
        }
        return newNode;
    }
    getBlockStates() {
        const blockCounts = {};
        const blockStates = {};
        this.nodeMap.forEach(({ node, index }) => {
            const blockStart = this.getBlockStartIndex(index);
            if (!node.stub && !node.failedLoad) {
                blockCounts[blockStart] = (blockCounts[blockStart] ?? 0) + 1;
            }
            let rowState = 'loaded';
            if (node.failedLoad) {
                rowState = 'failed';
            }
            else if (this.lazyBlockLoadingSvc.isRowLoading(this, blockStart)) {
                rowState = 'loading';
            }
            else if (this.nodesToRefresh.has(node) || node.stub) {
                rowState = 'needsLoading';
            }
            if (!blockStates[blockStart]) {
                blockStates[blockStart] = new Set();
            }
            blockStates[blockStart].add(rowState);
        });
        const statePriorityMap = {
            loading: 4,
            failed: 3,
            needsLoading: 2,
            loaded: 1,
        };
        const blockPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());
        const results = {};
        Object.entries(blockStates).forEach(([blockStart, uniqueStates]) => {
            const sortedStates = [...uniqueStates].sort((a, b) => (statePriorityMap[a] ?? 0) - (statePriorityMap[b] ?? 0));
            const priorityState = sortedStates[0];
            const blockNumber = Number(blockStart) / this.getBlockSize();
            const blockId = blockPrefix ? `${blockPrefix}-${blockNumber}` : String(blockNumber);
            results[blockId] = {
                blockNumber,
                startRow: Number(blockStart),
                endRow: Number(blockStart) + this.getBlockSize(),
                pageStatus: priorityState,
                loadedRowCount: blockCounts[blockStart] ?? 0,
            };
        });
        return results;
    }
    destroyRowAtIndex(atStoreIndex) {
        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);
        if (!lazyNode) {
            return;
        }
        this.nodeMap.delete(lazyNode);
        this.nodeDisplayIndexMap.delete(lazyNode.node.rowIndex);
        if (this.nodesToRefresh.size > 0) {
            // while refreshing, we retain the group nodes so they can be moved
            // without losing state
            this.removedNodeCache.set(lazyNode.node.id, lazyNode.node);
        }
        else {
            this.blockUtils.destroyRowNode(lazyNode.node);
        }
        this.nodesToRefresh.delete(lazyNode.node);
    }
    getSsrmParams() {
        return this.store.getSsrmParams();
    }
    /**
     * @param id the base id to be prefixed
     * @returns a node id with prefix if required
     */
    getPrefixedId(id) {
        if (this.defaultNodeIdPrefix) {
            return this.defaultNodeIdPrefix + '-' + id;
        }
        else {
            return id.toString();
        }
    }
    markBlockForVerify(rowIndex) {
        const [start, end] = this.getBlockBounds(rowIndex);
        const lazyNodesInRange = this.nodeMap.filter((lazyNode) => lazyNode.index >= start && lazyNode.index < end);
        lazyNodesInRange.forEach(({ node }) => {
            node.__needsRefreshWhenVisible = true;
        });
    }
    doesNodeMatch(data, node) {
        if (node.stub) {
            return false;
        }
        const id = this.getRowId(data);
        return id === null ? node.data === data : node.id === id;
    }
    /**
     * Deletes any stub nodes not within the given range
     */
    purgeStubsOutsideOfViewport() {
        const { firstRenderedRow, lastRenderedRow } = this.rowRenderer;
        const firstRowBlockStart = this.getBlockStartIndex(firstRenderedRow);
        const [, lastRowBlockEnd] = this.getBlockBounds(lastRenderedRow);
        this.nodeMap.forEach((lazyNode) => {
            // failed loads are still useful, so we don't purge them
            if (this.lazyBlockLoadingSvc.isRowLoading(this, lazyNode.index) || lazyNode.node.failedLoad) {
                return;
            }
            if (lazyNode.node.stub && (lazyNode.index < firstRowBlockStart || lazyNode.index > lastRowBlockEnd)) {
                this.destroyRowAtIndex(lazyNode.index);
            }
        });
    }
    getBlocksDistanceFromRow(nodes, otherDisplayIndex) {
        const blockDistanceToMiddle = {};
        nodes.forEach(({ node, index }) => {
            const [blockStart, blockEnd] = this.getBlockBounds(index);
            if (blockStart in blockDistanceToMiddle) {
                return;
            }
            const distStart = Math.abs(node.rowIndex - otherDisplayIndex);
            let distEnd;
            // may not have an end node if the block came back small
            const lastLazyNode = this.nodeMap.getBy('index', [blockEnd - 1]);
            if (lastLazyNode)
                distEnd = Math.abs(lastLazyNode.node.rowIndex - otherDisplayIndex);
            const farthest = distEnd == null || distStart < distEnd ? distStart : distEnd;
            blockDistanceToMiddle[blockStart] = farthest;
        });
        return Object.entries(blockDistanceToMiddle);
    }
    purgeExcessRows() {
        // Delete all stub nodes which aren't in the viewport or already loading
        this.purgeStubsOutsideOfViewport();
        if (this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null) {
            // if group is collapsed, or max blocks missing, ignore the event
            return;
        }
        const { firstRenderedRow, lastRenderedRow } = this.rowRenderer;
        // the start storeIndex of every block in this store
        const allLoadedBlocks = new Set();
        // the start storeIndex of every displayed block in this store
        const blocksInViewport = new Set();
        this.nodeMap.forEach(({ index, node }) => {
            const blockStart = this.getBlockStartIndex(index);
            allLoadedBlocks.add(blockStart);
            const isInViewport = node.rowIndex >= firstRenderedRow && node.rowIndex <= lastRenderedRow;
            if (isInViewport) {
                blocksInViewport.add(blockStart);
            }
        });
        // if the viewport is larger than the max blocks, then the viewport size is minimum cache size
        const numberOfBlocksToRetain = Math.max(blocksInViewport.size, this.storeParams.maxBlocksInCache ?? 0);
        // ensure there is blocks that can be removed
        const loadedBlockCount = allLoadedBlocks.size;
        const blocksToRemove = loadedBlockCount - numberOfBlocksToRetain;
        if (blocksToRemove <= 0) {
            return;
        }
        // the first and last block in the viewport
        let firstRowBlockStart = Number.MAX_SAFE_INTEGER;
        let lastRowBlockStart = Number.MIN_SAFE_INTEGER;
        blocksInViewport.forEach((blockStart) => {
            if (firstRowBlockStart > blockStart) {
                firstRowBlockStart = blockStart;
            }
            if (lastRowBlockStart < blockStart) {
                lastRowBlockStart = blockStart;
            }
        });
        // all nodes which aren't cached or in the viewport, and so can be removed
        const disposableNodes = this.nodeMap.filter(({ node, index }) => {
            const rowBlockStart = this.getBlockStartIndex(index);
            const rowBlockInViewport = rowBlockStart >= firstRowBlockStart && rowBlockStart <= lastRowBlockStart;
            return !rowBlockInViewport && !this.isNodeCached(node);
        });
        if (disposableNodes.length === 0) {
            return;
        }
        const midViewportRow = firstRenderedRow + (lastRenderedRow - firstRenderedRow) / 2;
        const blockDistanceArray = this.getBlocksDistanceFromRow(disposableNodes, midViewportRow);
        const blockSize = this.getBlockSize();
        // sort the blocks by distance from middle of viewport
        blockDistanceArray.sort((a, b) => Math.sign(b[1] - a[1]));
        // remove excess blocks, starting from furthest from viewport
        for (let i = 0; i < Math.min(blocksToRemove, blockDistanceArray.length); i++) {
            const blockStart = Number(blockDistanceArray[i][0]);
            for (let x = blockStart; x < blockStart + blockSize; x++) {
                const lazyNode = this.nodeMap.getBy('index', x);
                if (!lazyNode || this.isNodeCached(lazyNode.node)) {
                    continue;
                }
                this.destroyRowAtIndex(x);
            }
        }
    }
    isNodeFocused(node) {
        const focusedCell = this.focusSvc.getFocusCellToUseAfterRefresh();
        if (!focusedCell) {
            return false;
        }
        if (focusedCell.rowPinned != null) {
            return false;
        }
        const hasFocus = focusedCell.rowIndex === node.rowIndex;
        return hasFocus;
    }
    isNodeCached(node) {
        const isUnbalancedNode = this.gos.get('groupAllowUnbalanced') && node.key === '';
        return (node.isExpandable() && node.expanded) || this.isNodeFocused(node) || isUnbalancedNode;
    }
    extractDuplicateIds(rows) {
        if (this.getRowIdFunc == null) {
            return [];
        }
        const newIds = new Set();
        const duplicates = new Set();
        rows.forEach((data) => {
            const id = this.getRowId(data);
            if (newIds.has(id)) {
                duplicates.add(id);
                return;
            }
            newIds.add(id);
        });
        return [...duplicates];
    }
    onLoadSuccess(firstRowIndex, numberOfRowsExpected, response) {
        if (!this.live)
            return;
        const info = response.groupLevelInfo;
        this.store.setStoreInfo(info);
        if (this.getRowIdFunc != null) {
            const duplicates = this.extractDuplicateIds(response.rowData);
            if (duplicates.length > 0) {
                const duplicateIdText = duplicates.join(', ');
                (0, ag_grid_community_1._warn)(205, { duplicateIdText });
                this.onLoadFailed(firstRowIndex, numberOfRowsExpected);
                return;
            }
        }
        if (response.pivotResultFields) {
            this.serverSideRowModel.generateSecondaryColumns(response.pivotResultFields);
        }
        const wasRefreshing = this.nodesToRefresh.size > 0;
        response.rowData.forEach((data, responseRowIndex) => {
            const rowIndex = firstRowIndex + responseRowIndex;
            const nodeFromCache = this.nodeMap.getBy('index', rowIndex);
            // if stub, overwrite
            if (nodeFromCache?.node?.stub) {
                this.createRowAtIndex(rowIndex, data);
                return;
            }
            // node already exists, and same as node at designated position, update data
            if (nodeFromCache && this.doesNodeMatch(data, nodeFromCache.node)) {
                this.blockUtils.updateDataIntoRowNode(nodeFromCache.node, data);
                this.nodesToRefresh.delete(nodeFromCache.node);
                nodeFromCache.node.__needsRefreshWhenVisible = false;
                return;
            }
            // create row will handle deleting the overwritten row
            this.createRowAtIndex(rowIndex, data);
        });
        if (response.rowCount != undefined && response.rowCount !== -1) {
            // if the rowCount has been provided, set the row count
            this.numberOfRows = response.rowCount;
            this.isLastRowKnown = true;
        }
        else if (numberOfRowsExpected > response.rowData.length) {
            // infer the last row as the response came back short
            this.numberOfRows = firstRowIndex + response.rowData.length;
            this.isLastRowKnown = true;
        }
        else if (!this.isLastRowKnown) {
            // add 1 for loading row, as we don't know the last row
            const lastInferredRow = firstRowIndex + response.rowData.length + 1;
            if (lastInferredRow > this.numberOfRows) {
                this.numberOfRows = lastInferredRow;
            }
        }
        if (this.isLastRowKnown) {
            // delete any rows after the last index
            const lazyNodesAfterStoreEnd = this.nodeMap.filter((lazyNode) => lazyNode.index >= this.numberOfRows);
            lazyNodesAfterStoreEnd.forEach((lazyNode) => this.destroyRowAtIndex(lazyNode.index));
        }
        this.fireStoreUpdatedEvent();
        // Happens after store updated, as store updating can clear our excess rows.
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        if (wasRefreshing && finishedRefreshing) {
            this.fireRefreshFinishedEvent();
        }
    }
    fireRefreshFinishedEvent() {
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        // if anything refreshing currently, skip.
        if (!finishedRefreshing) {
            return;
        }
        // any nodes left in the map need to be cleaned up, this prevents us preserving nodes
        // indefinitely
        this.removedNodeCache.forEach((node) => {
            this.blockUtils.destroyRowNode(node);
        });
        this.removedNodeCache = new Map();
        this.store.fireRefreshFinishedEvent();
    }
    /**
     * @returns true if all rows are loaded
     */
    isStoreFullyLoaded() {
        const knowsSize = this.isLastRowKnown;
        const hasCorrectRowCount = this.nodeMap.getSize() === this.numberOfRows;
        if (!knowsSize || !hasCorrectRowCount) {
            return;
        }
        if (this.nodesToRefresh.size > 0) {
            return;
        }
        // nodeMap find cancels early when it finds a matching record.
        // better to use this than forEach
        let index = -1;
        const firstOutOfPlaceNode = this.nodeMap.find((lazyNode) => {
            index += 1;
            // node not contiguous, nodes must be missing
            if (lazyNode.index !== index) {
                return true;
            }
            // node data is out of date
            if (lazyNode.node.__needsRefreshWhenVisible) {
                return true;
            }
            // node not yet loaded
            if (lazyNode.node.stub) {
                return true;
            }
            return false;
        });
        return firstOutOfPlaceNode == null;
    }
    isLastRowIndexKnown() {
        return this.isLastRowKnown;
    }
    onLoadFailed(firstRowIndex, numberOfRowsExpected) {
        if (!this.live)
            return;
        const wasRefreshing = this.nodesToRefresh.size > 0;
        for (let i = firstRowIndex; i < firstRowIndex + numberOfRowsExpected && i < this.getRowCount(); i++) {
            let { node } = this.nodeMap.getBy('index', i) ?? {};
            if (node) {
                this.nodesToRefresh.delete(node);
            }
            if (!node || !node.stub) {
                if (node && !node.stub) {
                    // if node is not a stub, we destroy it and recreate as nodes can't go from data to stub
                    this.destroyRowAtIndex(i);
                }
                node = this.createRowAtIndex(i);
            }
            // this node has been refreshed, even if it wasn't successful
            node.__needsRefreshWhenVisible = false;
            node.failedLoad = true;
        }
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        if (wasRefreshing && finishedRefreshing) {
            this.fireRefreshFinishedEvent();
        }
        this.fireStoreUpdatedEvent();
    }
    markNodesForRefresh() {
        this.nodeMap.forEach((lazyNode) => {
            if (lazyNode.node.stub && !lazyNode.node.failedLoad) {
                return;
            }
            this.nodesToRefresh.add(lazyNode.node);
        });
        this.lazyBlockLoadingSvc.queueLoadCheck();
        if (this.isLastRowKnown && this.numberOfRows === 0) {
            this.numberOfRows = 1;
            this.isLastRowKnown = false;
            this.fireStoreUpdatedEvent();
        }
    }
    isNodeInCache(id) {
        return !!this.nodeMap.getBy('id', id);
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    fireStoreUpdatedEvent() {
        if (!this.live) {
            return;
        }
        this.store.fireStoreUpdatedEvent();
    }
    getRowId(data) {
        if (this.getRowIdFunc == null) {
            return null;
        }
        // find rowNode using id
        const { level } = this.store.getRowDetails();
        const parentKeys = this.store.getParentNode().getRoute() ?? [];
        return this.getRowIdFunc({
            data,
            parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
            level,
        });
    }
    getOrderedNodeMap() {
        const obj = {};
        this.nodeMap.forEach((node) => (obj[node.index] = node));
        return obj;
    }
    clearDisplayIndexes() {
        this.nodeDisplayIndexMap.clear();
    }
    /**
     * Client side sorting
     */
    clientSideSortRows() {
        const sortOptions = this.sortSvc?.getSortOptions() ?? [];
        const isAnySort = sortOptions.some((opt) => opt.sort != null);
        if (!isAnySort || !this.rowNodeSorter) {
            return;
        }
        // the node map does not need entirely recreated, only the indexes need updated.
        const allNodes = new Array(this.nodeMap.getSize());
        this.nodeMap.forEach((lazyNode) => (allNodes[lazyNode.index] = lazyNode.node));
        this.nodeMap.clear();
        const sortedNodes = this.rowNodeSorter.doFullSort(allNodes, sortOptions);
        sortedNodes.forEach((node, index) => {
            this.nodeMap.set({
                id: node.id,
                node,
                index,
            });
        });
    }
    /**
     * Transaction Support here
     */
    updateRowNodes(updates) {
        const updatedNodes = [];
        updates.forEach((data) => {
            const id = this.getRowId(data);
            const lazyNode = this.nodeMap.getBy('id', id);
            if (lazyNode) {
                this.blockUtils.updateDataIntoRowNode(lazyNode.node, data);
                updatedNodes.push(lazyNode.node);
            }
        });
        return updatedNodes;
    }
    insertRowNodes(inserts, indexToAdd) {
        // adjust row count to allow for footer row
        const realRowCount = this.store.getRowCount() - (this.store.getParentNode().sibling ? 1 : 0);
        // if missing and we know the last row, we're inserting at the end
        const addIndex = indexToAdd == null && this.isLastRowKnown ? realRowCount : indexToAdd;
        // can't insert nodes past the end of the store
        if (addIndex == null || realRowCount < addIndex) {
            return [];
        }
        const uniqueInsertsMap = {};
        inserts.forEach((data) => {
            const dataId = this.getRowId(data);
            if (dataId && this.isNodeInCache(dataId)) {
                return;
            }
            uniqueInsertsMap[dataId] = data;
        });
        const uniqueInserts = Object.values(uniqueInsertsMap);
        const numberOfInserts = uniqueInserts.length;
        if (numberOfInserts === 0) {
            return [];
        }
        const nodesToMove = this.nodeMap.filter((node) => node.index >= addIndex);
        // delete all nodes which need moved first, so they don't get overwritten
        nodesToMove.forEach((lazyNode) => this.nodeMap.delete(lazyNode));
        // then move the nodes to their new locations
        nodesToMove.forEach((lazyNode) => {
            this.nodeMap.set({
                node: lazyNode.node,
                index: lazyNode.index + numberOfInserts,
                id: lazyNode.id,
            });
        });
        // increase the store size to accommodate
        this.numberOfRows += numberOfInserts;
        // finally insert the new rows
        return uniqueInserts.map((data, uniqueInsertOffset) => this.createRowAtIndex(addIndex + uniqueInsertOffset, data));
    }
    removeRowNodes(idsToRemove) {
        const removedNodes = [];
        const nodesToVerify = [];
        // track how many nodes have been deleted, as when we pass other nodes we need to shift them up
        let deletedNodeCount = 0;
        const remainingIdsToRemove = [...idsToRemove];
        const allNodes = this.getOrderedNodeMap();
        let contiguousIndex = -1;
        for (const stringIndex of Object.keys(allNodes)) {
            contiguousIndex += 1;
            const node = allNodes[stringIndex];
            // finding the index allows the use of splice which should be slightly faster than both a check and filter
            const matchIndex = remainingIdsToRemove.findIndex((idToRemove) => idToRemove === node.id);
            if (matchIndex !== -1) {
                // found node, remove it from nodes to remove
                remainingIdsToRemove.splice(matchIndex, 1);
                this.destroyRowAtIndex(Number(stringIndex));
                removedNodes.push(node.node);
                deletedNodeCount += 1;
                continue;
            }
            // no nodes removed and this node doesn't match, so no need to shift
            if (deletedNodeCount === 0) {
                continue;
            }
            const numericStoreIndex = Number(stringIndex);
            if (contiguousIndex !== numericStoreIndex) {
                nodesToVerify.push(node.node);
            }
            // shift normal node up by number of deleted prior to this point
            this.nodeMap.delete(node);
            this.nodeMap.set({
                id: node.id,
                node: node.node,
                index: numericStoreIndex - deletedNodeCount,
            });
        }
        this.numberOfRows -= this.isLastRowIndexKnown() ? idsToRemove.length : deletedNodeCount;
        if (remainingIdsToRemove.length > 0 && nodesToVerify.length > 0) {
            nodesToVerify.forEach((node) => (node.__needsRefreshWhenVisible = true));
            this.lazyBlockLoadingSvc.queueLoadCheck();
        }
        return removedNodes;
    }
    /**
     * Return the block size configured for this cache
     */
    getBlockSize() {
        return this.storeParams.cacheBlockSize || DEFAULT_BLOCK_SIZE;
    }
    /**
     * Get the start index of the loading block for a given index
     */
    getBlockStartIndex(storeIndex) {
        const blockSize = this.getBlockSize();
        return storeIndex - (storeIndex % blockSize);
    }
    /**
     * Get the start and end index of a block, given a row store index
     */
    getBlockBounds(storeIndex) {
        const startOfBlock = this.getBlockStartIndex(storeIndex);
        const blockSize = this.getBlockSize();
        return [startOfBlock, startOfBlock + blockSize];
    }
}
exports.LazyCache = LazyCache;


/***/ }),

/***/ 5330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyStore = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const footerUtils_1 = __webpack_require__(6432);
const lazyCache_1 = __webpack_require__(4905);
class LazyStore extends ag_grid_community_1.BeanStub {
    wireBeans(beans) {
        this.blockUtils = beans.ssrmBlockUtils;
        this.storeUtils = beans.ssrmStoreUtils;
        this.selectionSvc = beans.selectionSvc;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
    }
    constructor(ssrmParams, storeParams, parentRowNode) {
        super();
        this.idSequence = { value: 0 };
        this.ssrmParams = ssrmParams;
        this.parentRowNode = parentRowNode;
        this.storeParams = storeParams;
        this.level = parentRowNode.level + 1;
        this.group = ssrmParams.rowGroupCols ? this.level < ssrmParams.rowGroupCols.length : false;
        this.leafGroup = ssrmParams.rowGroupCols ? this.level === ssrmParams.rowGroupCols.length - 1 : false;
        this.info = {};
    }
    postConstruct() {
        let numberOfRows = 1;
        if (this.level === 0) {
            numberOfRows = this.storeUtils.getServerSideInitialRowCount() ?? 1;
            this.eventSvc.dispatchEventOnce({
                type: 'rowCountReady',
            });
        }
        this.cache = this.createManagedBean(new lazyCache_1.LazyCache(this, numberOfRows, false, this.storeParams));
        const usingTreeData = this.gos.get('treeData');
        if (!usingTreeData && this.group && this.rowGroupColsSvc) {
            const groupColVo = this.ssrmParams.rowGroupCols[this.level];
            this.groupField = groupColVo.field;
            this.rowGroupColumn = this.rowGroupColsSvc.columns[this.level];
        }
    }
    destroy() {
        this.displayIndexStart = undefined;
        this.displayIndexEnd = undefined;
        this.destroyBean(this.cache);
        super.destroy();
    }
    /**
     * Given a server response, ingest the rows outside of the data source lifecycle.
     *
     * @param rowDataParams the server response containing the rows to ingest
     * @param startRow the index to start ingesting rows
     * @param expectedRows the expected number of rows in the response (used to determine if the last row index is known)
     */
    applyRowData(rowDataParams, startRow, expectedRows) {
        this.cache.onLoadSuccess(startRow, expectedRows, rowDataParams);
    }
    /**
     * Applies a given transaction to the data set within this store
     *
     * @param transaction an object containing delta instructions determining the changes to apply to this store
     * @returns an object determining the status of this transaction and effected nodes
     */
    applyTransaction(transaction) {
        const idFunc = (0, ag_grid_community_1._getRowIdCallback)(this.gos);
        if (!idFunc) {
            (0, ag_grid_community_1._warn)(206);
            return {
                status: ag_grid_community_1.ServerSideTransactionResultStatus.Cancelled,
            };
        }
        const applyCallback = this.gos.getCallback('isApplyServerSideTransaction');
        if (applyCallback) {
            const params = {
                transaction: transaction,
                parentNode: this.parentRowNode,
                groupLevelInfo: this.info,
            };
            const apply = applyCallback(params);
            if (!apply) {
                return { status: ag_grid_community_1.ServerSideTransactionResultStatus.Cancelled };
            }
        }
        // needs checked before transactions are applied, as rows won't be contiguous immediately
        // after
        const allRowsLoaded = this.cache.isStoreFullyLoaded();
        let updatedNodes = undefined;
        if (transaction.update?.length) {
            updatedNodes = this.cache.updateRowNodes(transaction.update);
        }
        let insertedNodes = undefined;
        if (transaction.add?.length) {
            let addIndex = transaction.addIndex;
            if (addIndex != null && addIndex < 0) {
                addIndex = undefined;
            }
            insertedNodes = this.cache.insertRowNodes(transaction.add, addIndex);
        }
        let removedNodes = undefined;
        if (transaction.remove?.length) {
            const allIdsToRemove = transaction.remove.map((data) => idFunc({ level: this.level, parentKeys: this.parentRowNode.getRoute() ?? [], data }));
            const allUniqueIdsToRemove = [...new Set(allIdsToRemove)];
            removedNodes = this.cache.removeRowNodes(allUniqueIdsToRemove);
        }
        const isClientSideSortingEnabled = this.gos.get('serverSideEnableClientSideSort');
        const isUpdateOrAdd = updatedNodes?.length || insertedNodes?.length;
        const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;
        if (isClientSideSort && isUpdateOrAdd) {
            // if client side sorting, we need to sort the rows after the transaction
            this.cache.clientSideSortRows();
        }
        this.updateSelectionAfterTransaction(updatedNodes, removedNodes);
        return {
            status: ag_grid_community_1.ServerSideTransactionResultStatus.Applied,
            update: updatedNodes,
            add: insertedNodes,
            remove: removedNodes,
        };
    }
    updateSelectionAfterTransaction(updatedNodes, removedNodes) {
        if (!this.selectionSvc) {
            return;
        }
        const nodesToDeselect = [];
        updatedNodes?.forEach((node) => {
            if (node.isSelected() && !node.selectable) {
                nodesToDeselect.push(node);
            }
        });
        removedNodes?.forEach((node) => {
            if (node.isSelected()) {
                nodesToDeselect.push(node);
            }
        });
        if (nodesToDeselect.length) {
            this.selectionSvc.setNodesSelected({
                newValue: false,
                clearSelection: false,
                nodes: nodesToDeselect,
                source: 'rowDataChanged',
            });
        }
    }
    /**
     * Clear the display indexes, used for fading rows out when stores are not being destroyed
     */
    clearDisplayIndexes() {
        this.displayIndexStart = undefined;
        this.displayIndexEnd = undefined;
        this.cache.getNodes().forEach((lazyNode) => this.blockUtils.clearDisplayIndex(lazyNode.node));
        if (this.parentRowNode.sibling) {
            this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling);
        }
        this.cache.clearDisplayIndexes();
    }
    /**
     * @returns an index representing the last sequentially displayed row in the grid for this store
     */
    getDisplayIndexStart() {
        return this.displayIndexStart;
    }
    /**
     * @returns the index representing one after the last sequentially displayed row in the grid for this store
     */
    getDisplayIndexEnd() {
        return this.displayIndexEnd;
    }
    /**
     * @returns the virtual size of this store
     */
    getRowCount() {
        if (this.parentRowNode.sibling) {
            return this.cache.getRowCount() + 1;
        }
        return this.cache.getRowCount();
    }
    /**
     * Sets the current row count of the store, and whether the last row index is known
     */
    setRowCount(rowCount, isLastRowIndexKnown) {
        this.cache.setRowCount(rowCount, isLastRowIndexKnown);
    }
    /**
     * Given a display index, returns whether that row is within this store or a child store of this store
     *
     * @param displayIndex the visible index of a row
     * @returns whether or not the row exists within this store
     */
    isDisplayIndexInStore(displayIndex) {
        if (this.cache.getRowCount() === 0)
            return false;
        return this.displayIndexStart <= displayIndex && displayIndex < this.getDisplayIndexEnd();
    }
    /**
     * Recursively sets up the display indexes and top position of every node belonging to this store.
     *
     * Called after a row height changes, or a store updated event.
     *
     * @param displayIndexSeq the number sequence for generating the display index of each row
     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
     */
    setDisplayIndexes(displayIndexSeq, nextRowTop, uiLevel) {
        this.displayIndexStart = displayIndexSeq.value;
        this.topPx = nextRowTop.value;
        const footerNode = this.parentRowNode.level > -1 && (0, ag_grid_community_1._getGroupTotalRowCallback)(this.gos)({ node: this.parentRowNode });
        if (!footerNode) {
            (0, footerUtils_1._destroyRowNodeFooter)(this.parentRowNode);
        }
        if (footerNode === 'top') {
            (0, footerUtils_1._createRowNodeFooter)(this.parentRowNode, this.beans);
            this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, displayIndexSeq, nextRowTop, uiLevel);
        }
        // delegate to the store to set the row display indexes
        this.cache.setDisplayIndexes(displayIndexSeq, nextRowTop, uiLevel);
        if (footerNode === 'bottom') {
            (0, footerUtils_1._createRowNodeFooter)(this.parentRowNode, this.beans);
            this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, displayIndexSeq, nextRowTop, uiLevel);
        }
        this.displayIndexEnd = displayIndexSeq.value;
        this.heightPx = nextRowTop.value - this.topPx;
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
     */
    forEachStoreDeep(callback, sequence = { value: 0 }) {
        callback(this, sequence.value++);
        this.cache.getNodes().forEach((lazyNode) => {
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachStoreDeep(callback, sequence);
            }
        });
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
     */
    forEachNodeDeep(callback, sequence = { value: 0 }) {
        this.cache.getNodes().forEach((lazyNode) => {
            callback(lazyNode.node, sequence.value++);
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachNodeDeep(callback, sequence);
            }
        });
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep
     */
    forEachNodeDeepAfterFilterAndSort(callback, sequence = { value: 0 }, includeFooterNodes = false) {
        const footerNode = this.parentRowNode.level > -1 && (0, ag_grid_community_1._getGroupTotalRowCallback)(this.gos)({ node: this.parentRowNode });
        if (footerNode === 'top') {
            callback(this.parentRowNode.sibling, sequence.value++);
        }
        const orderedNodes = this.cache.getOrderedNodeMap();
        for (const lazyNode of Object.values(orderedNodes)) {
            callback(lazyNode.node, sequence.value++);
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachNodeDeepAfterFilterAndSort(callback, sequence, includeFooterNodes);
            }
        }
        if (footerNode === 'bottom') {
            callback(this.parentRowNode.sibling, sequence.value++);
        }
    }
    /**
     * Removes the failed status from all nodes, and marks them as stub to encourage reloading
     */
    retryLoads() {
        this.cache.getNodes().forEach(({ node }) => {
            if (node.failedLoad) {
                node.failedLoad = false;
                node.__needsRefreshWhenVisible = true;
                node.stub = true;
            }
        });
        this.forEachChildStoreShallow((store) => store.retryLoads());
        this.fireStoreUpdatedEvent();
    }
    /**
     * Given a display index, returns the row at that location.
     *
     * @param displayRowIndex the displayed index within the grid to search for
     * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return
     */
    getRowUsingDisplayIndex(displayRowIndex) {
        if (this.parentRowNode.sibling && displayRowIndex === this.parentRowNode.sibling.rowIndex) {
            return this.parentRowNode.sibling;
        }
        return this.cache.getRowByDisplayIndex(displayRowIndex);
    }
    /**
     * Given a display index, returns the row top and height for the row at that index.
     *
     * @param displayIndex the display index of the node
     * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex
     */
    getRowBounds(displayIndex) {
        if (!this.isDisplayIndexInStore(displayIndex)) {
            return null;
        }
        const thisNode = this.cache.getNodeCachedByDisplayIndex(displayIndex);
        if (thisNode) {
            const boundsFromRow = this.blockUtils.extractRowBounds(thisNode, displayIndex);
            if (boundsFromRow) {
                return boundsFromRow;
            }
        }
        const { previousNode, nextNode } = this.cache.getSurroundingNodesByDisplayIndex(displayIndex) ?? {};
        // previous node may equal, or catch via detail node or child of group
        if (previousNode) {
            const boundsFromRow = this.blockUtils.extractRowBounds(previousNode.node, displayIndex);
            if (boundsFromRow != null) {
                return boundsFromRow;
            }
        }
        const defaultRowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(this.beans);
        // if node after this, can calculate backwards (and ignore detail/grouping)
        if (nextNode) {
            const numberOfRowDiff = (nextNode.node.rowIndex - displayIndex) * defaultRowHeight;
            return {
                rowTop: nextNode.node.rowTop - numberOfRowDiff,
                rowHeight: defaultRowHeight,
            };
        }
        // otherwise calculate from end of store
        const lastTop = this.topPx + this.heightPx;
        const numberOfRowDiff = (this.getDisplayIndexEnd() - displayIndex) * defaultRowHeight;
        return {
            rowTop: lastTop - numberOfRowDiff,
            rowHeight: defaultRowHeight,
        };
    }
    /**
     * Given a vertical pixel, determines whether this store contains a row at that pixel
     *
     * @param pixel a vertical pixel position from the grid
     * @returns whether that pixel points to a virtual space belonging to this store
     */
    isPixelInRange(pixel) {
        return pixel >= this.topPx && pixel < this.topPx + this.heightPx;
    }
    /**
     * Given a vertical pixel, returns the row existing at that pixel location
     *
     * @param pixel a vertical pixel position from the grid
     * @returns the display index at the given pixel location
     */
    getRowIndexAtPixel(pixel) {
        if (pixel < this.topPx) {
            return this.getDisplayIndexStart();
        }
        if (pixel >= this.topPx + this.heightPx) {
            return this.getDisplayIndexEnd() - 1;
        }
        if (this.parentRowNode.sibling &&
            pixel > this.parentRowNode.sibling.rowTop &&
            pixel < this.parentRowNode.sibling.rowTop + this.parentRowNode.sibling.rowHeight) {
            return this.parentRowNode.sibling.rowIndex;
        }
        let distToPreviousNodeTop = Number.MAX_SAFE_INTEGER;
        let previousNode = null;
        let distToNextNodeTop = Number.MAX_SAFE_INTEGER;
        let nextNode = null;
        this.cache.getNodes().forEach(({ node }) => {
            const distBetween = Math.abs(pixel - node.rowTop);
            // previous node
            if (node.rowTop < pixel) {
                if (distBetween < distToPreviousNodeTop) {
                    distToPreviousNodeTop = distBetween;
                    previousNode = node;
                }
                return;
            }
            // next node
            if (distBetween < distToNextNodeTop) {
                distToNextNodeTop = distBetween;
                nextNode = node;
            }
        });
        // cast these back as typescript doesn't understand the forEach above
        previousNode = previousNode;
        nextNode = nextNode;
        // previous node may equal, or catch via detail node or child of group
        if (previousNode) {
            const indexOfRow = this.blockUtils.getIndexAtPixel(previousNode, pixel);
            if (indexOfRow != null) {
                return indexOfRow;
            }
        }
        const defaultRowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(this.beans);
        // if node after this, can calculate backwards (and ignore detail/grouping)
        if (nextNode) {
            const nextTop = nextNode.rowTop;
            const numberOfRowDiff = Math.ceil((nextTop - pixel) / defaultRowHeight);
            return nextNode.rowIndex - numberOfRowDiff;
        }
        // otherwise calculate from end of store
        const nextTop = this.topPx + this.heightPx;
        const numberOfRowDiff = Math.floor((nextTop - pixel) / defaultRowHeight);
        return this.getDisplayIndexEnd() - numberOfRowDiff;
    }
    /**
     * Given a path of group keys, returns the child store for that group.
     *
     * @param keys the grouping path to the desired store
     * @returns the child store for the given keys, or null if not found
     */
    getChildStore(keys) {
        return this.storeUtils.getChildStore(keys, this, (key) => {
            const lazyNode = this.cache.getNodes().find((lazyNode) => lazyNode.node.key == key);
            if (!lazyNode) {
                return null;
            }
            return lazyNode.node;
        });
    }
    /**
     * Executes a provided callback on each child store belonging to this store
     *
     * @param cb the callback to execute
     */
    forEachChildStoreShallow(cb) {
        this.cache.getNodes().forEach(({ node }) => {
            if (node.childStore) {
                cb(node.childStore);
            }
        });
    }
    /**
     * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.
     *
     * If a purge refresh occurs, the row count is preserved.
     *
     * @param params a set of properties pertaining to the sort changes
     */
    refreshAfterSort(params) {
        const serverSortsAllLevels = this.storeUtils.isServerSideSortAllLevels();
        if (serverSortsAllLevels ||
            this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {
            const allRowsLoaded = this.cache.isStoreFullyLoaded();
            const isClientSideSortingEnabled = this.gos.get('serverSideEnableClientSideSort');
            const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;
            if (!isClientSideSort) {
                // if last row index was known, add a row back for lazy loading.
                const oldCount = this.cache.getRowCount();
                const lastKnown = this.cache.isLastRowIndexKnown();
                this.destroyBean(this.cache);
                this.cache = this.createManagedBean(new lazyCache_1.LazyCache(this, oldCount, lastKnown, this.storeParams));
                return;
            }
            // client side sorting only handles one level, so allow it to pass through
            // to recursive sort.
            this.cache.clientSideSortRows();
        }
        // call refreshAfterSort on children, as we did not purge.
        // if we did purge, no need to do this as all children were destroyed
        this.forEachChildStoreShallow((store) => store.refreshAfterSort(params));
    }
    /**
     * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.
     *
     * If a refresh occurs, the row count is reset.
     *
     * @param params a set of properties pertaining to the filter changes
     */
    refreshAfterFilter(params) {
        const serverFiltersAllLevels = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups();
        if (serverFiltersAllLevels ||
            this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {
            this.refreshStore(true);
            return;
        }
        // call refreshAfterFilter on children, as we did not purge.
        // if we did purge, no need to do this as all children were destroyed
        this.forEachChildStoreShallow((store) => store.refreshAfterFilter(params));
    }
    /**
     * Marks all existing nodes as requiring reloaded, and triggers a load check
     *
     * @param purge whether to remove all nodes and data in favour of stub nodes
     */
    refreshStore(purge) {
        if (purge) {
            this.destroyBean(this.cache);
            this.cache = this.createManagedBean(new lazyCache_1.LazyCache(this, 1, false, this.storeParams));
            this.fireStoreUpdatedEvent();
            return;
        }
        this.cache.markNodesForRefresh();
    }
    /**
     * Used for pagination, given a local/store index, returns the display index of that row
     *
     * @param topLevelIndex the store index of a row
     * @returns the display index for the given store index
     */
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const displayIndex = this.cache.getDisplayIndexFromStoreIndex(topLevelIndex);
        return displayIndex ?? topLevelIndex;
    }
    /**
     * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known
     *
     * @returns whether the last index of this store is known, or if lazy loading still required
     */
    isLastRowIndexKnown() {
        return this.cache.isLastRowIndexKnown();
    }
    /**
     * Used by the selection service to select a range of nodes
     *
     * @param firstInRange the first node in the range to find
     * @param lastInRange the last node in the range to find
     * @returns a range of nodes between firstInRange and lastInRange inclusive
     */
    getRowNodesInRange(firstInRange, lastInRange) {
        return this.cache
            .getNodes()
            .filter(({ node }) => {
            return node.rowIndex >= firstInRange.rowIndex && node.rowIndex <= lastInRange.rowIndex;
        })
            .map(({ node }) => node);
    }
    /**
     * Mutates a given array to add this stores state, and recursively add all the children store states.
     *
     * @param result a mutable results array
     */
    addStoreStates(result) {
        result.push({
            route: this.parentRowNode.getRoute() ?? [],
            rowCount: this.getRowCount(),
            lastRowIndexKnown: this.isLastRowIndexKnown(),
            info: this.info,
            maxBlocksInCache: this.storeParams.maxBlocksInCache,
            cacheBlockSize: this.storeParams.cacheBlockSize,
        });
        this.forEachChildStoreShallow((childStore) => childStore.addStoreStates(result));
    }
    getIdSequence() {
        return this.idSequence;
    }
    getParentNode() {
        return this.parentRowNode;
    }
    getRowDetails() {
        return {
            field: this.groupField,
            group: this.group,
            leafGroup: this.leafGroup,
            level: this.level,
            parent: this.parentRowNode,
            rowGroupColumn: this.rowGroupColumn,
        };
    }
    getSsrmParams() {
        return this.ssrmParams;
    }
    setStoreInfo(info) {
        if (info) {
            Object.assign(this.info, info);
        }
    }
    // gets called 1) row count changed 2) cache purged
    fireStoreUpdatedEvent() {
        // this results in row model firing ModelUpdated.
        // server side row model also updates the row indexes first
        this.eventSvc.dispatchEvent({
            type: 'storeUpdated',
        });
    }
    // gets called when row data updated, and no more refreshing needed
    fireRefreshFinishedEvent() {
        this.eventSvc.dispatchEvent({
            type: 'storeRefreshed',
            route: this.parentRowNode.getRoute(),
        });
    }
    getBlockStates() {
        return this.cache.getBlockStates();
    }
    getStoreBounds() {
        return {
            topPx: this.topPx,
            heightPx: this.heightPx,
        };
    }
    getCache() {
        return this.cache;
    }
}
exports.LazyStore = LazyStore;


/***/ }),

/***/ 2314:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiIndexMap = void 0;
class MultiIndexMap {
    constructor(...indexes) {
        this.indexes = indexes;
        this.maps = new Map(this.indexes.map((index) => [index, new Map()]));
    }
    getSize() {
        return this.maps.get(this.indexes[0]).size;
    }
    getBy(index, key) {
        const map = this.maps.get(index);
        return map.get(key);
    }
    set(item) {
        this.indexes.forEach((index) => {
            const map = this.maps.get(index);
            map.set(item[index], item);
        });
    }
    delete(item) {
        this.indexes.forEach((index) => {
            const map = this.maps.get(index);
            map.delete(item[index]);
        });
    }
    clear() {
        this.maps.forEach((map) => map.clear());
    }
    getIterator(index) {
        const map = this.maps.get(index);
        return map.values();
    }
    forEach(callback) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        while ((pointer = iterator.next())) {
            if (pointer.done)
                break;
            callback(pointer.value);
        }
    }
    find(callback) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        while ((pointer = iterator.next())) {
            if (pointer.done)
                break;
            if (callback(pointer.value)) {
                return pointer.value;
            }
        }
    }
    filter(predicate) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        const result = [];
        while ((pointer = iterator.next())) {
            if (pointer.done)
                break;
            if (predicate(pointer.value)) {
                result.push(pointer.value);
            }
        }
        return result;
    }
}
exports.MultiIndexMap = MultiIndexMap;


/***/ }),

/***/ 2697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StoreFactory = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const lazyStore_1 = __webpack_require__(5330);
class StoreFactory extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmStoreFactory';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.pivotColsSvc = beans.pivotColsSvc;
        this.rowAutoHeight = beans.rowAutoHeight;
    }
    createStore(ssrmParams, parentNode) {
        const storeParams = this.getStoreParams(ssrmParams, parentNode);
        return new lazyStore_1.LazyStore(ssrmParams, storeParams, parentNode);
    }
    getStoreParams(ssrmParams, parentNode) {
        const userStoreParams = this.getLevelSpecificParams(parentNode);
        // if user provided overrideParams, we take infiniteScroll from there if it exists
        const cacheBlockSize = this.getBlockSize(userStoreParams);
        const maxBlocksInCache = this.getMaxBlocksInCache(ssrmParams, userStoreParams);
        const storeParams = {
            cacheBlockSize,
            maxBlocksInCache,
        };
        return storeParams;
    }
    getMaxBlocksInCache(ssrmParams, userStoreParams) {
        const maxBlocksInCache = userStoreParams && userStoreParams.maxBlocksInCache != null
            ? userStoreParams.maxBlocksInCache
            : this.gos.get('maxBlocksInCache');
        const maxBlocksActive = maxBlocksInCache != null && maxBlocksInCache >= 0;
        if (!maxBlocksActive) {
            return;
        }
        if (ssrmParams.dynamicRowHeight) {
            (0, ag_grid_community_1._warn)(203);
            return;
        }
        if (this.rowAutoHeight?.active) {
            (0, ag_grid_community_1._warn)(204);
            return undefined;
        }
        return maxBlocksInCache;
    }
    getBlockSize(userStoreParams) {
        const blockSize = userStoreParams && userStoreParams.cacheBlockSize != null
            ? userStoreParams.cacheBlockSize
            : this.gos.get('cacheBlockSize');
        if (blockSize != null && blockSize > 0) {
            return blockSize;
        }
        else {
            return 100;
        }
    }
    getLevelSpecificParams(parentNode) {
        const callback = this.gos.getCallback('getServerSideGroupLevelParams');
        if (!callback) {
            return undefined;
        }
        const params = {
            level: parentNode.level + 1,
            parentRowNode: parentNode.level >= 0 ? parentNode : undefined,
            rowGroupColumns: this.rowGroupColsSvc?.columns ?? [],
            pivotColumns: this.pivotColsSvc?.columns ?? [],
            pivotMode: this.colModel.isPivotMode(),
        };
        const res = callback(params);
        return res;
    }
}
exports.StoreFactory = StoreFactory;


/***/ }),

/***/ 2234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StoreUtils = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class StoreUtils extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmStoreUtils';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.serverSideRowModel = beans.rowModel;
        this.storeFactory = beans.ssrmStoreFactory;
    }
    getChildStore(keys, currentCache, findNodeFunc) {
        if (!keys?.length) {
            return currentCache;
        }
        const nextKey = keys[0];
        const nextNode = findNodeFunc(nextKey);
        if (nextNode) {
            // if we have the final node, but not the final store, we create it to allow
            // early population of data
            if (keys.length === 1 && !nextNode.childStore) {
                const storeParams = this.serverSideRowModel.getParams();
                nextNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, nextNode));
            }
            const keyListForNextLevel = keys.slice(1, keys.length);
            const nextStore = nextNode.childStore;
            return nextStore ? nextStore.getChildStore(keyListForNextLevel) : null;
        }
        return null;
    }
    isServerRefreshNeeded(parentRowNode, rowGroupCols, params) {
        if (params.valueColChanged || params.secondaryColChanged) {
            return true;
        }
        const level = parentRowNode.level + 1;
        const grouping = level < rowGroupCols.length;
        const leafNodes = !grouping;
        if (leafNodes) {
            return true;
        }
        const colIdThisGroup = rowGroupCols[level].id;
        const actionOnThisGroup = params.changedColumns.indexOf(colIdThisGroup) > -1;
        if (actionOnThisGroup) {
            return true;
        }
        const allCols = this.colModel.getCols();
        const affectedGroupCols = allCols
            // find all impacted cols which also a group display column
            .filter((col) => col.getColDef().showRowGroup && params.changedColumns.includes(col.getId()))
            .map((col) => col.getColDef().showRowGroup)
            // if displaying all groups, or displaying the effected col for this group, refresh
            .some((group) => group === true || group === colIdThisGroup);
        return affectedGroupCols;
    }
    getServerSideInitialRowCount() {
        return this.gos.get('serverSideInitialRowCount');
    }
    isServerSideSortAllLevels() {
        return this.gos.get('serverSideSortAllLevels') && (0, ag_grid_community_1._isServerSideRowModel)(this.gos);
    }
    isServerSideOnlyRefreshFilteredGroups() {
        return this.gos.get('serverSideOnlyRefreshFilteredGroups') && (0, ag_grid_community_1._isServerSideRowModel)(this.gos);
    }
}
exports.StoreUtils = StoreUtils;


/***/ }),

/***/ 7332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class TransactionManager extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ssrmTxnManager';
        this.asyncTransactions = [];
    }
    wireBeans(beans) {
        this.valueCache = beans.valueCache;
        this.serverSideRowModel = beans.rowModel;
        this.selectionSvc = beans.selectionSvc;
    }
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!(0, ag_grid_community_1._isServerSideRowModel)(this.gos)) {
            return;
        }
    }
    applyTransactionAsync(transaction, callback) {
        if (this.asyncTransactionsTimeout == null) {
            this.scheduleExecuteAsync();
        }
        this.asyncTransactions.push({ transaction: transaction, callback: callback });
    }
    scheduleExecuteAsync() {
        const waitMillis = this.gos.get('asyncTransactionWaitMillis');
        this.asyncTransactionsTimeout = window.setTimeout(() => {
            this.executeAsyncTransactions();
        }, waitMillis);
    }
    executeAsyncTransactions() {
        if (!this.asyncTransactions) {
            return;
        }
        const resultFuncs = [];
        const resultsForEvent = [];
        const transactionsToRetry = [];
        let atLeastOneTransactionApplied = false;
        this.asyncTransactions.forEach((txWrapper) => {
            let result;
            const hasStarted = this.serverSideRowModel.executeOnStore(txWrapper.transaction.route, (cache) => {
                result = cache.applyTransaction(txWrapper.transaction);
            });
            if (!hasStarted) {
                result = { status: ag_grid_community_1.ServerSideTransactionResultStatus.StoreNotStarted };
            }
            else if (result == undefined) {
                result = { status: ag_grid_community_1.ServerSideTransactionResultStatus.StoreNotFound };
            }
            resultsForEvent.push(result);
            const retryTransaction = result.status == ag_grid_community_1.ServerSideTransactionResultStatus.StoreLoading;
            if (retryTransaction) {
                transactionsToRetry.push(txWrapper);
                return;
            }
            if (txWrapper.callback) {
                resultFuncs.push(() => txWrapper.callback(result));
            }
            if (result.status === ag_grid_community_1.ServerSideTransactionResultStatus.Applied) {
                atLeastOneTransactionApplied = true;
            }
        });
        // do callbacks in next VM turn so it's async
        if (resultFuncs.length > 0) {
            window.setTimeout(() => {
                resultFuncs.forEach((func) => func());
            }, 0);
        }
        this.asyncTransactionsTimeout = undefined;
        // this will be empty list if nothing to retry
        this.asyncTransactions = transactionsToRetry;
        if (atLeastOneTransactionApplied) {
            this.valueCache?.onDataChanged();
            this.eventSvc.dispatchEvent({ type: 'storeUpdated' });
        }
        if (resultsForEvent.length > 0) {
            this.eventSvc.dispatchEvent({
                type: 'asyncTransactionsFlushed',
                results: resultsForEvent,
            });
        }
    }
    flushAsyncTransactions() {
        // the timeout could be missing, if we are flushing due to row data loaded
        if (this.asyncTransactionsTimeout != null) {
            clearTimeout(this.asyncTransactionsTimeout);
        }
        this.executeAsyncTransactions();
    }
    applyTransaction(transaction) {
        let res;
        const hasStarted = this.serverSideRowModel.executeOnStore(transaction.route, (store) => {
            res = store.applyTransaction(transaction);
        });
        if (!hasStarted) {
            return { status: ag_grid_community_1.ServerSideTransactionResultStatus.StoreNotStarted };
        }
        else if (res) {
            this.valueCache?.onDataChanged();
            if (res.remove && this.selectionSvc) {
                const removedRowIds = res.remove.map((row) => row.id);
                this.selectionSvc.deleteSelectionStateFromParent(transaction.route || [], removedRowIds);
            }
            this.eventSvc.dispatchEvent({ type: 'storeUpdated' });
            return res;
        }
        else {
            return { status: ag_grid_community_1.ServerSideTransactionResultStatus.StoreNotFound };
        }
    }
}
exports.TransactionManager = TransactionManager;


/***/ }),

/***/ 4737:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideValuesExtractor = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const setFilterUtils_1 = __webpack_require__(2270);
/** @param V type of value in the Set Filter */
class ClientSideValuesExtractor {
    constructor(rowModel, filterParams, createKey, caseFormat, valueSvc, treeDataOrGrouping, treeData, groupAllowUnbalanced, addManagedEventListeners, rowGroupColsSvc) {
        this.rowModel = rowModel;
        this.filterParams = filterParams;
        this.createKey = createKey;
        this.caseFormat = caseFormat;
        this.valueSvc = valueSvc;
        this.treeDataOrGrouping = treeDataOrGrouping;
        this.treeData = treeData;
        this.groupAllowUnbalanced = groupAllowUnbalanced;
        this.addManagedEventListeners = addManagedEventListeners;
        this.rowGroupColsSvc = rowGroupColsSvc;
    }
    extractUniqueValuesAsync(predicate, existingValues) {
        return new ag_grid_community_1.AgPromise((resolve) => {
            if (this.rowModel.isRowDataLoaded()) {
                resolve(this.extractUniqueValues(predicate, existingValues));
            }
            else {
                const [destroyFunc] = this.addManagedEventListeners({
                    rowCountReady: () => {
                        destroyFunc?.();
                        resolve(this.extractUniqueValues(predicate, existingValues));
                    },
                });
            }
        });
    }
    extractUniqueValues(predicate, existingValues) {
        const values = new Map();
        const existingFormattedKeys = this.extractExistingFormattedKeys(existingValues);
        const formattedKeys = new Set();
        const treeData = this.treeData;
        const groupedCols = this.rowGroupColsSvc?.columns;
        const addValue = (unformattedKey, value) => {
            const formattedKey = this.caseFormat(unformattedKey);
            if (!formattedKeys.has(formattedKey)) {
                formattedKeys.add(formattedKey);
                let keyToAdd = unformattedKey;
                let valueToAdd = (0, ag_grid_community_1._makeNull)(value);
                // when case insensitive, we pick the first value to use. if this is later filtered out,
                // we still want to use the original value and not one with a different case
                const existingUnformattedKey = existingFormattedKeys?.get(formattedKey);
                if (existingUnformattedKey != null) {
                    keyToAdd = existingUnformattedKey;
                    valueToAdd = existingValues.get(existingUnformattedKey);
                }
                values.set(keyToAdd, valueToAdd);
            }
        };
        this.rowModel.forEachLeafNode((node) => {
            // only pull values from rows that have data. this means we skip filler group nodes.
            if (!node.data || !predicate(node)) {
                return;
            }
            if (this.treeDataOrGrouping) {
                this.addValueForTreeDataOrGrouping(node, treeData, groupedCols, addValue);
                return;
            }
            const value = this.getValue(node);
            if (value != null && Array.isArray(value)) {
                value.forEach((x) => {
                    addValue(this.createKey(x, node), x);
                });
                if (value.length === 0) {
                    addValue(null, null);
                }
            }
            else {
                addValue(this.createKey(value, node), value);
            }
        });
        return values;
    }
    addValueForTreeDataOrGrouping(node, treeData, groupedCols = [], addValue) {
        let dataPath;
        if (treeData) {
            if (node.childrenAfterGroup?.length) {
                return;
            }
            dataPath = node.getRoute() ?? [node.key ?? node.id];
        }
        else {
            dataPath = groupedCols.map((groupCol) => this.valueSvc.getKeyForNode(groupCol, node));
            dataPath.push(this.getValue(node));
        }
        const processedDataPath = (0, setFilterUtils_1.processDataPath)(dataPath, treeData, this.groupAllowUnbalanced);
        addValue(this.createKey(processedDataPath), processedDataPath);
    }
    getValue(node) {
        return this.filterParams.getValue(node);
    }
    extractExistingFormattedKeys(existingValues) {
        if (!existingValues) {
            return null;
        }
        const existingFormattedKeys = new Map();
        existingValues.forEach((_value, key) => {
            existingFormattedKeys.set(this.caseFormat(key), key);
        });
        return existingFormattedKeys;
    }
}
exports.ClientSideValuesExtractor = ClientSideValuesExtractor;


/***/ }),

/***/ 4510:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetValueModelFilteringKeys = void 0;
class SetValueModelFilteringKeys {
    constructor({ caseFormat }) {
        // To make the filtering fast, we store the keys in a Set rather than using the default array.
        this.filteringKeys = null;
        // This attribute contains keys that are actually used for filtering.
        // These keys take into account case sensitivity:
        // - When filtering is case-insensitive, all filtering keys are converted to upper case and stored here.
        // - When filtering is case-sensitive, this is the same as filteringKeys.
        this.filteringKeysCaseFormatted = null;
        this.hasNoAppliedFilteringKeys = false;
        this.caseFormat = caseFormat;
    }
    allFilteringKeys() {
        return this.filteringKeys;
    }
    allFilteringKeysCaseFormatted() {
        return this.filteringKeysCaseFormatted;
    }
    setFilteringKeys(filteringKeys) {
        this.filteringKeys = new Set(filteringKeys);
        this.hasNoAppliedFilteringKeys = !this.filteringKeys || this.filteringKeys.size === 0;
        this.filteringKeysCaseFormatted = new Set();
        this.filteringKeys.forEach((key) => this.filteringKeysCaseFormatted.add(this.caseFormat(key)));
    }
    addFilteringKey(key) {
        if (this.filteringKeys == null) {
            this.filteringKeys = new Set();
            this.filteringKeysCaseFormatted = new Set();
        }
        this.filteringKeys.add(key);
        this.filteringKeysCaseFormatted.add(this.caseFormat(key));
        if (this.hasNoAppliedFilteringKeys) {
            this.hasNoAppliedFilteringKeys = false;
        }
    }
    hasCaseFormattedFilteringKey(key) {
        return this.filteringKeysCaseFormatted.has(this.caseFormat(key));
    }
    hasFilteringKey(key) {
        return this.filteringKeys.has(key);
    }
    reset() {
        this.filteringKeys = null;
        this.filteringKeysCaseFormatted = null;
        this.hasNoAppliedFilteringKeys = false;
    }
}
exports.SetValueModelFilteringKeys = SetValueModelFilteringKeys;


/***/ }),

/***/ 8053:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlatSetDisplayValueModel = void 0;
const iSetDisplayValueModel_1 = __webpack_require__(3335);
class FlatSetDisplayValueModel {
    constructor(valueSvc, valueFormatter, formatter, column) {
        this.valueSvc = valueSvc;
        this.valueFormatter = valueFormatter;
        this.formatter = formatter;
        this.column = column;
        /** All keys that are currently displayed, after the mini-filter has been applied. */
        this.displayedKeys = [];
    }
    updateDisplayedValuesToAllAvailable(_getValue, _allKeys, availableKeys) {
        this.displayedKeys = Array.from(availableKeys);
    }
    updateDisplayedValuesToMatchMiniFilter(getValue, _allKeys, availableKeys, matchesFilter, nullMatchesFilter) {
        this.displayedKeys = [];
        for (const key of availableKeys) {
            if (key == null) {
                if (nullMatchesFilter) {
                    this.displayedKeys.push(key);
                }
            }
            else {
                const value = getValue(key);
                const valueFormatterValue = this.valueSvc.formatValue(this.column, null, value, this.valueFormatter, false);
                const textFormatterValue = this.formatter(valueFormatterValue);
                if (matchesFilter(textFormatterValue)) {
                    this.displayedKeys.push(key);
                }
            }
        }
    }
    getDisplayedValueCount() {
        return this.displayedKeys.length;
    }
    getDisplayedItem(index) {
        return this.displayedKeys[index];
    }
    getSelectAllItem() {
        return iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL;
    }
    getAddSelectionToFilterItem() {
        return iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER;
    }
    getDisplayedKeys() {
        return this.displayedKeys;
    }
    forEachDisplayedKey(func) {
        this.displayedKeys.forEach(func);
    }
    someDisplayedKey(func) {
        return this.displayedKeys.some(func);
    }
    hasGroups() {
        return false;
    }
    refresh() {
        // not used
    }
}
exports.FlatSetDisplayValueModel = FlatSetDisplayValueModel;


/***/ }),

/***/ 3335:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SET_FILTER_ADD_SELECTION_TO_FILTER = exports.SET_FILTER_SELECT_ALL = void 0;
exports.SET_FILTER_SELECT_ALL = '__AG_SELECT_ALL__';
exports.SET_FILTER_ADD_SELECTION_TO_FILTER = '__AG_ADD_SELECTION_TO_FILTER__';


/***/ }),

/***/ 3003:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_LOCALE_TEXT = void 0;
exports.DEFAULT_LOCALE_TEXT = {
    loadingOoo: 'Loading...',
    blanks: '(Blanks)',
    searchOoo: 'Search...',
    selectAll: '(Select All)',
    selectAllSearchResults: '(Select All Search Results)',
    addCurrentSelectionToFilter: 'Add current selection to filter',
    noMatches: 'No matches.',
};


/***/ }),

/***/ 2734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetFilter = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const virtualList_1 = __webpack_require__(7904);
const iSetDisplayValueModel_1 = __webpack_require__(3335);
const localeText_1 = __webpack_require__(3003);
const setFilterListItem_1 = __webpack_require__(105);
const setFilterModelFormatter_1 = __webpack_require__(5355);
const setFilterUtils_1 = __webpack_require__(2270);
const setValueModel_1 = __webpack_require__(4366);
/** @param V type of value in the Set Filter */
class SetFilter extends ag_grid_community_1.ProvidedFilter {
    wireBeans(beans) {
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.valueSvc = beans.valueSvc;
        this.dataTypeSvc = beans.dataTypeSvc;
    }
    constructor() {
        super('setFilter');
        this.filterType = 'set';
        this.eMiniFilter = ag_grid_community_1.RefPlaceholder;
        this.eFilterLoading = ag_grid_community_1.RefPlaceholder;
        this.eSetFilterList = ag_grid_community_1.RefPlaceholder;
        this.eFilterNoMatches = ag_grid_community_1.RefPlaceholder;
        this.caseSensitive = false;
        this.treeDataTreeList = false;
        this.groupingTreeList = false;
        this.hardRefreshVirtualList = false;
        this.noValueFormatterSupplied = false;
        this.filterModelFormatter = new setFilterModelFormatter_1.SetFilterModelFormatter();
        this.updateSetFilterOnParamsChange = (newParams) => {
            this.setFilterParams = newParams;
            this.caseSensitive = !!newParams.caseSensitive;
            const keyCreator = newParams.keyCreator ?? newParams.colDef.keyCreator;
            this.setValueFormatter(newParams.valueFormatter, keyCreator, !!newParams.treeList, !!newParams.colDef.refData);
            const isGroupCol = newParams.column.getId().startsWith(ag_grid_community_1.GROUP_AUTO_COLUMN_ID);
            this.treeDataTreeList = this.gos.get('treeData') && !!newParams.treeList && isGroupCol;
            this.groupingTreeList = !!this.rowGroupColsSvc?.columns.length && !!newParams.treeList && isGroupCol;
            this.createKey = this.generateCreateKey(keyCreator, this.treeDataTreeList || this.groupingTreeList);
        };
    }
    postConstruct() {
        super.postConstruct();
    }
    // unlike the simple filters, nothing in the set filter UI shows/hides.
    // maybe this method belongs in abstractSimpleFilter???
    updateUiVisibility() { }
    createBodyTemplate() {
        return /* html */ `
            <div class="ag-set-filter">
                <div data-ref="eFilterLoading" class="ag-filter-loading ag-hidden">${this.translateForSetFilter('loadingOoo')}</div>
                <ag-input-text-field class="ag-mini-filter" data-ref="eMiniFilter"></ag-input-text-field>
                <div data-ref="eFilterNoMatches" class="ag-filter-no-matches ag-hidden">${this.translateForSetFilter('noMatches')}</div>
                <div data-ref="eSetFilterList" class="ag-set-filter-list" role="presentation"></div>
            </div>`;
    }
    getAgComponents() {
        return [ag_grid_community_1.AgInputTextFieldSelector];
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        if (e.defaultPrevented) {
            return;
        }
        switch (e.key) {
            case ag_grid_community_1.KeyCode.SPACE:
                this.handleKeySpace(e);
                break;
            case ag_grid_community_1.KeyCode.ENTER:
                this.handleKeyEnter(e);
                break;
            case ag_grid_community_1.KeyCode.LEFT:
                this.handleKeyLeft(e);
                break;
            case ag_grid_community_1.KeyCode.RIGHT:
                this.handleKeyRight(e);
                break;
        }
    }
    handleKeySpace(e) {
        this.getComponentForKeyEvent(e)?.toggleSelected();
    }
    handleKeyEnter(e) {
        const { excelMode, readOnly } = this.setFilterParams;
        if (!excelMode || !!readOnly) {
            return;
        }
        e.preventDefault();
        // in Excel Mode, hitting Enter is the same as pressing the Apply button
        this.onBtApply(false, false, e);
        if (this.setFilterParams.excelMode === 'mac') {
            // in Mac version, select all the input text
            this.eMiniFilter.getInputElement().select();
        }
    }
    handleKeyLeft(e) {
        this.getComponentForKeyEvent(e)?.setExpanded(false);
    }
    handleKeyRight(e) {
        this.getComponentForKeyEvent(e)?.setExpanded(true);
    }
    getComponentForKeyEvent(e) {
        if (!this.eSetFilterList.contains((0, ag_grid_community_1._getActiveDomElement)(this.beans))) {
            return;
        }
        const currentItem = this.virtualList.getLastFocusedRow();
        if (currentItem == null) {
            return;
        }
        const component = this.virtualList.getComponentAt(currentItem);
        if (component == null) {
            return;
        }
        e.preventDefault();
        const { readOnly } = this.setFilterParams;
        if (readOnly) {
            return;
        }
        return component;
    }
    getCssIdentifier() {
        return 'set-filter';
    }
    setModel(model) {
        if (model == null && this.valueModel.getModel() == null) {
            // refreshing is expensive. if new and old model are both null (e.g. nothing set), skip.
            // mini filter isn't contained within the model, so always reset
            this.setMiniFilter(null);
            return ag_grid_community_1.AgPromise.resolve();
        }
        return super.setModel(model);
    }
    refresh(params) {
        this.applyExcelModeOptions(params);
        if (!super.refresh(params)) {
            return false;
        }
        const oldParams = this.setFilterParams;
        // Those params have a large impact and should trigger a reload when they change.
        const paramsThatForceReload = [
            'treeList',
            'treeListPathGetter',
            'caseSensitive',
            'comparator',
            'excelMode',
        ];
        if (paramsThatForceReload.some((param) => params[param] !== oldParams?.[param])) {
            return false;
        }
        if (this.haveColDefParamsChanged(params)) {
            return false;
        }
        super.updateParams(params);
        this.updateSetFilterOnParamsChange(params);
        this.updateMiniFilter();
        if (params.suppressSelectAll !== oldParams?.suppressSelectAll) {
            this.createVirtualListModel(params);
        }
        this.valueModel.updateOnParamsChange(params).then(() => {
            this.refreshFilterValues();
        });
        return true;
    }
    haveColDefParamsChanged(params) {
        const { colDef, keyCreator } = params;
        const { colDef: existingColDef, keyCreator: existingKeyCreator } = this.setFilterParams;
        const currentKeyCreator = keyCreator ?? colDef.keyCreator;
        const previousKeyCreator = existingKeyCreator ?? existingColDef?.keyCreator;
        const filterValueGetterChanged = colDef.filterValueGetter !== existingColDef?.filterValueGetter;
        const keyCreatorChanged = currentKeyCreator !== previousKeyCreator;
        const valueFormatterIsKeyCreatorAndHasChanged = !!this.dataTypeSvc &&
            !!currentKeyCreator &&
            this.dataTypeSvc.getFormatValue(colDef.cellDataType) === currentKeyCreator &&
            colDef.valueFormatter !== existingColDef?.valueFormatter;
        return filterValueGetterChanged || keyCreatorChanged || valueFormatterIsKeyCreatorAndHasChanged;
    }
    setModelAndRefresh(values) {
        return this.valueModel.setModel(values).then(() => {
            if (this.isAlive()) {
                // Async values could arrive after the grid has been destroyed
                this.checkAndRefreshVirtualList();
            }
        });
    }
    resetUiToDefaults() {
        this.setMiniFilter(null);
        return this.setModelAndRefresh(null);
    }
    setModelIntoUi(model) {
        this.setMiniFilter(null);
        const values = model == null ? null : model.values;
        return this.setModelAndRefresh(values);
    }
    getModelFromUi() {
        const values = this.valueModel.getModel();
        if (!values) {
            return null;
        }
        return { values, filterType: this.filterType };
    }
    getValueModel() {
        return this.valueModel;
    }
    areModelsEqual(a, b) {
        // both are missing
        if (a == null && b == null) {
            return true;
        }
        return a != null && b != null && (0, ag_grid_community_1._areEqual)(a.values, b.values);
    }
    setParams(params) {
        this.applyExcelModeOptions(params);
        super.setParams(params);
        this.updateSetFilterOnParamsChange(params);
        const keyCreator = params.keyCreator ?? params.colDef.keyCreator;
        this.valueModel = new setValueModel_1.SetValueModel({
            filterParams: params,
            setIsLoading: (loading) => this.setIsLoading(loading),
            translate: (key) => this.translateForSetFilter(key),
            caseFormat: (v) => this.caseFormat(v),
            createKey: this.createKey,
            valueFormatter: this.valueFormatter,
            usingComplexObjects: !!keyCreator,
            gos: this.gos,
            rowGroupColsSvc: this.rowGroupColsSvc,
            valueSvc: this.valueSvc,
            treeDataTreeList: this.treeDataTreeList,
            groupingTreeList: this.groupingTreeList,
            addManagedEventListeners: (handlers) => this.addManagedEventListeners(handlers),
        });
        this.initialiseFilterBodyUi();
        this.addEventListenersForDataChanges();
    }
    onAddCurrentSelectionToFilterChange(newValue) {
        this.valueModel.setAddCurrentSelectionToFilter(newValue);
    }
    setValueFormatter(providedValueFormatter, keyCreator, treeList, isRefData) {
        let valueFormatter = providedValueFormatter;
        if (!valueFormatter) {
            if (keyCreator && !treeList) {
                (0, ag_grid_community_1._error)(249);
                return;
            }
            this.noValueFormatterSupplied = true;
            // ref data is handled by ValueService
            if (!isRefData) {
                valueFormatter = (params) => (0, ag_grid_community_1._toStringOrNull)(params.value);
            }
        }
        this.valueFormatter = valueFormatter;
    }
    generateCreateKey(keyCreator, treeDataOrGrouping) {
        if (treeDataOrGrouping && !keyCreator) {
            (0, ag_grid_community_1._error)(250);
            return () => null;
        }
        if (keyCreator) {
            return (value, node = null) => {
                const params = this.getKeyCreatorParams(value, node);
                return (0, ag_grid_community_1._makeNull)(keyCreator(params));
            };
        }
        return (value) => (0, ag_grid_community_1._makeNull)((0, ag_grid_community_1._toStringOrNull)(value));
    }
    getFormattedValue(key) {
        let value = this.valueModel.getValue(key);
        if (this.noValueFormatterSupplied && (this.treeDataTreeList || this.groupingTreeList) && Array.isArray(value)) {
            // essentially get back the cell value
            value = (0, ag_grid_community_1._last)(value);
        }
        const formattedValue = this.valueSvc.formatValue(this.setFilterParams.column, null, value, this.valueFormatter, false);
        return ((formattedValue == null ? (0, ag_grid_community_1._toStringOrNull)(value) : formattedValue) ?? this.translateForSetFilter('blanks'));
    }
    applyExcelModeOptions(params) {
        // apply default options to match Excel behaviour, unless they have already been specified
        if (params.excelMode === 'windows') {
            if (!params.buttons) {
                params.buttons = ['apply', 'cancel'];
            }
            if (params.closeOnApply == null) {
                params.closeOnApply = true;
            }
        }
        else if (params.excelMode === 'mac') {
            if (!params.buttons) {
                params.buttons = ['reset'];
            }
            if (params.applyMiniFilterWhileTyping == null) {
                params.applyMiniFilterWhileTyping = true;
            }
            if (params.debounceMs == null) {
                params.debounceMs = 500;
            }
        }
        if (params.excelMode && params.defaultToNothingSelected) {
            params.defaultToNothingSelected = false;
            (0, ag_grid_community_1._warn)(207);
        }
    }
    addEventListenersForDataChanges() {
        if (!this.isValuesTakenFromGrid()) {
            return;
        }
        this.addManagedPropertyListeners(['groupAllowUnbalanced'], () => {
            this.syncAfterDataChange();
        });
        this.addManagedEventListeners({
            cellValueChanged: (event) => {
                // only interested in changes to do with this column
                if (event.column === this.setFilterParams.column) {
                    this.syncAfterDataChange();
                }
            },
        });
    }
    syncAfterDataChange() {
        const promise = this.valueModel.refreshValues();
        return promise.then(() => {
            this.checkAndRefreshVirtualList();
            if (!this.applyActive || this.areModelsEqual(this.getModel(), this.getModelFromUi())) {
                this.onBtApply(false, true);
            }
        });
    }
    setIsLoading(isLoading) {
        (0, ag_grid_community_1._setDisplayed)(this.eFilterLoading, isLoading);
        if (!isLoading) {
            // hard refresh when async data received
            this.hardRefreshVirtualList = true;
        }
    }
    initialiseFilterBodyUi() {
        this.initVirtualList();
        this.initMiniFilter();
    }
    initVirtualList() {
        const translate = this.getLocaleTextFunc();
        const filterListName = translate('ariaFilterList', 'Filter List');
        const isTree = !!this.setFilterParams.treeList;
        const virtualList = (this.virtualList = this.createBean(new virtualList_1.VirtualList({
            cssIdentifier: 'filter',
            ariaRole: isTree ? 'tree' : 'listbox',
            listName: filterListName,
        })));
        const eSetFilterList = this.eSetFilterList;
        if (isTree) {
            eSetFilterList.classList.add('ag-set-filter-tree-list');
        }
        if (eSetFilterList) {
            eSetFilterList.appendChild(virtualList.getGui());
        }
        const { cellHeight } = this.setFilterParams;
        if (cellHeight != null) {
            virtualList.setRowHeight(cellHeight);
        }
        const componentCreator = (item, listItemElement) => this.createSetListItem(item, isTree, listItemElement);
        virtualList.setComponentCreator(componentCreator);
        const componentUpdater = (item, component) => this.updateSetListItem(item, component);
        virtualList.setComponentUpdater(componentUpdater);
        this.createVirtualListModel(this.setFilterParams);
    }
    createVirtualListModel(params) {
        let model;
        if (params.suppressSelectAll) {
            model = new ModelWrapper(this.valueModel);
        }
        else {
            model = new ModelWrapperWithSelectAll(this.valueModel, () => this.isSelectAllSelected());
        }
        if (params.treeList) {
            model = new TreeModelWrapper(model);
        }
        this.virtualList.setModel(model);
    }
    getSelectAllLabel() {
        const key = this.valueModel.getMiniFilter() == null || !this.setFilterParams.excelMode
            ? 'selectAll'
            : 'selectAllSearchResults';
        return this.translateForSetFilter(key);
    }
    getAddSelectionToFilterLabel() {
        return this.translateForSetFilter('addCurrentSelectionToFilter');
    }
    createSetListItem(item, isTree, focusWrapper) {
        const groupsExist = this.valueModel.hasGroups();
        const { isSelected, isExpanded } = this.isSelectedExpanded(item);
        const { value, depth, isGroup, hasIndeterminateExpandState, selectedListener, expandedListener } = this.newSetListItemAttributes(item);
        const itemParams = {
            focusWrapper,
            value,
            params: this.setFilterParams,
            translate: (translateKey) => this.translateForSetFilter(translateKey),
            valueFormatter: this.valueFormatter,
            item,
            isSelected,
            isTree,
            depth,
            groupsExist,
            isGroup,
            isExpanded,
            hasIndeterminateExpandState,
        };
        const listItem = this.createBean(new setFilterListItem_1.SetFilterListItem(itemParams));
        listItem.addEventListener('selectionChanged', selectedListener);
        if (expandedListener) {
            listItem.addEventListener('expandedChanged', expandedListener);
        }
        return listItem;
    }
    newSetTreeItemAttributes(item) {
        const groupsExist = this.valueModel.hasGroups();
        // Select all option
        if (item.key === iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL) {
            return {
                value: () => this.getSelectAllLabel(),
                isGroup: groupsExist,
                depth: item.depth,
                hasIndeterminateExpandState: true,
                selectedListener: (e) => this.onSelectAll(e.isSelected),
                expandedListener: (e) => this.onExpandAll(e.item, e.isExpanded),
            };
        }
        // Add selection to filter option
        if (item.key === iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER) {
            return {
                value: () => this.getAddSelectionToFilterLabel(),
                depth: item.depth,
                isGroup: false,
                hasIndeterminateExpandState: false,
                selectedListener: (e) => {
                    this.onAddCurrentSelectionToFilterChange(e.isSelected);
                },
            };
        }
        // Group
        if (item.children) {
            return {
                value: this.setFilterParams.treeListFormatter?.(item.treeKey, item.depth, item.parentTreeKeys) ??
                    item.treeKey,
                depth: item.depth,
                isGroup: true,
                selectedListener: (e) => this.onGroupItemSelected(e.item, e.isSelected),
                expandedListener: (e) => this.onExpandedChanged(e.item, e.isExpanded),
            };
        }
        // Leaf
        return {
            value: this.setFilterParams.treeListFormatter?.(item.treeKey, item.depth, item.parentTreeKeys) ?? item.treeKey,
            depth: item.depth,
            selectedListener: (e) => this.onItemSelected(e.item.key, e.isSelected),
        };
    }
    newSetListItemAttributes(item) {
        // Tree item
        if (this.isSetFilterModelTreeItem(item)) {
            return this.newSetTreeItemAttributes(item);
        }
        // List item - 'Select All'
        if (item === iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL) {
            return {
                value: () => this.getSelectAllLabel(),
                selectedListener: (e) => this.onSelectAll(e.isSelected),
            };
        }
        // List item - 'Add selection to filter'
        if (item === iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER) {
            return {
                value: () => this.getAddSelectionToFilterLabel(),
                selectedListener: (e) => {
                    this.onAddCurrentSelectionToFilterChange(e.isSelected);
                },
            };
        }
        // List item
        return {
            value: this.valueModel.getValue(item),
            selectedListener: (e) => this.onItemSelected(e.item, e.isSelected),
        };
    }
    updateSetListItem(item, component) {
        const { isSelected, isExpanded } = this.isSelectedExpanded(item);
        component.refresh(item, isSelected, isExpanded);
    }
    isSelectedExpanded(item) {
        let isSelected;
        let isExpanded;
        if (this.isSetFilterModelTreeItem(item)) {
            isExpanded = item.expanded;
            if (item.key === iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL) {
                isSelected = this.isSelectAllSelected();
            }
            else if (item.key === iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER) {
                isSelected = this.valueModel.isAddCurrentSelectionToFilterChecked();
            }
            else if (item.children) {
                isSelected = this.areAllChildrenSelected(item);
            }
            else {
                isSelected = this.valueModel.isKeySelected(item.key);
            }
        }
        else {
            if (item === iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL) {
                isSelected = this.isSelectAllSelected();
            }
            else if (item === iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER) {
                isSelected = this.valueModel.isAddCurrentSelectionToFilterChecked();
            }
            else {
                isSelected = this.valueModel.isKeySelected(item);
            }
        }
        return { isSelected, isExpanded };
    }
    isSetFilterModelTreeItem(item) {
        return item?.treeKey !== undefined;
    }
    initMiniFilter() {
        const { eMiniFilter } = this;
        const translate = this.getLocaleTextFunc();
        eMiniFilter.setDisplayed(!this.setFilterParams.suppressMiniFilter);
        eMiniFilter.setValue(this.valueModel.getMiniFilter());
        eMiniFilter.onValueChange(() => this.onMiniFilterInput());
        eMiniFilter.setInputAriaLabel(translate('ariaSearchFilterValues', 'Search filter values'));
        this.addManagedElementListeners(eMiniFilter.getInputElement(), {
            keydown: (e) => this.onMiniFilterKeyDown(e),
        });
    }
    updateMiniFilter() {
        const { eMiniFilter } = this;
        if (eMiniFilter.isDisplayed() !== !this.setFilterParams.suppressMiniFilter) {
            eMiniFilter.setDisplayed(!this.setFilterParams.suppressMiniFilter);
        }
        const miniFilterValue = this.valueModel.getMiniFilter();
        if (eMiniFilter.getValue() !== miniFilterValue) {
            eMiniFilter.setValue(miniFilterValue);
        }
    }
    // we need to have the GUI attached before we can draw the virtual rows, as the
    // virtual row logic needs info about the GUI state
    afterGuiAttached(params) {
        super.afterGuiAttached(params);
        // collapse all tree list items (if tree list)
        this.resetExpansion();
        this.refreshVirtualList();
        const { eMiniFilter } = this;
        eMiniFilter.setInputPlaceholder(this.translateForSetFilter('searchOoo'));
        if (!params || !params.suppressFocus) {
            if (eMiniFilter.isDisplayed()) {
                eMiniFilter.getFocusableElement().focus();
            }
            else {
                this.virtualList.awaitStable(() => this.virtualList.focusRow(0));
            }
        }
    }
    afterGuiDetached() {
        super.afterGuiDetached();
        // discard any unapplied UI state (reset to model)
        if (this.setFilterParams.excelMode) {
            this.resetMiniFilter();
        }
        const appliedModel = this.getModel();
        if (this.setFilterParams.excelMode || !this.areModelsEqual(appliedModel, this.getModelFromUi())) {
            this.resetUiToActiveModel(appliedModel);
            this.showOrHideResults();
        }
    }
    applyModel(source = 'api') {
        if (this.setFilterParams.excelMode &&
            source !== 'rowDataUpdated' &&
            this.valueModel.isEverythingVisibleSelected()) {
            // In Excel, if the filter is applied with all visible values selected, then any active filter on the
            // column is removed. This ensures the filter is removed in this situation.
            this.valueModel.selectAllMatchingMiniFilter();
        }
        // Here we implement AG-9090 TC2
        // When 'Add current selection to filter' is visible and checked, but no filter is applied:
        // Do NOT apply the current selection as filter.
        const shouldKeepCurrentSelection = this.valueModel.showAddCurrentSelectionToFilter() && this.valueModel.isAddCurrentSelectionToFilterChecked();
        if (shouldKeepCurrentSelection && !this.getModel()) {
            return false;
        }
        const result = super.applyModel(source);
        // keep appliedModelKeys in sync with the applied model
        const appliedModel = this.getModel();
        if (appliedModel) {
            if (!shouldKeepCurrentSelection) {
                this.valueModel.setAppliedModelKeys(new Set());
            }
            appliedModel.values.forEach((key) => {
                this.valueModel.addToAppliedModelKeys(key);
            });
        }
        else {
            if (!shouldKeepCurrentSelection) {
                this.valueModel.setAppliedModelKeys(null);
            }
        }
        return result;
    }
    isModelValid(model) {
        return this.setFilterParams.excelMode ? model == null || model.values.length > 0 : true;
    }
    doesFilterPass(params) {
        if (!this.valueModel.getCaseFormattedAppliedModelKeys()) {
            return true;
        }
        // if nothing selected, don't need to check value
        if (!this.valueModel.hasAnyAppliedModelKey()) {
            return false;
        }
        const { node } = params;
        if (this.treeDataTreeList) {
            return this.doesFilterPassForTreeData(node);
        }
        if (this.groupingTreeList) {
            return this.doesFilterPassForGrouping(node);
        }
        const value = this.getValueFromNode(node);
        if (value != null && Array.isArray(value)) {
            if (value.length === 0) {
                return this.valueModel.hasAppliedModelKey(null);
            }
            return value.some((v) => this.isInAppliedModel(this.createKey(v, node)));
        }
        return this.isInAppliedModel(this.createKey(value, node));
    }
    doesFilterPassForTreeData(node) {
        if (node.childrenAfterGroup?.length) {
            // only perform checking on leaves. The core filtering logic for tree data won't work properly otherwise
            return false;
        }
        return this.isInAppliedModel(this.createKey((0, setFilterUtils_1.processDataPath)(node.getRoute() ?? [node.key ?? node.id], true, this.gos.get('groupAllowUnbalanced'))));
    }
    doesFilterPassForGrouping(node) {
        const dataPath = (this.rowGroupColsSvc?.columns ?? []).map((groupCol) => this.valueSvc.getKeyForNode(groupCol, node));
        dataPath.push(this.getValueFromNode(node));
        return this.isInAppliedModel(this.createKey((0, setFilterUtils_1.processDataPath)(dataPath, false, this.gos.get('groupAllowUnbalanced'))));
    }
    isInAppliedModel(key) {
        return this.valueModel.hasAppliedModelKey(key);
    }
    getValueFromNode(node) {
        return this.setFilterParams.getValue(node);
    }
    getKeyCreatorParams(value, node = null) {
        const { colDef, column, api, context } = this.setFilterParams;
        return {
            value,
            colDef,
            column,
            node,
            data: node?.data,
            api,
            context,
        };
    }
    onNewRowsLoaded() {
        if (this.isValuesTakenFromGrid()) {
            this.syncAfterDataChange();
        }
    }
    isValuesTakenFromGrid() {
        const valuesType = this.valueModel.getValuesType();
        return valuesType === setValueModel_1.SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
    }
    //noinspection JSUnusedGlobalSymbols
    /**
     * Public method provided so the user can change the value of the filter once
     * the filter has been already started
     * @param values The values to use.
     */
    setFilterValues(values) {
        this.valueModel.overrideValues(values).then(() => {
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        });
    }
    //noinspection JSUnusedGlobalSymbols
    /**
     * Public method provided so the user can reset the values of the filter once that it has started.
     */
    resetFilterValues() {
        this.valueModel.setValuesType(setValueModel_1.SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES);
        this.syncAfterDataChange();
    }
    refreshFilterValues() {
        // the model is still being initialised
        if (!this.valueModel.isInitialised()) {
            return;
        }
        this.valueModel.refreshValues().then(() => {
            this.hardRefreshVirtualList = true;
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        });
    }
    onAnyFilterChanged() {
        // don't block the current action when updating the values for this filter
        setTimeout(() => {
            if (!this.isAlive()) {
                return;
            }
            this.valueModel.refreshAfterAnyFilterChanged().then((refresh) => {
                if (refresh) {
                    this.checkAndRefreshVirtualList();
                    this.showOrHideResults();
                }
            });
        }, 0);
    }
    onMiniFilterInput() {
        if (!this.valueModel.setMiniFilter(this.eMiniFilter.getValue())) {
            return;
        }
        const { applyMiniFilterWhileTyping, readOnly } = this.setFilterParams;
        if (!readOnly && applyMiniFilterWhileTyping) {
            this.filterOnAllVisibleValues(false);
        }
        else {
            this.updateUiAfterMiniFilterChange();
        }
    }
    updateUiAfterMiniFilterChange() {
        const { excelMode, readOnly } = this.setFilterParams;
        if (excelMode == null || !!readOnly) {
            this.checkAndRefreshVirtualList();
        }
        else if (this.valueModel.getMiniFilter() == null) {
            this.resetUiToActiveModel(this.getModel());
        }
        else {
            this.valueModel.selectAllMatchingMiniFilter(true);
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        }
        this.showOrHideResults();
    }
    showOrHideResults() {
        const hideResults = this.valueModel.getMiniFilter() != null && this.valueModel.getDisplayedValueCount() < 1;
        (0, ag_grid_community_1._setDisplayed)(this.eFilterNoMatches, hideResults);
        (0, ag_grid_community_1._setDisplayed)(this.eSetFilterList, !hideResults);
    }
    resetMiniFilter() {
        this.eMiniFilter.setValue(null, true);
        this.valueModel.setMiniFilter(null);
    }
    resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
        // override the default behaviour as we don't always want to clear the mini filter
        this.setModelAndRefresh(currentModel == null ? null : currentModel.values).then(() => {
            this.onUiChanged(false, 'prevent');
            afterUiUpdatedFunc?.();
        });
    }
    handleCancelEnd(e) {
        this.setMiniFilter(null);
        super.handleCancelEnd(e);
    }
    onMiniFilterKeyDown(e) {
        const { excelMode, readOnly } = this.setFilterParams;
        if (e.key === ag_grid_community_1.KeyCode.ENTER && !excelMode && !readOnly) {
            this.filterOnAllVisibleValues();
        }
    }
    filterOnAllVisibleValues(applyImmediately = true) {
        this.valueModel.selectAllMatchingMiniFilter(true);
        this.checkAndRefreshVirtualList();
        this.onUiChanged(false, applyImmediately ? 'immediately' : 'debounce');
        this.showOrHideResults();
    }
    focusRowIfAlive(rowIndex) {
        if (rowIndex == null) {
            return;
        }
        window.setTimeout(() => {
            if (this.isAlive()) {
                this.virtualList.focusRow(rowIndex);
            }
        }, 0);
    }
    onSelectAll(isSelected) {
        if (isSelected) {
            this.valueModel.selectAllMatchingMiniFilter();
        }
        else {
            this.valueModel.deselectAllMatchingMiniFilter();
        }
        this.refreshAfterSelection();
    }
    onGroupItemSelected(item, isSelected) {
        const recursiveGroupSelection = (i) => {
            if (i.children) {
                i.children.forEach((childItem) => recursiveGroupSelection(childItem));
            }
            else {
                this.selectItem(i.key, isSelected);
            }
        };
        recursiveGroupSelection(item);
        this.refreshAfterSelection();
    }
    onItemSelected(key, isSelected) {
        this.selectItem(key, isSelected);
        this.refreshAfterSelection();
    }
    selectItem(key, isSelected) {
        if (isSelected) {
            this.valueModel.selectKey(key);
        }
        else {
            this.valueModel.deselectKey(key);
        }
    }
    onExpandAll(item, isExpanded) {
        const recursiveExpansion = (i) => {
            if (i.filterPasses && i.available && i.children) {
                i.children.forEach((childItem) => recursiveExpansion(childItem));
                i.expanded = isExpanded;
            }
        };
        recursiveExpansion(item);
        this.refreshAfterExpansion();
    }
    onExpandedChanged(item, isExpanded) {
        item.expanded = isExpanded;
        this.refreshAfterExpansion();
    }
    refreshAfterExpansion() {
        const focusedRow = this.virtualList.getLastFocusedRow();
        this.valueModel.updateDisplayedValues('expansion');
        this.checkAndRefreshVirtualList();
        this.focusRowIfAlive(focusedRow);
    }
    refreshAfterSelection() {
        const focusedRow = this.virtualList.getLastFocusedRow();
        this.checkAndRefreshVirtualList();
        this.onUiChanged();
        this.focusRowIfAlive(focusedRow);
    }
    setMiniFilter(newMiniFilter) {
        this.eMiniFilter.setValue(newMiniFilter);
        this.onMiniFilterInput();
    }
    getMiniFilter() {
        return this.valueModel.getMiniFilter();
    }
    checkAndRefreshVirtualList() {
        this.virtualList.refresh(!this.hardRefreshVirtualList);
        if (this.hardRefreshVirtualList) {
            this.hardRefreshVirtualList = false;
        }
    }
    getFilterKeys() {
        return this.valueModel.getKeys();
    }
    getFilterValues() {
        return this.valueModel.getValues();
    }
    getValues() {
        return this.getFilterKeys();
    }
    refreshVirtualList() {
        if (this.setFilterParams.refreshValuesOnOpen) {
            this.refreshFilterValues();
        }
        else {
            this.checkAndRefreshVirtualList();
        }
    }
    translateForSetFilter(key) {
        const translate = this.getLocaleTextFunc();
        return translate(key, localeText_1.DEFAULT_LOCALE_TEXT[key]);
    }
    isSelectAllSelected() {
        if (!this.setFilterParams.defaultToNothingSelected) {
            // everything selected by default
            if (this.valueModel.hasSelections() && this.valueModel.isNothingVisibleSelected()) {
                return false;
            }
            if (this.valueModel.isEverythingVisibleSelected()) {
                return true;
            }
        }
        else {
            // nothing selected by default
            if (this.valueModel.hasSelections() && this.valueModel.isEverythingVisibleSelected()) {
                return true;
            }
            if (this.valueModel.isNothingVisibleSelected()) {
                return false;
            }
        }
        // returning `undefined` means the checkbox status is indeterminate.
        return undefined;
    }
    areAllChildrenSelected(item) {
        const recursiveChildSelectionCheck = (i) => {
            if (i.children) {
                let someTrue = false;
                let someFalse = false;
                const mixed = i.children.some((child) => {
                    if (!child.filterPasses || !child.available) {
                        return false;
                    }
                    const childSelected = recursiveChildSelectionCheck(child);
                    if (childSelected === undefined) {
                        return true;
                    }
                    if (childSelected) {
                        someTrue = true;
                    }
                    else {
                        someFalse = true;
                    }
                    return someTrue && someFalse;
                });
                // returning `undefined` means the checkbox status is indeterminate.
                // if not mixed and some true, all must be true
                return mixed ? undefined : someTrue;
            }
            else {
                return this.valueModel.isKeySelected(i.key);
            }
        };
        if (!this.setFilterParams.defaultToNothingSelected) {
            // everything selected by default
            return recursiveChildSelectionCheck(item);
        }
        else {
            // nothing selected by default
            return this.valueModel.hasSelections() && recursiveChildSelectionCheck(item);
        }
    }
    destroy() {
        this.virtualList = this.destroyBean(this.virtualList);
        super.destroy();
    }
    caseFormat(valueToFormat) {
        if (valueToFormat == null || typeof valueToFormat !== 'string') {
            return valueToFormat;
        }
        return this.caseSensitive ? valueToFormat : valueToFormat.toUpperCase();
    }
    resetExpansion() {
        if (!this.setFilterParams.treeList) {
            return;
        }
        const selectAllItem = this.valueModel.getSelectAllItem();
        if (this.isSetFilterModelTreeItem(selectAllItem)) {
            const recursiveCollapse = (i) => {
                if (i.children) {
                    i.children.forEach((childItem) => recursiveCollapse(childItem));
                    i.expanded = false;
                }
            };
            recursiveCollapse(selectAllItem);
            this.valueModel.updateDisplayedValues('expansion');
        }
    }
    getModelAsString(model) {
        return this.filterModelFormatter.getModelAsString(model, this);
    }
    getPositionableElement() {
        return this.eSetFilterList;
    }
}
exports.SetFilter = SetFilter;
class ModelWrapper {
    constructor(model) {
        this.model = model;
    }
    getRowCount() {
        return this.model.getDisplayedValueCount();
    }
    getRow(index) {
        return this.model.getDisplayedItem(index);
    }
    areRowsEqual(oldRow, newRow) {
        return oldRow === newRow;
    }
}
class ModelWrapperWithSelectAll {
    constructor(model, isSelectAllSelected) {
        this.model = model;
        this.isSelectAllSelected = isSelectAllSelected;
    }
    getRowCount() {
        const showAddCurrentSelectionToFilter = this.model.showAddCurrentSelectionToFilter();
        const outboundItems = showAddCurrentSelectionToFilter ? 2 : 1;
        return this.model.getDisplayedValueCount() + outboundItems;
    }
    getRow(index) {
        if (index === 0) {
            return this.model.getSelectAllItem();
        }
        const showAddCurrentSelectionToFilter = this.model.showAddCurrentSelectionToFilter();
        const outboundItems = showAddCurrentSelectionToFilter ? 2 : 1;
        if (index === 1 && showAddCurrentSelectionToFilter) {
            return this.model.getAddSelectionToFilterItem();
        }
        return this.model.getDisplayedItem(index - outboundItems);
    }
    areRowsEqual(oldRow, newRow) {
        return oldRow === newRow;
    }
}
// isRowSelected is used by VirtualList to add aria tags for flat lists. We want to suppress this when using trees
class TreeModelWrapper {
    constructor(model) {
        this.model = model;
    }
    getRowCount() {
        return this.model.getRowCount();
    }
    getRow(index) {
        return this.model.getRow(index);
    }
    areRowsEqual(oldRow, newRow) {
        if (oldRow == null && newRow == null) {
            return true;
        }
        return oldRow != null && newRow != null && oldRow.treeKey === newRow.treeKey && oldRow.depth === newRow.depth;
    }
}


/***/ }),

/***/ 105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetFilterListItem = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
/** @param V type of value in the Set Filter */
class SetFilterListItem extends ag_grid_community_1.Component {
    constructor(params) {
        super(params.isGroup
            ? /* html */ `
            <div class="ag-set-filter-item" aria-hidden="true">
                <span class="ag-set-filter-group-icons">
                    <span class="ag-set-filter-group-closed-icon" data-ref="eGroupClosedIcon"></span>
                    <span class="ag-set-filter-group-opened-icon" data-ref="eGroupOpenedIcon"></span>
                    <span class="ag-set-filter-group-indeterminate-icon" data-ref="eGroupIndeterminateIcon"></span>
                </span>
                <ag-checkbox data-ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
            </div>`
            : /* html */ `
            <div class="ag-set-filter-item">
                <ag-checkbox data-ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
            </div>`, [ag_grid_community_1.AgCheckboxSelector]);
        this.eCheckbox = ag_grid_community_1.RefPlaceholder;
        this.eGroupOpenedIcon = ag_grid_community_1.RefPlaceholder;
        this.eGroupClosedIcon = ag_grid_community_1.RefPlaceholder;
        this.eGroupIndeterminateIcon = ag_grid_community_1.RefPlaceholder;
        this.formattedValue = null;
        this.focusWrapper = params.focusWrapper;
        this.value = params.value;
        this.params = params.params;
        this.translate = params.translate;
        this.valueFormatter = params.valueFormatter;
        this.item = params.item;
        this.isSelected = params.isSelected;
        this.isTree = params.isTree;
        this.depth = params.depth ?? 0;
        this.isGroup = params.isGroup;
        this.groupsExist = params.groupsExist;
        this.isExpanded = params.isExpanded;
        this.hasIndeterminateExpandState = params.hasIndeterminateExpandState;
    }
    postConstruct() {
        this.tooltipFeature = this.createOptionalManagedBean(this.beans.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getColDef: () => this.params.colDef,
            getColumn: () => this.params.column,
            getLocation: () => 'setFilterValue',
            shouldDisplayTooltip: () => this.shouldDisplayTooltip?.() ?? true,
            getValueFormatted: () => this.formattedValue,
            getAdditionalParams: () => (this.isTree ? { level: this.depth } : {}),
        }));
        this.addDestroyFunc(() => this.destroyCellRendererComponent?.());
        this.render();
        this.eCheckbox
            .setLabelEllipsis(true)
            .setValue(this.isSelected, true)
            .setDisabled(!!this.params.readOnly)
            .getInputElement()
            .setAttribute('tabindex', '-1');
        this.refreshVariableAriaLabels();
        if (this.isTree) {
            if (this.depth > 0) {
                this.addCssClass('ag-set-filter-indent-' + this.depth);
                this.getGui().style.setProperty('--ag-indentation-level', String(this.depth));
            }
            if (this.isGroup) {
                this.setupExpansion();
            }
            else {
                if (this.groupsExist) {
                    this.addCssClass('ag-set-filter-add-group-indent');
                }
            }
            (0, ag_grid_community_1._setAriaLevel)(this.getAriaElement(), this.depth + 1);
        }
        this.refreshAriaChecked();
        if (this.params.readOnly) {
            // Don't add event listeners if we're read-only.
            return;
        }
        this.eCheckbox.onValueChange((value) => this.onCheckboxChanged(!!value));
    }
    getFocusableElement() {
        return this.focusWrapper;
    }
    setupExpansion() {
        const { eGroupClosedIcon, eGroupOpenedIcon, eGroupIndeterminateIcon, hasIndeterminateExpandState, beans } = this;
        eGroupClosedIcon.appendChild((0, ag_grid_community_1._createIcon)('setFilterGroupClosed', beans, null));
        eGroupOpenedIcon.appendChild((0, ag_grid_community_1._createIcon)('setFilterGroupOpen', beans, null));
        const listener = this.onExpandOrContractClicked.bind(this);
        this.addManagedElementListeners(eGroupClosedIcon, { click: listener });
        this.addManagedElementListeners(eGroupOpenedIcon, { click: listener });
        if (hasIndeterminateExpandState) {
            eGroupIndeterminateIcon.appendChild((0, ag_grid_community_1._createIcon)('setFilterGroupIndeterminate', beans, null));
            this.addManagedElementListeners(eGroupIndeterminateIcon, {
                click: listener,
            });
        }
        this.setExpandedIcons();
        this.refreshAriaExpanded();
    }
    onExpandOrContractClicked() {
        this.setExpanded(!this.isExpanded);
    }
    setExpanded(isExpanded, silent) {
        if (this.isGroup && isExpanded !== this.isExpanded) {
            this.isExpanded = isExpanded;
            const event = {
                type: 'expandedChanged',
                isExpanded: !!isExpanded,
                item: this.item,
            };
            if (!silent) {
                this.dispatchLocalEvent(event);
            }
            this.setExpandedIcons();
            this.refreshAriaExpanded();
        }
    }
    setExpandedIcons() {
        const { isExpanded, hasIndeterminateExpandState, eGroupClosedIcon, eGroupOpenedIcon, eGroupIndeterminateIcon } = this;
        (0, ag_grid_community_1._setDisplayed)(eGroupClosedIcon, hasIndeterminateExpandState ? isExpanded === false : !isExpanded);
        (0, ag_grid_community_1._setDisplayed)(eGroupOpenedIcon, isExpanded === true);
        if (hasIndeterminateExpandState) {
            (0, ag_grid_community_1._setDisplayed)(eGroupIndeterminateIcon, isExpanded === undefined);
        }
    }
    onCheckboxChanged(isSelected) {
        this.isSelected = isSelected;
        const event = {
            type: 'selectionChanged',
            isSelected,
            item: this.item,
        };
        this.dispatchLocalEvent(event);
        this.refreshVariableAriaLabels();
        this.refreshAriaChecked();
    }
    toggleSelected() {
        if (this.params.readOnly) {
            return;
        }
        this.setSelected(!this.isSelected);
    }
    setSelected(isSelected, silent) {
        this.isSelected = isSelected;
        this.eCheckbox.setValue(isSelected, silent);
        this.refreshAriaChecked();
    }
    refreshVariableAriaLabels() {
        if (!this.isTree) {
            return;
        }
        const translate = this.getLocaleTextFunc();
        const checkboxValue = this.eCheckbox.getValue();
        const state = checkboxValue === undefined
            ? translate('ariaIndeterminate', 'indeterminate')
            : checkboxValue
                ? translate('ariaVisible', 'visible')
                : translate('ariaHidden', 'hidden');
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        (0, ag_grid_community_1._setAriaLabelledBy)(this.eCheckbox.getInputElement(), undefined);
        this.eCheckbox.setInputAriaLabel(`${visibilityLabel} (${state})`);
    }
    setupFixedAriaLabels(value) {
        if (!this.isTree) {
            return;
        }
        const translate = this.getLocaleTextFunc();
        const itemLabel = translate('ariaFilterValue', 'Filter Value');
        const ariaEl = this.getAriaElement();
        (0, ag_grid_community_1._setAriaLabel)(ariaEl, `${value} ${itemLabel}`);
        (0, ag_grid_community_1._setAriaDescribedBy)(ariaEl, this.eCheckbox.getInputElement().id);
    }
    refreshAriaChecked() {
        const ariaEl = this.getAriaElement();
        (0, ag_grid_community_1._setAriaChecked)(ariaEl, this.eCheckbox.getValue());
    }
    refreshAriaExpanded() {
        (0, ag_grid_community_1._setAriaExpanded)(this.getAriaElement(), !!this.isExpanded);
    }
    refresh(item, isSelected, isExpanded) {
        this.item = item;
        // setExpanded checks if value has changed, setSelected does not
        if (isSelected !== this.isSelected) {
            this.setSelected(isSelected, true);
        }
        this.setExpanded(isExpanded, true);
        const { cellRendererComponent, cellRendererParams, beans, params } = this;
        if (this.valueFunction) {
            // underlying value might have changed, so call again and re-render
            const value = this.valueFunction();
            this.setTooltipAndCellRendererParams(value, value);
            if (!cellRendererComponent) {
                this.renderCellWithoutCellRenderer();
            }
        }
        if (cellRendererComponent) {
            // need to get correct params for refresh from comp details
            const compDetails = (0, ag_grid_community_1._getCellRendererDetails)(beans.userCompFactory, params, cellRendererParams);
            const success = cellRendererComponent.refresh?.(compDetails?.params ?? cellRendererParams);
            if (!success) {
                const oldComponent = cellRendererComponent;
                this.renderCell();
                this.destroyBean(oldComponent);
            }
        }
    }
    render() {
        const { params: { column }, } = this;
        let { value } = this;
        let formattedValue = null;
        if (typeof value === 'function') {
            this.valueFunction = value;
            formattedValue = this.valueFunction();
            // backwards compatibility for select all in value
            value = formattedValue;
        }
        else if (this.isTree) {
            // tree values are already formatted via treeListFormatter
            formattedValue = (0, ag_grid_community_1._toStringOrNull)(value);
        }
        else {
            formattedValue = this.getFormattedValue(column, value);
        }
        this.formattedValue = formattedValue;
        this.setTooltipAndCellRendererParams(value, formattedValue);
        this.renderCell();
    }
    setTooltipAndCellRendererParams(value, formattedValue) {
        const gos = this.gos;
        if (this.params.showTooltips && (!(0, ag_grid_community_1._isShowTooltipWhenTruncated)(gos) || !this.params.cellRenderer)) {
            const newTooltipText = formattedValue != null ? formattedValue : (0, ag_grid_community_1._toStringOrNull)(value);
            this.shouldDisplayTooltip = (0, ag_grid_community_1._getShouldDisplayTooltip)(gos, () => this.eCheckbox.getGui().querySelector('.ag-label'));
            this.tooltipFeature?.setTooltipAndRefresh(newTooltipText);
        }
        this.cellRendererParams = gos.addGridCommonParams({
            value,
            valueFormatted: formattedValue,
            colDef: this.params.colDef,
            column: this.params.column,
            setTooltip: (value, shouldDisplayTooltip) => {
                gos.assertModuleRegistered('Tooltip', 3);
                this.shouldDisplayTooltip = shouldDisplayTooltip;
                this.tooltipFeature?.setTooltipAndRefresh(value);
            },
        });
    }
    getFormattedValue(column, value) {
        return this.beans.valueSvc.formatValue(column, null, value, this.valueFormatter, false);
    }
    renderCell() {
        const compDetails = (0, ag_grid_community_1._getCellRendererDetails)(this.beans.userCompFactory, this.params, this.cellRendererParams);
        const cellRendererPromise = compDetails?.newAgStackInstance();
        if (cellRendererPromise == null) {
            this.renderCellWithoutCellRenderer();
            return;
        }
        cellRendererPromise.then((component) => {
            if (component) {
                this.cellRendererComponent = component;
                this.eCheckbox.setLabel(component.getGui());
                this.destroyCellRendererComponent = () => this.destroyBean(component);
            }
        });
    }
    renderCellWithoutCellRenderer() {
        const { valueFormatted, value } = this.cellRendererParams;
        let valueToRender = (valueFormatted == null ? value : valueFormatted) ?? this.translate('blanks');
        if (typeof valueToRender !== 'string') {
            (0, ag_grid_community_1._warn)(208);
            valueToRender = '';
        }
        this.eCheckbox.setLabel(valueToRender);
        this.setupFixedAriaLabels(valueToRender);
    }
    getComponentHolder() {
        return this.params.column.getColDef();
    }
}
exports.SetFilterListItem = SetFilterListItem;


/***/ }),

/***/ 5355:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetFilterModelFormatter = void 0;
class SetFilterModelFormatter {
    getModelAsString(model, setFilter) {
        const { values } = model || setFilter.getModel() || {};
        const valueModel = setFilter.getValueModel();
        if (values == null || valueModel == null) {
            return '';
        }
        const availableKeys = values.filter((v) => valueModel.isKeyAvailable(v));
        const numValues = availableKeys.length;
        const formattedValues = availableKeys.slice(0, 10).map((key) => setFilter.getFormattedValue(key));
        return `(${numValues}) ${formattedValues.join(',')}${numValues > 10 ? ',...' : ''}`;
    }
}
exports.SetFilterModelFormatter = SetFilterModelFormatter;


/***/ }),

/***/ 9002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetFilterModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const setFilter_1 = __webpack_require__(2734);
const setFloatingFilter_1 = __webpack_require__(4716);
/**
 * @feature Filtering -> Set Filter
 */
exports.SetFilterModule = {
    moduleName: 'SetFilter',
    version: version_1.VERSION,
    userComponents: { agSetColumnFilter: setFilter_1.SetFilter, agSetColumnFloatingFilter: setFloatingFilter_1.SetFloatingFilterComp },
    icons: {
        // set filter tree list group contracted (click to expand)
        setFilterGroupClosed: 'tree-closed',
        // set filter tree list group expanded (click to contract)
        setFilterGroupOpen: 'tree-open',
        // set filter tree list expand/collapse all button, shown when some children are expanded and
        //     others are collapsed
        setFilterGroupIndeterminate: 'tree-indeterminate',
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._ColumnFilterModule],
};


/***/ }),

/***/ 2270:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processDataPath = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function processDataPath(dataPath, treeData, groupAllowUnbalanced) {
    let processedDataPath = dataPath;
    if (!processedDataPath) {
        return null;
    }
    processedDataPath = processedDataPath.map((treeKey) => (0, ag_grid_community_1._toStringOrNull)((0, ag_grid_community_1._makeNull)(treeKey)));
    // leave `null`s in the path unless unbalanced groups
    if (!treeData && groupAllowUnbalanced && processedDataPath.some((treeKey) => treeKey == null)) {
        if ((0, ag_grid_community_1._last)(processedDataPath) == null) {
            return null;
        }
        return processedDataPath.filter((treeKey) => treeKey != null);
    }
    return processedDataPath;
}
exports.processDataPath = processDataPath;


/***/ }),

/***/ 4716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetFloatingFilterComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const setFilter_1 = __webpack_require__(2734);
const setFilterModelFormatter_1 = __webpack_require__(5355);
class SetFloatingFilterComp extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.colNames = beans.colNames;
    }
    constructor() {
        super(
        /* html */ `
            <div class="ag-floating-filter-input ag-set-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`, [ag_grid_community_1.AgInputTextFieldSelector]);
        this.eFloatingFilterText = ag_grid_community_1.RefPlaceholder;
        this.availableValuesListenerAdded = false;
        this.filterModelFormatter = new setFilterModelFormatter_1.SetFilterModelFormatter();
    }
    init(params) {
        this.params = params;
        this.eFloatingFilterText.setDisabled(true).addGuiEventListener('click', () => this.params.showParentFilter());
        this.setParams(params);
    }
    setParams(params) {
        const displayName = this.colNames.getDisplayNameForColumn(params.column, 'header', true);
        const translate = this.getLocaleTextFunc();
        this.eFloatingFilterText.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);
    }
    refresh(params) {
        this.params = params;
        this.setParams(params);
    }
    onParentModelChanged(parentModel) {
        this.updateFloatingFilterText(parentModel);
    }
    parentSetFilterInstance(cb) {
        this.params.parentFilterInstance((filter) => {
            if (!(filter instanceof setFilter_1.SetFilter)) {
                (0, ag_grid_community_1._error)(248);
                return;
            }
            cb(filter);
        });
    }
    addAvailableValuesListener() {
        this.parentSetFilterInstance((setFilter) => {
            const setValueModel = setFilter.getValueModel();
            if (!setValueModel) {
                return;
            }
            // unlike other filters, what we show in the floating filter can be different, even
            // if another filter changes. this is due to how set filter restricts its values based
            // on selections in other filters, e.g. if you filter Language to English, then the set filter
            // on Country will only show English speaking countries. Thus the list of items to show
            // in the floating filter can change.
            this.addManagedListeners(setValueModel, { availableValuesChanged: () => this.updateFloatingFilterText() });
        });
        this.availableValuesListenerAdded = true;
    }
    updateFloatingFilterText(parentModel) {
        if (!this.availableValuesListenerAdded) {
            this.addAvailableValuesListener();
        }
        this.parentSetFilterInstance((setFilter) => {
            this.eFloatingFilterText.setValue(this.filterModelFormatter.getModelAsString(parentModel, setFilter));
        });
    }
}
exports.SetFloatingFilterComp = SetFloatingFilterComp;


/***/ }),

/***/ 4366:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetValueModel = exports.SetFilterModelValuesType = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const clientSideValueExtractor_1 = __webpack_require__(4737);
const filteringKeys_1 = __webpack_require__(4510);
const flatSetDisplayValueModel_1 = __webpack_require__(8053);
const treeSetDisplayValueModel_1 = __webpack_require__(5546);
var SetFilterModelValuesType;
(function (SetFilterModelValuesType) {
    SetFilterModelValuesType[SetFilterModelValuesType["PROVIDED_LIST"] = 0] = "PROVIDED_LIST";
    SetFilterModelValuesType[SetFilterModelValuesType["PROVIDED_CALLBACK"] = 1] = "PROVIDED_CALLBACK";
    SetFilterModelValuesType[SetFilterModelValuesType["TAKEN_FROM_GRID_VALUES"] = 2] = "TAKEN_FROM_GRID_VALUES";
})(SetFilterModelValuesType || (exports.SetFilterModelValuesType = SetFilterModelValuesType = {}));
/** @param V type of value in the Set Filter */
class SetValueModel {
    constructor(params) {
        this.localEventService = new ag_grid_community_1.LocalEventService();
        this.miniFilterText = null;
        /** When true, in excelMode = 'windows', it adds previously selected filter items to newly checked filter selection */
        this.addCurrentSelectionToFilter = false;
        /** Values provided to the filter for use. */
        this.providedValues = null;
        /** All possible values for the filter, sorted if required. */
        this.allValues = new Map();
        /** Remaining keys when filters from other columns have been applied. */
        this.availableKeys = new Set();
        /** Keys that have been selected for this filter. */
        this.selectedKeys = new Set();
        this.initialised = false;
        const { usingComplexObjects, rowGroupColsSvc, valueSvc, treeDataTreeList, groupingTreeList, filterParams, gos, valueFormatter, addManagedEventListeners, } = params;
        const { column, colDef, textFormatter, doesRowPassOtherFilter, suppressSorting, comparator, rowModel, values, caseSensitive, treeList, treeListPathGetter, treeListFormatter, } = filterParams;
        this.filterParams = filterParams;
        this.gos = gos;
        this.setIsLoading = params.setIsLoading;
        this.translate = params.translate;
        this.caseFormat = params.caseFormat;
        this.createKey = params.createKey;
        this.usingComplexObjects = !!params.usingComplexObjects;
        this.formatter = textFormatter ?? ((value) => value ?? null);
        this.doesRowPassOtherFilters = doesRowPassOtherFilter;
        this.suppressSorting = suppressSorting || false;
        this.filteringKeys = new filteringKeys_1.SetValueModelFilteringKeys({ caseFormat: this.caseFormat });
        const keyComparator = comparator ?? colDef.comparator;
        const treeDataOrGrouping = !!treeDataTreeList || !!groupingTreeList;
        // If using complex objects and a comparator is provided, sort by values, otherwise need to sort by the string keys.
        // Also if tree data, grouping, or date with tree list, then need to do value sort
        this.compareByValue = !!((usingComplexObjects && keyComparator) ||
            treeDataOrGrouping ||
            (treeList && !treeListPathGetter));
        if (treeDataOrGrouping && !keyComparator) {
            this.entryComparator = this.createTreeDataOrGroupingComparator();
        }
        else if (treeList && !treeListPathGetter && !keyComparator) {
            this.entryComparator = ([_aKey, aValue], [_bKey, bValue]) => (0, ag_grid_community_1._defaultComparator)(aValue, bValue);
        }
        else {
            this.entryComparator = ([_aKey, aValue], [_bKey, bValue]) => keyComparator(aValue, bValue);
        }
        this.keyComparator = keyComparator ?? ag_grid_community_1._defaultComparator;
        this.caseSensitive = !!caseSensitive;
        const groupAllowUnbalanced = gos.get('groupAllowUnbalanced');
        if ((0, ag_grid_community_1._isClientSideRowModel)(gos, rowModel)) {
            this.clientSideValuesExtractor = new clientSideValueExtractor_1.ClientSideValuesExtractor(rowModel, this.filterParams, this.createKey, this.caseFormat, valueSvc, treeDataOrGrouping, !!treeDataTreeList, groupAllowUnbalanced, addManagedEventListeners, rowGroupColsSvc);
        }
        if (values == null) {
            this.valuesType = SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
        }
        else {
            this.valuesType = Array.isArray(values)
                ? SetFilterModelValuesType.PROVIDED_LIST
                : SetFilterModelValuesType.PROVIDED_CALLBACK;
            this.providedValues = values;
        }
        this.displayValueModel = treeList
            ? new treeSetDisplayValueModel_1.TreeSetDisplayValueModel(this.formatter, treeListPathGetter, treeListFormatter, treeDataTreeList || groupingTreeList)
            : new flatSetDisplayValueModel_1.FlatSetDisplayValueModel(valueSvc, valueFormatter, this.formatter, column);
        this.updateAllValues().then((updatedKeys) => this.resetSelectionState(updatedKeys || []));
    }
    addEventListener(eventType, listener, async) {
        this.localEventService.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, listener, async) {
        this.localEventService.removeEventListener(eventType, listener, async);
    }
    updateOnParamsChange(filterParams) {
        return new ag_grid_community_1.AgPromise((resolve) => {
            const { values, textFormatter, suppressSorting, treeListFormatter } = filterParams;
            const currentProvidedValues = this.providedValues;
            const currentSuppressSorting = this.suppressSorting;
            this.filterParams = filterParams;
            this.formatter = textFormatter ?? ((value) => value ?? null);
            this.suppressSorting = suppressSorting || false;
            this.providedValues = values ?? null;
            if (this.displayValueModel instanceof treeSetDisplayValueModel_1.TreeSetDisplayValueModel) {
                this.displayValueModel.updateOnParamsChange(treeListFormatter);
            }
            // Rebuild values when values or their sort order changes
            if (this.providedValues !== currentProvidedValues || this.suppressSorting !== currentSuppressSorting) {
                if (!values || values.length === 0) {
                    this.valuesType = SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
                    this.providedValues = null;
                }
                else {
                    this.valuesType = Array.isArray(values)
                        ? SetFilterModelValuesType.PROVIDED_LIST
                        : SetFilterModelValuesType.PROVIDED_CALLBACK;
                }
                const currentModel = this.getModel();
                this.updateAllValues().then(() => {
                    this.setModel(currentModel).then(() => resolve());
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Re-fetches the values used in the filter from the value source.
     * If keepSelection is false, the filter selection will be reset to everything selected,
     * otherwise the current selection will be preserved.
     */
    refreshValues() {
        return new ag_grid_community_1.AgPromise((resolve) => {
            // don't get the model until values are resolved, as there could be queued setModel calls
            this.allValuesPromise.then(() => {
                const currentModel = this.getModel();
                this.updateAllValues();
                // ensure model is updated for new values
                this.setModel(currentModel).then(() => resolve());
            });
        });
    }
    /**
     * Overrides the current values being used for the set filter.
     * If keepSelection is false, the filter selection will be reset to everything selected,
     * otherwise the current selection will be preserved.
     */
    overrideValues(valuesToUse) {
        return new ag_grid_community_1.AgPromise((resolve) => {
            // wait for any existing values to be populated before overriding
            this.allValuesPromise.then(() => {
                this.valuesType = SetFilterModelValuesType.PROVIDED_LIST;
                this.providedValues = valuesToUse;
                this.refreshValues().then(() => resolve());
            });
        });
    }
    /** @return has anything been updated */
    refreshAfterAnyFilterChanged() {
        if (this.showAvailableOnly()) {
            return this.allValuesPromise.then((keys) => {
                this.updateAvailableKeys(keys ?? [], 'otherFilter');
                return true;
            });
        }
        return ag_grid_community_1.AgPromise.resolve(false);
    }
    isInitialised() {
        return this.initialised;
    }
    updateAllValues() {
        this.allValuesPromise = new ag_grid_community_1.AgPromise((resolve) => {
            switch (this.valuesType) {
                case SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES:
                    this.getValuesFromRowsAsync(false).then((values) => resolve(this.processAllValues(values)));
                    break;
                case SetFilterModelValuesType.PROVIDED_LIST: {
                    resolve(this.processAllValues(this.uniqueValues(this.validateProvidedValues(this.providedValues))));
                    break;
                }
                case SetFilterModelValuesType.PROVIDED_CALLBACK: {
                    this.setIsLoading(true);
                    const callback = this.providedValues;
                    const { column, colDef } = this.filterParams;
                    const params = this.gos.addGridCommonParams({
                        success: (values) => {
                            this.setIsLoading(false);
                            resolve(this.processAllValues(this.uniqueValues(this.validateProvidedValues(values))));
                        },
                        colDef,
                        column,
                    });
                    window.setTimeout(() => callback(params), 0);
                    break;
                }
            }
        });
        this.allValuesPromise
            .then((values) => this.updateAvailableKeys(values || [], 'reload'))
            .then(() => (this.initialised = true));
        return this.allValuesPromise;
    }
    processAllValues(values) {
        const sortedKeys = this.sortKeys(values);
        this.allValues = values ?? new Map();
        return sortedKeys;
    }
    validateProvidedValues(values) {
        if (this.usingComplexObjects && values?.length) {
            const firstValue = values[0];
            if (firstValue && typeof firstValue !== 'object' && typeof firstValue !== 'function') {
                const firstKey = this.createKey(firstValue);
                if (firstKey == null) {
                    (0, ag_grid_community_1._warn)(209);
                }
                else {
                    (0, ag_grid_community_1._warn)(210);
                }
            }
        }
        return values;
    }
    setValuesType(value) {
        this.valuesType = value;
    }
    getValuesType() {
        return this.valuesType;
    }
    isKeyAvailable(key) {
        return this.availableKeys.has(key);
    }
    showAvailableOnly() {
        return this.valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
    }
    updateAvailableKeys(allKeys, source) {
        const availableKeys = this.showAvailableOnly() ? this.sortKeys(this.getValuesFromRows(true)) : allKeys;
        this.availableKeys = new Set(availableKeys);
        this.localEventService.dispatchEvent({ type: 'availableValuesChanged' });
        this.updateDisplayedValues(source, allKeys);
    }
    sortKeys(nullableValues) {
        const values = nullableValues ?? new Map();
        if (this.suppressSorting) {
            return Array.from(values.keys());
        }
        let sortedKeys;
        if (this.compareByValue) {
            sortedKeys = Array.from(values.entries())
                .sort(this.entryComparator)
                .map(([key]) => key);
        }
        else {
            sortedKeys = Array.from(values.keys()).sort(this.keyComparator);
        }
        if (this.filterParams.excelMode && values.has(null)) {
            // ensure the blank value always appears last
            sortedKeys = sortedKeys.filter((v) => v != null);
            sortedKeys.push(null);
        }
        return sortedKeys;
    }
    getParamsForValuesFromRows(removeUnavailableValues = false) {
        if (!this.clientSideValuesExtractor) {
            (0, ag_grid_community_1._error)(113);
            return null;
        }
        const predicate = (node) => !removeUnavailableValues || this.doesRowPassOtherFilters(node);
        const existingValues = removeUnavailableValues && !this.caseSensitive ? this.allValues : undefined;
        return { predicate, existingValues };
    }
    getValuesFromRows(removeUnavailableValues = false) {
        const params = this.getParamsForValuesFromRows(removeUnavailableValues);
        if (!params) {
            return null;
        }
        return this.clientSideValuesExtractor.extractUniqueValues(params.predicate, params.existingValues);
    }
    getValuesFromRowsAsync(removeUnavailableValues = false) {
        const params = this.getParamsForValuesFromRows(removeUnavailableValues);
        if (!params) {
            return ag_grid_community_1.AgPromise.resolve(null);
        }
        return this.clientSideValuesExtractor.extractUniqueValuesAsync(params.predicate, params.existingValues);
    }
    /** Sets mini filter value. Returns true if it changed from last value, otherwise false. */
    setMiniFilter(value) {
        value = (0, ag_grid_community_1._makeNull)(value);
        if (this.miniFilterText === value) {
            //do nothing if filter has not changed
            return false;
        }
        if (value === null) {
            // Reset 'Add current selection to filter' checkbox when clearing mini filter
            this.setAddCurrentSelectionToFilter(false);
        }
        this.miniFilterText = value;
        this.updateDisplayedValues('miniFilter');
        return true;
    }
    getMiniFilter() {
        return this.miniFilterText;
    }
    updateDisplayedValues(source, allKeys) {
        if (source === 'expansion') {
            this.displayValueModel.refresh();
            return;
        }
        // if no filter, just display all available values
        if (this.miniFilterText == null) {
            this.displayValueModel.updateDisplayedValuesToAllAvailable((key) => this.getValue(key), allKeys, this.availableKeys, source);
            return;
        }
        // if filter present, we filter down the list
        // to allow for case insensitive searches, upper-case both filter text and value
        const formattedFilterText = this.caseFormat(this.formatter(this.miniFilterText) || '');
        const matchesFilter = (valueToCheck) => valueToCheck != null && this.caseFormat(valueToCheck).indexOf(formattedFilterText) >= 0;
        const nullMatchesFilter = !!this.filterParams.excelMode && matchesFilter(this.translate('blanks'));
        this.displayValueModel.updateDisplayedValuesToMatchMiniFilter((key) => this.getValue(key), allKeys, this.availableKeys, matchesFilter, nullMatchesFilter, source);
    }
    getDisplayedValueCount() {
        return this.displayValueModel.getDisplayedValueCount();
    }
    getDisplayedItem(index) {
        return this.displayValueModel.getDisplayedItem(index);
    }
    getSelectAllItem() {
        return this.displayValueModel.getSelectAllItem();
    }
    getAddSelectionToFilterItem() {
        return this.displayValueModel.getAddSelectionToFilterItem();
    }
    hasSelections() {
        return this.filterParams.defaultToNothingSelected
            ? this.selectedKeys.size > 0
            : this.allValues.size !== this.selectedKeys.size;
    }
    getKeys() {
        return Array.from(this.allValues.keys());
    }
    getValues() {
        return Array.from(this.allValues.values());
    }
    getValue(key) {
        return this.allValues.get(key);
    }
    setAddCurrentSelectionToFilter(value) {
        this.addCurrentSelectionToFilter = value;
    }
    isInWindowsExcelMode() {
        return this.filterParams.excelMode === 'windows';
    }
    isAddCurrentSelectionToFilterChecked() {
        return this.isInWindowsExcelMode() && this.addCurrentSelectionToFilter;
    }
    showAddCurrentSelectionToFilter() {
        // We only show the 'Add current selection to filter' option
        // when excel mode is enabled with 'windows' mode
        // and when the users types a value in the mini filter.
        return this.isInWindowsExcelMode() && (0, ag_grid_community_1._exists)(this.miniFilterText) && this.miniFilterText.length > 0;
    }
    selectAllMatchingMiniFilter(clearExistingSelection = false) {
        if (this.miniFilterText == null) {
            // ensure everything is selected
            this.selectedKeys = new Set(this.allValues.keys());
        }
        else {
            // ensure everything that matches the mini filter is selected
            if (clearExistingSelection) {
                this.selectedKeys.clear();
            }
            this.displayValueModel.forEachDisplayedKey((key) => this.selectedKeys.add(key));
        }
    }
    deselectAllMatchingMiniFilter() {
        if (this.miniFilterText == null) {
            // ensure everything is deselected
            this.selectedKeys.clear();
        }
        else {
            // ensure everything that matches the mini filter is deselected
            this.displayValueModel.forEachDisplayedKey((key) => this.selectedKeys.delete(key));
        }
    }
    selectKey(key) {
        this.selectedKeys.add(key);
    }
    deselectKey(key) {
        if (this.filterParams.excelMode && this.isEverythingVisibleSelected()) {
            // ensure we're starting from the correct "everything selected" state
            this.resetSelectionState(this.displayValueModel.getDisplayedKeys());
        }
        this.selectedKeys.delete(key);
    }
    isKeySelected(key) {
        return this.selectedKeys.has(key);
    }
    isEverythingVisibleSelected() {
        return !this.displayValueModel.someDisplayedKey((it) => !this.isKeySelected(it));
    }
    isNothingVisibleSelected() {
        return !this.displayValueModel.someDisplayedKey((it) => this.isKeySelected(it));
    }
    getModel() {
        if (!this.hasSelections()) {
            return null;
        }
        // When excelMode = 'windows' and the user has ticked 'Add current selection to filter'
        // the filtering keys can be different from the selected keys, and they should be included
        // in the model.
        const filteringKeys = this.isAddCurrentSelectionToFilterChecked()
            ? this.filteringKeys.allFilteringKeys()
            : null;
        if (filteringKeys && filteringKeys.size > 0) {
            if (this.selectedKeys) {
                // When existing filtering keys are present along with selected keys,
                // we combine them and return the result.
                // We use a set structure to avoid duplicates
                const modelKeys = new Set([
                    ...Array.from(filteringKeys),
                    ...Array.from(this.selectedKeys).filter((key) => !filteringKeys.has(key)),
                ]);
                return Array.from(modelKeys);
            }
            return Array.from(filteringKeys);
        }
        // No extra filtering keys are present - so just return the selected keys
        return Array.from(this.selectedKeys);
    }
    setModel(model) {
        return this.allValuesPromise.then((keys) => {
            if (model == null) {
                this.resetSelectionState(keys ?? []);
            }
            else {
                // select all values from the model that exist in the filter
                this.selectedKeys.clear();
                const existingFormattedKeys = new Map();
                this.allValues.forEach((_value, key) => {
                    existingFormattedKeys.set(this.caseFormat(key), key);
                });
                model.forEach((unformattedKey) => {
                    const formattedKey = this.caseFormat((0, ag_grid_community_1._makeNull)(unformattedKey));
                    const existingUnformattedKey = existingFormattedKeys.get(formattedKey);
                    if (existingUnformattedKey !== undefined) {
                        this.selectKey(existingUnformattedKey);
                    }
                });
            }
        });
    }
    uniqueValues(values) {
        const uniqueValues = new Map();
        const formattedKeys = new Set();
        (values ?? []).forEach((value) => {
            const valueToUse = (0, ag_grid_community_1._makeNull)(value);
            const unformattedKey = this.createKey(valueToUse);
            const formattedKey = this.caseFormat(unformattedKey);
            if (!formattedKeys.has(formattedKey)) {
                formattedKeys.add(formattedKey);
                uniqueValues.set(unformattedKey, valueToUse);
            }
        });
        return uniqueValues;
    }
    resetSelectionState(keys) {
        if (this.filterParams.defaultToNothingSelected) {
            this.selectedKeys.clear();
        }
        else {
            this.selectedKeys = new Set(keys);
        }
    }
    hasGroups() {
        return this.displayValueModel.hasGroups();
    }
    createTreeDataOrGroupingComparator() {
        return ([_aKey, aValue], [_bKey, bValue]) => {
            if (aValue == null) {
                return bValue == null ? 0 : -1;
            }
            else if (bValue == null) {
                return 1;
            }
            for (let i = 0; i < aValue.length; i++) {
                if (i >= bValue.length) {
                    return 1;
                }
                const diff = (0, ag_grid_community_1._defaultComparator)(aValue[i], bValue[i]);
                if (diff !== 0) {
                    return diff;
                }
            }
            return 0;
        };
    }
    setAppliedModelKeys(appliedModelKeys) {
        this.filteringKeys.setFilteringKeys(appliedModelKeys);
    }
    addToAppliedModelKeys(appliedModelKey) {
        this.filteringKeys.addFilteringKey(appliedModelKey);
    }
    getAppliedModelKeys() {
        return this.filteringKeys.allFilteringKeys();
    }
    getCaseFormattedAppliedModelKeys() {
        return this.filteringKeys.allFilteringKeysCaseFormatted();
    }
    hasAppliedModelKey(appliedModelKey) {
        return this.filteringKeys.hasCaseFormattedFilteringKey(appliedModelKey);
    }
    hasAnyAppliedModelKey() {
        return !this.filteringKeys.hasNoAppliedFilteringKeys;
    }
}
exports.SetValueModel = SetValueModel;


/***/ }),

/***/ 5546:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeSetDisplayValueModel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const iSetDisplayValueModel_1 = __webpack_require__(3335);
const DATE_TREE_LIST_PATH_GETTER = (date) => date ? [String(date.getFullYear()), String(date.getMonth() + 1), String(date.getDate())] : null;
class TreeSetDisplayValueModel {
    constructor(formatter, treeListPathGetter, treeListFormatter, treeDataOrGrouping) {
        this.formatter = formatter;
        this.treeListPathGetter = treeListPathGetter;
        this.treeListFormatter = treeListFormatter;
        this.treeDataOrGrouping = treeDataOrGrouping;
        /** all displayed items in a tree structure */
        this.allDisplayedItemsTree = [];
        /** all displayed items flattened and filtered */
        this.activeDisplayedItemsFlat = [];
        this.selectAllItem = {
            depth: 0,
            filterPasses: true,
            available: true,
            treeKey: iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL,
            children: this.allDisplayedItemsTree,
            expanded: true,
            key: iSetDisplayValueModel_1.SET_FILTER_SELECT_ALL,
            parentTreeKeys: [],
        };
        this.addSelectionToFilterItem = {
            depth: 0,
            filterPasses: true,
            available: true,
            treeKey: iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER,
            expanded: true,
            key: iSetDisplayValueModel_1.SET_FILTER_ADD_SELECTION_TO_FILTER,
            parentTreeKeys: [],
        };
    }
    updateOnParamsChange(treeListFormatter) {
        this.treeListFormatter = treeListFormatter;
    }
    updateDisplayedValuesToAllAvailable(getValue, allKeys, availableKeys, source) {
        if (source === 'reload') {
            this.generateItemTree(getValue, allKeys, availableKeys);
        }
        else if (source === 'otherFilter') {
            this.updateAvailable(availableKeys);
            this.updateExpandAll();
        }
        else if (source === 'miniFilter') {
            this.resetFilter();
            this.updateExpandAll();
        }
        this.flattenItems();
    }
    updateDisplayedValuesToMatchMiniFilter(getValue, allKeys, availableKeys, matchesFilter, nullMatchesFilter, source) {
        if (source === 'reload') {
            this.generateItemTree(getValue, allKeys, availableKeys);
        }
        else if (source === 'otherFilter') {
            this.updateAvailable(availableKeys);
        }
        this.updateFilter(matchesFilter, nullMatchesFilter);
        this.updateExpandAll();
        this.flattenItems();
    }
    generateItemTree(getValue, allKeys, availableKeys) {
        this.allDisplayedItemsTree = [];
        this.groupsExist = false;
        const treeListPathGetter = this.getTreeListPathGetter(getValue, availableKeys);
        for (const key of allKeys) {
            const value = getValue(key);
            const dataPath = treeListPathGetter(value) ?? [null];
            if (dataPath.length > 1) {
                this.groupsExist = true;
            }
            const available = availableKeys.has(key);
            let children = this.allDisplayedItemsTree;
            let item;
            let parentTreeKeys = [];
            dataPath.forEach((treeKey, depth) => {
                if (!children) {
                    children = [];
                    item.children = children;
                }
                item = children.find((child) => child.treeKey?.toUpperCase() === treeKey?.toUpperCase());
                if (!item) {
                    item = { treeKey, depth, filterPasses: true, expanded: false, available, parentTreeKeys };
                    if (depth === dataPath.length - 1) {
                        item.key = key;
                    }
                    children.push(item);
                }
                children = item.children;
                parentTreeKeys = [...parentTreeKeys, treeKey];
            });
        }
        // update the parent availability based on the children
        this.updateAvailable(availableKeys);
        this.selectAllItem.children = this.allDisplayedItemsTree;
        this.selectAllItem.expanded = false;
    }
    getTreeListPathGetter(getValue, availableKeys) {
        if (this.treeListPathGetter) {
            return this.treeListPathGetter;
        }
        if (this.treeDataOrGrouping) {
            return (value) => value;
        }
        // infer from data
        let isDate = false;
        for (const availableKey of availableKeys) {
            // find the first non-null value
            const value = getValue(availableKey);
            if (value instanceof Date) {
                isDate = true;
                break;
            }
            else if (value != null) {
                break;
            }
        }
        if (isDate) {
            return DATE_TREE_LIST_PATH_GETTER;
        }
        (0, ag_grid_community_1._warn)(211);
        return (value) => [String(value)];
    }
    flattenItems() {
        this.activeDisplayedItemsFlat = [];
        const recursivelyFlattenDisplayedItems = (items) => {
            items.forEach((item) => {
                if (!item.filterPasses || !item.available) {
                    return;
                }
                this.activeDisplayedItemsFlat.push(item);
                if (item.children && item.expanded) {
                    recursivelyFlattenDisplayedItems(item.children);
                }
            });
        };
        recursivelyFlattenDisplayedItems(this.allDisplayedItemsTree);
    }
    resetFilter() {
        const recursiveFilterReset = (item) => {
            if (item.children) {
                item.children.forEach((child) => {
                    recursiveFilterReset(child);
                });
            }
            item.filterPasses = true;
        };
        this.allDisplayedItemsTree.forEach((item) => recursiveFilterReset(item));
    }
    updateFilter(matchesFilter, nullMatchesFilter) {
        const passesFilter = (item) => {
            if (!item.available) {
                return false;
            }
            if (item.treeKey == null) {
                return nullMatchesFilter;
            }
            return matchesFilter(this.formatter(this.treeListFormatter
                ? this.treeListFormatter(item.treeKey, item.depth, item.parentTreeKeys)
                : item.treeKey));
        };
        this.allDisplayedItemsTree.forEach((item) => this.recursiveItemCheck(item, false, passesFilter, 'filterPasses'));
    }
    getDisplayedValueCount() {
        return this.activeDisplayedItemsFlat.length;
    }
    getDisplayedItem(index) {
        return this.activeDisplayedItemsFlat[index];
    }
    getSelectAllItem() {
        return this.selectAllItem;
    }
    getAddSelectionToFilterItem() {
        return this.addSelectionToFilterItem;
    }
    getDisplayedKeys() {
        const displayedKeys = [];
        this.forEachDisplayedKey((key) => displayedKeys.push(key));
        return displayedKeys;
    }
    forEachDisplayedKey(func) {
        const recursiveForEachItem = (item, topParentExpanded) => {
            if (item.children) {
                if (!item.expanded || !topParentExpanded) {
                    // if the parent is not expanded, we need to iterate the entire tree
                    item.children.forEach((child) => {
                        if (child.filterPasses) {
                            recursiveForEachItem(child, false);
                        }
                    });
                }
            }
            else {
                func(item.key);
            }
        };
        this.activeDisplayedItemsFlat.forEach((item) => recursiveForEachItem(item, true));
    }
    someDisplayedKey(func) {
        const recursiveSomeItem = (item, topParentExpanded) => {
            if (item.children) {
                if (!item.expanded || !topParentExpanded) {
                    // if the parent is not expanded, we need to iterate the entire tree
                    return item.children.some((child) => {
                        if (child.filterPasses) {
                            return recursiveSomeItem(child, false);
                        }
                        return false;
                    });
                }
            }
            else {
                return func(item.key);
            }
            return false;
        };
        return this.activeDisplayedItemsFlat.some((item) => recursiveSomeItem(item, true));
    }
    hasGroups() {
        return this.groupsExist;
    }
    refresh() {
        this.updateExpandAll();
        this.flattenItems();
    }
    updateExpandAll() {
        const recursiveExpansionCheck = (items, someTrue, someFalse) => {
            for (const item of items) {
                if (!item.filterPasses || !item.available || !item.children) {
                    continue;
                }
                // indeterminate state only exists for expand all, so don't need to check for the current item
                someTrue = someTrue || !!item.expanded;
                someFalse = someFalse || !item.expanded;
                if (someTrue && someFalse) {
                    // already indeterminate. No need to check the children
                    return undefined;
                }
                const childExpanded = recursiveExpansionCheck(item.children, someTrue, someFalse);
                if (childExpanded === undefined) {
                    return undefined;
                }
                else if (childExpanded) {
                    someTrue = true;
                }
                else {
                    someFalse = true;
                }
            }
            return someTrue && someFalse ? undefined : someTrue;
        };
        const item = this.getSelectAllItem();
        item.expanded = recursiveExpansionCheck(item.children, false, false);
    }
    recursiveItemCheck(item, parentPasses, checkFunction, itemProp) {
        let atLeastOneChildPassed = false;
        if (item.children) {
            item.children.forEach((child) => {
                const childPasses = this.recursiveItemCheck(child, parentPasses || checkFunction(item), checkFunction, itemProp);
                atLeastOneChildPassed = atLeastOneChildPassed || childPasses;
            });
        }
        const itemPasses = parentPasses || atLeastOneChildPassed || checkFunction(item);
        item[itemProp] = itemPasses;
        return itemPasses;
    }
    updateAvailable(availableKeys) {
        const isAvailable = (item) => availableKeys.has(item.key);
        this.allDisplayedItemsTree.forEach((item) => this.recursiveItemCheck(item, false, isAvailable, 'available'));
    }
}
exports.TreeSetDisplayValueModel = TreeSetDisplayValueModel;


/***/ }),

/***/ 9172:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgHorizontalResize = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgHorizontalResize extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-tool-panel-horizontal-resize"></div>`);
        this.minWidth = 100;
        this.maxWidth = null;
    }
    postConstruct() {
        const finishedWithResizeFunc = this.beans.horizontalResizeSvc.addResizeBar({
            eResizeBar: this.getGui(),
            dragStartPixels: 1,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this),
            onResizeEnd: this.onResizeEnd.bind(this),
        });
        this.addDestroyFunc(finishedWithResizeFunc);
        this.inverted = this.gos.get('enableRtl');
    }
    dispatchResizeEvent(start, end, width) {
        this.eventSvc.dispatchEvent({
            type: 'toolPanelSizeChanged',
            width: width,
            started: start,
            ended: end,
        });
    }
    onResizeStart() {
        this.startingWidth = this.elementToResize.offsetWidth;
        this.dispatchResizeEvent(true, false, this.startingWidth);
    }
    onResizeEnd(delta) {
        return this.onResizing(delta, true);
    }
    onResizing(delta, isEnd = false) {
        const direction = this.inverted ? -1 : 1;
        let newWidth = Math.max(this.minWidth, Math.floor(this.startingWidth - delta * direction));
        if (this.maxWidth != null) {
            newWidth = Math.min(this.maxWidth, newWidth);
        }
        this.elementToResize.style.width = `${newWidth}px`;
        this.dispatchResizeEvent(false, isEnd, newWidth);
    }
}
exports.AgHorizontalResize = AgHorizontalResize;


/***/ }),

/***/ 911:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agSideBarCSS = void 0;
exports.agSideBarCSS = `.ag-tool-panel-wrapper{cursor:default;display:flex;overflow:hidden auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-side-bar-panel-width)}.ag-select-agg-func-item{align-items:center;display:flex;flex:1 1 auto;flex-flow:row nowrap;height:100%;overflow:hidden;position:relative;text-overflow:ellipsis;white-space:nowrap;>*{flex:none}}.ag-tool-panel-horizontal-resize{cursor:ew-resize;height:100%;position:absolute;top:0;width:5px;z-index:1}.ag-side-bar{background-color:var(--ag-side-bar-background-color);display:flex;flex-direction:row-reverse;position:relative}:where(.ag-ltr) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{right:-3px}:where(.ag-rtl) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-ltr) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-rtl) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{right:-3px}.ag-side-bar-left{flex-direction:row;order:-1}.ag-side-buttons{background-color:var(--ag-side-button-bar-background-color);padding-top:var(--ag-side-button-bar-top-padding);position:relative}.ag-side-button{background-color:var(--ag-side-button-background-color);border-bottom:var(--ag-side-button-selected-border);border-bottom-color:transparent;border-top:var(--ag-side-button-selected-border);border-top-color:transparent;color:var(--ag-side-button-text-color);position:relative;&:before{background-color:transparent;bottom:0;content:"";display:block;position:absolute;top:0;transition:background-color var(--ag-side-button-selected-underline-transition-duration);width:var(--ag-side-button-selected-underline-width)}&:hover{background-color:var(--ag-side-button-hover-background-color);color:var(--ag-side-button-hover-text-color)}&.ag-selected{background-color:var(--ag-side-button-selected-background-color);border-bottom:var(--ag-side-button-selected-border);color:var(--ag-side-button-selected-text-color);&:where(:not(:first-of-type)){border-top:var(--ag-side-button-selected-border)}&:before{background-color:var(--ag-side-button-selected-underline-color)}}}:where(.ag-ltr) .ag-side-button{&:before{left:0}}:where(.ag-rtl) .ag-side-button{&:before{right:0}}.ag-side-button-button{align-items:center;cursor:pointer;display:flex;flex-direction:column;gap:var(--ag-spacing);position:relative;white-space:nowrap;width:100%;&:focus{box-shadow:none}}:where(.ag-ltr) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding)}:where(.ag-rtl) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding)}.ag-side-button-button:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-side-button-label{writing-mode:vertical-lr}@media (resolution <= 1.5x){.ag-side-button-label{font-family:"Segoe UI",var(--ag-font-family)}:where(.ag-ltr) .ag-side-button-label{transform:rotate(.05deg)}:where(.ag-rtl) .ag-side-button-label{transform:rotate(-.05deg)}}:where(.ag-ltr) .ag-side-bar-left,:where(.ag-rtl) .ag-side-bar-right{border-right:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-left:var(--ag-side-panel-border)}}:where(.ag-ltr) .ag-side-bar-right,:where(.ag-rtl) .ag-side-bar-left{border-left:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-right:var(--ag-side-panel-border)}}`;


/***/ }),

/***/ 3814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgSideBarSelector = exports.AgSideBar = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const enterpriseFocusUtils_1 = __webpack_require__(6242);
const agSideBar_css_GENERATED_1 = __webpack_require__(911);
const agSideBarButtons_1 = __webpack_require__(7861);
const sideBarDefParser_1 = __webpack_require__(8124);
const toolPanelWrapper_1 = __webpack_require__(6443);
class AgSideBar extends ag_grid_community_1.Component {
    constructor() {
        super(
        /* html */
        `<div class="ag-side-bar ag-unselectable">
                <ag-side-bar-buttons data-ref="sideBarButtons"></ag-side-bar-buttons>
            </div>`, [agSideBarButtons_1.AgSideBarButtonsSelector]);
        this.sideBarButtons = ag_grid_community_1.RefPlaceholder;
        this.toolPanelWrappers = [];
        this.registerCSS(agSideBar_css_GENERATED_1.agSideBarCSS);
    }
    postConstruct() {
        this.sideBarButtons.addEventListener('sideBarButtonClicked', this.onToolPanelButtonClicked.bind(this));
        const { beans, gos } = this;
        const { sideBar: sideBarState } = gos.get('initialState') ?? {};
        this.setSideBarDef({
            sideBarDef: (0, sideBarDefParser_1.parseSideBarDef)(gos.get('sideBar')),
            sideBarState,
        });
        this.addManagedPropertyListener('sideBar', this.onSideBarUpdated.bind(this));
        beans.sideBar.comp = this;
        const eGui = this.getFocusableElement();
        this.createManagedBean(new ag_grid_community_1.ManagedFocusFeature(eGui, {
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
        }));
        (0, ag_grid_community_1._addFocusableContainerListener)(beans, this, eGui);
    }
    onTabKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        const { beans, sideBarButtons } = this;
        const eGui = this.getGui();
        const sideBarGui = sideBarButtons.getGui();
        const activeElement = (0, ag_grid_community_1._getActiveDomElement)(beans);
        const openPanel = eGui.querySelector('.ag-tool-panel-wrapper:not(.ag-hidden)');
        const target = e.target;
        if (!openPanel) {
            return (0, ag_grid_community_1._focusNextGridCoreContainer)(beans, e.shiftKey, true);
        }
        if (sideBarGui.contains(activeElement)) {
            if ((0, ag_grid_community_1._focusInto)(openPanel, e.shiftKey)) {
                e.preventDefault();
            }
            return;
        }
        // only handle backwards focus to target the sideBar buttons
        if (!e.shiftKey) {
            return;
        }
        let nextEl = null;
        if (openPanel.contains(activeElement)) {
            nextEl = (0, ag_grid_community_1._findNextFocusableElement)(beans, openPanel, undefined, true);
        }
        else if ((0, enterpriseFocusUtils_1.isTargetUnderManagedComponent)(openPanel, target) && e.shiftKey) {
            nextEl = (0, enterpriseFocusUtils_1.findFocusableElementBeforeTabGuard)(openPanel, target);
        }
        if (!nextEl) {
            nextEl = sideBarGui.querySelector('.ag-selected button');
        }
        if (nextEl && nextEl !== e.target) {
            e.preventDefault();
            nextEl.focus();
        }
    }
    handleKeyDown(e) {
        const currentButton = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        const sideBarButtons = this.sideBarButtons;
        if (!sideBarButtons.getGui().contains(currentButton)) {
            return;
        }
        const sideBarGui = sideBarButtons.getGui();
        const buttons = Array.prototype.slice.call(sideBarGui.querySelectorAll('.ag-side-button'));
        const currentPos = buttons.findIndex((button) => button.contains(currentButton));
        let nextPos = null;
        switch (e.key) {
            case ag_grid_community_1.KeyCode.LEFT:
            case ag_grid_community_1.KeyCode.UP:
                nextPos = Math.max(0, currentPos - 1);
                break;
            case ag_grid_community_1.KeyCode.RIGHT:
            case ag_grid_community_1.KeyCode.DOWN:
                nextPos = Math.min(currentPos + 1, buttons.length - 1);
                break;
        }
        if (nextPos === null) {
            return;
        }
        const innerButton = buttons[nextPos].querySelector('button');
        if (innerButton) {
            innerButton.focus();
            e.preventDefault();
        }
    }
    onToolPanelButtonClicked(event) {
        const id = event.toolPanelId;
        const openedItem = this.openedItem();
        // if item was already open, we close it
        if (openedItem === id) {
            this.openToolPanel(undefined, 'sideBarButtonClicked'); // passing undefined closes
        }
        else {
            this.openToolPanel(id, 'sideBarButtonClicked');
        }
    }
    clearDownUi() {
        this.sideBarButtons.clearButtons();
        this.destroyToolPanelWrappers();
    }
    setSideBarDef({ sideBarDef, sideBarState, existingToolPanelWrappers, }) {
        // initially hide side bar
        this.setDisplayed(false);
        this.sideBar = sideBarDef;
        if (!!sideBarDef && !!sideBarDef.toolPanels) {
            const toolPanelDefs = sideBarDef.toolPanels;
            this.createToolPanelsAndSideButtons(toolPanelDefs, sideBarState, existingToolPanelWrappers);
            if (!this.toolPanelWrappers.length) {
                return;
            }
            const shouldDisplaySideBar = sideBarState ? sideBarState.visible : !sideBarDef.hiddenByDefault;
            this.setDisplayed(shouldDisplaySideBar);
            this.setSideBarPosition(sideBarState ? sideBarState.position : sideBarDef.position);
            if (shouldDisplaySideBar) {
                if (sideBarState) {
                    const { openToolPanel } = sideBarState;
                    if (openToolPanel) {
                        this.openToolPanel(openToolPanel, 'sideBarInitializing');
                    }
                }
                else {
                    this.openToolPanel(sideBarDef.defaultToolPanel, 'sideBarInitializing');
                }
            }
        }
    }
    getDef() {
        return this.sideBar;
    }
    setSideBarPosition(position) {
        if (!position) {
            position = 'right';
        }
        this.position = position;
        const isLeft = position === 'left';
        const resizerSide = isLeft ? 'right' : 'left';
        this.addOrRemoveCssClass('ag-side-bar-left', isLeft);
        this.addOrRemoveCssClass('ag-side-bar-right', !isLeft);
        this.toolPanelWrappers.forEach((wrapper) => {
            wrapper.setResizerSizerSide(resizerSide);
        });
        this.dispatchSideBarUpdated();
        return this;
    }
    setDisplayed(displayed, options) {
        super.setDisplayed(displayed, options);
        this.dispatchSideBarUpdated();
    }
    getState() {
        const toolPanels = {};
        this.toolPanelWrappers.forEach((wrapper) => {
            toolPanels[wrapper.getToolPanelId()] = wrapper.getToolPanelInstance()?.getState?.();
        });
        return {
            visible: this.isDisplayed(),
            position: this.position,
            openToolPanel: this.openedItem(),
            toolPanels,
        };
    }
    createToolPanelsAndSideButtons(defs, sideBarState, existingToolPanelWrappers) {
        for (const def of defs) {
            this.createToolPanelAndSideButton(def, sideBarState?.toolPanels?.[def.id], existingToolPanelWrappers?.[def.id]);
        }
    }
    validateDef(def) {
        if (def.id == null) {
            (0, ag_grid_community_1._warn)(212);
            return false;
        }
        if (def.toolPanel === 'agFiltersToolPanel') {
            if (this.beans.filterManager?.isAdvFilterEnabled()) {
                (0, ag_grid_community_1._warn)(213);
                return false;
            }
        }
        return true;
    }
    createToolPanelAndSideButton(def, initialState, existingToolPanelWrapper) {
        if (!this.validateDef(def)) {
            return;
        }
        let wrapper;
        if (existingToolPanelWrapper) {
            wrapper = existingToolPanelWrapper;
        }
        else {
            wrapper = this.createBean(new toolPanelWrapper_1.ToolPanelWrapper());
            const created = wrapper.setToolPanelDef(def, {
                initialState,
                onStateUpdated: () => this.dispatchSideBarUpdated(),
            });
            if (!created) {
                return;
            }
        }
        wrapper.setDisplayed(false);
        const wrapperGui = wrapper.getGui();
        this.appendChild(wrapperGui);
        this.toolPanelWrappers.push(wrapper);
        const button = this.sideBarButtons.addButtonComp(def);
        (0, ag_grid_community_1._setAriaControls)(button.eToggleButton, wrapperGui);
    }
    refresh() {
        this.toolPanelWrappers.forEach((wrapper) => wrapper.refresh());
    }
    openToolPanel(key, source = 'api') {
        const currentlyOpenedKey = this.openedItem();
        if (currentlyOpenedKey === key) {
            return;
        }
        this.toolPanelWrappers.forEach((wrapper) => {
            const show = key === wrapper.getToolPanelId();
            wrapper.setDisplayed(show);
        });
        const newlyOpenedKey = this.openedItem();
        const openToolPanelChanged = currentlyOpenedKey !== newlyOpenedKey;
        if (openToolPanelChanged) {
            this.sideBarButtons.setActiveButton(key);
            this.raiseToolPanelVisibleEvent(key, currentlyOpenedKey ?? undefined, source);
        }
    }
    getToolPanelInstance(key) {
        const toolPanelWrapper = this.toolPanelWrappers.filter((toolPanel) => toolPanel.getToolPanelId() === key)[0];
        if (!toolPanelWrapper) {
            (0, ag_grid_community_1._warn)(214, { key });
            return;
        }
        return toolPanelWrapper.getToolPanelInstance();
    }
    raiseToolPanelVisibleEvent(key, previousKey, source) {
        const switchingToolPanel = !!key && !!previousKey;
        const eventSvc = this.eventSvc;
        if (previousKey) {
            eventSvc.dispatchEvent({
                type: 'toolPanelVisibleChanged',
                source,
                key: previousKey,
                visible: false,
                switchingToolPanel,
            });
        }
        if (key) {
            eventSvc.dispatchEvent({
                type: 'toolPanelVisibleChanged',
                source,
                key,
                visible: true,
                switchingToolPanel,
            });
        }
    }
    close(source = 'api') {
        this.openToolPanel(undefined, source);
    }
    isToolPanelShowing() {
        return !!this.openedItem();
    }
    openedItem() {
        let activeToolPanel = null;
        this.toolPanelWrappers.forEach((wrapper) => {
            if (wrapper.isDisplayed()) {
                activeToolPanel = wrapper.getToolPanelId();
            }
        });
        return activeToolPanel;
    }
    onSideBarUpdated() {
        const sideBarDef = (0, sideBarDefParser_1.parseSideBarDef)(this.gos.get('sideBar'));
        const existingToolPanelWrappers = {};
        if (sideBarDef && this.sideBar) {
            sideBarDef.toolPanels?.forEach((toolPanelDef) => {
                const { id } = toolPanelDef;
                if (!id) {
                    return;
                }
                const existingToolPanelDef = this.sideBar.toolPanels?.find((toolPanelDefToCheck) => toolPanelDefToCheck.id === id);
                if (!existingToolPanelDef || toolPanelDef.toolPanel !== existingToolPanelDef.toolPanel) {
                    return;
                }
                const toolPanelWrapper = this.toolPanelWrappers.find((toolPanel) => toolPanel.getToolPanelId() === id);
                if (!toolPanelWrapper) {
                    return;
                }
                const params = this.gos.addGridCommonParams({
                    ...(toolPanelDef.toolPanelParams ?? {}),
                    onStateUpdated: () => this.dispatchSideBarUpdated(),
                });
                const hasRefreshed = toolPanelWrapper.getToolPanelInstance()?.refresh(params);
                if (hasRefreshed !== true) {
                    return;
                }
                this.toolPanelWrappers = this.toolPanelWrappers.filter((toolPanel) => toolPanel !== toolPanelWrapper);
                (0, ag_grid_community_1._removeFromParent)(toolPanelWrapper.getGui());
                existingToolPanelWrappers[id] = toolPanelWrapper;
            });
        }
        this.clearDownUi();
        // don't re-assign initial state
        this.setSideBarDef({ sideBarDef, existingToolPanelWrappers });
    }
    dispatchSideBarUpdated() {
        this.eventSvc.dispatchEvent({ type: 'sideBarUpdated' });
    }
    destroyToolPanelWrappers() {
        this.toolPanelWrappers.forEach((wrapper) => {
            (0, ag_grid_community_1._removeFromParent)(wrapper.getGui());
            this.destroyBean(wrapper);
        });
        this.toolPanelWrappers.length = 0;
    }
    destroy() {
        this.destroyToolPanelWrappers();
        super.destroy();
    }
}
exports.AgSideBar = AgSideBar;
exports.AgSideBarSelector = {
    selector: 'AG-SIDE-BAR',
    component: AgSideBar,
};


/***/ }),

/***/ 7861:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgSideBarButtonsSelector = exports.AgSideBarButtons = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const sideBarButtonComp_1 = __webpack_require__(3945);
class AgSideBarButtons extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-side-buttons" role="tablist"></div>`);
        this.buttonComps = [];
    }
    postConstruct() {
        this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
    }
    handleKeyDown(e) {
        if (e.key !== ag_grid_community_1.KeyCode.TAB || !e.shiftKey) {
            return;
        }
        if ((0, ag_grid_community_1._focusNextGridCoreContainer)(this.beans, true)) {
            e.preventDefault();
            return;
        }
        // Prevent the tab to go in an loop without exit inside the sidebar
        (0, ag_grid_community_1._stopPropagationForAgGrid)(e);
    }
    setActiveButton(id) {
        this.buttonComps.forEach((comp) => {
            comp.setSelected(id === comp.getToolPanelId());
        });
    }
    addButtonComp(def) {
        const buttonComp = this.createBean(new sideBarButtonComp_1.SideBarButtonComp(def));
        this.buttonComps.push(buttonComp);
        this.appendChild(buttonComp);
        buttonComp.addEventListener('toggleButtonClicked', () => {
            this.dispatchLocalEvent({
                type: 'sideBarButtonClicked',
                toolPanelId: def.id,
            });
        });
        return buttonComp;
    }
    clearButtons() {
        this.buttonComps = this.destroyBeans(this.buttonComps);
        (0, ag_grid_community_1._clearElement)(this.getGui());
        super.destroy();
    }
    destroy() {
        this.clearButtons();
        super.destroy();
    }
}
exports.AgSideBarButtons = AgSideBarButtons;
exports.AgSideBarButtonsSelector = {
    selector: 'AG-SIDE-BAR-BUTTONS',
    component: AgSideBarButtons,
};


/***/ }),

/***/ 9705:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeLeafPathTrees = exports.isColGroupDef = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function isColGroupDef(colDef) {
    return !!colDef && typeof colDef.children !== 'undefined';
}
exports.isColGroupDef = isColGroupDef;
function getId(colDef) {
    return isColGroupDef(colDef) ? colDef.groupId : colDef.colId;
}
function addChildrenToGroup(tree, groupId, colDef) {
    const subGroupIsSplit = (currentSubGroup, currentSubGroupToAdd) => {
        const existingChildIds = currentSubGroup.children.map(getId);
        const childGroupAlreadyExists = existingChildIds.includes(getId(currentSubGroupToAdd));
        const lastChild = (0, ag_grid_community_1._last)(currentSubGroup.children);
        const lastChildIsDifferent = lastChild && getId(lastChild) !== getId(currentSubGroupToAdd);
        return childGroupAlreadyExists && lastChildIsDifferent;
    };
    if (!isColGroupDef(tree)) {
        return true;
    }
    const currentGroup = tree;
    const groupToAdd = colDef;
    if (subGroupIsSplit(currentGroup, groupToAdd)) {
        currentGroup.children.push(groupToAdd);
        return true;
    }
    if (currentGroup.groupId === groupId) {
        // add children that don't already exist to group
        const existingChildIds = currentGroup.children.map(getId);
        const colDefAlreadyPresent = existingChildIds.includes(getId(groupToAdd));
        if (!colDefAlreadyPresent) {
            currentGroup.children.push(groupToAdd);
            return true;
        }
    }
    // recurse until correct group is found to add children
    for (let i = currentGroup.children.length - 1; i >= 0; i--) {
        if (addChildrenToGroup(currentGroup.children[i], groupId, colDef)) {
            break;
        }
    }
    return false;
}
function mergeLeafPathTrees(leafPathTrees) {
    const matchingRootGroupIds = (pathA, pathB) => {
        const bothPathsAreGroups = isColGroupDef(pathA) && isColGroupDef(pathB);
        return bothPathsAreGroups && getId(pathA) === getId(pathB);
    };
    const mergeTrees = (treeA, treeB) => {
        if (!isColGroupDef(treeB)) {
            return treeA;
        }
        const mergeResult = treeA;
        const groupToMerge = treeB;
        if (groupToMerge.children && groupToMerge.groupId) {
            const added = addChildrenToGroup(mergeResult, groupToMerge.groupId, groupToMerge.children[0]);
            if (added) {
                return mergeResult;
            }
        }
        groupToMerge.children.forEach((child) => mergeTrees(mergeResult, child));
        return mergeResult;
    };
    // we can't just merge the leaf path trees as groups can be split apart - instead only merge if leaf
    // path groups with the same root group id are contiguous.
    const mergeColDefs = [];
    for (let i = 1; i <= leafPathTrees.length; i++) {
        const first = leafPathTrees[i - 1];
        const second = leafPathTrees[i];
        if (matchingRootGroupIds(first, second)) {
            leafPathTrees[i] = mergeTrees(first, second);
        }
        else {
            mergeColDefs.push(first);
        }
    }
    return mergeColDefs;
}
exports.mergeLeafPathTrees = mergeLeafPathTrees;


/***/ }),

/***/ 6092:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.syncLayoutWithGrid = exports.toolPanelCreateColumnTree = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const sideBarUtils_1 = __webpack_require__(9705);
function toolPanelCreateColumnTree(colModel, colDefs) {
    const invalidColIds = [];
    const createDummyColGroup = (abstractColDef, depth) => {
        if ((0, sideBarUtils_1.isColGroupDef)(abstractColDef)) {
            // creating 'dummy' group which is not associated with grid column group
            const groupDef = abstractColDef;
            const groupId = typeof groupDef.groupId !== 'undefined' ? groupDef.groupId : groupDef.headerName;
            const group = new ag_grid_community_1.AgProvidedColumnGroup(groupDef, groupId, false, depth);
            const children = [];
            groupDef.children.forEach((def) => {
                const child = createDummyColGroup(def, depth + 1);
                // check column exists in case invalid colDef is supplied for primary column
                if (child) {
                    children.push(child);
                }
            });
            group.setChildren(children);
            return group;
        }
        else {
            const colDef = abstractColDef;
            const key = colDef.colId ? colDef.colId : colDef.field;
            const column = colModel.getColDefCol(key);
            if (!column) {
                invalidColIds.push(colDef);
            }
            return column;
        }
    };
    const mappedResults = [];
    colDefs.forEach((colDef) => {
        const result = createDummyColGroup(colDef, 0);
        if (result) {
            // only return correctly mapped colDef results
            mappedResults.push(result);
        }
    });
    if (invalidColIds.length > 0) {
        (0, ag_grid_community_1._warn)(217, { invalidColIds });
    }
    return mappedResults;
}
exports.toolPanelCreateColumnTree = toolPanelCreateColumnTree;
function syncLayoutWithGrid(colModel, syncLayoutCallback) {
    // extract ordered list of leaf path trees (column group hierarchy for each individual leaf column)
    const leafPathTrees = getLeafPathTrees(colModel);
    // merge leaf path tree taking split column groups into account
    const mergedColumnTrees = (0, sideBarUtils_1.mergeLeafPathTrees)(leafPathTrees);
    // sync layout with merged column trees
    syncLayoutCallback(mergedColumnTrees);
}
exports.syncLayoutWithGrid = syncLayoutWithGrid;
function getLeafPathTrees(colModel) {
    // leaf tree paths are obtained by walking up the tree starting at a column until we reach the top level group.
    const getLeafPathTree = (node, childDef) => {
        let leafPathTree;
        // build up tree in reverse order
        if ((0, ag_grid_community_1.isProvidedColumnGroup)(node)) {
            if (node.isPadding()) {
                // skip over padding groups
                leafPathTree = childDef;
            }
            else {
                const groupDef = Object.assign({}, node.getColGroupDef());
                // ensure group contains groupId
                groupDef.groupId = node.getGroupId();
                groupDef.children = [childDef];
                leafPathTree = groupDef;
            }
        }
        else {
            const colDef = Object.assign({}, node.getColDef());
            // ensure col contains colId
            colDef.colId = node.getColId();
            leafPathTree = colDef;
        }
        // walk tree
        const parent = node.getOriginalParent();
        if (parent) {
            // keep walking up the tree until we reach the root
            return getLeafPathTree(parent, leafPathTree);
        }
        else {
            // we have reached the root - exit with resulting leaf path tree
            return leafPathTree;
        }
    };
    // obtain a sorted list of all grid columns
    const allGridColumns = colModel.getCols();
    // only primary columns and non row group columns should appear in the tool panel
    const allPrimaryGridColumns = allGridColumns.filter((column) => {
        const colDef = column.getColDef();
        return column.isPrimary() && !colDef.showRowGroup;
    });
    // construct a leaf path tree for each column
    return allPrimaryGridColumns.map((col) => getLeafPathTree(col, col.getColDef()));
}


/***/ }),

/***/ 2024:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSideBar = exports.getToolPanelInstance = exports.isToolPanelShowing = exports.refreshToolPanel = exports.getOpenedToolPanel = exports.closeToolPanel = exports.openToolPanel = exports.setSideBarPosition = exports.setSideBarVisible = exports.isSideBarVisible = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function isSideBarVisible(beans) {
    return beans.sideBar?.comp.isDisplayed() ?? false;
}
exports.isSideBarVisible = isSideBarVisible;
function setSideBarVisible(beans, show) {
    beans.sideBar?.comp.setDisplayed(show);
}
exports.setSideBarVisible = setSideBarVisible;
function setSideBarPosition(beans, position) {
    beans.sideBar?.comp.setSideBarPosition(position);
}
exports.setSideBarPosition = setSideBarPosition;
function openToolPanel(beans, key) {
    beans.sideBar?.comp.openToolPanel(key, 'api');
}
exports.openToolPanel = openToolPanel;
function closeToolPanel(beans) {
    beans.sideBar?.comp.close('api');
}
exports.closeToolPanel = closeToolPanel;
function getOpenedToolPanel(beans) {
    return beans.sideBar?.comp.openedItem() ?? null;
}
exports.getOpenedToolPanel = getOpenedToolPanel;
function refreshToolPanel(beans) {
    beans.sideBar?.comp.refresh();
}
exports.refreshToolPanel = refreshToolPanel;
function isToolPanelShowing(beans) {
    return beans.sideBar?.comp.isToolPanelShowing() ?? false;
}
exports.isToolPanelShowing = isToolPanelShowing;
function getToolPanelInstance(beans, id) {
    const comp = beans.sideBar?.comp.getToolPanelInstance(id);
    return (0, ag_grid_community_1._unwrapUserComp)(comp);
}
exports.getToolPanelInstance = getToolPanelInstance;
function getSideBar(beans) {
    return beans.sideBar?.comp.getDef();
}
exports.getSideBar = getSideBar;


/***/ }),

/***/ 3945:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SideBarButtonComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class SideBarButtonComp extends ag_grid_community_1.Component {
    constructor(toolPanelDef) {
        super();
        this.toolPanelDef = toolPanelDef;
        this.eToggleButton = ag_grid_community_1.RefPlaceholder;
        this.eIconWrapper = ag_grid_community_1.RefPlaceholder;
        this.eLabel = ag_grid_community_1.RefPlaceholder;
    }
    getToolPanelId() {
        return this.toolPanelDef.id;
    }
    postConstruct() {
        const template = this.createTemplate();
        this.setTemplate(template, []);
        this.setLabel();
        this.setIcon();
        this.addManagedElementListeners(this.eToggleButton, { click: this.onButtonPressed.bind(this) });
        this.eToggleButton.setAttribute('id', `ag-${this.getCompId()}-button`);
    }
    createTemplate() {
        const res = 
        /* html */
        `<div class="ag-side-button" role="presentation">
                <button type="button" data-ref="eToggleButton" tabindex="-1" role="tab" aria-expanded="false" class="ag-button ag-side-button-button">
                    <div data-ref="eIconWrapper" class="ag-side-button-icon-wrapper" aria-hidden="true"></div>
                    <span data-ref="eLabel" class="ag-side-button-label"></span>
                </button>
            </div>`;
        return res;
    }
    setLabel() {
        const translate = this.getLocaleTextFunc();
        const def = this.toolPanelDef;
        const label = translate(def.labelKey, def.labelDefault);
        this.eLabel.innerText = label;
    }
    setIcon() {
        this.eIconWrapper.insertAdjacentElement('afterbegin', (0, ag_grid_community_1._createIconNoSpan)(this.toolPanelDef.iconKey, this.beans));
    }
    onButtonPressed() {
        this.dispatchLocalEvent({ type: 'toggleButtonClicked' });
    }
    setSelected(selected) {
        this.addOrRemoveCssClass('ag-selected', selected);
        (0, ag_grid_community_1._setAriaExpanded)(this.eToggleButton, selected);
    }
}
exports.SideBarButtonComp = SideBarButtonComp;


/***/ }),

/***/ 8124:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSideBarDef = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const DEFAULT_COLUMN_COMP = {
    id: 'columns',
    labelDefault: 'Columns',
    labelKey: 'columns',
    iconKey: 'columnsToolPanel',
    toolPanel: 'agColumnsToolPanel',
};
const DEFAULT_FILTER_COMP = {
    id: 'filters',
    labelDefault: 'Filters',
    labelKey: 'filters',
    iconKey: 'filtersToolPanel',
    toolPanel: 'agFiltersToolPanel',
};
const DEFAULT_BY_KEY = {
    columns: DEFAULT_COLUMN_COMP,
    filters: DEFAULT_FILTER_COMP,
};
function parseSideBarDef(toParse) {
    if (!toParse) {
        return undefined;
    }
    if (toParse === true) {
        return {
            toolPanels: [DEFAULT_COLUMN_COMP, DEFAULT_FILTER_COMP],
            defaultToolPanel: 'columns',
        };
    }
    if (typeof toParse === 'string') {
        return parseSideBarDef([toParse]);
    }
    if (Array.isArray(toParse)) {
        const comps = [];
        toParse.forEach((key) => {
            const lookupResult = DEFAULT_BY_KEY[key];
            if (!lookupResult) {
                (0, ag_grid_community_1._warn)(215, { key, defaultByKey: DEFAULT_BY_KEY });
                return;
            }
            comps.push(lookupResult);
        });
        if (comps.length === 0) {
            return undefined;
        }
        return {
            toolPanels: comps,
            defaultToolPanel: comps[0].id,
        };
    }
    const result = {
        toolPanels: parseComponents(toParse.toolPanels),
        defaultToolPanel: toParse.defaultToolPanel,
        hiddenByDefault: toParse.hiddenByDefault,
        position: toParse.position,
    };
    return result;
}
exports.parseSideBarDef = parseSideBarDef;
function parseComponents(from) {
    const result = [];
    if (!from) {
        return result;
    }
    from.forEach((it) => {
        let toAdd = null;
        if (typeof it === 'string') {
            const lookupResult = DEFAULT_BY_KEY[it];
            if (!lookupResult) {
                (0, ag_grid_community_1._warn)(215, { key: it, defaultByKey: DEFAULT_BY_KEY });
                return;
            }
            toAdd = lookupResult;
        }
        else {
            toAdd = it;
        }
        result.push(toAdd);
    });
    return result;
}


/***/ }),

/***/ 6358:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SideBarModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const sideBarApi_1 = __webpack_require__(2024);
const sideBarService_1 = __webpack_require__(6191);
/**
 * @feature Accessories -> Side Bar
 * @gridOption sideBar
 */
exports.SideBarModule = {
    moduleName: 'SideBar',
    version: version_1.VERSION,
    beans: [sideBarService_1.SideBarService],
    apiFunctions: {
        isSideBarVisible: sideBarApi_1.isSideBarVisible,
        setSideBarVisible: sideBarApi_1.setSideBarVisible,
        setSideBarPosition: sideBarApi_1.setSideBarPosition,
        openToolPanel: sideBarApi_1.openToolPanel,
        closeToolPanel: sideBarApi_1.closeToolPanel,
        getOpenedToolPanel: sideBarApi_1.getOpenedToolPanel,
        refreshToolPanel: sideBarApi_1.refreshToolPanel,
        isToolPanelShowing: sideBarApi_1.isToolPanelShowing,
        getToolPanelInstance: sideBarApi_1.getToolPanelInstance,
        getSideBar: sideBarApi_1.getSideBar,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._HorizontalResizeModule],
};


/***/ }),

/***/ 6191:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SideBarService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agSideBar_1 = __webpack_require__(3814);
class SideBarService extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'sideBar';
    }
    getSelector() {
        return agSideBar_1.AgSideBarSelector;
    }
}
exports.SideBarService = SideBarService;


/***/ }),

/***/ 6443:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolPanelWrapper = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agHorizontalResize_1 = __webpack_require__(9172);
function getToolPanelCompDetails(userCompFactory, toolPanelDef, params) {
    return userCompFactory.getCompDetails(toolPanelDef, ToolPanelComponent, undefined, params, true);
}
const ToolPanelComponent = {
    name: 'toolPanel',
    optionalMethods: ['refresh', 'getState'],
};
class ToolPanelWrapper extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-tool-panel-wrapper" role="tabpanel"/>`);
    }
    postConstruct() {
        const eGui = this.getGui();
        const resizeBar = (this.resizeBar = this.createManagedBean(new agHorizontalResize_1.AgHorizontalResize()));
        eGui.setAttribute('id', `ag-${this.getCompId()}`);
        resizeBar.elementToResize = eGui;
        this.appendChild(resizeBar);
    }
    getToolPanelId() {
        return this.toolPanelId;
    }
    setToolPanelDef(toolPanelDef, params) {
        const { id, minWidth, maxWidth, width } = toolPanelDef;
        this.toolPanelId = id;
        this.width = width;
        const compDetails = getToolPanelCompDetails(this.beans.userCompFactory, toolPanelDef, params);
        if (compDetails == null) {
            return false;
        }
        const componentPromise = compDetails.newAgStackInstance();
        this.params = compDetails.params;
        componentPromise.then(this.setToolPanelComponent.bind(this));
        const resizeBar = this.resizeBar;
        if (minWidth != null) {
            resizeBar.minWidth = minWidth;
        }
        if (maxWidth != null) {
            resizeBar.maxWidth = maxWidth;
        }
        return true;
    }
    setToolPanelComponent(compInstance) {
        this.toolPanelCompInstance = compInstance;
        this.appendChild(compInstance.getGui());
        this.addDestroyFunc(() => {
            this.destroyBean(compInstance);
        });
        const width = this.width;
        if (width) {
            this.getGui().style.width = `${width}px`;
        }
    }
    getToolPanelInstance() {
        return this.toolPanelCompInstance;
    }
    setResizerSizerSide(side) {
        const isRtl = this.gos.get('enableRtl');
        const isLeft = side === 'left';
        const inverted = isRtl ? isLeft : !isLeft;
        this.resizeBar.inverted = inverted;
    }
    refresh() {
        this.toolPanelCompInstance?.refresh(this.params);
    }
}
exports.ToolPanelWrapper = ToolPanelWrapper;


/***/ }),

/***/ 4087:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sparklineCSS = void 0;
exports.sparklineCSS = `.ag-sparkline-wrapper{height:100%;left:0;position:absolute;top:0;width:100%}.ag-sparkline-wrapper :where(canvas){position:absolute}`;


/***/ }),

/***/ 2437:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparklineCellRenderer = exports.DEFAULT_THEMES = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const sparklinesUtils_1 = __webpack_require__(6464);
exports.DEFAULT_THEMES = ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];
class SparklineCellRenderer extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-sparkline-wrapper">
            <span data-ref="eSparkline"></span>
        </div>`);
        this.eSparkline = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.addManagedPropertyListeners(['chartThemeOverrides', 'chartThemes'], (_event) => this.refresh(this.params));
    }
    init(params) {
        this.refresh(params);
        const unsubscribeFromResize = (0, ag_grid_community_1._observeResize)(this.beans, this.getGui(), () => this.refresh(params));
        this.addDestroyFunc(() => unsubscribeFromResize());
    }
    getThemeName() {
        const availableThemes = this.gos.get('chartThemes');
        return (availableThemes || exports.DEFAULT_THEMES)[0];
    }
    refresh(params) {
        this.params = params;
        const { clientWidth: width, clientHeight: height } = this.getGui();
        if (!this.sparklineInstance && params && width > 0 && height) {
            this.sparklineOptions = {
                container: this.eSparkline,
                width,
                height,
                ...params.sparklineOptions,
                data: this.processData(params.value),
            };
            if (this.sparklineOptions.tooltip?.renderer) {
                this.wrapTooltipRenderer();
            }
            else {
                this.sparklineOptions.tooltip = {
                    ...this.sparklineOptions.tooltip,
                    renderer: (params) => ({ content: this.createDefaultContent(params) }),
                };
            }
            // Only bar sparklines have itemStyler
            const theme = this.sparklineOptions?.theme;
            if (this.sparklineOptions.type === 'bar' && this.sparklineOptions.itemStyler) {
                this.wrapItemStyler(this.sparklineOptions);
            }
            else if (theme?.overrides?.bar?.series?.itemStyler) {
                this.wrapItemStyler(theme.overrides.bar.series);
            }
            this.updateTheme(this.sparklineOptions);
            // create new sparkline
            this.sparklineInstance = params.createSparkline(this.sparklineOptions);
            return true;
        }
        else if (this.sparklineInstance) {
            const data = params?.value;
            this.sparklineOptions.width = width;
            this.sparklineOptions.height = height;
            this.sparklineOptions.data = this.processData(data);
            this.updateTheme(this.sparklineOptions);
            this.sparklineInstance.updateDelta(this.sparklineOptions);
            return true;
        }
        return false;
    }
    updateTheme(sparklineOptions) {
        const themeName = this.getThemeName();
        if (typeof sparklineOptions.theme === 'string' || !sparklineOptions.theme) {
            sparklineOptions.theme = themeName;
        }
        else if (sparklineOptions.theme) {
            sparklineOptions.theme.baseTheme = themeName;
        }
    }
    processData(data = []) {
        if (data.length === 0) {
            return data;
        }
        return data.filter((item) => item != null);
    }
    createContext() {
        return {
            data: this.params?.data,
            cellData: this.params?.value,
        };
    }
    createDefaultContent(params, userRendererResult) {
        const userTitle = userRendererResult?.title;
        const xKeyProvided = this.sparklineOptions.xKey;
        const tupleData = Array.isArray(this.sparklineOptions.data?.[0]);
        const showXValue = !userTitle && (xKeyProvided || tupleData);
        return `${showXValue ? `${params.xValue} ` : ''}${params.yValue}`;
    }
    wrapItemStyler(container) {
        container.itemStyler = (0, sparklinesUtils_1.wrapFn)(container.itemStyler, (fn, stylerParams) => {
            return fn({
                ...stylerParams,
                context: this.createContext(),
            });
        });
    }
    wrapTooltipRenderer() {
        this.sparklineOptions.tooltip = {
            ...this.sparklineOptions.tooltip,
            renderer: (0, sparklinesUtils_1.wrapFn)(this.sparklineOptions.tooltip.renderer, (fn, tooltipParams) => {
                const userRendererResult = fn({
                    ...tooltipParams,
                    context: this.createContext(),
                });
                if (typeof userRendererResult === 'string') {
                    return userRendererResult;
                }
                return {
                    content: this.createDefaultContent(tooltipParams, userRendererResult),
                    ...userRendererResult,
                };
            }),
        };
    }
    destroy() {
        super.destroy();
        this.sparklineInstance?.destroy();
    }
}
exports.SparklineCellRenderer = SparklineCellRenderer;


/***/ }),

/***/ 2949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparklinesModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const sparkline_css_GENERATED_1 = __webpack_require__(4087);
const sparklineCellRenderer_1 = __webpack_require__(2437);
const moduleName = 'Sparklines';
/**
 * @feature Sparklines
 * Requires the AG Charts library to be provided to this module via the `with` method.
 * The AG Charts module can be imported from either `ag-charts-community` or `ag-charts-enterprise`.
 * @example
 * import { AgChartsCommunityModule } from 'ag-charts-community';
 * import { ModuleRegistry } from 'ag-grid-community';
 * import { SparklinesModule } from 'ag-grid-enterprise';
 *
 * ModuleRegistry.registerModules([ SparklinesModule.with(AgChartsCommunityModule) ]);
 */
exports.SparklinesModule = {
    moduleName,
    version: version_1.VERSION,
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
    validate: () => {
        return {
            isValid: false,
            message: (0, ag_grid_community_1._preInitErrMsg)(258),
        };
    },
    with: (params) => {
        params.setup();
        return {
            moduleName,
            version: version_1.VERSION,
            dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
            css: [sparkline_css_GENERATED_1.sparklineCSS],
            userComponents: {
                agSparklineCellRenderer: {
                    classImp: sparklineCellRenderer_1.SparklineCellRenderer,
                    /** Default params for provided components */
                    params: { createSparkline: params.createSparkline },
                },
            },
            validate: () => {
                return { isValid: true };
            },
        };
    },
};


/***/ }),

/***/ 6464:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapFn = void 0;
const WrappedFunctionMarker = Symbol('WrappedFunctionMarker');
const wrapFn = (fn, wrapperFn) => {
    if (fn[WrappedFunctionMarker]) {
        return fn;
    }
    const wrapped = (...args) => wrapperFn(fn, ...args);
    wrapped[WrappedFunctionMarker] = WrappedFunctionMarker;
    return wrapped;
};
exports.wrapFn = wrapFn;


/***/ }),

/***/ 2875:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agStatusBarCSS = void 0;
exports.agStatusBarCSS = `.ag-status-bar{border-top:var(--ag-footer-row-border);display:flex;justify-content:space-between;line-height:1.5;overflow:hidden;padding-left:calc(var(--ag-spacing)*4);padding-right:calc(var(--ag-spacing)*4)}.ag-status-panel{display:inline-flex}.ag-status-name-value{font-weight:500;margin-left:var(--ag-spacing);margin-right:var(--ag-spacing);padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding);white-space:nowrap}.ag-status-bar-left{display:inline-flex}.ag-status-bar-center{display:inline-flex;text-align:center}.ag-status-bar-right{display:inline-flex}`;


/***/ }),

/***/ 1866:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgStatusBarSelector = exports.AgStatusBar = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agStatusBar_css_GENERATED_1 = __webpack_require__(2875);
function getStatusPanelCompDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, StatusPanelComponent, undefined, params, true);
}
const StatusPanelComponent = {
    name: 'statusPanel',
    optionalMethods: ['refresh'],
};
class AgStatusBar extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.userCompFactory = beans.userCompFactory;
        this.statusBarSvc = beans.statusBarSvc;
    }
    constructor() {
        super(/* html */ `<div class="ag-status-bar">
            <div data-ref="eStatusBarLeft" class="ag-status-bar-left" role="status"></div>
            <div data-ref="eStatusBarCenter" class="ag-status-bar-center" role="status"></div>
            <div data-ref="eStatusBarRight" class="ag-status-bar-right" role="status"></div>
        </div>`);
        this.updateQueued = false;
        this.panelsPromise = ag_grid_community_1.AgPromise.resolve();
        this.eStatusBarLeft = ag_grid_community_1.RefPlaceholder;
        this.eStatusBarCenter = ag_grid_community_1.RefPlaceholder;
        this.eStatusBarRight = ag_grid_community_1.RefPlaceholder;
        this.compDestroyFunctions = {};
        this.registerCSS(agStatusBar_css_GENERATED_1.agStatusBarCSS);
    }
    postConstruct() {
        this.processStatusPanels(new Map());
        this.addManagedPropertyListeners(['statusBar'], this.handleStatusBarChanged.bind(this));
    }
    processStatusPanels(existingStatusPanelsToReuse) {
        const statusPanels = this.gos.get('statusBar')?.statusPanels;
        if (statusPanels) {
            const leftStatusPanelComponents = statusPanels.filter((componentConfig) => componentConfig.align === 'left');
            const centerStatusPanelComponents = statusPanels.filter((componentConfig) => componentConfig.align === 'center');
            const rightStatusPanelComponents = statusPanels.filter((componentConfig) => !componentConfig.align || componentConfig.align === 'right');
            this.panelsPromise = ag_grid_community_1.AgPromise.all([
                this.createAndRenderComponents(leftStatusPanelComponents, this.eStatusBarLeft, existingStatusPanelsToReuse),
                this.createAndRenderComponents(centerStatusPanelComponents, this.eStatusBarCenter, existingStatusPanelsToReuse),
                this.createAndRenderComponents(rightStatusPanelComponents, this.eStatusBarRight, existingStatusPanelsToReuse),
            ]);
        }
        else {
            this.setDisplayed(false);
        }
    }
    handleStatusBarChanged() {
        if (this.updateQueued) {
            return;
        }
        this.updateQueued = true;
        this.panelsPromise.then(() => {
            this.updateStatusBar();
            this.updateQueued = false;
        });
    }
    updateStatusBar() {
        const statusPanels = this.gos.get('statusBar')?.statusPanels;
        const validStatusBarPanelsProvided = Array.isArray(statusPanels) && statusPanels.length > 0;
        this.setDisplayed(validStatusBarPanelsProvided);
        const existingStatusPanelsToReuse = new Map();
        if (validStatusBarPanelsProvided) {
            statusPanels.forEach((statusPanelConfig) => {
                const key = statusPanelConfig.key ?? statusPanelConfig.statusPanel;
                const existingStatusPanel = this.statusBarSvc.getStatusPanel(key);
                if (existingStatusPanel?.refresh) {
                    const newParams = this.gos.addGridCommonParams(statusPanelConfig.statusPanelParams ?? {});
                    const hasRefreshed = existingStatusPanel.refresh(newParams);
                    if (hasRefreshed) {
                        existingStatusPanelsToReuse.set(key, existingStatusPanel);
                        delete this.compDestroyFunctions[key];
                        (0, ag_grid_community_1._removeFromParent)(existingStatusPanel.getGui());
                    }
                }
            });
        }
        this.resetStatusBar();
        if (validStatusBarPanelsProvided) {
            this.processStatusPanels(existingStatusPanelsToReuse);
        }
    }
    resetStatusBar() {
        this.eStatusBarLeft.innerHTML = '';
        this.eStatusBarCenter.innerHTML = '';
        this.eStatusBarRight.innerHTML = '';
        this.destroyComponents();
        this.statusBarSvc.unregisterAllComponents();
    }
    destroy() {
        this.destroyComponents();
        super.destroy();
    }
    destroyComponents() {
        Object.values(this.compDestroyFunctions).forEach((func) => func());
        this.compDestroyFunctions = {};
    }
    createAndRenderComponents(statusBarComponents, ePanelComponent, existingStatusPanelsToReuse) {
        const componentDetails = [];
        statusBarComponents.forEach((componentConfig) => {
            // default to the component name if no key supplied
            const key = componentConfig.key || componentConfig.statusPanel;
            const existingStatusPanel = existingStatusPanelsToReuse.get(key);
            let promise;
            if (existingStatusPanel) {
                promise = ag_grid_community_1.AgPromise.resolve(existingStatusPanel);
            }
            else {
                const params = {};
                const compDetails = getStatusPanelCompDetails(this.userCompFactory, componentConfig, params);
                if (compDetails == null) {
                    return;
                }
                promise = compDetails.newAgStackInstance();
            }
            componentDetails.push({
                key,
                promise,
            });
        });
        return ag_grid_community_1.AgPromise.all(componentDetails.map((details) => details.promise)).then(() => {
            componentDetails.forEach((componentDetail) => {
                componentDetail.promise.then((component) => {
                    const destroyFunc = () => {
                        this.destroyBean(component);
                    };
                    if (this.isAlive()) {
                        this.statusBarSvc.registerStatusPanel(componentDetail.key, component);
                        ePanelComponent.appendChild(component.getGui());
                        this.compDestroyFunctions[componentDetail.key] = destroyFunc;
                    }
                    else {
                        destroyFunc();
                    }
                });
            });
        });
    }
}
exports.AgStatusBar = AgStatusBar;
exports.AgStatusBarSelector = {
    selector: 'AG-STATUS-BAR',
    component: AgStatusBar,
};


/***/ }),

/***/ 3910:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgNameValueSelector = exports.AgNameValue = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgNameValue extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `<div class="ag-status-name-value">
            <span data-ref="eLabel"></span>:&nbsp;
            <span data-ref="eValue" class="ag-status-name-value-value"></span>
        </div>`);
        this.eLabel = ag_grid_community_1.RefPlaceholder;
        this.eValue = ag_grid_community_1.RefPlaceholder;
    }
    setLabel(key, defaultValue) {
        // we want to hide until the first value comes in
        this.setDisplayed(false);
        const localeTextFunc = this.getLocaleTextFunc();
        this.eLabel.innerHTML = localeTextFunc(key, defaultValue);
    }
    setValue(value) {
        this.eValue.innerHTML = value;
    }
}
exports.AgNameValue = AgNameValue;
exports.AgNameValueSelector = {
    selector: 'AG-NAME-VALUE',
    component: AgNameValue,
};


/***/ }),

/***/ 8999:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregationComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agNameValue_1 = __webpack_require__(3910);
function _formatNumberTwoDecimalPlacesAndCommas(value, getLocaleTextFunc) {
    if (typeof value !== 'number') {
        return '';
    }
    return (0, ag_grid_community_1._formatNumberCommas)(Math.round(value * 100) / 100, getLocaleTextFunc);
}
class AggregationComp extends ag_grid_community_1.Component {
    constructor() {
        super(
        /* html */ `<div class="ag-status-panel ag-status-panel-aggregations">
            <ag-name-value data-ref="avgAggregationComp"></ag-name-value>
            <ag-name-value data-ref="countAggregationComp"></ag-name-value>
            <ag-name-value data-ref="minAggregationComp"></ag-name-value>
            <ag-name-value data-ref="maxAggregationComp"></ag-name-value>
            <ag-name-value data-ref="sumAggregationComp"></ag-name-value>
        </div>`, [agNameValue_1.AgNameValueSelector]);
        this.sumAggregationComp = ag_grid_community_1.RefPlaceholder;
        this.countAggregationComp = ag_grid_community_1.RefPlaceholder;
        this.minAggregationComp = ag_grid_community_1.RefPlaceholder;
        this.maxAggregationComp = ag_grid_community_1.RefPlaceholder;
        this.avgAggregationComp = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        if (!(0, ag_grid_community_1._isClientSideRowModel)(this.gos) && !(0, ag_grid_community_1._isServerSideRowModel)(this.gos)) {
            (0, ag_grid_community_1._warn)(221);
            return;
        }
        this.avgAggregationComp.setLabel('avg', 'Average');
        this.countAggregationComp.setLabel('count', 'Count');
        this.minAggregationComp.setLabel('min', 'Min');
        this.maxAggregationComp.setLabel('max', 'Max');
        this.sumAggregationComp.setLabel('sum', 'Sum');
        this.addManagedEventListeners({
            cellSelectionChanged: this.onCellSelectionChanged.bind(this),
            modelUpdated: this.onCellSelectionChanged.bind(this),
        });
    }
    init(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.params = params;
        this.onCellSelectionChanged();
        return true;
    }
    setAggregationComponentValue(aggFuncName, value, visible) {
        const statusBarValueComponent = this.getAllowedAggregationValueComponent(aggFuncName);
        if ((0, ag_grid_community_1._exists)(statusBarValueComponent) && statusBarValueComponent) {
            statusBarValueComponent.setValue(_formatNumberTwoDecimalPlacesAndCommas(value, this.getLocaleTextFunc.bind(this)));
            statusBarValueComponent.setDisplayed(visible);
        }
        else {
            // might have previously been visible, so hide now
            this.getAggregationValueComponent(aggFuncName)?.setDisplayed(false);
        }
    }
    getAllowedAggregationValueComponent(aggFuncName) {
        // if the user has specified the agAggregationPanelComp but no aggFuncs we show the all
        // if the user has specified the agAggregationPanelComp and aggFuncs, then we only show the aggFuncs listed
        const { aggFuncs } = this.params;
        if (!aggFuncs || aggFuncs.includes(aggFuncName)) {
            return this.getAggregationValueComponent(aggFuncName);
        }
        // either we can't find it (which would indicate a typo or similar user side), or the user has deliberately
        // not listed the component in aggFuncs
        return null;
    }
    getAggregationValueComponent(aggFuncName) {
        // converts user supplied agg name to our reference - eg: sum => sumAggregationComp
        const refComponentName = `${aggFuncName}AggregationComp`;
        return this[refComponentName];
    }
    onCellSelectionChanged() {
        const beans = this.beans;
        const { rangeSvc, valueSvc, cellNavigation } = beans;
        const cellRanges = rangeSvc?.getCellRanges();
        let sum = 0;
        let count = 0;
        let numberCount = 0;
        let min = null;
        let max = null;
        const cellsSoFar = {};
        if (cellRanges?.length && rangeSvc) {
            for (let i = 0; i < cellRanges.length; i++) {
                const cellRange = cellRanges[i];
                let currentRow = rangeSvc.getRangeStartRow(cellRange);
                const lastRow = rangeSvc.getRangeEndRow(cellRange);
                while (true) {
                    const finishedAllRows = (0, ag_grid_community_1._missing)(currentRow) || !currentRow || (0, ag_grid_community_1._isRowBefore)(lastRow, currentRow);
                    if (finishedAllRows || !currentRow || !cellRange.columns) {
                        break;
                    }
                    cellRange.columns.forEach((col) => {
                        if (currentRow === null) {
                            return;
                        }
                        // we only want to include each cell once, in case a cell is in multiple ranges
                        const cellId = (0, ag_grid_community_1._createCellId)({
                            rowPinned: currentRow.rowPinned,
                            column: col,
                            rowIndex: currentRow.rowIndex,
                        });
                        if (cellsSoFar[cellId]) {
                            return;
                        }
                        cellsSoFar[cellId] = true;
                        const rowNode = (0, ag_grid_community_1._getRowNode)(beans, currentRow);
                        if ((0, ag_grid_community_1._missing)(rowNode)) {
                            return;
                        }
                        let value = valueSvc.getValue(col, rowNode);
                        // if empty cell, skip it, doesn't impact count or anything
                        if ((0, ag_grid_community_1._missing)(value) || value === '') {
                            return;
                        }
                        count++;
                        // see if value is wrapped, can happen when doing count() or avg() functions
                        if (typeof value === 'object' && 'value' in value) {
                            value = value.value;
                            // ensure that the new value wouldn't have been skipped by the previous check
                            if (value === '') {
                                return;
                            }
                        }
                        if (typeof value === 'string') {
                            value = Number(value);
                        }
                        if (typeof value === 'number' && !isNaN(value)) {
                            sum += value;
                            if (max === null || value > max) {
                                max = value;
                            }
                            if (min === null || value < min) {
                                min = value;
                            }
                            numberCount++;
                        }
                    });
                    currentRow = cellNavigation.getRowBelow(currentRow);
                }
            }
        }
        const gotResult = count > 1;
        const gotNumberResult = numberCount > 1;
        // we show count even if no numbers
        this.setAggregationComponentValue('count', count, gotResult);
        // show if numbers found
        this.setAggregationComponentValue('sum', sum, gotNumberResult);
        this.setAggregationComponentValue('min', min, gotNumberResult);
        this.setAggregationComponentValue('max', max, gotNumberResult);
        this.setAggregationComponentValue('avg', sum / numberCount, gotNumberResult);
    }
}
exports.AggregationComp = AggregationComp;


/***/ }),

/***/ 1741:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilteredRowsComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agNameValue_1 = __webpack_require__(3910);
class FilteredRowsComp extends agNameValue_1.AgNameValue {
    postConstruct() {
        this.setLabel('filteredRows', 'Filtered');
        if (!(0, ag_grid_community_1._isClientSideRowModel)(this.gos)) {
            (0, ag_grid_community_1._warn)(222);
            return;
        }
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-filtered-row-count');
        this.setDisplayed(true);
        const listener = this.onDataChanged.bind(this);
        this.addManagedEventListeners({ modelUpdated: listener });
        listener();
    }
    onDataChanged() {
        const totalRowCountValue = this.getTotalRowCountValue();
        const filteredRowCountValue = this.getFilteredRowCountValue();
        this.setValue((0, ag_grid_community_1._formatNumberCommas)(filteredRowCountValue, this.getLocaleTextFunc.bind(this)));
        this.setDisplayed(totalRowCountValue !== filteredRowCountValue);
    }
    getTotalRowCountValue() {
        let totalRowCount = 0;
        this.beans.rowModel.forEachNode(() => (totalRowCount += 1));
        return totalRowCount;
    }
    getFilteredRowCountValue() {
        let filteredRowCount = 0;
        this.beans.rowModel.forEachNodeAfterFilter((node) => {
            if (!node.group) {
                filteredRowCount += 1;
            }
        });
        return filteredRowCount;
    }
    init() { }
    refresh() {
        return true;
    }
}
exports.FilteredRowsComp = FilteredRowsComp;


/***/ }),

/***/ 8123:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectedRowsComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agNameValue_1 = __webpack_require__(3910);
class SelectedRowsComp extends agNameValue_1.AgNameValue {
    postConstruct() {
        const gos = this.gos;
        if (!(0, ag_grid_community_1._isClientSideRowModel)(gos) && !(0, ag_grid_community_1._isServerSideRowModel)(gos)) {
            (0, ag_grid_community_1._warn)(223);
            return;
        }
        this.setLabel('selectedRows', 'Selected');
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-selected-row-count');
        this.onRowSelectionChanged();
        const eventListener = this.onRowSelectionChanged.bind(this);
        this.addManagedEventListeners({ modelUpdated: eventListener, selectionChanged: eventListener });
    }
    onRowSelectionChanged() {
        const selectedRowCount = this.beans.selectionSvc?.getSelectionCount() ?? 0;
        if (selectedRowCount < 0) {
            this.setValue('?');
            this.setDisplayed(true);
            return;
        }
        this.setValue((0, ag_grid_community_1._formatNumberCommas)(selectedRowCount, this.getLocaleTextFunc.bind(this)));
        this.setDisplayed(selectedRowCount > 0);
    }
    init() { }
    refresh() {
        return true;
    }
}
exports.SelectedRowsComp = SelectedRowsComp;


/***/ }),

/***/ 1646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TotalAndFilteredRowsComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agNameValue_1 = __webpack_require__(3910);
class TotalAndFilteredRowsComp extends agNameValue_1.AgNameValue {
    postConstruct() {
        if (!(0, ag_grid_community_1._isClientSideRowModel)(this.gos)) {
            (0, ag_grid_community_1._warn)(224);
            return;
        }
        this.setLabel('totalAndFilteredRows', 'Rows');
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-total-and-filtered-row-count');
        this.setDisplayed(true);
        this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) });
        this.onDataChanged();
    }
    onDataChanged() {
        const getLocaleTextFunc = this.getLocaleTextFunc.bind(this);
        const rowCount = (0, ag_grid_community_1._formatNumberCommas)(this.getFilteredRowCountValue(), getLocaleTextFunc);
        const totalRowCount = (0, ag_grid_community_1._formatNumberCommas)(this.getTotalRowCount(), getLocaleTextFunc);
        if (rowCount === totalRowCount) {
            this.setValue(rowCount);
        }
        else {
            const localeTextFunc = this.getLocaleTextFunc();
            this.setValue(`${rowCount} ${localeTextFunc('of', 'of')} ${totalRowCount}`);
        }
    }
    getFilteredRowCountValue() {
        let filteredRowCount = 0;
        this.beans.rowModel.forEachNodeAfterFilter((node) => {
            if (!node.group) {
                filteredRowCount++;
            }
        });
        return filteredRowCount;
    }
    getTotalRowCount() {
        let totalRowCount = 0;
        this.beans.rowModel.forEachNode((node) => {
            if (!node.group) {
                totalRowCount++;
            }
        });
        return totalRowCount;
    }
    init() { }
    refresh() {
        return true;
    }
}
exports.TotalAndFilteredRowsComp = TotalAndFilteredRowsComp;


/***/ }),

/***/ 2042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TotalRowsComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agNameValue_1 = __webpack_require__(3910);
class TotalRowsComp extends agNameValue_1.AgNameValue {
    postConstruct() {
        this.setLabel('totalRows', 'Total Rows');
        if (!(0, ag_grid_community_1._isClientSideRowModel)(this.gos)) {
            (0, ag_grid_community_1._warn)(225);
            return;
        }
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-total-row-count');
        this.setDisplayed(true);
        this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) });
        this.onDataChanged();
    }
    onDataChanged() {
        this.setValue((0, ag_grid_community_1._formatNumberCommas)(this.getRowCountValue(), this.getLocaleTextFunc.bind(this)));
    }
    getRowCountValue() {
        let totalRowCount = 0;
        this.beans.rowModel.forEachLeafNode(() => (totalRowCount += 1));
        return totalRowCount;
    }
    init() { }
    refresh() {
        return true;
    }
}
exports.TotalRowsComp = TotalRowsComp;


/***/ }),

/***/ 9516:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStatusPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function getStatusPanel(beans, key) {
    const comp = beans.statusBarSvc?.getStatusPanel(key);
    return (0, ag_grid_community_1._unwrapUserComp)(comp);
}
exports.getStatusPanel = getStatusPanel;


/***/ }),

/***/ 8450:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarModule = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const agStatusBar_1 = __webpack_require__(1866);
const aggregationComp_1 = __webpack_require__(8999);
const filteredRowsComp_1 = __webpack_require__(1741);
const selectedRowsComp_1 = __webpack_require__(8123);
const totalAndFilteredRowsComp_1 = __webpack_require__(1646);
const totalRowsComp_1 = __webpack_require__(2042);
const statusBarApi_1 = __webpack_require__(9516);
const statusBarService_1 = __webpack_require__(7947);
/**
 * @feature Accessories -> Status Bar
 * @gridOption statusBar
 */
exports.StatusBarModule = {
    moduleName: 'StatusBar',
    version: version_1.VERSION,
    beans: [statusBarService_1.StatusBarService],
    userComponents: {
        agAggregationComponent: aggregationComp_1.AggregationComp,
        agTotalRowCountComponent: totalRowsComp_1.TotalRowsComp,
        agFilteredRowCountComponent: filteredRowsComp_1.FilteredRowsComp,
        agTotalAndFilteredRowCountComponent: totalAndFilteredRowsComp_1.TotalAndFilteredRowsComp,
        agSelectedRowCountComponent: selectedRowsComp_1.SelectedRowsComp,
    },
    selectors: [agStatusBar_1.AgStatusBarSelector],
    apiFunctions: {
        getStatusPanel: statusBarApi_1.getStatusPanel,
    },
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, ag_grid_community_1._KeyboardNavigationModule],
};


/***/ }),

/***/ 7947:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarService = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class StatusBarService extends ag_grid_community_1.BeanStub {
    // tslint:disable-next-line
    constructor() {
        super();
        this.beanName = 'statusBarSvc';
        this.comps = new Map();
    }
    registerStatusPanel(key, component) {
        this.comps.set(key, component);
    }
    unregisterStatusPanel(key) {
        this.comps.delete(key);
    }
    unregisterAllComponents() {
        this.comps.clear();
    }
    getStatusPanel(key) {
        return this.comps.get(key);
    }
    destroy() {
        this.unregisterAllComponents();
        super.destroy();
    }
}
exports.StatusBarService = StatusBarService;


/***/ }),

/***/ 987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractClientSideTreeNodeManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const rowGroupingUtils_1 = __webpack_require__(8105);
const treeNode_1 = __webpack_require__(5012);
const treeRow_1 = __webpack_require__(2546);
const getExpandedInitialValue = (details, oldRow, row) => {
    if (oldRow !== row &&
        oldRow !== null &&
        oldRow.group &&
        (0, treeRow_1.isTreeRowExpandedInitialized)(oldRow) &&
        !details.isGroupOpenByDefault // If we have a callback, we use that instead
    ) {
        // When removing a group and so it gets replaced by a filler or new node, its expanded state is retained. See AG-12591
        return oldRow.expanded;
    }
    const userCallback = details.isGroupOpenByDefault;
    return userCallback
        ? userCallback({
            rowNode: row,
            field: row.field,
            key: row.key,
            level: row.level,
            rowGroupColumn: row.rowGroupColumn,
        }) == true
        : details.expandByDefault === -1 || row.level < details.expandByDefault;
};
class AbstractClientSideTreeNodeManager extends ag_grid_community_1.AbstractClientSideNodeManager {
    constructor() {
        super(...arguments);
        this.oldGroupDisplayColIds = '';
        /** Rows that are pending deletion, this.commitDeletedRows() will finalize removal. */
        this.rowsPendingDestruction = null;
        /** The root node of the tree. */
        this.treeRoot = null;
    }
    activate(rootNode) {
        super.activate(rootNode);
        (this.treeRoot ?? (this.treeRoot = new treeNode_1.TreeNode(null, '', -1))).setRow(rootNode);
    }
    destroy() {
        super.destroy();
        // Forcefully deallocate memory
        this.treeRoot = null;
        this.rowsPendingDestruction = null;
        this.oldGroupDisplayColIds = '';
    }
    deactivate() {
        const treeRoot = this.treeRoot;
        if (treeRoot) {
            const rootRow = treeRoot.row;
            if (rootRow !== null) {
                treeRoot.removeRow(rootRow);
                (0, treeRow_1.clearTreeRowFlags)(rootRow);
            }
            this.treeDestroy(treeRoot);
        }
        this.commitDestroyedRows();
        super.deactivate();
        this.treeRoot = null;
        this.oldGroupDisplayColIds = '';
    }
    /** Add or updates the row to a non-root node, preparing the tree correctly for the commit. */
    treeSetRow(node, newRow, created) {
        const { level, row: oldRow } = node;
        if (level < 0) {
            return false; // Cannot overwrite the root row
        }
        let invalidate = false;
        if (oldRow !== newRow) {
            const prevNode = newRow.treeNode;
            if (prevNode !== null && prevNode !== node) {
                // The new row is somewhere else in the tree, we need to move it.
                prevNode.removeRow(newRow);
                prevNode.invalidate();
            }
            if (oldRow === null) {
                // No previous row, just set the new row.
                node.setRow(newRow);
                invalidate = true;
            }
            else if (!oldRow.data) {
                // We are replacing a filler row with a real row.
                node.setRow(newRow);
                this.destroyRow(oldRow, true); // Delete the filler node
                invalidate = true;
            }
            else {
                // We have a new non-filler row, but we had already one, this is a duplicate
                if (node.addDuplicateRow(newRow)) {
                    invalidate = true;
                }
            }
        }
        if (!created && !(0, treeRow_1.isTreeRowUpdated)(newRow)) {
            (0, treeRow_1.setTreeRowUpdated)(newRow);
            invalidate = true;
        }
        if (invalidate) {
            node.invalidate();
        }
        this.rowsPendingDestruction?.delete(newRow); // This row is not deleted.
        return invalidate;
    }
    /**
     * Overwrites the row property of a non-root node to null.
     * @returns The previous row, if any, that was overwritten.
     */
    treeRemove(node, oldRow) {
        const { parent, level } = node;
        if (level < 0) {
            return; // Cannot overwrite a null node or the root row
        }
        let invalidate = false;
        if (node.removeRow(oldRow)) {
            invalidate = true;
            if (parent) {
                parent.childrenChanged = true;
            }
            this.destroyRow(oldRow, !oldRow.data);
        }
        if (invalidate) {
            node.invalidate();
        }
    }
    /** Commit the changes performed to the tree */
    treeCommit(changedPath) {
        const { treeRoot, rootNode } = this;
        if (!treeRoot || !rootNode) {
            return;
        }
        const treeData = this.treeData;
        const details = {
            rootNode,
            changedPath,
            treeData,
            expandByDefault: this.gos.get('groupDefaultExpanded'),
            isGroupOpenByDefault: this.gos.getCallback('isGroupOpenByDefault'),
        };
        this.treeCommitChildren(details, treeRoot, false);
        const rootRow = treeRoot.row;
        if (rootRow) {
            if (treeData) {
                rootRow.leafGroup = false; // no pivoting with tree data
            }
            if (treeRoot.childrenChanged) {
                if (treeRoot.updateChildrenAfterGroup(treeData)) {
                    (0, treeRow_1.markTreeRowPathChanged)(rootRow);
                }
            }
            if ((0, treeRow_1.isTreeRowPathChanged)(rootRow)) {
                if (details.changedPath?.active) {
                    details.changedPath.addParentNode(rootRow);
                }
            }
            (0, treeRow_1.markTreeRowCommitted)(rootRow);
            rootRow.updateHasChildren();
        }
        this.commitDestroyedRows();
        this.beans.selectionSvc?.updateSelectableAfterGrouping(changedPath);
    }
    /** Calls commitChild for each invalidated child, recursively. We commit only the invalidated paths. */
    treeCommitChildren(details, parent, collapsed) {
        while (true) {
            const child = parent.dequeueInvalidated();
            if (child === null) {
                break;
            }
            if (child.parent === parent) {
                this.treeCommitChild(details, child, collapsed || !(parent.row?.expanded ?? true));
            }
        }
        // Ensure the childrenAfterGroup array is up to date with treeData flag
        parent.childrenChanged || (parent.childrenChanged = (details.treeData ? parent.size : 0) !== parent.row.childrenAfterGroup?.length);
    }
    /** Commit the changes performed to a node and its children */
    treeCommitChild(details, node, collapsed) {
        if (node.isEmptyFillerNode()) {
            this.treeClear(node);
            return; // Removed. No need to process children.
        }
        this.treeCommitPreOrder(details, node);
        this.treeCommitChildren(details, node, collapsed);
        if (node.isEmptyFillerNode()) {
            this.treeClear(node);
            return; // Removed. No need to process further
        }
        this.treeCommitPostOrder(details, node, collapsed);
    }
    treeCommitPreOrder(details, node) {
        let row = node.row;
        if (row === null) {
            row = this.createFillerRow(node);
            node.setRow(row);
        }
        else {
            row = node.sortFirstDuplicateRow(); // The main row must have the smallest sourceRowIndex of duplicates
            if (row.allChildrenCount === undefined) {
                row.allChildrenCount = null; // initialize to null if this field wasn't initialized yet
            }
        }
        if (details.treeData) {
            row.parent = node.parent.row;
            if (node.oldRow !== row) {
                // We need to update children rows parents, as the row changed
                for (const child of node.enumChildren()) {
                    const childRow = child.row;
                    if (childRow !== null) {
                        childRow.parent = row;
                    }
                }
            }
            const key = node.key;
            if (row.key !== key) {
                row.key = key;
                (0, treeRow_1.setTreeRowKeyChanged)(row);
                this.setGroupData(row, key);
            }
            else if (!row.groupData) {
                this.setGroupData(row, key);
            }
        }
        else {
            row.key = node.key;
            row.parent = details.rootNode;
        }
    }
    treeCommitPostOrder(details, node, collapsed) {
        const parent = node.parent;
        const row = node.row;
        const oldRow = node.oldRow;
        const treeData = details.treeData;
        if (node.childrenChanged) {
            if (node.updateChildrenAfterGroup(treeData)) {
                (0, treeRow_1.markTreeRowPathChanged)(row);
            }
        }
        if (node.leafChildrenChanged) {
            node.updateAllLeafChildren();
        }
        const hasChildren = !!row.childrenAfterGroup?.length;
        const group = hasChildren || !row.data;
        const oldGroup = row.group;
        if (oldGroup !== group) {
            (0, treeRow_1.markTreeRowPathChanged)(row);
            (0, rowGroupingUtils_1.setRowNodeGroup)(row, this.beans, group); // Internally calls updateHasChildren
            if (!group && !row.expanded) {
                (0, treeRow_1.setTreeRowExpandedInitialized)(row, false);
            }
        }
        else if (row.hasChildren() !== hasChildren) {
            (0, treeRow_1.markTreeRowPathChanged)(row);
            row.updateHasChildren();
        }
        if (group && !(0, treeRow_1.isTreeRowExpandedInitialized)(row)) {
            row.expanded = getExpandedInitialValue(details, oldRow, row);
            (0, treeRow_1.setTreeRowExpandedInitialized)(row, true);
        }
        if ((0, treeRow_1.isTreeRowUpdated)(row)) {
            (0, treeRow_1.markTreeRowPathChanged)(parent.row);
            if ((0, treeRow_1.isTreeRowKeyChanged)(row)) {
                // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get
                // refreshed into the gui.
                // this is needed to kick off the event that rowComp listens to for refresh. this in turn
                // then will get each cell in the row to refresh - which is what we need as we don't know which
                // columns will be displaying the rowNode.key info.
                row.setData(row.data);
            }
        }
        if (oldRow !== row) {
            node.oldRow = row;
            if (oldRow !== null && (oldGroup || node.size !== 0)) {
                (0, treeRow_1.markTreeRowPathChanged)(row);
            }
            parent.childrenChanged = true;
            (0, treeRow_1.markTreeRowPathChanged)(parent.row);
        }
        if ((0, treeRow_1.isTreeRowPathChanged)(row)) {
            if (treeData && details.changedPath?.active) {
                details.changedPath.addParentNode(row);
            }
            else {
                (0, treeRow_1.markTreeRowPathChanged)(details.rootNode);
            }
        }
        (0, treeRow_1.markTreeRowCommitted)(row);
        if (node.duplicateRows?.size && !node.duplicateRowsWarned) {
            node.duplicateRowsWarned = true;
            (0, ag_grid_community_1._warn)(186, {
                rowId: row.id,
                rowData: row.data,
                duplicateRowsData: Array.from(node.duplicateRows).map((r) => r.data),
            });
        }
        if (collapsed && row.rowIndex !== null) {
            row.clearRowTopAndRowIndex(); // Hidden.
        }
        const sourceIdx = node.getNewSourceIdx();
        const prevRowIdx = node.sourceIdx;
        if (prevRowIdx !== sourceIdx) {
            node.sourceIdx = sourceIdx;
            if (prevRowIdx !== -1) {
                // TODO: this is not optimal, it has false positives.
                // we could optimize it if we have a way to know if a node
                // is out of order, we could do this by using a linked list instead of a map, so
                // we can directly know if a node is out of order in O(1)
                parent.childrenChanged = true; // The order of children in parent might have changed
            }
        }
    }
    createFillerRow(node) {
        const row = new ag_grid_community_1.RowNode(this.beans); // Create a filler node
        row.key = node.key;
        row.group = true;
        row.field = null;
        row.leafGroup = false;
        row.rowGroupIndex = null;
        row.allChildrenCount = null;
        // Generate a unique id for the filler row
        let id = node.level + '-' + node.key;
        let p = node.parent;
        while (p !== null) {
            const parent = p.parent;
            if (parent === null) {
                break;
            }
            id = `${p.level}-${p.key}-${id}`;
            p = parent;
        }
        row.id = ag_grid_community_1._ROW_ID_PREFIX_ROW_GROUP + id;
        return row;
    }
    setGroupData(row, key) {
        const groupData = {};
        row.groupData = groupData;
        const groupDisplayCols = this.beans.showRowGroupCols?.getShowRowGroupCols();
        if (groupDisplayCols) {
            for (const col of groupDisplayCols) {
                // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column
                // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so
                groupData[col.getColId()] = key;
            }
        }
    }
    /** Called to clear a subtree. */
    treeClear(node) {
        const { parent, oldRow, row, level } = node;
        if (parent !== null && oldRow !== null) {
            parent.childrenChanged = true;
            if (parent.row !== null) {
                (0, treeRow_1.markTreeRowPathChanged)(parent.row);
            }
        }
        if (row !== null) {
            if (level >= 0) {
                let row = node.row;
                while (row !== null && node.removeRow(row)) {
                    this.destroyRow(row, !row.data);
                    row = node.row;
                }
            }
        }
        for (const child of node.enumChildren()) {
            this.treeClear(child);
        }
        node.destroy();
    }
    /** Called by the deactivate, to destroy the whole tree. */
    treeDestroy(node) {
        const { row, level, duplicateRows } = node;
        if (row) {
            if (level >= 0 && !row.data) {
                this.destroyRow(row, true); // Delete the filler node
            }
            else {
                (0, treeRow_1.clearTreeRowFlags)(row); // Just clear the flags
            }
        }
        if (duplicateRows) {
            for (const row of duplicateRows) {
                if (level >= 0 && !row.data) {
                    this.destroyRow(row, true); // Delete filler nodes
                }
                else {
                    (0, treeRow_1.clearTreeRowFlags)(row); // Just clear the flags
                }
            }
        }
        for (const child of node.enumChildren()) {
            this.treeDestroy(child);
        }
        node.destroy();
    }
    /**
     * Finalizes the deletion of a row.
     * @param immediate If true, the row is deleted immediately.
     * If false, the row is marked for deletion, and will be deleted later with this.deleteDeletedRows()
     */
    destroyRow(row, immediate) {
        if (row.isSelected()) {
            immediate = false; // Need to be deleted later as we need to unselect it first
        }
        else if (!(0, treeRow_1.isTreeRowCommitted)(row)) {
            (0, treeRow_1.clearTreeRowFlags)(row);
            return; // Never committed, or already deleted, and not selected. Nothing to do.
        }
        if (!immediate) {
            (this.rowsPendingDestruction ?? (this.rowsPendingDestruction = new Set())).add(row);
            return; // We will delete it later with commitDeletedRows
        }
        (0, treeRow_1.clearTreeRowFlags)(row);
        // We execute this only if the row was committed at least once before, and not already deleted.
        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and
        // remove, if rowTop is still present, the rowComp thinks it's just moved position.
        row.clearRowTopAndRowIndex();
        row.groupData = null;
    }
    /**
     * destroyRow can defer the deletion to the end of the commit stage.
     * This method finalizes the deletion of rows that were marked for deletion.
     */
    commitDestroyedRows() {
        const { rowsPendingDestruction } = this;
        let nodesToUnselect = null;
        if (rowsPendingDestruction !== null) {
            for (const row of rowsPendingDestruction) {
                this.destroyRow(row, true);
                if (row.isSelected()) {
                    (nodesToUnselect ?? (nodesToUnselect = [])).push(row);
                }
            }
            this.rowsPendingDestruction = null;
        }
        if (nodesToUnselect) {
            this.deselectNodes(nodesToUnselect);
        }
    }
    refreshModel(params) {
        if (!params.afterColumnsChanged) {
            return; // nothing to do
        }
        // Check if group data need to be recomputed due to group columns change
        if (this.treeData) {
            const newGroupDisplayColIds = this.beans.showRowGroupCols
                ?.getShowRowGroupCols()
                ?.map((c) => c.getId())
                .join('-') ?? '';
            // if the group display cols have changed, then we need to update rowNode.groupData
            // (regardless of tree data or row grouping)
            if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {
                this.oldGroupDisplayColIds = newGroupDisplayColIds;
                const rowNodes = this.rootNode?.childrenAfterGroup;
                if (rowNodes) {
                    for (let i = 0, len = rowNodes.length ?? 0; i < len; ++i) {
                        const rowNode = rowNodes[i];
                        const treeNode = rowNode.treeNode;
                        if (treeNode) {
                            this.setGroupData(rowNode, treeNode.key);
                        }
                    }
                }
            }
        }
        else {
            this.oldGroupDisplayColIds = '';
        }
    }
}
exports.AbstractClientSideTreeNodeManager = AbstractClientSideTreeNodeManager;


/***/ }),

/***/ 4352:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideChildrenTreeNodeManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const abstractClientSideTreeNodeManager_1 = __webpack_require__(987);
const fieldAccess_1 = __webpack_require__(7084);
class ClientSideChildrenTreeNodeManager extends abstractClientSideTreeNodeManager_1.AbstractClientSideTreeNodeManager {
    constructor() {
        super(...arguments);
        this.beanName = 'csrmChildrenTreeNodeSvc';
        this.childrenGetter = null;
    }
    get treeData() {
        return this.gos.get('treeData');
    }
    extractRowData() {
        const treeRoot = this.treeRoot;
        return treeRoot && Array.from(treeRoot.enumChildren(), (node) => node.row.data);
    }
    destroy() {
        super.destroy();
        // Forcefully deallocate memory
        this.childrenGetter = null;
    }
    activate(rootNode) {
        const oldChildrenGetter = this.childrenGetter;
        const childrenField = this.gos.get('treeDataChildrenField');
        if (!oldChildrenGetter || oldChildrenGetter.path !== childrenField) {
            this.childrenGetter = (0, fieldAccess_1.makeFieldPathGetter)(childrenField);
        }
        super.activate(rootNode);
    }
    loadNewRowData(rowData) {
        const treeRoot = this.treeRoot;
        const rootNode = this.rootNode;
        const childrenGetter = this.childrenGetter;
        const processedData = new Map();
        const allLeafChildren = [];
        rootNode.allLeafChildren = allLeafChildren;
        this.treeClear(treeRoot);
        treeRoot.setRow(rootNode);
        const processChild = (node, data) => {
            let row = processedData.get(data);
            if (row !== undefined) {
                (0, ag_grid_community_1._error)(2, { nodeId: row.id }); // Duplicate node
                return;
            }
            row = this.createRowNode(data, allLeafChildren.length);
            processedData.set(data, row);
            allLeafChildren.push(row);
            node = node.upsertKey(row.id);
            this.treeSetRow(node, row, true);
            const children = childrenGetter?.(data);
            if (children) {
                for (let i = 0, len = children.length; i < len; ++i) {
                    processChild(node, children[i]);
                }
            }
        };
        for (let i = 0, len = rowData.length; i < len; ++i) {
            processChild(treeRoot, rowData[i]);
        }
        this.treeCommit();
    }
    setImmutableRowData(params, rowData) {
        const gos = this.gos;
        const treeRoot = this.treeRoot;
        const rootNode = this.rootNode;
        const childrenGetter = this.childrenGetter;
        const getRowIdFunc = (0, ag_grid_community_1._getRowIdCallback)(gos);
        const canReorder = !gos.get('suppressMaintainUnsortedOrder');
        const processedData = new Map();
        const changedPath = new ag_grid_community_1.ChangedPath(false, rootNode);
        params.changedPath = changedPath;
        const changedRowNodes = params.changedRowNodes;
        const oldAllLeafChildren = rootNode.allLeafChildren;
        const allLeafChildren = [];
        const nodesToUnselect = [];
        let orderChanged = false;
        let rowsChanged = false;
        const processChildrenNoReorder = (node, children) => {
            for (let i = 0, len = children.length; i < len; ++i) {
                processChild(node, children[i]);
            }
        };
        const processChildrenReOrder = (node, children) => {
            const childrenLen = children?.length;
            let inOrder = true;
            let prevIndex = -1;
            for (let i = 0; i < childrenLen; ++i) {
                const oldSourceRowIndex = processChild(node, children[i]);
                if (oldSourceRowIndex >= 0) {
                    if (oldSourceRowIndex < prevIndex) {
                        inOrder = false;
                    }
                    prevIndex = oldSourceRowIndex;
                }
            }
            if (!inOrder) {
                orderChanged = true;
                if (!node.childrenChanged) {
                    node.childrenChanged = true;
                    node.invalidate();
                }
            }
        };
        const processChildren = canReorder ? processChildrenReOrder : processChildrenNoReorder;
        const processChild = (parent, data) => {
            let row = processedData.get(data);
            if (row !== undefined) {
                (0, ag_grid_community_1._warn)(2, { nodeId: row.id }); // Duplicate node
                return -1;
            }
            const id = getRowIdFunc({ data, level: parent.level + 1 });
            let created = false;
            row = this.getRowNode(id);
            if (row) {
                if (row.data !== data) {
                    changedRowNodes.update(row);
                    row.updateData(data);
                    if (!row.selectable && row.isSelected()) {
                        nodesToUnselect.push(row);
                    }
                }
            }
            else {
                row = this.createRowNode(data, -1);
                changedRowNodes.add(row);
                created = true;
            }
            processedData.set(data, row);
            let oldSourceRowIndex;
            let node;
            if (canReorder) {
                node = parent.appendKey(row.id);
                oldSourceRowIndex = row.sourceRowIndex;
                row.sourceRowIndex = allLeafChildren.push(row) - 1;
            }
            else {
                node = parent.upsertKey(row.id);
                oldSourceRowIndex = -1;
            }
            if (this.treeSetRow(node, row, created)) {
                rowsChanged = true;
            }
            const children = childrenGetter?.(data);
            if (children) {
                processChildren(node, children);
            }
            return oldSourceRowIndex;
        };
        processChildren(treeRoot, rowData);
        if (oldAllLeafChildren) {
            for (let i = 0, len = oldAllLeafChildren.length; i < len; ++i) {
                const row = oldAllLeafChildren[i];
                const node = row.treeNode;
                if (node) {
                    const data = row.data;
                    if (data && !processedData.has(data)) {
                        changedRowNodes.remove(row);
                        this.treeRemove(node, row);
                    }
                }
            }
        }
        if (!canReorder) {
            // To maintain the old order, we need to process all children as they appear in the node, recursively
            const appendChildren = (node) => {
                for (const child of node.enumChildren()) {
                    const row = child.row;
                    if (row) {
                        row.sourceRowIndex = allLeafChildren.push(row) - 1;
                        appendChildren(child);
                    }
                }
            };
            appendChildren(treeRoot);
        }
        rootNode.allLeafChildren = allLeafChildren;
        treeRoot.allLeafChildren = allLeafChildren;
        if (nodesToUnselect.length) {
            this.deselectNodes(nodesToUnselect);
        }
        this.treeCommit(changedPath);
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.allLeafChildren = allLeafChildren;
        }
        if (rowsChanged || orderChanged) {
            params.step = 'group';
            params.rowDataUpdated = true;
            params.rowNodesOrderChanged = orderChanged;
        }
    }
    refreshModel(params) {
        const { rootNode, treeRoot } = this;
        if (!treeRoot) {
            return; // Not active, destroyed
        }
        if (params.changedProps?.has('treeData') && !params.newData) {
            treeRoot.setRow(rootNode);
            const allLeafChildren = rootNode?.allLeafChildren;
            if (allLeafChildren) {
                for (let i = 0, len = allLeafChildren.length; i < len; ++i) {
                    const row = allLeafChildren[i];
                    row.groupData = null;
                    row.treeNode?.invalidate();
                }
            }
            this.treeCommit();
        }
        super.refreshModel(params);
    }
}
exports.ClientSideChildrenTreeNodeManager = ClientSideChildrenTreeNodeManager;


/***/ }),

/***/ 4292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSidePathTreeNodeManager = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const abstractClientSideTreeNodeManager_1 = __webpack_require__(987);
class ClientSidePathTreeNodeManager extends abstractClientSideTreeNodeManager_1.AbstractClientSideTreeNodeManager {
    constructor() {
        super(...arguments);
        this.beanName = 'csrmPathTreeNodeSvc';
    }
    loadNewRowData(rowData) {
        const rootNode = this.rootNode;
        const treeRoot = this.treeRoot;
        this.treeClear(treeRoot);
        treeRoot.setRow(rootNode);
        super.loadNewRowData(rowData);
        const allLeafChildren = rootNode.allLeafChildren;
        const getDataPath = this.gos.get('getDataPath');
        for (let i = 0, len = allLeafChildren.length; i < len; ++i) {
            this.addOrUpdateRow(getDataPath, allLeafChildren[i], true);
        }
        this.treeCommit();
    }
    get treeData() {
        const gos = this.gos;
        return gos.get('treeData') && !!gos.get('getDataPath');
    }
    refreshModel(params) {
        const changedRowNodes = params.changedRowNodes;
        if (changedRowNodes) {
            this.executeTransactions(changedRowNodes, params.changedPath, params.rowNodesOrderChanged);
        }
        super.refreshModel(params);
    }
    executeTransactions(changedRowNodes, changedPath, rowNodesOrderMaybeChanged) {
        const treeRoot = this.treeRoot;
        if (!treeRoot) {
            return; // Destroyed or not active
        }
        treeRoot.setRow(this.rootNode);
        for (const row of changedRowNodes.removals) {
            const node = row.treeNode;
            if (node) {
                this.treeRemove(node, row);
            }
        }
        const updates = changedRowNodes.updates;
        const getDataPath = this.gos.get('getDataPath');
        for (const row of updates.keys()) {
            this.addOrUpdateRow(getDataPath, row, updates.get(row));
        }
        const rows = treeRoot.row?.allLeafChildren;
        if (rowNodesOrderMaybeChanged && rows) {
            for (let rowIdx = 0, rowsLen = rows.length; rowIdx < rowsLen; ++rowIdx) {
                const node = rows[rowIdx].treeNode;
                if (node && node.sourceIdx !== rowIdx) {
                    node.invalidateOrder(); // Order might have changed
                }
            }
        }
        this.treeCommit(changedPath); // One single commit for all the transactions
    }
    addOrUpdateRow(getDataPath, row, created) {
        const treeRoot = this.treeRoot;
        if (!this.treeData) {
            // We assume that the data is flat and we use id as the key for the tree nodes.
            // This happens when treeData is false and getDataPath is undefined/null.
            this.treeSetRow(treeRoot.upsertKey(row.id), row, created);
            return;
        }
        const path = getDataPath?.(row.data);
        const pathLength = path?.length;
        if (!pathLength) {
            (0, ag_grid_community_1._warn)(185, { data: row.data });
        }
        else {
            // Gets the last node of a path. Inserts filler nodes where needed.
            let level = 0;
            let node = treeRoot;
            do {
                node = node.upsertKey(path[level++]);
            } while (level < pathLength);
            this.treeSetRow(node, row, created);
        }
    }
}
exports.ClientSidePathTreeNodeManager = ClientSidePathTreeNodeManager;


/***/ }),

/***/ 7084:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeFieldPathGetter = void 0;
const parseFieldPath = (fieldPath) => {
    if (typeof fieldPath !== 'string' || !fieldPath.length) {
        return [];
    }
    const segments = fieldPath.split('.');
    if (segments.includes('__proto__')) {
        // TODO: maybe we should raise an error like 'Field path contains restricted keyword "__proto__"'
        return []; // Avoid the risk of accessing prototype
    }
    return segments;
};
/**
 * Precompiles a field getter function for a given field path.
 * Note: the result should be cached, as it can be reused for multiple objects.
 * @param fieldPath The field path to compile, for example 'a.b.c'.
 * @returns A function that retrieves the value of the field from an object.
 */
const makeFieldPathGetter = (fieldPath) => {
    const splitPath = parseFieldPath(fieldPath);
    let result = null;
    const last = splitPath.length - 1;
    if (last === 0) {
        result = ((data) => data?.[fieldPath]);
    }
    else if (last > 0) {
        result = ((data) => {
            let value = data;
            for (let i = 0; i <= last && value !== null && value !== undefined; ++i) {
                value = value[splitPath[i]];
                if (i < last && typeof value !== 'object' && value !== undefined) {
                    // TODO: maybe we should raise an error like 'Accessing a ' + typeof value + ' not allowed in field path'
                    return null;
                }
            }
            return value;
        });
    }
    else {
        result = (() => undefined);
    }
    result.path = fieldPath;
    return result;
};
exports.makeFieldPathGetter = makeFieldPathGetter;


/***/ }),

/***/ 9428:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeDataModule = exports.SharedTreeDataModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const aggregationModule_1 = __webpack_require__(7032);
const rowHierarchyModule_1 = __webpack_require__(6858);
const version_1 = __webpack_require__(7205);
const clientSideChildrenTreeNodeManager_1 = __webpack_require__(4352);
const clientSidePathTreeNodeManager_1 = __webpack_require__(4292);
/**
 * @internal
 */
exports.SharedTreeDataModule = {
    moduleName: 'SharedTreeData',
    version: version_1.VERSION,
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule, aggregationModule_1.SharedAggregationModule, rowHierarchyModule_1.GroupColumnModule, rowHierarchyModule_1.StickyRowModule],
};
/**
 * @feature Tree Data
 * @gridOption treeData
 */
exports.TreeDataModule = {
    moduleName: 'TreeData',
    version: version_1.VERSION,
    beans: [clientSidePathTreeNodeManager_1.ClientSidePathTreeNodeManager, clientSideChildrenTreeNodeManager_1.ClientSideChildrenTreeNodeManager],
    rowModels: ['clientSide'],
    dependsOn: [exports.SharedTreeDataModule, aggregationModule_1.AggregationModule, rowHierarchyModule_1.ClientSideRowModelHierarchyModule],
};


/***/ }),

/***/ 5012:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeNode = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const treeNodePositionComparer = (a, b) => a.treeNode.sourceIdx - b.treeNode.sourceIdx;
/** An empty iterator, to avoid null checking when we iterate the children map */
const EMPTY_CHILDREN = ag_grid_community_1._EmptyArray.values();
/** Disassociate a node from a row, breaking the association to the node. Only the row is modified, not the TreeNode. */
const orphanRow = (row, root) => {
    row.parent = null;
    row.treeNode = null;
    if (root) {
        row.childrenAfterGroup = [];
    }
    else {
        row.level = 0;
        row.childrenAfterGroup = null;
        row.allLeafChildren = null;
    }
};
/**
 * We keep a secondary tree data structure based on TreeNode together with the RowNodes.
 * We associate a RowNode with a TreeNode, both storing the row in node.row and by storing the TreeNode in row.treeNode field.
 * We break the association when the row is removed or the TreeStrategy destroyed.
 * Consider that a TreeNode can contain more than one RowNode if there are duplicates keys in the same group,
 * in this case it means that the rows will have the same TreeNode.
 *
 * TreeStrategy uses a two stage approach both for first time creation and updates.
 * Multiple updates interact with the tree, and a commit stage commits all updates reducing expensive computations.
 *
 * Operations that do not affect the order will invalidate only the affected paths with node.invalidate(),
 * so that the commit operation will only update the affected paths without traversing the whole tree.
 * Consider that order of invalidated items is not deterministic, so the commit operation should be able to handle any order.
 *
 * During commit, the childrenAfterGroup and allLeafChildren arrays are rebuilt, and the updates are applied.
 * The empty filler nodes nodes are removed.
 * Before commit those arrays are NOT representing the truth, so they should not be used.
 */
class TreeNode {
    constructor(
    /** The parent node of this node. Is null if destroyed or if is the root. */
    parent, 
    /** The key of this node. */
    key, 
    /** The level of this node. Root has level -1 */
    level) {
        this.parent = parent;
        this.key = key;
        this.level = level;
        /** Contains all the children by their key */
        this.children = null;
        /**
         * The head of the singly linked list of direct children nodes that are invalidated and need to be committed.
         * We use this so we can invalidate just the path and explore only the invalidated during commit.
         * Also, once a path is invalidated the next invalidation will not add the same node again and stop the recursion quickly.
         */
        this.invalidatedHead = null;
        /**
         * The next node in the linked list of parent.invalidatedHead.
         * - undefined: the node is not invalidated (not present in the parent linked list)
         * - null: this is the first and last node in the linked list
         * - TreeNode instance: is the next node in the linked list
         */
        this.invalidatedNext = undefined;
        /** The RowNode associated to this tree node */
        this.row = null;
        /** We use this during commit to understand if the row changed. After commit, it will be the same as this.row. */
        this.oldRow = null;
        /**
         * There may be duplicate rows if they have the same key.
         * This is NOT an edge case, temporarily duplicates may arise during transactions.
         * For example, think about swapping the paths of two nodes, they will have the same key for a short while.
         */
        this.duplicateRows = null;
        /** We keep the row.childrenAfterGroup here, we just swap arrays when we assign rows */
        this.childrenAfterGroup = ag_grid_community_1._EmptyArray;
        /**
         * We keep the row.allLeafChildren here, we just swap arrays when we assign or swap the row to this node.
         * If this is null, we are borrowing the allLeafChildren array from one of the children,
         * in this case the row.allLeafChildren will be the same as one of the childrenAfterGroup[x].allLeafChildren,
         * to get the allLeafChildren if is null, do node.allLeafChildren ?? node.row.allLeafChildren.
         */
        this.allLeafChildren = ag_grid_community_1._EmptyArray;
        /** Indicates whether childrenAfterGroup might need to be recomputed and sorted. Reset during commit. */
        this.childrenChanged = false;
        /** Indicates whether allLeafChildren should be recomputed. Reset to false during commit. */
        this.leafChildrenChanged = false;
        /** The ordering this node had in the previous commit. */
        this.sourceIdx = -1;
    }
    /** Returns the number of children in this node */
    get size() {
        return this.children?.size ?? 0;
    }
    isEmptyFillerNode() {
        return !this.row?.data && !this.children?.size;
    }
    /** Returns an iterator able to iterate all children in this node, in order of insertion */
    enumChildren() {
        return this.children?.values() ?? EMPTY_CHILDREN;
    }
    /**
     * Gets a node a key in the given parent. If the node does not exists, creates a filler node, with null row.
     * We cast to string just to be sure the user passed a string correctly and not a number or something else.
     * @param key - The key of the node to get.
     * @param append - If true, the node will be moved to the end of the children list.
     * @returns the node at the given key, or a new filler node inserted there if it does not exist.
     */
    upsertKey(key) {
        if (typeof key !== 'string') {
            key = String(key);
        }
        let node = this.children?.get(key);
        if (!node) {
            node = new TreeNode(this, key, this.level + 1);
            (this.children ?? (this.children = new Map()))?.set(node.key, node); // Add to the map
        }
        return node;
    }
    /** Same as upsertKey, but moves the node to the end no matter what. */
    appendKey(key) {
        const children = this.children;
        if (typeof key !== 'string') {
            key = String(key);
        }
        let node = children?.get(key);
        if (node) {
            children.delete(key); // Remove from the map
            children.set(key, node); // Reinsert to the map
        }
        else {
            node = new TreeNode(this, key, this.level + 1);
            (this.children ?? (this.children = new Map()))?.set(node.key, node); // Add to the map
        }
        return node;
    }
    /** Removes this node from the parent, and free memory. This node cannot be used after this. */
    destroy() {
        const { row, parent } = this;
        if (parent === null) {
            return;
        }
        parent?.children?.delete(this.key);
        if (row !== null) {
            orphanRow(row, true);
        }
        this.parent = null;
    }
    /**
     * Sets the row for the TreeNode.
     * If the row is already set, it will be replaced with the new row, and the old row will be orphaned.
     * childrenAfterGroup and allLeafChildren will be reassigned.
     * @returns True if the row changed
     */
    setRow(newRow) {
        const { level, row: oldRow, childrenAfterGroup } = this;
        if (level < 0) {
            if (oldRow !== null && oldRow !== newRow) {
                orphanRow(oldRow, true);
            }
        }
        else {
            if (oldRow === newRow) {
                return false; // Already the same row
            }
            if (oldRow !== null) {
                if (newRow !== null) {
                    newRow.allLeafChildren = oldRow.allLeafChildren ?? this.allLeafChildren ?? ag_grid_community_1._EmptyArray;
                }
                orphanRow(oldRow, false); // Unlink the old row, is being replaced
            }
            else if (newRow !== null) {
                newRow.allLeafChildren = this.allLeafChildren ?? ag_grid_community_1._EmptyArray;
            }
        }
        if (newRow !== null) {
            newRow.level = level;
            newRow.childrenAfterGroup = childrenAfterGroup;
            newRow.treeNode = this;
        }
        this.row = newRow;
        return true;
    }
    /**
     * Removes a row from the tree node.
     * If the row is the main row, it will be replaced with the first row in the duplicate rows, if any.
     * If the row is a duplicate row, it will be removed from the duplicate rows.
     * @param rowToRemove - The row to be removed.
     * @returns `true` if the row was successfully removed, `false` if the row was not found.
     */
    removeRow(rowToRemove) {
        const { level, row, duplicateRows, childrenAfterGroup } = this;
        if (row === rowToRemove) {
            const duplicate = this.popDuplicateRow();
            if (duplicate) {
                this.row = duplicate;
                duplicate.childrenAfterGroup = childrenAfterGroup;
                if (level >= 0) {
                    duplicate.allLeafChildren = row.allLeafChildren ?? this.allLeafChildren ?? ag_grid_community_1._EmptyArray;
                }
            }
            else {
                this.row = null;
            }
        }
        else {
            // Delete from the duplicate rows
            if (!duplicateRows?.delete(rowToRemove)) {
                return false; // Not found
            }
            if (duplicateRows.size === 0) {
                this.duplicateRows = null; // Free memory
            }
        }
        orphanRow(rowToRemove, level < 0);
        return true;
    }
    /**
     * Adds a duplicate row to the tree node.
     * @param newRow - The new row to be added.
     * @returns A boolean indicating whether the row was successfully added.
     */
    addDuplicateRow(newRow) {
        const { level } = this;
        let duplicateRows = this.duplicateRows;
        if (duplicateRows === null) {
            duplicateRows = new Set();
            this.duplicateRows = duplicateRows;
        }
        else if (duplicateRows.has(newRow)) {
            return false; // Already present
        }
        duplicateRows.add(newRow);
        newRow.treeNode = this;
        newRow.level = level;
        if (level >= 0) {
            newRow.allLeafChildren = ag_grid_community_1._EmptyArray;
        }
        newRow.childrenAfterGroup = ag_grid_community_1._EmptyArray;
        return true;
    }
    /**
     * This is needed to be sure that the row is the duplicate row with the smallest sourceRowIndex, in O(n).
     * @returns this.row
     */
    sortFirstDuplicateRow() {
        const duplicateRows = this.duplicateRows;
        const oldRow = this.row;
        if (!oldRow || !duplicateRows) {
            return oldRow;
        }
        let newRow = oldRow;
        for (const row of duplicateRows) {
            if (row.sourceRowIndex < newRow.sourceRowIndex) {
                newRow = row; // found a smaller one
            }
        }
        if (newRow !== oldRow) {
            // Swap the rows
            newRow.childrenAfterGroup = this.childrenAfterGroup;
            newRow.allLeafChildren = oldRow.allLeafChildren ?? this.allLeafChildren ?? ag_grid_community_1._EmptyArray;
            oldRow.childrenAfterGroup = ag_grid_community_1._EmptyArray;
            oldRow.allLeafChildren = ag_grid_community_1._EmptyArray;
            duplicateRows.delete(newRow);
            duplicateRows.add(oldRow);
            this.row = newRow;
        }
        return newRow;
    }
    /** Pops the first duplicate row from the list of duplicates */
    popDuplicateRow() {
        let result = null;
        const duplicateRows = this.duplicateRows;
        if (duplicateRows !== null) {
            result = duplicateRows.values().next().value;
            if (result !== null && duplicateRows.delete(result) && duplicateRows.size === 0) {
                this.duplicateRows = null; // Free memory
            }
        }
        return result;
    }
    /**
     * Dequeues the next child invalidated node to be committed. Order is not deterministic.
     * @returns the next child node to be committed, or null if all children were already dequeued.
     */
    dequeueInvalidated() {
        const node = this.invalidatedHead;
        if (node !== null) {
            this.invalidatedHead = node.invalidatedNext ?? null;
            node.invalidatedNext = undefined; // Mark as not invalidated
        }
        return node;
    }
    /**
     * Invalidates this node and all its parents until the root is reached.
     * Order of invalidated nodes is not deterministic.
     * The root itself cannot be invalidated, as it has no parents.
     * If a node is already invalidated, it will stop the recursion.
     */
    invalidate() {
        let node = this;
        let parent = this.parent;
        while (parent !== null && node.invalidatedNext === undefined) {
            node.invalidatedNext = parent.invalidatedHead;
            parent.invalidatedHead = node;
            node = parent;
            parent = node.parent;
        }
    }
    /** Marks childrenChanged in the parent, so the childrenAfterGroup will be recomputed and invalidates the parent. */
    invalidateOrder() {
        const parent = this.parent;
        if (parent !== null && !parent.childrenChanged && ((this.children?.size ?? 0) > 1 || !parent.row?.data)) {
            parent.childrenChanged = true;
            parent.invalidate();
        }
    }
    /**
     * When we receive rowNodeOrder not undefined, we need to update the rowPosition of the node,
     * to ensure it will be sorted in the right order in childrenAfterGroup.
     * This function makes sense to be called only in the post-order commit DFS
     * as it assumes children's childrenAfterGroup is already updated.
     * @returns the rowPosition the node should have.
     */
    getNewSourceIdx() {
        const row = this.row;
        if (row?.data) {
            return row.sourceRowIndex;
        }
        // This is a filler node, return the rowPosition of the first child
        return this.childrenAfterGroup[0]?.treeNode?.sourceIdx ?? this.sourceIdx;
    }
    /**
     * This is called in post order during commit to update the childrenAfterGroup array.
     * It uses the rowNodeOrder map to sort the children in the right order, if is passed.
     * It assumes all children childrenAfterGroup are up to date and rows all created.
     *
     * It replaces the array with _EmptyArray if there are no children, to reduce memory usage and GC pressure.
     * It does sort the children only if strictly needed, to avoid unnecessary work.
     *
     * If the order changes, also the order in the children map will be updated,
     * so the next call to enumChildren() will return the children in the right order.
     */
    updateChildrenAfterGroup(treeData) {
        this.childrenChanged = false; // Reset the flag for this node
        const childrenCount = (treeData && this.children?.size) || 0;
        if (childrenCount === 0) {
            this.row.childrenAfterGroup = ag_grid_community_1._EmptyArray;
            if (this.childrenAfterGroup.length === 0) {
                return false; // No children
            }
            this.leafChildrenChanged = true;
            this.childrenAfterGroup = ag_grid_community_1._EmptyArray;
            return true; // Children cleared
        }
        let nodesChanged = false;
        let childrenAfterGroup = this.childrenAfterGroup;
        if (childrenAfterGroup === ag_grid_community_1._EmptyArray) {
            childrenAfterGroup = new Array(childrenCount);
            this.childrenAfterGroup = childrenAfterGroup;
            this.row.childrenAfterGroup = childrenAfterGroup;
            nodesChanged = true;
        }
        else if (childrenAfterGroup.length !== childrenCount) {
            childrenAfterGroup.length = childrenCount;
            nodesChanged = true;
        }
        let index = 0;
        let prevPosition = -1;
        let needSort = false;
        for (const child of this.enumChildren()) {
            const nextPosition = child.getNewSourceIdx();
            if (nextPosition < prevPosition) {
                needSort = true;
            }
            prevPosition = nextPosition;
            child.sourceIdx = nextPosition;
            const row = child.row;
            if (childrenAfterGroup[index] !== row) {
                childrenAfterGroup[index] = row;
                nodesChanged = true;
            }
            ++index;
        }
        if (nodesChanged) {
            this.leafChildrenChanged = true; // Note: we are not invalidating this if order only changes
        }
        if (needSort) {
            this.reorderChildrenList(childrenAfterGroup);
        }
        return nodesChanged || needSort;
    }
    /** This reorders the given array and rebuild the children map. */
    reorderChildrenList(childrenAfterGroup) {
        const childrenCount = childrenAfterGroup.length;
        const children = this.children;
        childrenAfterGroup.sort(treeNodePositionComparer);
        // We need to rebuild the children map in the right order
        children.clear();
        for (let i = 0; i < childrenCount; ++i) {
            const node = childrenAfterGroup[i].treeNode;
            children.set(node.key, node);
        }
    }
    /**
     * Rebuild the allLeafChildren rows array of a node. It uses childrenAfterGroup, we assume to be already updated.
     * This is called in post order during commit, after the childrenAfterGroup are updated with updateChildrenAfterGroup().
     * It uses the childrenAfterGroup and allLeafChildren of all the children, we assume they are updated.
     */
    updateAllLeafChildren() {
        const { parent, row, childrenAfterGroup } = this;
        this.leafChildrenChanged = false; // Reset the flag for this node
        let nodesChanged = false;
        const childrenAfterGroupLen = childrenAfterGroup.length;
        if (childrenAfterGroupLen === 0) {
            // No children, no leaf nodes.
            nodesChanged = row.allLeafChildren?.length !== 0;
            row.allLeafChildren = ag_grid_community_1._EmptyArray;
            this.allLeafChildren = ag_grid_community_1._EmptyArray;
        }
        else if (childrenAfterGroupLen === 1 && childrenAfterGroup[0].allLeafChildren?.length) {
            // We can avoid building the leaf children array if we are a node with just one child that has leafs
            // In this case we use the allLeafChildren of the child by assigning it to this.row.allLeafChildren in O(1)
            // and without occupying any extra memory.
            row.allLeafChildren = childrenAfterGroup[0].allLeafChildren; // Use the same array
            // Set allLeafChildren to null as indicator that we are borrowing the array from one of the children
            // This is used to prevent `updateAllLeafChildren` modifying this array in a future pass, if this nodes
            // direct children have been updated.
            // In this case we will have to use this.row.allLeafChildren to access the allLeafChildren array.
            this.allLeafChildren = null;
            nodesChanged = true; // This must be true as this may come from a child that changed
        }
        else {
            // We need to rebuild the allLeafChildren array, we use children allLeafChildren arrays
            let allLeafChildren = this.allLeafChildren;
            if (allLeafChildren === ag_grid_community_1._EmptyArray || allLeafChildren === null) {
                allLeafChildren = [];
                this.allLeafChildren = allLeafChildren;
            }
            const oldAllLeafChildrenLength = allLeafChildren.length;
            let writeIdx = 0;
            for (let i = 0; i < childrenAfterGroupLen; ++i) {
                const childRow = childrenAfterGroup[i];
                const childAllLeafChildren = childRow.allLeafChildren;
                const childAllLeafChildrenLen = childAllLeafChildren.length;
                if (childAllLeafChildrenLen) {
                    for (let j = 0; j < childAllLeafChildrenLen; ++j) {
                        const leaf = childAllLeafChildren[j];
                        if (writeIdx >= oldAllLeafChildrenLength || allLeafChildren[writeIdx] !== leaf) {
                            allLeafChildren[writeIdx] = leaf;
                            nodesChanged = true;
                        }
                        ++writeIdx;
                    }
                }
                else {
                    if ((writeIdx >= oldAllLeafChildrenLength || allLeafChildren[writeIdx] !== childRow) && childRow) {
                        allLeafChildren[writeIdx] = childRow;
                        nodesChanged = true;
                    }
                    ++writeIdx;
                }
            }
            if (oldAllLeafChildrenLength !== writeIdx) {
                allLeafChildren.length = writeIdx;
                nodesChanged = true;
            }
            if (row.allLeafChildren !== allLeafChildren) {
                row.allLeafChildren = allLeafChildren;
                nodesChanged = true;
            }
        }
        if (nodesChanged && parent) {
            parent.leafChildrenChanged = true; // Propagate to the parent, as it may need to rebuild its allLeafChildren too
        }
    }
}
exports.TreeNode = TreeNode;


/***/ }),

/***/ 2546:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearTreeRowFlags = exports.markTreeRowCommitted = exports.markTreeRowPathChanged = exports.setTreeRowKeyChanged = exports.setTreeRowUpdated = exports.setTreeRowExpandedInitialized = exports.isTreeRowPathChanged = exports.isTreeRowKeyChanged = exports.isTreeRowUpdated = exports.isTreeRowExpandedInitialized = exports.isTreeRowCommitted = void 0;
/** We set this on the first time the node is committed. We unset this if the row gets deleted. */
const isTreeRowCommitted = (row) => (row.treeNodeFlags & 1 /* Flags.Committed */) !== 0;
exports.isTreeRowCommitted = isTreeRowCommitted;
/** Check if the expanded state needs to be initialized, first time for a node, or again if the node was removed */
const isTreeRowExpandedInitialized = (row) => (row.treeNodeFlags & 2 /* Flags.ExpandedInitialized */) !== 0;
exports.isTreeRowExpandedInitialized = isTreeRowExpandedInitialized;
/** We use this to mark a row as updated by an updated transaction */
const isTreeRowUpdated = (row) => (row.treeNodeFlags & 4 /* Flags.RowUpdated */) !== 0;
exports.isTreeRowUpdated = isTreeRowUpdated;
/** We use this to see if a row changed key during commit */
const isTreeRowKeyChanged = (row) => (row.treeNodeFlags & 8 /* Flags.KeyChanged */) !== 0;
exports.isTreeRowKeyChanged = isTreeRowKeyChanged;
/** Returns true if markTreeRowPathChanged was called. Reset during commit.  */
const isTreeRowPathChanged = (row) => (row.treeNodeFlags & 16 /* Flags.PathChanged */) !== 0;
exports.isTreeRowPathChanged = isTreeRowPathChanged;
/** Changes the expanded initialized state, so it can be recomputed again. */
const setTreeRowExpandedInitialized = (row, value) => {
    if (value) {
        row.treeNodeFlags |= 2 /* Flags.ExpandedInitialized */;
    }
    else {
        row.treeNodeFlags &= ~2 /* Flags.ExpandedInitialized */;
    }
};
exports.setTreeRowExpandedInitialized = setTreeRowExpandedInitialized;
/**
 * We use this to mark a row as updated by an updated transaction.
 * This will be set only if the row was committed at least once before.
 */
const setTreeRowUpdated = (row) => {
    const flags = row.treeNodeFlags;
    if ((flags & 1 /* Flags.Committed */) !== 0) {
        row.treeNodeFlags = flags | 4 /* Flags.RowUpdated */;
    }
};
exports.setTreeRowUpdated = setTreeRowUpdated;
/**
 * We use this to mark that a row changed key during commit.
 * This will be set only if the row was committed at least once before.
 */
const setTreeRowKeyChanged = (row) => {
    const flags = row.treeNodeFlags;
    if ((flags & 1 /* Flags.Committed */) !== 0) {
        row.treeNodeFlags = flags | (8 /* Flags.KeyChanged */ | 4 /* Flags.RowUpdated */);
    }
};
exports.setTreeRowKeyChanged = setTreeRowKeyChanged;
/** If this is true, commit stage must invoke changedPath.addParentNode */
const markTreeRowPathChanged = (row) => {
    row.treeNodeFlags |= 16 /* Flags.PathChanged */;
};
exports.markTreeRowPathChanged = markTreeRowPathChanged;
/** Called when the row is committed. */
const markTreeRowCommitted = (row) => {
    const isRoot = row.level < 0;
    const oldFlags = row.treeNodeFlags;
    const wasCommitted = (oldFlags & 1 /* Flags.Committed */) !== 0;
    row.treeNodeFlags = 1 /* Flags.Committed */ | (oldFlags & ~(4 /* Flags.RowUpdated */ | 8 /* Flags.KeyChanged */ | 16 /* Flags.PathChanged */));
    if (!wasCommitted || isRoot) {
        // We need to ensure that arrays are not null if the row was never committed or is the root
        const childrenAfterGroup = row.childrenAfterGroup;
        row.childrenAfterFilter = childrenAfterGroup;
        row.childrenAfterAggFilter = childrenAfterGroup;
        row.childrenAfterSort = childrenAfterGroup;
    }
    if (isRoot) {
        const sibling = row.sibling;
        if (sibling) {
            sibling.childrenAfterGroup = row.childrenAfterGroup;
            sibling.childrenMapped = row.childrenMapped;
        }
    }
};
exports.markTreeRowCommitted = markTreeRowCommitted;
/** Clears all the flags, called when the row is deleted from the tree */
const clearTreeRowFlags = (row) => {
    row.treeNodeFlags = 0;
};
exports.clearTreeRowFlags = clearTreeRowFlags;


/***/ }),

/***/ 7205:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VERSION = void 0;
// DO NOT UPDATE MANUALLY: Generated from script during build time
exports.VERSION = '33.0.3';


/***/ }),

/***/ 4790:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewportRowModel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class ViewportRowModel extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowModel';
        // rowRenderer tells us these
        this.firstRow = -1;
        this.lastRow = -1;
        // datasource tells us this
        this.rowCount = -1;
        this.rowNodesByIndex = {};
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid(_startPixel, _endPixel, _startLimitIndex, _endLimitIndex) {
        return false;
    }
    postConstruct() {
        const beans = this.beans;
        this.rowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(beans);
        this.addManagedEventListeners({ viewportChanged: this.onViewportChanged.bind(this) });
        this.addManagedPropertyListener('viewportDatasource', () => this.updateDatasource());
        this.addManagedPropertyListener('rowHeight', () => {
            this.rowHeight = (0, ag_grid_community_1._getRowHeightAsNumber)(beans);
            this.updateRowHeights();
        });
    }
    start() {
        this.updateDatasource();
    }
    isLastRowIndexKnown() {
        return true;
    }
    destroy() {
        this.destroyDatasource();
        super.destroy();
    }
    destroyDatasource() {
        const datasource = this.datasource;
        if (!datasource) {
            return;
        }
        datasource.destroy?.();
        this.beans.rowRenderer.datasourceChanged();
        this.firstRow = -1;
        this.lastRow = -1;
    }
    updateDatasource() {
        const datasource = this.gos.get('viewportDatasource');
        if (datasource) {
            this.setViewportDatasource(datasource);
        }
    }
    getPageSize() {
        return this.gos.get('viewportRowModelPageSize');
    }
    getBufferSize() {
        return this.gos.get('viewportRowModelBufferSize');
    }
    calculateFirstRow(firstRenderedRow) {
        const bufferSize = this.getBufferSize();
        const pageSize = this.getPageSize();
        const afterBuffer = firstRenderedRow - bufferSize;
        if (afterBuffer < 0) {
            return 0;
        }
        return Math.floor(afterBuffer / pageSize) * pageSize;
    }
    calculateLastRow(lastRenderedRow) {
        if (lastRenderedRow === -1) {
            return lastRenderedRow;
        }
        const bufferSize = this.getBufferSize();
        const pageSize = this.getPageSize();
        const afterBuffer = lastRenderedRow + bufferSize;
        const result = Math.ceil(afterBuffer / pageSize) * pageSize;
        const lastRowIndex = this.rowCount - 1;
        return Math.min(result, lastRowIndex);
    }
    onViewportChanged(event) {
        const newFirst = this.calculateFirstRow(event.firstRow);
        const newLast = this.calculateLastRow(event.lastRow);
        if (this.firstRow !== newFirst || this.lastRow !== newLast) {
            this.firstRow = newFirst;
            this.lastRow = newLast;
            this.purgeRowsNotInViewport();
            this.datasource?.setViewportRange(this.firstRow, this.lastRow);
        }
    }
    purgeRowsNotInViewport() {
        const rowNodesByIndex = this.rowNodesByIndex;
        Object.keys(rowNodesByIndex).forEach((indexStr) => {
            const index = parseInt(indexStr, 10);
            if (index < this.firstRow || index > this.lastRow) {
                if (this.isRowFocused(index)) {
                    return;
                }
                delete rowNodesByIndex[index];
            }
        });
    }
    isRowFocused(rowIndex) {
        const focusedCell = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
        if (!focusedCell) {
            return false;
        }
        if (focusedCell.rowPinned != null) {
            return false;
        }
        const hasFocus = focusedCell.rowIndex === rowIndex;
        return hasFocus;
    }
    setViewportDatasource(viewportDatasource) {
        this.destroyDatasource();
        this.datasource = viewportDatasource;
        this.rowCount = -1;
        if (!viewportDatasource.init) {
            (0, ag_grid_community_1._warn)(226);
        }
        else {
            viewportDatasource.init({
                setRowCount: this.setRowCount.bind(this),
                setRowData: this.setRowData.bind(this),
                getRow: this.getRow.bind(this),
            });
        }
    }
    getType() {
        return 'viewport';
    }
    getRow(rowIndex) {
        if (!this.rowNodesByIndex[rowIndex]) {
            this.rowNodesByIndex[rowIndex] = this.createBlankRowNode(rowIndex);
        }
        return this.rowNodesByIndex[rowIndex];
    }
    getRowNode(id) {
        let result;
        this.forEachNode((rowNode) => {
            if (rowNode.id === id) {
                result = rowNode;
            }
        });
        return result;
    }
    getRowCount() {
        return this.rowCount === -1 ? 0 : this.rowCount;
    }
    getRowIndexAtPixel(pixel) {
        if (this.rowHeight !== 0) {
            // avoid divide by zero error
            return Math.floor(pixel / this.rowHeight);
        }
        return 0;
    }
    getRowBounds(index) {
        const rowHeight = this.rowHeight;
        return {
            rowHeight,
            rowTop: rowHeight * index,
        };
    }
    updateRowHeights() {
        const rowHeight = this.rowHeight;
        this.forEachNode((node) => {
            node.setRowHeight(rowHeight);
            node.setRowTop(rowHeight * node.rowIndex);
        });
        this.eventSvc.dispatchEvent({
            type: 'modelUpdated',
            newData: false,
            newPage: false,
            keepRenderedRows: true,
            animate: false,
        });
    }
    getTopLevelRowCount() {
        return this.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        return topLevelIndex;
    }
    isEmpty() {
        return this.rowCount > 0;
    }
    isRowsToRender() {
        return this.rowCount > 0;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        const firstIndex = firstInRange.rowIndex;
        const lastIndex = lastInRange.rowIndex;
        const firstNodeOutOfRange = firstIndex < this.firstRow || firstIndex > this.lastRow;
        const lastNodeOutOfRange = lastIndex < this.firstRow || lastIndex > this.lastRow;
        if (firstNodeOutOfRange || lastNodeOutOfRange) {
            return [];
        }
        const result = [];
        const startIndex = firstIndex <= lastIndex ? firstIndex : lastIndex;
        const endIndex = firstIndex <= lastIndex ? lastIndex : firstIndex;
        for (let i = startIndex; i <= endIndex; i++) {
            result.push(this.rowNodesByIndex[i]);
        }
        return result;
    }
    forEachNode(callback) {
        let callbackCount = 0;
        Object.keys(this.rowNodesByIndex).forEach((indexStr) => {
            const index = parseInt(indexStr, 10);
            const rowNode = this.rowNodesByIndex[index];
            callback(rowNode, callbackCount);
            callbackCount++;
        });
    }
    setRowData(rowData) {
        const rowNodesByIndex = this.rowNodesByIndex;
        for (const [indexStr, dataItem] of Object.entries(rowData)) {
            const index = parseInt(indexStr, 10);
            // we should never keep rows that we didn't specifically ask for, this
            // guarantees the contract we have with the server.
            if (index >= this.firstRow && index <= this.lastRow) {
                let rowNode = rowNodesByIndex[index];
                // the abnormal case is we requested a row even though the grid didn't need it
                // as a result of the paging and buffer (ie the row is off screen), in which
                // case we need to create a new node now
                if ((0, ag_grid_community_1._missing)(rowNode)) {
                    rowNode = this.createBlankRowNode(index);
                    rowNodesByIndex[index] = rowNode;
                }
                // now we deffo have a row node, so set in the details
                // if the grid already asked for this row (the normal case), then we would
                // of put a placeholder node in place.
                rowNode.setDataAndId(dataItem, index.toString());
            }
        }
    }
    createBlankRowNode(rowIndex) {
        const rowNode = new ag_grid_community_1.RowNode(this.beans);
        const rowHeight = this.rowHeight;
        rowNode.setRowHeight(rowHeight);
        rowNode.setRowTop(rowHeight * rowIndex);
        rowNode.setRowIndex(rowIndex);
        return rowNode;
    }
    setRowCount(rowCount, keepRenderedRows = false) {
        if (rowCount === this.rowCount) {
            return;
        }
        this.rowCount = rowCount;
        const eventSvc = this.eventSvc;
        eventSvc.dispatchEventOnce({
            type: 'rowCountReady',
        });
        eventSvc.dispatchEvent({
            type: 'modelUpdated',
            newData: false,
            newPage: false,
            keepRenderedRows: keepRenderedRows,
            animate: false,
        });
    }
    isRowPresent(rowNode) {
        const foundRowNode = this.getRowNode(rowNode.id);
        return !!foundRowNode;
    }
}
exports.ViewportRowModel = ViewportRowModel;


/***/ }),

/***/ 7794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewportRowModelModule = void 0;
const agGridEnterpriseModule_1 = __webpack_require__(9206);
const version_1 = __webpack_require__(7205);
const viewportRowModel_1 = __webpack_require__(4790);
/**
 * @feature Viewport Row Model
 */
exports.ViewportRowModelModule = {
    moduleName: 'ViewportRowModel',
    version: version_1.VERSION,
    rowModels: ['viewport'],
    beans: [viewportRowModel_1.ViewportRowModel],
    dependsOn: [agGridEnterpriseModule_1.EnterpriseCoreModule],
};


/***/ }),

/***/ 7437:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPillContainer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPill_1 = __webpack_require__(3264);
class AgPillContainer extends ag_grid_community_1.Component {
    constructor() {
        super(/* html */ `
            <div class="ag-pill-container" role="listbox"></div>
            `);
        this.pills = [];
    }
    init(params) {
        this.params = params;
        this.refresh();
    }
    refresh() {
        this.clearPills();
        const { params, onPillKeyDown } = this;
        const values = params.getValue();
        if (!Array.isArray(values)) {
            return;
        }
        const len = values.length;
        for (let i = 0; i < len; i++) {
            const value = values[i];
            const pill = this.createBean(new agPill_1.AgPill({
                onButtonClick: () => this.onPillButtonClick(pill),
                onKeyDown: onPillKeyDown.bind(this),
            }));
            const pillGui = pill.getGui();
            (0, ag_grid_community_1._setAriaPosInSet)(pillGui, i + 1);
            (0, ag_grid_community_1._setAriaSetSize)(pillGui, len);
            if (params.onPillMouseDown) {
                pill.addGuiEventListener('mousedown', params.onPillMouseDown);
            }
            if (params.announceItemFocus) {
                pill.addGuiEventListener('focus', params.announceItemFocus);
            }
            pill.setText(value);
            pill.toggleCloseButtonClass('ag-icon-cancel', true);
            this.appendChild(pillGui);
            this.pills.push(pill);
        }
    }
    onNavigationKeyDown(e) {
        const { key } = e;
        if (!this.pills.length || (key !== ag_grid_community_1.KeyCode.LEFT && key !== ag_grid_community_1.KeyCode.RIGHT)) {
            return;
        }
        e.preventDefault();
        const { params, beans } = this;
        const activeEl = (0, ag_grid_community_1._getActiveDomElement)(beans);
        const eGui = this.getGui();
        if (eGui.contains(activeEl)) {
            const nextFocusableEl = (0, ag_grid_community_1._findNextFocusableElement)(beans, eGui, false, key === ag_grid_community_1.KeyCode.LEFT);
            if (nextFocusableEl) {
                nextFocusableEl.focus();
            }
            else if (params.eWrapper) {
                params.eWrapper.focus();
            }
        }
        else {
            const focusableElements = (0, ag_grid_community_1._findFocusableElements)(eGui);
            if (focusableElements.length > 0) {
                focusableElements[key === ag_grid_community_1.KeyCode.RIGHT ? 0 : focusableElements.length - 1].focus();
            }
        }
    }
    clearPills() {
        const eGui = this.getGui();
        if (eGui.contains((0, ag_grid_community_1._getActiveDomElement)(this.beans)) && this.params.eWrapper) {
            this.params.eWrapper.focus();
        }
        (0, ag_grid_community_1._clearElement)(eGui);
        this.destroyBeans(this.pills);
        this.pills = [];
    }
    onPillButtonClick(pill) {
        this.deletePill(pill);
    }
    onPillKeyDown(e) {
        const key = e.key;
        if (key !== ag_grid_community_1.KeyCode.DELETE && key !== ag_grid_community_1.KeyCode.BACKSPACE) {
            return;
        }
        e.preventDefault();
        const eDoc = (0, ag_grid_community_1._getDocument)(this.beans);
        const pillIndex = this.pills.findIndex((pill) => pill.getGui().contains(eDoc.activeElement));
        if (pillIndex === -1) {
            return;
        }
        const pill = this.pills[pillIndex];
        if (pill) {
            this.deletePill(pill, pillIndex);
        }
    }
    deletePill(pill, restoreFocusToIndex) {
        const value = pill.getText();
        const values = (this.params.getValue() || []).filter((val) => val !== value);
        this.params.setValue(values);
        if (!values.length && this.params.eWrapper) {
            this.params.eWrapper.focus();
        }
        else if (restoreFocusToIndex != null) {
            const pill = this.pills[Math.min(restoreFocusToIndex, this.pills.length - 1)];
            if (pill) {
                pill.getFocusableElement().focus();
            }
        }
    }
    destroy() {
        this.clearPills();
        super.destroy();
    }
}
exports.AgPillContainer = AgPillContainer;


/***/ }),

/***/ 8775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgDialog = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPanel_1 = __webpack_require__(7325);
class AgDialog extends agPanel_1.AgPanel {
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
    }
    constructor(config) {
        super({ ...config, popup: true });
        this.isMaximizable = false;
        this.isMaximized = false;
        this.maximizeListeners = [];
        this.resizeListenerDestroy = null;
        this.lastPosition = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
        };
    }
    postConstruct() {
        const eGui = this.getGui();
        const { movable, resizable, maximizable, modal, postProcessPopupParams } = this.config;
        this.addCssClass('ag-dialog');
        super.postConstruct();
        if (postProcessPopupParams) {
            const { type, eventSource, column, mouseEvent, rowNode } = postProcessPopupParams;
            this.popupSvc?.callPostProcessPopup(type, eGui, eventSource, mouseEvent, column, rowNode);
        }
        this.tabGuardFeature = this.createManagedBean(new ag_grid_community_1.TabGuardFeature(this));
        this.tabGuardFeature.initialiseTabGuard({
            isFocusableContainer: true,
            onFocusIn: () => {
                this.popupSvc?.bringPopupToFront(eGui);
            },
            onTabKeyDown: (e) => {
                if (modal) {
                    return;
                }
                const backwards = e.shiftKey;
                const nextFocusableElement = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, eGui, false, backwards);
                if (!nextFocusableElement || this.tabGuardFeature.getTabGuardCtrl().isTabGuard(nextFocusableElement)) {
                    if ((0, ag_grid_community_1._focusNextGridCoreContainer)(this.beans, backwards)) {
                        e.preventDefault();
                    }
                }
            },
        });
        if (movable) {
            this.setMovable(movable);
        }
        if (maximizable) {
            this.setMaximizable(maximizable);
        }
        if (resizable) {
            this.setResizable(resizable);
        }
        if (!this.config.modal) {
            const gridCtrl = this.beans.ctrlsSvc.get('gridCtrl');
            gridCtrl.addFocusableContainer(this);
            this.addDestroyFunc(() => gridCtrl.removeFocusableContainer(this));
        }
    }
    setAllowFocus(allowFocus) {
        this.tabGuardFeature.getTabGuardCtrl().setAllowFocus(allowFocus);
    }
    renderComponent() {
        const eGui = this.getGui();
        const { alwaysOnTop, modal, title, afterGuiAttached } = this.config;
        const translate = this.getLocaleTextFunc();
        const addPopupRes = this.popupSvc?.addPopup({
            modal,
            eChild: eGui,
            closeOnEsc: true,
            closedCallback: this.onClosed.bind(this),
            alwaysOnTop,
            ariaLabel: title || translate('ariaLabelDialog', 'Dialog'),
            afterGuiAttached,
        });
        if (addPopupRes) {
            this.close = addPopupRes.hideFunc;
        }
    }
    onClosed(event) {
        this.destroy();
        this.config.closedCallback?.(event);
    }
    toggleMaximize() {
        const position = this.positionableFeature.getPosition();
        if (this.isMaximized) {
            const { x, y, width, height } = this.lastPosition;
            this.setWidth(width);
            this.setHeight(height);
            this.positionableFeature.offsetElement(x, y);
        }
        else {
            this.lastPosition.width = this.getWidth();
            this.lastPosition.height = this.getHeight();
            this.lastPosition.x = position.x;
            this.lastPosition.y = position.y;
            this.positionableFeature.offsetElement(0, 0);
            this.setHeight('100%');
            this.setWidth('100%');
        }
        this.isMaximized = !this.isMaximized;
        this.refreshMaximizeIcon();
    }
    refreshMaximizeIcon() {
        (0, ag_grid_community_1._setDisplayed)(this.maximizeIcon, !this.isMaximized);
        (0, ag_grid_community_1._setDisplayed)(this.minimizeIcon, this.isMaximized);
    }
    clearMaximizebleListeners() {
        if (this.maximizeListeners.length) {
            this.maximizeListeners.forEach((destroyListener) => destroyListener());
            this.maximizeListeners.length = 0;
        }
        if (this.resizeListenerDestroy) {
            this.resizeListenerDestroy();
            this.resizeListenerDestroy = null;
        }
    }
    destroy() {
        this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp);
        this.clearMaximizebleListeners();
        super.destroy();
    }
    setResizable(resizable) {
        this.positionableFeature.setResizable(resizable);
    }
    setMovable(movable) {
        this.positionableFeature.setMovable(movable, this.eTitleBar);
    }
    setMaximizable(maximizable) {
        if (!maximizable) {
            this.clearMaximizebleListeners();
            if (this.maximizeButtonComp) {
                this.destroyBean(this.maximizeButtonComp);
                this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = undefined;
            }
            return;
        }
        const eTitleBar = this.eTitleBar;
        if (!eTitleBar || maximizable === this.isMaximizable) {
            return;
        }
        const maximizeButtonComp = this.buildMaximizeAndMinimizeElements();
        this.refreshMaximizeIcon();
        maximizeButtonComp.addManagedElementListeners(maximizeButtonComp.getGui(), {
            click: this.toggleMaximize.bind(this),
        });
        this.addTitleBarButton(maximizeButtonComp, 0);
        this.maximizeListeners.push(...this.addManagedElementListeners(eTitleBar, {
            dblclick: this.toggleMaximize.bind(this),
        }));
        [this.resizeListenerDestroy] = this.addManagedListeners(this.positionableFeature, {
            resize: () => {
                this.isMaximized = false;
                this.refreshMaximizeIcon();
            },
        });
    }
    buildMaximizeAndMinimizeElements() {
        const maximizeButtonComp = (this.maximizeButtonComp = this.createBean(new ag_grid_community_1.Component(/* html */ `<div class="ag-dialog-button"></span>`)));
        const eGui = maximizeButtonComp.getGui();
        this.maximizeIcon = (0, ag_grid_community_1._createIconNoSpan)('maximize', this.beans);
        eGui.appendChild(this.maximizeIcon);
        this.maximizeIcon.classList.add('ag-panel-title-bar-button-icon');
        this.minimizeIcon = (0, ag_grid_community_1._createIconNoSpan)('minimize', this.beans);
        eGui.appendChild(this.minimizeIcon);
        this.minimizeIcon.classList.add('ag-panel-title-bar-button-icon');
        return maximizeButtonComp;
    }
}
exports.AgDialog = AgDialog;


/***/ }),

/***/ 1421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgGroupComponentSelector = exports.AgGroupComponent = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function getAgGroupComponentTemplate(params) {
    const cssIdentifier = params.cssIdentifier || 'default';
    const direction = params.direction || 'vertical';
    return /* html */ `
        <div class="ag-group ag-${cssIdentifier}-group" role="presentation">
            <div data-ref="eToolbar" class="ag-group-toolbar ag-${cssIdentifier}-group-toolbar">
                <ag-checkbox data-ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div data-ref="eContainer" class="ag-group-container ag-group-container-${direction} ag-${cssIdentifier}-group-container"></div>
        </div>
    `;
}
class AgGroupComponent extends ag_grid_community_1.Component {
    constructor(params = {}) {
        super(getAgGroupComponentTemplate(params), [ag_grid_community_1.AgCheckboxSelector]);
        this.params = params;
        this.suppressEnabledCheckbox = true;
        this.suppressToggleExpandOnEnableChange = false;
        this.eToolbar = ag_grid_community_1.RefPlaceholder;
        this.cbGroupEnabled = ag_grid_community_1.RefPlaceholder;
        this.eContainer = ag_grid_community_1.RefPlaceholder;
        const { enabled, items, suppressEnabledCheckbox, expanded, suppressToggleExpandOnEnableChange, useToggle: toggleMode, } = params;
        this.cssIdentifier = params.cssIdentifier || 'default';
        this.enabled = enabled != null ? enabled : true;
        this.items = items || [];
        this.useToggle = toggleMode ?? false;
        this.alignItems = params.alignItems || 'center';
        // expanded by default
        this.expanded = expanded == null ? true : expanded;
        if (suppressEnabledCheckbox != null) {
            this.suppressEnabledCheckbox = suppressEnabledCheckbox;
        }
        if (suppressToggleExpandOnEnableChange != null) {
            this.suppressToggleExpandOnEnableChange = suppressToggleExpandOnEnableChange;
        }
    }
    postConstruct() {
        this.setupTitleBar();
        if (this.items.length) {
            const initialItems = this.items;
            this.items = [];
            this.addItems(initialItems);
        }
        const localeTextFunc = this.getLocaleTextFunc();
        this.cbGroupEnabled.setLabel(localeTextFunc('enabled', 'Enabled'));
        if (this.enabled) {
            this.setEnabled(this.enabled, undefined, true);
        }
        this.setAlignItems(this.alignItems);
        const { onEnableChange, onExpandedChange, suppressOpenCloseIcons } = this.params;
        this.hideEnabledCheckbox(this.suppressEnabledCheckbox);
        this.hideOpenCloseIcons(suppressOpenCloseIcons ?? false);
        this.refreshChildDisplay();
        (0, ag_grid_community_1._setDisplayed)(this.eContainer, this.expanded);
        this.cbGroupEnabled.onValueChange((newSelection) => {
            this.setEnabled(newSelection, true, this.suppressToggleExpandOnEnableChange);
            this.dispatchEnableChangeEvent(newSelection);
        });
        if (onEnableChange != null) {
            this.onEnableChange(onEnableChange);
        }
        if (onExpandedChange != null) {
            this.onExpandedChange(onExpandedChange);
        }
    }
    refreshChildDisplay() {
        (0, ag_grid_community_1._setDisplayed)(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox);
        this.eTitleBar?.refreshOnExpand(this.expanded);
    }
    isExpanded() {
        return this.expanded;
    }
    setAlignItems(alignment) {
        if (this.alignItems !== alignment) {
            this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`);
        }
        this.alignItems = alignment;
        const newCls = `ag-group-item-alignment-${this.alignItems}`;
        this.addCssClass(newCls);
        return this;
    }
    toggleGroupExpand(expanded, silent) {
        if (this.eTitleBar?.isSuppressCollapse() && !this.useToggle) {
            expanded = true;
            silent = true;
        }
        else {
            expanded = expanded != null ? expanded : !this.expanded;
            if (this.expanded === expanded) {
                return this;
            }
        }
        this.expanded = expanded;
        this.refreshChildDisplay();
        (0, ag_grid_community_1._setDisplayed)(this.eContainer, expanded);
        if (!silent) {
            this.dispatchLocalEvent({
                type: expanded ? 'expanded' : 'collapsed',
            });
        }
        return this;
    }
    addItems(items) {
        items.forEach((item) => this.addItem(item));
    }
    prependItem(item) {
        this.insertItem(item, true);
    }
    addItem(item) {
        this.insertItem(item, false);
    }
    insertItem(item, prepend) {
        const container = this.eContainer;
        const el = item instanceof ag_grid_community_1.Component ? item.getGui() : item;
        el.classList.add('ag-group-item', `ag-${this.cssIdentifier}-group-item`);
        if (prepend) {
            container.insertAdjacentElement('afterbegin', el);
            this.items.unshift(el);
        }
        else {
            container.appendChild(el);
            this.items.push(el);
        }
    }
    hideItem(hide, index) {
        const itemToHide = this.items[index];
        (0, ag_grid_community_1._setDisplayed)(itemToHide, !hide);
    }
    getItemIndex(item) {
        const el = item instanceof ag_grid_community_1.Component ? item.getGui() : item;
        return this.items.indexOf(el);
    }
    setTitle(title) {
        this.eTitleBar?.setTitle(title);
        return this;
    }
    addTitleBarWidget(el) {
        this.eTitleBar?.addWidget(el);
        return this;
    }
    addCssClassToTitleBar(cssClass) {
        this.eTitleBar?.addCssClass(cssClass);
    }
    dispatchEnableChangeEvent(enabled) {
        const event = {
            type: 'enableChange',
            enabled,
        };
        this.dispatchLocalEvent(event);
    }
    setEnabled(enabled, skipToggle, skipExpand) {
        this.enabled = enabled;
        this.refreshDisabledStyles();
        if (!skipExpand) {
            this.toggleGroupExpand(enabled);
        }
        if (!skipToggle) {
            this.cbGroupEnabled.setValue(enabled);
            this.eToggle?.setValue(enabled);
        }
        return this;
    }
    isEnabled() {
        return this.enabled;
    }
    onEnableChange(callbackFn) {
        this.addManagedListeners(this, { enableChange: (event) => callbackFn(event.enabled) });
        return this;
    }
    onExpandedChange(callbackFn) {
        this.addManagedListeners(this, {
            expanded: () => callbackFn(true),
            collapsed: () => callbackFn(false),
        });
        return this;
    }
    hideEnabledCheckbox(hide) {
        this.suppressEnabledCheckbox = hide;
        this.refreshChildDisplay();
        this.refreshDisabledStyles();
        return this;
    }
    hideOpenCloseIcons(hide) {
        this.eTitleBar?.hideOpenCloseIcons(hide);
        return this;
    }
    refreshDisabledStyles() {
        const disabled = !this.enabled;
        this.eContainer.classList.toggle('ag-disabled', disabled);
        this.eTitleBar?.refreshDisabledStyles(this.suppressEnabledCheckbox && disabled);
        this.eContainer.classList.toggle('ag-disabled-group-container', disabled);
    }
    setupTitleBar() {
        const titleBar = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
        this.eToolbar.insertAdjacentElement('beforebegin', titleBar.getGui());
    }
    createDefaultTitleBar() {
        const titleBar = this.createManagedBean(new DefaultTitleBar(this.params));
        this.eTitleBar = titleBar;
        titleBar.refreshOnExpand(this.expanded);
        this.addManagedListeners(titleBar, {
            expandedChanged: (event) => this.toggleGroupExpand(event.expanded),
        });
        return titleBar;
    }
    createToggleTitleBar() {
        const eToggle = this.createManagedBean(new ag_grid_community_1.AgToggleButton({
            value: this.enabled,
            label: this.params.title,
            labelAlignment: 'left',
            labelWidth: 'flex',
            onValueChange: (enabled) => {
                this.setEnabled(enabled, true);
                this.dispatchEnableChangeEvent(enabled);
            },
        }));
        eToggle.addCssClass('ag-group-title-bar');
        eToggle.addCssClass(`ag-${this.params.cssIdentifier ?? 'default'}-group-title-bar ag-unselectable`);
        this.eToggle = eToggle;
        this.toggleGroupExpand(this.enabled);
        return eToggle;
    }
}
exports.AgGroupComponent = AgGroupComponent;
const TITLE_BAR_DISABLED_CLASS = 'ag-disabled-group-title-bar';
function getDefaultTitleBarTemplate(params) {
    const cssIdentifier = params.cssIdentifier ?? 'default';
    const role = params.suppressKeyboardNavigation ? 'presentation' : 'role';
    return /* html */ `
        <div class="ag-group-title-bar ag-${cssIdentifier}-group-title-bar ag-unselectable" role="${role}">
            <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" data-ref="eGroupOpenedIcon" role="presentation"></span>
            <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" data-ref="eGroupClosedIcon" role="presentation"></span>
            <span data-ref="eTitle" class="ag-group-title ag-${cssIdentifier}-group-title"></span>
        </div>
    `;
}
class DefaultTitleBar extends ag_grid_community_1.Component {
    constructor(params = {}) {
        super(getDefaultTitleBarTemplate(params));
        this.suppressOpenCloseIcons = false;
        this.suppressKeyboardNavigation = false;
        this.eGroupOpenedIcon = ag_grid_community_1.RefPlaceholder;
        this.eGroupClosedIcon = ag_grid_community_1.RefPlaceholder;
        this.eTitle = ag_grid_community_1.RefPlaceholder;
        const { title, suppressOpenCloseIcons, suppressKeyboardNavigation } = params;
        if (!!title && title.length > 0) {
            this.title = title;
        }
        if (suppressOpenCloseIcons != null) {
            this.suppressOpenCloseIcons = suppressOpenCloseIcons;
        }
        this.suppressKeyboardNavigation = suppressKeyboardNavigation ?? false;
    }
    postConstruct() {
        this.setTitle(this.title);
        this.hideOpenCloseIcons(this.suppressOpenCloseIcons);
        this.setupExpandContract();
    }
    setupExpandContract() {
        this.eGroupClosedIcon.appendChild((0, ag_grid_community_1._createIcon)('accordionClosed', this.beans, null));
        this.eGroupOpenedIcon.appendChild((0, ag_grid_community_1._createIcon)('accordionOpen', this.beans, null));
        this.addManagedElementListeners(this.getGui(), {
            click: () => this.dispatchExpandChanged(),
            keydown: (e) => {
                switch (e.key) {
                    case ag_grid_community_1.KeyCode.ENTER:
                    case ag_grid_community_1.KeyCode.SPACE:
                        e.preventDefault();
                        this.dispatchExpandChanged();
                        break;
                    case ag_grid_community_1.KeyCode.RIGHT:
                    case ag_grid_community_1.KeyCode.LEFT:
                        e.preventDefault();
                        this.dispatchExpandChanged(e.key === ag_grid_community_1.KeyCode.RIGHT);
                        break;
                }
            },
        });
    }
    refreshOnExpand(expanded) {
        this.refreshAriaStatus(expanded);
        this.refreshOpenCloseIcons(expanded);
    }
    refreshAriaStatus(expanded) {
        if (!this.suppressOpenCloseIcons) {
            (0, ag_grid_community_1._setAriaExpanded)(this.getGui(), expanded);
        }
    }
    refreshOpenCloseIcons(expanded) {
        const showIcon = !this.suppressOpenCloseIcons;
        (0, ag_grid_community_1._setDisplayed)(this.eGroupOpenedIcon, showIcon && expanded);
        (0, ag_grid_community_1._setDisplayed)(this.eGroupClosedIcon, showIcon && !expanded);
    }
    isSuppressCollapse() {
        return this.suppressOpenCloseIcons;
    }
    dispatchExpandChanged(expanded) {
        const event = {
            type: 'expandedChanged',
            expanded,
        };
        this.dispatchLocalEvent(event);
    }
    setTitle(title) {
        const eGui = this.getGui();
        const hasTitle = !!title && title.length > 0;
        title = hasTitle ? title : undefined;
        this.eTitle.textContent = title ?? '';
        (0, ag_grid_community_1._setDisplayed)(eGui, hasTitle);
        if (title !== this.title) {
            this.title = title;
        }
        const disabled = eGui.classList.contains(TITLE_BAR_DISABLED_CLASS);
        this.refreshDisabledStyles(disabled);
        return this;
    }
    addWidget(el) {
        this.getGui().appendChild(el);
        return this;
    }
    hideOpenCloseIcons(hide) {
        this.suppressOpenCloseIcons = hide;
        if (hide) {
            this.dispatchExpandChanged(true);
        }
        return this;
    }
    refreshDisabledStyles(disabled) {
        const eGui = this.getGui();
        if (disabled) {
            eGui.classList.add(TITLE_BAR_DISABLED_CLASS);
            eGui.removeAttribute('tabindex');
        }
        else {
            eGui.classList.remove(TITLE_BAR_DISABLED_CLASS);
            if (typeof this.title === 'string' && !this.suppressKeyboardNavigation) {
                eGui.setAttribute('tabindex', '0');
            }
            else {
                eGui.removeAttribute('tabindex');
            }
        }
    }
}
exports.AgGroupComponentSelector = {
    selector: 'AG-GROUP-COMPONENT',
    component: AgGroupComponent,
};


/***/ }),

/***/ 7040:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgMenuItemComponent = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agMenuList_1 = __webpack_require__(9476);
const agMenuPanel_1 = __webpack_require__(568);
function getMenuItemCompDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, MenuItemComponent, 'agMenuItem', params, true);
}
const MenuItemComponent = {
    name: 'menuItem',
    optionalMethods: ['setActive', 'select', 'setExpanded', 'configureDefaults'],
};
class AgMenuItemComponent extends ag_grid_community_1.BeanStub {
    constructor() {
        super(...arguments);
        this.ACTIVATION_DELAY = 80;
        this.isActive = false;
        this.subMenuIsOpen = false;
        this.subMenuIsOpening = false;
        this.suppressRootStyles = true;
        this.suppressAria = true;
        this.suppressFocus = true;
    }
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
        this.userCompFactory = beans.userCompFactory;
        this.registry = beans.registry;
    }
    init(params) {
        const { menuItemDef, isAnotherSubMenuOpen, level, childComponent, contextParams } = params;
        this.params = params.menuItemDef;
        this.level = level;
        this.isAnotherSubMenuOpen = isAnotherSubMenuOpen;
        this.childComponent = childComponent;
        this.contextParams = contextParams;
        this.cssClassPrefix = this.params.menuItemParams?.cssClassPrefix ?? 'ag-menu-option';
        const compDetails = getMenuItemCompDetails(this.userCompFactory, this.params, {
            ...menuItemDef,
            level,
            isAnotherSubMenuOpen,
            openSubMenu: (activateFirstItem) => this.openSubMenu(activateFirstItem),
            closeSubMenu: () => this.closeSubMenu(),
            closeMenu: (event) => this.closeMenu(event),
            updateTooltip: (tooltip, shouldDisplayTooltip) => this.refreshTooltip(tooltip, shouldDisplayTooltip),
            onItemActivated: () => this.onItemActivated(),
        });
        return (compDetails?.newAgStackInstance().then((comp) => {
            this.menuItemComp = comp;
            const configureDefaults = comp.configureDefaults?.();
            if (configureDefaults) {
                this.configureDefaults(configureDefaults === true ? undefined : configureDefaults);
            }
        }) ?? ag_grid_community_1.AgPromise.resolve());
    }
    addListeners(eGui, params) {
        if (!params?.suppressClick) {
            this.addManagedElementListeners(eGui, { click: (e) => this.onItemSelected(e) });
        }
        if (!params?.suppressKeyboardSelect) {
            this.addManagedElementListeners(eGui, {
                keydown: (e) => {
                    if (e.key === ag_grid_community_1.KeyCode.ENTER || e.key === ag_grid_community_1.KeyCode.SPACE) {
                        e.preventDefault();
                        this.onItemSelected(e);
                    }
                },
            });
        }
        if (!params?.suppressMouseDown) {
            this.addManagedElementListeners(eGui, {
                mousedown: (e) => {
                    // Prevent event bubbling to other event handlers such as PopupService triggering
                    // premature closing of any open sub-menu popup.
                    e.stopPropagation();
                    e.preventDefault();
                },
            });
        }
        if (!params?.suppressMouseOver) {
            this.addManagedElementListeners(eGui, {
                mouseenter: () => this.onMouseEnter(),
                mouseleave: () => this.onMouseLeave(),
            });
        }
    }
    isDisabled() {
        return !!this.params.disabled;
    }
    openSubMenu(activateFirstItem = false, event) {
        this.closeSubMenu();
        if (!this.params.subMenu) {
            return;
        }
        this.subMenuIsOpening = true;
        const ePopup = (0, ag_grid_community_1._loadTemplate)(/* html */ `<div class="ag-menu" role="presentation"></div>`);
        this.eSubMenuGui = ePopup;
        let destroySubMenu;
        let afterGuiAttached = () => {
            this.subMenuIsOpening = false;
        };
        if (this.childComponent) {
            const menuPanel = this.createBean(new agMenuPanel_1.AgMenuPanel(this.childComponent));
            menuPanel.setParentComponent(this);
            const subMenuGui = menuPanel.getGui();
            const mouseEvent = 'mouseenter';
            const mouseEnterListener = () => this.cancelDeactivate();
            subMenuGui.addEventListener(mouseEvent, mouseEnterListener);
            destroySubMenu = () => subMenuGui.removeEventListener(mouseEvent, mouseEnterListener);
            ePopup.appendChild(subMenuGui);
            if (this.childComponent.afterGuiAttached) {
                afterGuiAttached = () => {
                    this.childComponent.afterGuiAttached();
                    this.subMenuIsOpening = false;
                };
            }
        }
        else if (this.params.subMenu) {
            const childMenu = this.createBean(new agMenuList_1.AgMenuList(this.level + 1, this.contextParams));
            childMenu.setParentComponent(this);
            childMenu.addMenuItems(this.params.subMenu);
            ePopup.appendChild(childMenu.getGui());
            // bubble menu item selected events
            this.addManagedListeners(childMenu, { closeMenu: (e) => this.dispatchLocalEvent(e) });
            childMenu.addGuiEventListener('mouseenter', () => this.cancelDeactivate());
            destroySubMenu = () => this.destroyBean(childMenu);
            if (activateFirstItem) {
                afterGuiAttached = () => {
                    childMenu.activateFirstItem();
                    this.subMenuIsOpening = false;
                };
            }
        }
        const { popupSvc } = this;
        const positionCallback = () => {
            const eventSource = this.eGui;
            popupSvc?.positionPopupForMenu({
                eventSource,
                ePopup,
            });
            const { column, node } = this.contextParams;
            popupSvc?.callPostProcessPopup('subMenu', ePopup, eventSource, event instanceof MouseEvent ? event : undefined, column, node);
        };
        const translate = this.getLocaleTextFunc();
        const addPopupRes = popupSvc?.addPopup({
            modal: true,
            eChild: ePopup,
            positionCallback,
            anchorToElement: this.eGui,
            ariaLabel: translate('ariaLabelSubMenu', 'SubMenu'),
            afterGuiAttached,
        });
        this.subMenuIsOpen = true;
        this.setAriaExpanded(true);
        this.hideSubMenu = () => {
            if (addPopupRes) {
                addPopupRes.hideFunc();
            }
            this.subMenuIsOpen = false;
            this.setAriaExpanded(false);
            destroySubMenu();
            this.menuItemComp.setExpanded?.(false);
            this.eSubMenuGui = undefined;
        };
        this.menuItemComp.setExpanded?.(true);
    }
    setAriaExpanded(expanded) {
        if (!this.suppressAria) {
            (0, ag_grid_community_1._setAriaExpanded)(this.eGui, expanded);
        }
    }
    closeSubMenu() {
        if (!this.hideSubMenu) {
            return;
        }
        this.hideSubMenu();
        this.hideSubMenu = null;
        this.setAriaExpanded(false);
    }
    isSubMenuOpen() {
        return this.subMenuIsOpen;
    }
    isSubMenuOpening() {
        return this.subMenuIsOpening;
    }
    activate(openSubMenu) {
        this.cancelActivate();
        if (this.params.disabled) {
            return;
        }
        this.isActive = true;
        if (!this.suppressRootStyles) {
            this.eGui.classList.add(`${this.cssClassPrefix}-active`);
        }
        this.menuItemComp.setActive?.(true);
        if (!this.suppressFocus) {
            this.eGui.focus({ preventScroll: true });
        }
        if (openSubMenu && this.params.subMenu) {
            window.setTimeout(() => {
                if (this.isAlive() && this.isActive) {
                    this.openSubMenu();
                }
            }, 300);
        }
        this.onItemActivated();
    }
    deactivate() {
        this.cancelDeactivate();
        if (!this.suppressRootStyles) {
            this.eGui.classList.remove(`${this.cssClassPrefix}-active`);
        }
        this.menuItemComp.setActive?.(false);
        this.isActive = false;
        if (this.subMenuIsOpen) {
            this.hideSubMenu();
        }
    }
    getGui() {
        return this.menuItemComp.getGui();
    }
    getParentComponent() {
        return this.parentComponent;
    }
    setParentComponent(component) {
        this.parentComponent = component;
    }
    getSubMenuGui() {
        return this.eSubMenuGui;
    }
    onItemSelected(event) {
        this.menuItemComp.select?.();
        if (this.params.action) {
            this.beans.frameworkOverrides.wrapOutgoing(() => this.params.action(this.gos.addGridCommonParams({
                ...this.contextParams,
            })));
        }
        else {
            this.openSubMenu(event && event.type === 'keydown', event);
        }
        if ((this.params.subMenu && !this.params.action) || this.params.suppressCloseOnSelect) {
            return;
        }
        this.closeMenu(event);
    }
    closeMenu(event) {
        const e = {
            type: 'closeMenu',
        };
        if (event) {
            if (event instanceof MouseEvent) {
                e.mouseEvent = event;
            }
            else {
                e.keyboardEvent = event;
            }
        }
        this.dispatchLocalEvent(e);
    }
    onItemActivated() {
        const event = {
            type: 'menuItemActivated',
            menuItem: this,
        };
        this.dispatchLocalEvent(event);
    }
    cancelActivate() {
        if (this.activateTimeoutId) {
            window.clearTimeout(this.activateTimeoutId);
            this.activateTimeoutId = 0;
        }
    }
    cancelDeactivate() {
        if (this.deactivateTimeoutId) {
            window.clearTimeout(this.deactivateTimeoutId);
            this.deactivateTimeoutId = 0;
        }
    }
    onMouseEnter() {
        this.cancelDeactivate();
        if (this.isAnotherSubMenuOpen()) {
            // wait to see if the user enters the open sub-menu
            this.activateTimeoutId = window.setTimeout(() => this.activate(true), this.ACTIVATION_DELAY);
        }
        else {
            // activate immediately
            this.activate(true);
        }
    }
    onMouseLeave() {
        this.cancelActivate();
        if (this.isSubMenuOpen()) {
            // wait to see if the user enters the sub-menu
            this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), this.ACTIVATION_DELAY);
        }
        else {
            // de-activate immediately
            this.deactivate();
        }
    }
    configureDefaults(params) {
        if (!this.menuItemComp) {
            // need to wait for init to complete
            setTimeout(() => this.configureDefaults(params));
            return;
        }
        let eGui = this.menuItemComp.getGui();
        const { suppressRootStyles, suppressTooltip, suppressAria, suppressTabIndex, suppressFocus } = params || {};
        // in some frameworks, `getGui` might be a framework element
        const rootElement = this.menuItemComp.getRootElement?.();
        if (rootElement) {
            if (!suppressRootStyles) {
                eGui.classList.add('ag-menu-option-custom');
            }
            eGui = rootElement;
        }
        this.eGui = eGui;
        this.suppressRootStyles = !!suppressRootStyles;
        if (!this.suppressRootStyles) {
            eGui.classList.add(this.cssClassPrefix);
            this.params.cssClasses?.forEach((it) => eGui.classList.add(it));
            if (this.params.disabled) {
                eGui.classList.add(`${this.cssClassPrefix}-disabled`);
            }
        }
        if (!suppressTooltip) {
            this.refreshTooltip(this.params.tooltip);
        }
        this.suppressAria = !!suppressAria;
        if (!this.suppressAria) {
            (0, ag_grid_community_1._setAriaRole)(eGui, 'treeitem');
            (0, ag_grid_community_1._setAriaLevel)(eGui, this.level + 1);
            if (this.params.disabled) {
                (0, ag_grid_community_1._setAriaDisabled)(eGui, true);
            }
        }
        if (!suppressTabIndex) {
            eGui.setAttribute('tabindex', '-1');
        }
        if (!this.params.disabled) {
            this.addListeners(eGui, params);
        }
        this.suppressFocus = !!suppressFocus;
    }
    refreshTooltip(tooltip, shouldDisplayTooltip) {
        this.tooltip = tooltip;
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        if (!tooltip || !this.menuItemComp) {
            return;
        }
        const tooltipFeature = this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            getTooltipValue: () => this.tooltip,
            getLocation: () => 'menu',
            shouldDisplayTooltip,
        });
        if (tooltipFeature) {
            this.tooltipFeature = this.createBean(tooltipFeature);
        }
    }
    destroy() {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        this.menuItemComp?.destroy?.();
        super.destroy();
    }
}
exports.AgMenuItemComponent = AgMenuItemComponent;


/***/ }),

/***/ 3360:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgMenuItemRenderer = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgMenuItemRenderer extends ag_grid_community_1.Component {
    constructor() {
        super();
        this.setTemplate(/* html */ `<div></div>`);
    }
    init(params) {
        this.params = params;
        this.cssClassPrefix = this.params.cssClassPrefix ?? 'ag-menu-option';
        this.addAriaAttributes();
        this.addIcon();
        this.addName();
        this.addShortcut();
        this.addSubMenu();
    }
    configureDefaults() {
        return true;
    }
    addAriaAttributes() {
        const { checked, subMenu } = this.params;
        const eGui = this.getGui();
        if (checked) {
            (0, ag_grid_community_1._setAriaChecked)(eGui, checked);
        }
        if (subMenu) {
            (0, ag_grid_community_1._setAriaExpanded)(eGui, false);
        }
    }
    addIcon() {
        if (this.params.isCompact) {
            return;
        }
        const iconWrapper = (0, ag_grid_community_1._loadTemplate)(
        /* html */
        `<span data-ref="eIcon" class="${this.getClassName('part')} ${this.getClassName('icon')}" role="presentation"></span>`);
        const { checked, icon } = this.params;
        if (checked) {
            iconWrapper.appendChild((0, ag_grid_community_1._createIconNoSpan)('check', this.beans));
        }
        else if (icon) {
            if ((0, ag_grid_community_1._isNodeOrElement)(icon)) {
                iconWrapper.appendChild(icon);
            }
            else if (typeof icon === 'string') {
                iconWrapper.innerHTML = icon;
            }
            else {
                (0, ag_grid_community_1._warn)(227);
            }
        }
        this.getGui().appendChild(iconWrapper);
    }
    addName() {
        const name = (0, ag_grid_community_1._loadTemplate)(
        /* html */
        `<span data-ref="eName" class="${this.getClassName('part')} ${this.getClassName('text')}">${this.params.name || ''}</span>`);
        this.getGui().appendChild(name);
    }
    addShortcut() {
        if (this.params.isCompact) {
            return;
        }
        const shortcut = (0, ag_grid_community_1._loadTemplate)(
        /* html */
        `<span data-ref="eShortcut" class="${this.getClassName('part')} ${this.getClassName('shortcut')}">${this.params.shortcut || ''}</span>`);
        this.getGui().appendChild(shortcut);
    }
    addSubMenu() {
        const pointer = (0, ag_grid_community_1._loadTemplate)(
        /* html */
        `<span data-ref="ePopupPointer" class="${this.getClassName('part')} ${this.getClassName('popup-pointer')}"></span>`);
        const eGui = this.getGui();
        if (this.params.subMenu) {
            const iconName = this.gos.get('enableRtl') ? 'subMenuOpenRtl' : 'subMenuOpen';
            pointer.appendChild((0, ag_grid_community_1._createIconNoSpan)(iconName, this.beans));
        }
        eGui.appendChild(pointer);
    }
    getClassName(suffix) {
        return `${this.cssClassPrefix}-${suffix}`;
    }
}
exports.AgMenuItemRenderer = AgMenuItemRenderer;


/***/ }),

/***/ 9476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgMenuList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agMenuItemComponent_1 = __webpack_require__(7040);
class AgMenuList extends ag_grid_community_1.TabGuardComp {
    constructor(level = 0, params) {
        super(/* html */ `<div class="ag-menu-list" role="tree"></div>`);
        this.level = level;
        this.menuItems = [];
        this.params = params ?? {
            column: null,
            node: null,
            value: null,
        };
    }
    postConstruct() {
        this.initialiseTabGuard({
            onTabKeyDown: (e) => this.onTabKeyDown(e),
            handleKeyDown: (e) => this.handleKeyDown(e),
            onFocusIn: (e) => this.handleFocusIn(e),
            onFocusOut: (e) => this.handleFocusOut(e),
        });
    }
    onTabKeyDown(e) {
        const parent = this.getParentComponent();
        const parentGui = parent && parent.getGui();
        const isManaged = parentGui && parentGui.classList.contains('ag-focus-managed');
        if (!isManaged) {
            e.preventDefault();
        }
        if (e.shiftKey) {
            this.closeIfIsChild(e);
        }
    }
    handleKeyDown(e) {
        switch (e.key) {
            case ag_grid_community_1.KeyCode.UP:
            case ag_grid_community_1.KeyCode.RIGHT:
            case ag_grid_community_1.KeyCode.DOWN:
            case ag_grid_community_1.KeyCode.LEFT:
                e.preventDefault();
                this.handleNavKey(e.key);
                break;
            case ag_grid_community_1.KeyCode.ESCAPE:
                if (this.closeIfIsChild()) {
                    (0, ag_grid_community_1._stopPropagationForAgGrid)(e);
                }
                break;
        }
    }
    handleFocusIn(e) {
        // if focus is coming from outside the menu list, then re-activate an item
        const oldFocusedElement = e.relatedTarget;
        if (!this.tabGuardFeature.getTabGuardCtrl().isTabGuard(oldFocusedElement) &&
            (this.getGui().contains(oldFocusedElement) ||
                this.activeMenuItem?.getSubMenuGui()?.contains(oldFocusedElement))) {
            return;
        }
        if (this.activeMenuItem) {
            this.activeMenuItem.activate();
        }
        else {
            this.activateFirstItem();
        }
    }
    handleFocusOut(e) {
        // if focus is going outside the menu list, deactivate the current item
        const newFocusedElement = e.relatedTarget;
        if (!this.activeMenuItem ||
            this.getGui().contains(newFocusedElement) ||
            this.activeMenuItem.getSubMenuGui()?.contains(newFocusedElement)) {
            return;
        }
        if (!this.activeMenuItem.isSubMenuOpening()) {
            this.activeMenuItem.deactivate();
        }
    }
    clearActiveItem() {
        if (this.activeMenuItem) {
            this.activeMenuItem.deactivate();
            this.activeMenuItem = null;
        }
    }
    addMenuItems(menuItems) {
        if (menuItems == null) {
            return;
        }
        ag_grid_community_1.AgPromise.all(menuItems.map((menuItemOrString) => {
            if (menuItemOrString === 'separator') {
                return ag_grid_community_1.AgPromise.resolve({ eGui: this.createSeparator() });
            }
            else if (typeof menuItemOrString === 'string') {
                (0, ag_grid_community_1._warn)(228, { menuItemOrString });
                return ag_grid_community_1.AgPromise.resolve({ eGui: null });
            }
            else {
                return this.addItem(menuItemOrString);
            }
        })).then((elements) => {
            (elements ?? []).forEach((element) => {
                if (element?.eGui) {
                    this.appendChild(element.eGui);
                    if (element.comp) {
                        this.menuItems.push(element.comp);
                    }
                }
            });
        });
    }
    addItem(menuItemDef) {
        const menuItem = this.createManagedBean(new agMenuItemComponent_1.AgMenuItemComponent());
        return menuItem
            .init({
            menuItemDef,
            isAnotherSubMenuOpen: () => this.menuItems.some((m) => m.isSubMenuOpen()),
            level: this.level,
            contextParams: this.params,
        })
            .then(() => {
            menuItem.setParentComponent(this);
            this.addManagedListeners(menuItem, {
                closeMenu: (event) => {
                    this.dispatchLocalEvent(event);
                },
                menuItemActivated: (event) => {
                    if (this.activeMenuItem && this.activeMenuItem !== event.menuItem) {
                        this.activeMenuItem.deactivate();
                    }
                    this.activeMenuItem = event.menuItem;
                },
            });
            return {
                comp: menuItem,
                eGui: menuItem.getGui(),
            };
        });
    }
    activateFirstItem() {
        const item = this.menuItems.filter((currentItem) => !currentItem.isDisabled())[0];
        if (!item) {
            return;
        }
        item.activate();
    }
    createSeparator() {
        const separatorHtml = /* html */ `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`;
        return (0, ag_grid_community_1._loadTemplate)(separatorHtml);
    }
    handleNavKey(key) {
        switch (key) {
            case ag_grid_community_1.KeyCode.UP:
            case ag_grid_community_1.KeyCode.DOWN: {
                const nextItem = this.findNextItem(key === ag_grid_community_1.KeyCode.UP);
                if (nextItem && nextItem !== this.activeMenuItem) {
                    nextItem.activate();
                }
                return;
            }
        }
        const left = this.gos.get('enableRtl') ? ag_grid_community_1.KeyCode.RIGHT : ag_grid_community_1.KeyCode.LEFT;
        if (key === left) {
            this.closeIfIsChild();
        }
        else {
            this.openChild();
        }
    }
    closeIfIsChild(e) {
        const parentItem = this.getParentComponent();
        if (parentItem && parentItem instanceof agMenuItemComponent_1.AgMenuItemComponent) {
            if (e) {
                e.preventDefault();
            }
            parentItem.closeSubMenu();
            parentItem.getGui().focus();
            return true;
        }
        return false;
    }
    openChild() {
        if (this.activeMenuItem) {
            this.activeMenuItem.openSubMenu(true);
        }
    }
    findNextItem(up) {
        const items = this.menuItems.filter((item) => !item.isDisabled());
        if (!items.length) {
            return;
        }
        if (!this.activeMenuItem) {
            return up ? (0, ag_grid_community_1._last)(items) : items[0];
        }
        if (up) {
            items.reverse();
        }
        let nextItem;
        let foundCurrent = false;
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (!foundCurrent) {
                if (item === this.activeMenuItem) {
                    foundCurrent = true;
                }
                continue;
            }
            nextItem = item;
            break;
        }
        if (foundCurrent && !nextItem) {
            // start again from the beginning (/end)
            return items[0];
        }
        return nextItem || this.activeMenuItem;
    }
    destroy() {
        this.clearActiveItem();
        super.destroy();
    }
}
exports.AgMenuList = AgMenuList;


/***/ }),

/***/ 568:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgMenuPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class AgMenuPanel extends ag_grid_community_1.TabGuardComp {
    constructor(wrappedComponent) {
        super();
        this.setTemplateFromElement(wrappedComponent.getGui(), undefined, undefined, true);
    }
    postConstruct() {
        this.initialiseTabGuard({
            onTabKeyDown: (e) => this.onTabKeyDown(e),
            handleKeyDown: (e) => this.handleKeyDown(e),
        });
    }
    handleKeyDown(e) {
        if (e.key === ag_grid_community_1.KeyCode.ESCAPE) {
            this.closePanel();
        }
    }
    onTabKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        this.closePanel();
        e.preventDefault();
    }
    closePanel() {
        const menuItem = this.parentComponent;
        menuItem.closeSubMenu();
        setTimeout(() => menuItem.getGui().focus(), 0);
    }
}
exports.AgMenuPanel = AgMenuPanel;


/***/ }),

/***/ 7088:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agPanelCSS = void 0;
exports.agPanelCSS = `.ag-panel{background-color:var(--ag-panel-background-color);display:flex;flex-direction:column;overflow:hidden;position:relative}.ag-dialog{border:var(--ag-dialog-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dialog-shadow);position:absolute}.ag-panel-title-bar{align-items:center;background-color:var(--ag-panel-title-bar-background-color);border-bottom:var(--ag-panel-title-bar-border);color:var(--ag-header-text-color);cursor:default;display:flex;flex:none;height:var(--ag-header-height);padding:var(--ag-spacing) var(--ag-cell-horizontal-padding)}.ag-panel-title-bar-button{cursor:pointer}:where(.ag-ltr) .ag-panel-title-bar-button{margin-left:calc(var(--ag-spacing)*2);margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-panel-title-bar-button{margin-left:var(--ag-spacing);margin-right:calc(var(--ag-spacing)*2)}.ag-panel-title-bar-title{color:var(--ag-header-text-color);flex:1 1 auto;font-weight:500}.ag-panel-title-bar-buttons{display:flex}.ag-panel-content-wrapper{display:flex;flex:1 1 auto;overflow:hidden;position:relative}:where(.ag-dragging-fill-handle) .ag-dialog,:where(.ag-dragging-range-handle) .ag-dialog{opacity:.7;pointer-events:none}`;


/***/ }),

/***/ 7325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agPanel_css_GENERATED_1 = __webpack_require__(7088);
function getTemplate(config) {
    const cssIdentifier = config.cssIdentifier || 'default';
    return /* html */ `<div class="ag-panel ag-${cssIdentifier}-panel" tabindex="-1">
        <div data-ref="eTitleBar" class="ag-panel-title-bar ag-${cssIdentifier}-panel-title-bar ag-unselectable">
            <span data-ref="eTitle" class="ag-panel-title-bar-title ag-${cssIdentifier}-panel-title-bar-title"></span>
            <div data-ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${cssIdentifier}-panel-title-bar-buttons"></div>
        </div>
        <div data-ref="eContentWrapper" class="ag-panel-content-wrapper ag-${cssIdentifier}-panel-content-wrapper"></div>
    </div>`;
}
const CLOSE_BTN_TEMPLATE = /* html */ `<div class="ag-button"></div>`;
class AgPanel extends ag_grid_community_1.Component {
    constructor(config) {
        super(getTemplate(config));
        this.config = config;
        this.closable = true;
        this.eContentWrapper = ag_grid_community_1.RefPlaceholder;
        this.eTitleBar = ag_grid_community_1.RefPlaceholder;
        this.eTitleBarButtons = ag_grid_community_1.RefPlaceholder;
        this.eTitle = ag_grid_community_1.RefPlaceholder;
        this.registerCSS(agPanel_css_GENERATED_1.agPanelCSS);
    }
    postConstruct() {
        const { component, closable, hideTitleBar, title, minWidth = 250, width, minHeight = 250, height, centered, popup, x, y, } = this.config;
        this.positionableFeature = new ag_grid_community_1.PositionableFeature(this.getGui(), {
            minWidth,
            width,
            minHeight,
            height,
            centered,
            x,
            y,
            popup,
            calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight(),
        });
        this.createManagedBean(this.positionableFeature);
        const eGui = this.getGui();
        if (component) {
            this.setBodyComponent(component);
        }
        if (!hideTitleBar) {
            if (title) {
                this.setTitle(title);
            }
            this.setClosable(closable != null ? closable : this.closable);
        }
        else {
            (0, ag_grid_community_1._setDisplayed)(this.eTitleBar, false);
        }
        this.addManagedElementListeners(this.eTitleBar, {
            mousedown: (e) => {
                if (eGui.contains(e.relatedTarget) ||
                    eGui.contains((0, ag_grid_community_1._getActiveDomElement)(this.beans)) ||
                    this.eTitleBarButtons.contains(e.target)) {
                    e.preventDefault();
                    return;
                }
                const focusEl = this.eContentWrapper.querySelector('button, [href], input, select, textarea, [tabindex]');
                if (focusEl) {
                    focusEl.focus();
                }
            },
        });
        if (popup && this.positionableFeature.isPositioned()) {
            return;
        }
        if (this.renderComponent) {
            this.renderComponent();
        }
        this.positionableFeature.initialisePosition();
        this.eContentWrapper.style.height = '0';
    }
    renderComponent() {
        const eGui = this.getGui();
        eGui.focus();
        this.close = () => {
            eGui.parentElement.removeChild(eGui);
            this.destroy();
        };
    }
    getHeight() {
        return this.positionableFeature.getHeight();
    }
    setHeight(height) {
        this.positionableFeature.setHeight(height);
    }
    getWidth() {
        return this.positionableFeature.getWidth();
    }
    setWidth(width) {
        this.positionableFeature.setWidth(width);
    }
    setClosable(closable) {
        if (closable !== this.closable) {
            this.closable = closable;
        }
        if (closable) {
            const closeButtonComp = (this.closeButtonComp = new ag_grid_community_1.Component(CLOSE_BTN_TEMPLATE));
            this.createBean(closeButtonComp);
            const eGui = closeButtonComp.getGui();
            const child = (0, ag_grid_community_1._createIconNoSpan)('close', this.beans);
            child.classList.add('ag-panel-title-bar-button-icon');
            eGui.appendChild(child);
            this.addTitleBarButton(closeButtonComp);
            closeButtonComp.addManagedElementListeners(eGui, { click: this.onBtClose.bind(this) });
        }
        else if (this.closeButtonComp) {
            const eGui = this.closeButtonComp.getGui();
            eGui.parentElement.removeChild(eGui);
            this.closeButtonComp = this.destroyBean(this.closeButtonComp);
        }
    }
    setBodyComponent(bodyComponent) {
        bodyComponent.setParentComponent(this);
        this.eContentWrapper.appendChild(bodyComponent.getGui());
    }
    addTitleBarButton(button, position) {
        const eTitleBarButtons = this.eTitleBarButtons;
        const buttons = eTitleBarButtons.children;
        const len = buttons.length;
        if (position == null) {
            position = len;
        }
        position = Math.max(0, Math.min(position, len));
        button.addCssClass('ag-panel-title-bar-button');
        const eGui = button.getGui();
        if (position === 0) {
            eTitleBarButtons.insertAdjacentElement('afterbegin', eGui);
        }
        else if (position === len) {
            eTitleBarButtons.insertAdjacentElement('beforeend', eGui);
        }
        else {
            buttons[position - 1].insertAdjacentElement('afterend', eGui);
        }
        button.setParentComponent(this);
    }
    getBodyHeight() {
        return (0, ag_grid_community_1._getInnerHeight)(this.eContentWrapper);
    }
    getBodyWidth() {
        return (0, ag_grid_community_1._getInnerWidth)(this.eContentWrapper);
    }
    setTitle(title) {
        this.eTitle.innerText = title;
    }
    // called when user hits the 'x' in the top right
    onBtClose() {
        this.close();
    }
    destroy() {
        if (this.closeButtonComp) {
            this.closeButtonComp = this.destroyBean(this.closeButtonComp);
        }
        const eGui = this.getGui();
        if (eGui && (0, ag_grid_community_1._isVisible)(eGui)) {
            this.close();
        }
        super.destroy();
    }
}
exports.AgPanel = AgPanel;


/***/ }),

/***/ 3264:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPill = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const ag_grid_community_2 = __webpack_require__(6624);
class AgPill extends ag_grid_community_2.Component {
    constructor(config) {
        super(/* html */ `
            <div class="ag-pill" role="option">
                <span class="ag-pill-text" data-ref="eText"></span>
                <span class="ag-button ag-pill-button" data-ref="eButton" role="presentation"></span>
            </div>
        `);
        this.config = config;
        this.eText = ag_grid_community_1.RefPlaceholder;
        this.eButton = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        const { config, eButton } = this;
        const { onKeyDown, onButtonClick } = config;
        this.getGui().setAttribute('tabindex', String(this.gos.get('tabIndex')));
        this.addGuiEventListener('focus', () => {
            this.eButton.focus();
        });
        if (onKeyDown) {
            this.addGuiEventListener('keydown', onKeyDown);
        }
        if (onButtonClick) {
            this.addManagedElementListeners(eButton, {
                click: onButtonClick,
            });
        }
    }
    toggleCloseButtonClass(className, force) {
        this.eButton.classList.toggle(className, force);
    }
    setText(text) {
        this.eText.textContent = text;
    }
    getText() {
        return this.eText.textContent;
    }
}
exports.AgPill = AgPill;


/***/ }),

/***/ 7720:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agRichSelectCSS = void 0;
exports.agRichSelectCSS = `.ag-rich-select{cursor:default;height:100%}.ag-rich-select-value{align-items:center;background-color:var(--ag-input-background-color);display:flex;height:100%;padding:var(--ag-spacing);:where(.ag-picker-field-display){overflow:hidden;text-overflow:ellipsis;&:where(.ag-display-as-placeholder){opacity:.5}}}.ag-rich-select-list{background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);box-shadow:var(--ag-dropdown-shadow);height:auto;position:relative;width:100%;:where(.ag-loading-text){padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}}.ag-rich-select-row{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;padding:0 var(--ag-spacing);white-space:nowrap}.ag-rich-select-row-selected{background-color:var(--ag-selected-row-background-color)}.ag-rich-select-row-highlighted,.ag-rich-select-row:hover{background-image:linear-gradient(var(--ag-row-hover-color),var(--ag-row-hover-color))}.ag-rich-select-row-text-highlight{font-weight:700}.ag-rich-select-field-input{flex:1 1 auto;:where(.ag-input-field-input){border:none!important;box-shadow:none!important;padding:0!important;text-overflow:ellipsis;&::-moz-placeholder{opacity:.8}&::placeholder{opacity:.8}}}:where(.ag-ltr) .ag-rich-select-field-input{left:var(--ag-spacing)}:where(.ag-rtl) .ag-rich-select-field-input{right:var(--ag-spacing)}:where(.ag-popup-editor) .ag-rich-select-value{height:var(--ag-row-height);min-width:200px}.ag-rich-select-virtual-list-item{cursor:default;height:var(--ag-list-item-height)}.ag-pill-container{display:flex;flex-wrap:nowrap;gap:.25rem}.ag-pill{align-items:center;background:var(--ag-select-cell-background-color);border:var(--ag-select-cell-border);border-radius:var(--ag-border-radius);display:flex;padding:0 .25rem;white-space:nowrap}.ag-pill-button{border:none;padding:0;&:hover{color:var(--ag-accent-color);cursor:pointer}}:where(.ag-ltr) .ag-pill-button{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-pill-button{margin-right:var(--ag-spacing)}`;


/***/ }),

/***/ 2005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgRichSelect = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const AgPillContainer_1 = __webpack_require__(7437);
const agRichSelect_css_GENERATED_1 = __webpack_require__(7720);
const agRichSelectList_1 = __webpack_require__(5805);
class AgRichSelect extends ag_grid_community_1.AgPickerField {
    wireBeans(beans) {
        this.userCompFactory = beans.userCompFactory;
        this.ariaAnnounce = beans.ariaAnnounce;
        this.registry = beans.registry;
    }
    constructor(config) {
        super({
            pickerAriaLabelKey: 'ariaLabelRichSelectField',
            pickerAriaLabelValue: 'Rich Select Field',
            pickerType: 'ag-list',
            className: 'ag-rich-select',
            pickerIcon: 'richSelectOpen',
            ariaRole: 'combobox',
            template: config?.template ??
                /* html */ `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-rich-select-value ag-picker-collapsed">
                    <span data-ref="eDisplayField" class="ag-picker-field-display"></span>
                    <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                    <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                    <span data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></span>
                </div>
            </div>`,
            agComponents: [ag_grid_community_1.AgInputTextFieldSelector],
            modalPicker: false,
            ...config,
            // maxPickerHeight needs to be set after expanding `config`
            maxPickerHeight: config?.maxPickerHeight ?? 'calc(var(--ag-row-height) * 6.5)',
        });
        this.searchString = '';
        this.searchStringCreator = null;
        this.eInput = ag_grid_community_1.RefPlaceholder;
        this.eDeselect = ag_grid_community_1.RefPlaceholder;
        this.skipWrapperAnnouncement = false;
        const { value, valueList, searchStringCreator } = config || {};
        if (value !== undefined) {
            this.value = value;
        }
        if (valueList != null) {
            this.values = valueList;
        }
        if (searchStringCreator) {
            this.searchStringCreator = searchStringCreator;
        }
        this.registerCSS(agRichSelect_css_GENERATED_1.agRichSelectCSS);
    }
    postConstruct() {
        this.tooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            shouldDisplayTooltip: () => this.shouldDisplayTooltip?.() ?? true,
        }));
        super.postConstruct();
        this.createListComponent();
        this.eDeselect.appendChild((0, ag_grid_community_1._createIconNoSpan)('richSelectRemove', this.beans));
        const { allowTyping, placeholder, suppressDeselectAll } = this.config;
        this.eDeselect.classList.add('ag-hidden');
        if (allowTyping) {
            this.eInput.setAutoComplete(false).setInputPlaceholder(placeholder);
            this.eDisplayField.classList.add('ag-hidden');
        }
        else {
            this.eInput.setDisplayed(false);
        }
        this.setupAriaProperties();
        const { searchDebounceDelay = 300 } = this.config;
        this.clearSearchString = (0, ag_grid_community_1._debounce)(this, this.clearSearchString.bind(this), searchDebounceDelay);
        this.renderSelectedValue();
        if (allowTyping) {
            this.eInput.onValueChange((value) => this.searchTextFromString(value));
        }
        this.addManagedElementListeners(this.eWrapper, { focus: this.onWrapperFocus.bind(this) });
        this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
        if (!suppressDeselectAll) {
            this.addManagedElementListeners(this.eDeselect, {
                mousedown: this.onDeselectAllMouseDown.bind(this),
                click: this.onDeselectAllClick.bind(this),
            });
        }
    }
    setupAriaProperties() {
        const { eWrapper, gos } = this;
        eWrapper.tabIndex = gos.get('tabIndex');
        const translate = this.getLocaleTextFunc();
        this.ariaDeleteSelection = translate('ariaLabelRichSelectDeleteSelection', 'Press DELETE to deselect item');
        this.ariaDeselectAllItems = translate('ariaLabelRichSelectDeselectAllItems', 'Press DELETE to deselect all items');
        this.ariaToggleSelection = translate('ariaLabelRichSelectToggleSelection', 'Press SPACE to toggle selection');
    }
    createListComponent() {
        this.listComponent = this.createBean(new agRichSelectList_1.AgRichSelectList(this.config, this.eWrapper, () => this.searchString));
        this.listComponent.setParentComponent(this);
        this.addManagedListeners(this.listComponent, {
            richSelectListRowSelected: (e) => {
                this.onListValueSelected(e.value, e.fromEnterKey);
            },
        });
    }
    renderSelectedValue() {
        const { value, eDisplayField, config, gos } = this;
        const { allowTyping, cellRenderer, initialInputValue, multiSelect, suppressDeselectAll, suppressMultiSelectPillRenderer, } = config;
        const valueFormatted = this.config.valueFormatter ? this.config.valueFormatter(value) : value;
        if (allowTyping) {
            this.eInput.setValue(initialInputValue ?? valueFormatted);
            return;
        }
        if (multiSelect && !suppressDeselectAll) {
            const isEmpty = value == null || (Array.isArray(value) && value.length === 0);
            this.eDeselect.classList.toggle('ag-hidden', isEmpty);
        }
        let userCompDetails;
        if (multiSelect && !suppressMultiSelectPillRenderer) {
            this.createOrUpdatePillContainer(eDisplayField);
            return;
        }
        if (cellRenderer) {
            userCompDetails = (0, ag_grid_community_1._getEditorRendererDetails)(this.userCompFactory, config, {
                value,
                valueFormatted,
                getValue: () => this.getValue(),
                setValue: (value) => {
                    this.setValue(value, true);
                },
                setTooltip: (value, shouldDisplayTooltip) => {
                    gos.assertModuleRegistered('Tooltip', 3);
                    this.shouldDisplayTooltip = shouldDisplayTooltip;
                    this.tooltipFeature?.setTooltipAndRefresh(value);
                },
            });
        }
        let userCompDetailsPromise;
        if (userCompDetails) {
            userCompDetailsPromise = userCompDetails.newAgStackInstance();
        }
        if (userCompDetailsPromise) {
            (0, ag_grid_community_1._clearElement)(eDisplayField);
            (0, ag_grid_community_1._bindCellRendererToHtmlElement)(userCompDetailsPromise, eDisplayField);
            userCompDetailsPromise.then((renderer) => {
                this.addDestroyFunc(() => this.destroyBean(renderer));
            });
        }
        else {
            if ((0, ag_grid_community_1._exists)(this.value)) {
                eDisplayField.innerText = valueFormatted;
                eDisplayField.classList.remove('ag-display-as-placeholder');
            }
            else {
                const { placeholder } = config;
                if ((0, ag_grid_community_1._exists)(placeholder)) {
                    eDisplayField.innerHTML = `${(0, ag_grid_community_1._escapeString)(placeholder)}`;
                    eDisplayField.classList.add('ag-display-as-placeholder');
                }
                else {
                    (0, ag_grid_community_1._clearElement)(eDisplayField);
                }
            }
            this.shouldDisplayTooltip = (0, ag_grid_community_1._shouldDisplayTooltip)(() => this.eDisplayField);
            this.tooltipFeature?.setTooltipAndRefresh(valueFormatted ?? null);
        }
    }
    createPickerComponent() {
        const { values } = this;
        if (values) {
            this.setValueList({ valueList: values });
        }
        // do not create the picker every time to save state
        return this.listComponent;
    }
    setSearchStringCreator(searchStringFn) {
        this.searchStringCreator = searchStringFn;
    }
    setValueList(params) {
        const { valueList, refresh } = params;
        if (!this.listComponent || this.listComponent.getCurrentList() === valueList) {
            return;
        }
        this.listComponent.setCurrentList(valueList);
        if (refresh) {
            // if `values` is not present, it means the valuesList was set asynchronously
            if (!this.values) {
                this.values = valueList;
                if (this.isPickerDisplayed) {
                    const hasRefreshed = this.listComponent.selectValue(this.value);
                    if (!hasRefreshed) {
                        this.listComponent.refresh();
                    }
                }
            }
            else {
                this.listComponent.refresh(true);
            }
            this.alignPickerToComponent();
        }
    }
    showPicker() {
        super.showPicker();
        const { listComponent, value } = this;
        if (!listComponent) {
            return;
        }
        let idx = null;
        if (this.value != null) {
            listComponent.selectValue(this.value);
            idx = listComponent.getIndicesForValues(Array.isArray(value) ? value : [value])[0];
        }
        if (idx != null) {
            listComponent.highlightIndex(idx);
        }
        else {
            listComponent.refresh();
        }
        this.displayOrHidePicker();
    }
    beforeHidePicker() {
        super.beforeHidePicker();
    }
    createOrUpdatePillContainer(container) {
        if (!this.pillContainer) {
            const pillContainer = (this.pillContainer = this.createBean(new AgPillContainer_1.AgPillContainer()));
            this.addDestroyFunc(() => {
                this.destroyBean(this.pillContainer);
                this.pillContainer = null;
            });
            (0, ag_grid_community_1._clearElement)(container);
            container.appendChild(pillContainer.getGui());
            pillContainer.init({
                eWrapper: this.eWrapper,
                onPillMouseDown: (e) => {
                    e.stopImmediatePropagation();
                },
                announceItemFocus: () => {
                    this.announceAriaValue(this.ariaDeleteSelection);
                },
                getValue: () => this.getValue(),
                setValue: (value) => this.setValue(value, true),
            });
        }
        this.doWhileBlockingAnnouncement(() => this.pillContainer?.refresh());
    }
    doWhileBlockingAnnouncement(func) {
        this.skipWrapperAnnouncement = true;
        func();
        this.skipWrapperAnnouncement = false;
    }
    onWrapperFocus() {
        const { eInput, config } = this;
        const { allowTyping, multiSelect, suppressDeselectAll } = config;
        if (allowTyping) {
            const focusableEl = eInput.getFocusableElement();
            focusableEl.focus();
            focusableEl.select();
        }
        else if (multiSelect && !suppressDeselectAll && !this.skipWrapperAnnouncement) {
            this.announceAriaValue(this.ariaDeselectAllItems);
        }
    }
    onWrapperFocusOut(e) {
        if (!this.eWrapper.contains(e.relatedTarget)) {
            this.hidePicker();
        }
    }
    onDeselectAllMouseDown(e) {
        // don't expand or collapse picker when clicking on deselect all
        e.stopImmediatePropagation();
    }
    onDeselectAllClick() {
        this.setValue([], true);
    }
    buildSearchStringFromKeyboardEvent(searchKey) {
        let { key } = searchKey;
        if (key === ag_grid_community_1.KeyCode.BACKSPACE) {
            this.searchString = this.searchString.slice(0, -1);
            key = '';
        }
        else if (!(0, ag_grid_community_1._isEventFromPrintableCharacter)(searchKey)) {
            return;
        }
        searchKey.preventDefault();
        this.searchTextFromCharacter(key);
    }
    searchTextFromCharacter(char) {
        this.searchString += char;
        this.runSearch();
        this.clearSearchString();
    }
    searchTextFromString(str) {
        if (str == null) {
            str = '';
        }
        this.searchString = str;
        this.runSearch();
    }
    buildSearchStrings(values) {
        const { valueFormatter = (value) => value } = this.config;
        let searchStrings;
        if (typeof values[0] === 'number' || typeof values[0] === 'string') {
            searchStrings = values.map((v) => valueFormatter(v));
        }
        else if (typeof values[0] === 'object' && this.searchStringCreator) {
            searchStrings = this.searchStringCreator(values);
        }
        return searchStrings;
    }
    filterListModel(filteredValues) {
        const { filterList } = this.config;
        if (!filterList) {
            return;
        }
        this.setValueList({ valueList: filteredValues, refresh: true });
    }
    runSearch() {
        if (!this.listComponent) {
            return;
        }
        const { values } = this;
        const searchStrings = this.buildSearchStrings(values);
        if (!searchStrings) {
            this.listComponent.highlightIndex(-1);
            return;
        }
        const { suggestions, filteredValues } = this.getSuggestionsAndFilteredValues(this.searchString, searchStrings);
        const { filterList, highlightMatch, searchType = 'fuzzy' } = this.config;
        const filterValueLen = filteredValues.length;
        const shouldFilter = !!(filterList && this.searchString !== '');
        this.filterListModel(shouldFilter ? filteredValues : values);
        if (suggestions.length) {
            const topSuggestionIndex = shouldFilter ? 0 : searchStrings.indexOf(suggestions[0]);
            this.listComponent?.highlightIndex(topSuggestionIndex);
        }
        else {
            this.listComponent?.highlightIndex(-1);
            if (!shouldFilter || filterValueLen) {
                this.listComponent?.ensureIndexVisible(0);
            }
            else if (shouldFilter) {
                this.getAriaElement().removeAttribute('data-active-option');
                const eListAriaEl = this.listComponent?.getAriaElement();
                if (eListAriaEl) {
                    (0, ag_grid_community_1._setAriaActiveDescendant)(eListAriaEl, null);
                }
            }
        }
        if (highlightMatch && searchType !== 'fuzzy') {
            this.listComponent?.highlightFilterMatch(this.searchString);
        }
        this.displayOrHidePicker();
    }
    getSuggestionsAndFilteredValues(searchValue, valueList) {
        let suggestions = [];
        const filteredValues = [];
        if (!searchValue.length) {
            return { suggestions, filteredValues };
        }
        const { searchType = 'fuzzy', filterList } = this.config;
        if (searchType === 'fuzzy') {
            const fuzzySearchResult = (0, ag_grid_community_1._fuzzySuggestions)({
                inputValue: searchValue,
                allSuggestions: valueList,
                hideIrrelevant: true,
                addSequentialWeight: true,
            });
            suggestions = fuzzySearchResult.values;
            const indices = fuzzySearchResult.indices;
            if (filterList && indices.length) {
                for (let i = 0; i < indices.length; i++) {
                    filteredValues.push(this.values[indices[i]]);
                }
            }
        }
        else {
            suggestions = valueList.filter((val, idx) => {
                const currentValue = val.toLocaleLowerCase();
                const valueToMatch = this.searchString.toLocaleLowerCase();
                const isMatch = searchType === 'match'
                    ? currentValue.startsWith(valueToMatch)
                    : currentValue.indexOf(valueToMatch) !== -1;
                if (filterList && isMatch) {
                    filteredValues.push(this.values[idx]);
                }
                return isMatch;
            });
        }
        return { suggestions, filteredValues };
    }
    displayOrHidePicker() {
        if (!this.listComponent) {
            return;
        }
        const eListGui = this.listComponent.getGui();
        const list = this.listComponent.getCurrentList();
        const toggleValue = list ? list.length === 0 : false;
        eListGui.classList.toggle('ag-hidden', toggleValue);
    }
    clearSearchString() {
        this.searchString = '';
    }
    setValue(value, silent, fromPicker, skipRendering) {
        if (this.value === value) {
            return this;
        }
        const isArray = Array.isArray(value);
        if (value != null) {
            if (!isArray) {
                const list = this.listComponent?.getCurrentList();
                const index = list ? list.indexOf(value) : -1;
                if (index === -1) {
                    return this;
                }
            }
            if (!fromPicker) {
                this.listComponent?.selectValue(value);
            }
        }
        super.setValue(value, silent);
        if (!skipRendering) {
            this.renderSelectedValue();
        }
        return this;
    }
    onNavigationKeyDown(event, key, announceItem) {
        // if we don't preventDefault the page body and/or grid scroll will move.
        event.preventDefault();
        const isDown = key === ag_grid_community_1.KeyCode.DOWN;
        if (!this.isPickerDisplayed && isDown) {
            this.showPicker();
            return;
        }
        this.listComponent?.onNavigationKeyDown(key, announceItem);
    }
    onEnterKeyDown(e) {
        if (!this.isPickerDisplayed) {
            return;
        }
        e.preventDefault();
        if (this.listComponent?.getCurrentList()) {
            const lastRowHovered = this.listComponent.getLastItemHovered();
            if (this.config.multiSelect || lastRowHovered == null) {
                this.dispatchPickerEventAndHidePicker(this.value, true);
            }
            else {
                this.onListValueSelected(new Set([lastRowHovered]), true);
            }
        }
    }
    onDeleteKeyDown(e) {
        const { eWrapper, beans } = this;
        const activeEl = (0, ag_grid_community_1._getActiveDomElement)(beans);
        if (activeEl === eWrapper) {
            e.preventDefault();
            this.setValue([], true);
        }
    }
    onTabKeyDown() {
        const { config, isPickerDisplayed, listComponent } = this;
        const { multiSelect } = config;
        if (!isPickerDisplayed || !listComponent) {
            return;
        }
        if (multiSelect) {
            const values = this.getValueFromSet(listComponent.getSelectedItems());
            if (values) {
                this.setValue(values, false, true, true);
            }
        }
        else {
            this.setValue(listComponent.getLastItemHovered(), false, true);
        }
        this.hidePicker();
    }
    getValueFromSet(valueSet) {
        const { multiSelect } = this.config;
        let newValue = null;
        for (const value of valueSet) {
            if (valueSet.size === 1 && !multiSelect) {
                newValue = value;
                break;
            }
            if (!newValue) {
                newValue = [];
            }
            newValue.push(value);
        }
        if (Array.isArray(newValue)) {
            newValue.sort();
        }
        return newValue;
    }
    onListValueSelected(valueSet, fromEnterKey) {
        const newValue = this.getValueFromSet(valueSet);
        this.setValue(newValue, false, true);
        if (!this.config.multiSelect) {
            this.dispatchPickerEventAndHidePicker(newValue, fromEnterKey);
        }
    }
    dispatchPickerEventAndHidePicker(value, fromEnterKey) {
        const event = {
            type: 'fieldPickerValueSelected',
            fromEnterKey,
            value,
        };
        this.dispatchLocalEvent(event);
        this.hidePicker();
    }
    getFocusableElement() {
        const { allowTyping } = this.config;
        if (allowTyping) {
            return this.eInput.getFocusableElement();
        }
        return super.getFocusableElement();
    }
    onKeyDown(e) {
        const { key } = e;
        const { isPickerDisplayed, config, listComponent, pickerComponent } = this;
        const { allowTyping, multiSelect, suppressDeselectAll } = config;
        switch (key) {
            case ag_grid_community_1.KeyCode.LEFT:
            case ag_grid_community_1.KeyCode.RIGHT:
                if (!allowTyping || this.pillContainer) {
                    e.preventDefault();
                    if (this.pillContainer) {
                        this.listComponent?.highlightIndex(-1);
                        this.pillContainer.onNavigationKeyDown(e);
                    }
                }
                break;
            case ag_grid_community_1.KeyCode.PAGE_HOME:
            case ag_grid_community_1.KeyCode.PAGE_END:
                if (allowTyping) {
                    e.preventDefault();
                    const inputEl = this.eInput.getInputElement();
                    const target = key === ag_grid_community_1.KeyCode.PAGE_HOME ? 0 : inputEl.value.length;
                    inputEl.setSelectionRange(target, target);
                    break;
                }
            // Only break here for allowTyping, otherwise use the same logic as PageUp/PageDown
            // eslint-disable-next-line
            case ag_grid_community_1.KeyCode.PAGE_UP:
            case ag_grid_community_1.KeyCode.PAGE_DOWN:
                e.preventDefault();
                if (pickerComponent) {
                    listComponent?.navigateToPage(key);
                }
                break;
            case ag_grid_community_1.KeyCode.DOWN:
            case ag_grid_community_1.KeyCode.UP:
                this.onNavigationKeyDown(e, key, () => {
                    if (multiSelect) {
                        this.doWhileBlockingAnnouncement(() => this.eWrapper.focus());
                        this.announceAriaValue(this.ariaToggleSelection);
                    }
                });
                break;
            case ag_grid_community_1.KeyCode.ESCAPE:
                if (isPickerDisplayed) {
                    if ((0, ag_grid_community_1._isVisible)(this.listComponent.getGui())) {
                        e.preventDefault();
                        (0, ag_grid_community_1._stopPropagationForAgGrid)(e);
                    }
                    this.hidePicker();
                }
                break;
            case ag_grid_community_1.KeyCode.ENTER:
                this.onEnterKeyDown(e);
                break;
            case ag_grid_community_1.KeyCode.SPACE:
                if (isPickerDisplayed && multiSelect && listComponent) {
                    e.preventDefault();
                    const lastItemHovered = listComponent.getLastItemHovered();
                    if (lastItemHovered) {
                        listComponent.toggleListItemSelection(lastItemHovered);
                    }
                }
                break;
            case ag_grid_community_1.KeyCode.TAB:
                this.onTabKeyDown();
                break;
            case ag_grid_community_1.KeyCode.DELETE:
                if (multiSelect && !suppressDeselectAll) {
                    this.onDeleteKeyDown(e);
                }
                break;
            default:
                if (!allowTyping) {
                    this.buildSearchStringFromKeyboardEvent(e);
                }
        }
    }
    announceAriaValue(value) {
        this.ariaAnnounce?.announceValue(value, 'richSelect');
    }
    destroy() {
        if (this.listComponent) {
            this.listComponent = this.destroyBean(this.listComponent);
        }
        super.destroy();
    }
}
exports.AgRichSelect = AgRichSelect;


/***/ }),

/***/ 5805:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgRichSelectList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const agRichSelectRow_1 = __webpack_require__(7793);
const virtualList_1 = __webpack_require__(7904);
const LIST_COMPONENT_NAME = 'ag-rich-select-list';
const ROW_COMPONENT_NAME = 'ag-rich-select-row';
class AgRichSelectList extends virtualList_1.VirtualList {
    constructor(params, richSelectWrapper, getSearchString) {
        super({ cssIdentifier: 'rich-select' });
        this.params = params;
        this.richSelectWrapper = richSelectWrapper;
        this.getSearchString = getSearchString;
        this.lastRowHovered = -1;
        this.selectedItems = new Set();
        this.params = params;
        this.setComponentCreator(this.createRowComponent.bind(this));
        /* nothing to update but method required to soft refresh */
        this.setComponentUpdater(() => { });
    }
    postConstruct() {
        super.postConstruct();
        this.createLoadingElement();
        const { cellRowHeight, pickerAriaLabelKey, pickerAriaLabelValue } = this.params;
        if (cellRowHeight) {
            this.setRowHeight(cellRowHeight);
        }
        const eGui = this.getGui();
        const eListAriaEl = this.getAriaElement();
        this.addManagedListeners(eGui, {
            mousemove: this.onMouseMove.bind(this),
            mouseout: this.onMouseOut.bind(this),
            mousedown: this.onMouseDown.bind(this),
            click: this.onClick.bind(this),
        });
        eGui.classList.add(LIST_COMPONENT_NAME);
        const listId = `${LIST_COMPONENT_NAME}-${this.getCompId()}`;
        eListAriaEl.setAttribute('id', listId);
        const translate = this.getLocaleTextFunc();
        const ariaLabel = translate(pickerAriaLabelKey, pickerAriaLabelValue);
        (0, ag_grid_community_1._setAriaLabel)(eListAriaEl, ariaLabel);
        (0, ag_grid_community_1._setAriaControls)(this.richSelectWrapper, eListAriaEl);
    }
    navigateToPage(key) {
        const newIndex = super.navigateToPage(key, this.lastRowHovered);
        if (newIndex != null) {
            (0, ag_grid_community_1._requestAnimationFrame)(this.beans, () => {
                if (!this.isAlive()) {
                    return null;
                }
                this.highlightIndex(newIndex);
            });
        }
        return newIndex;
    }
    drawVirtualRows(softRefresh) {
        super.drawVirtualRows(softRefresh);
        this.refreshSelectedItems();
    }
    highlightFilterMatch(searchString) {
        this.forEachRenderedRow((cmp) => {
            cmp.highlightString(searchString);
        });
    }
    onNavigationKeyDown(key, announceItem) {
        (0, ag_grid_community_1._requestAnimationFrame)(this.beans, () => {
            if (!this.currentList || !this.isAlive()) {
                return;
            }
            const len = this.currentList.length;
            const oldIndex = this.lastRowHovered;
            const diff = key === ag_grid_community_1.KeyCode.DOWN ? 1 : -1;
            const newIndex = Math.min(Math.max(oldIndex === -1 ? 0 : oldIndex + diff, 0), len - 1);
            this.highlightIndex(newIndex);
            announceItem();
        });
    }
    selectValue(value) {
        if (!this.currentList) {
            if (this.eLoading) {
                this.appendChild(this.eLoading);
            }
            return false;
        }
        if (this.eLoading?.offsetParent) {
            this.eLoading.parentElement?.removeChild(this.eLoading);
        }
        if (value == null) {
            return false;
        }
        const selectedPositions = this.getIndicesForValues(value);
        const refresh = selectedPositions.length > 0;
        if (refresh) {
            // make sure the virtual list has been sized correctly
            this.refresh();
            this.ensureIndexVisible(selectedPositions[0]);
            // this second call to refresh is necessary to force scrolled elements
            // to be rendered with the correct index info.
            this.refresh(true);
        }
        this.selectListItems(Array.isArray(value) ? value : [value]);
        return refresh;
    }
    selectListItems(values, append = false) {
        if (!append) {
            this.selectedItems.clear();
        }
        for (let i = 0; i < values.length; i++) {
            const currentItem = values[i];
            if (this.selectedItems.has(currentItem)) {
                continue;
            }
            this.selectedItems.add(currentItem);
        }
        this.refreshSelectedItems();
    }
    getCurrentList() {
        return this.currentList;
    }
    setCurrentList(list) {
        this.currentList = list;
        this.setModel({
            getRowCount: () => list.length,
            getRow: (index) => list[index],
            areRowsEqual: (oldRow, newRow) => oldRow === newRow,
        });
    }
    getSelectedItems() {
        return this.selectedItems;
    }
    getLastItemHovered() {
        return this.currentList[this.lastRowHovered];
    }
    highlightIndex(index, preventUnnecessaryScroll) {
        if (!this.currentList) {
            return;
        }
        if (index < 0 || index >= this.currentList.length) {
            this.lastRowHovered = -1;
        }
        else {
            this.lastRowHovered = index;
            const wasScrolled = this.ensureIndexVisible(index, !preventUnnecessaryScroll);
            if (wasScrolled && !preventUnnecessaryScroll) {
                this.refresh(true);
            }
        }
        this.forEachRenderedRow((cmp, idx) => {
            const highlighted = index === idx;
            cmp.toggleHighlighted(highlighted);
            if (highlighted) {
                const idForParent = `${ROW_COMPONENT_NAME}-${cmp.getCompId()}`;
                (0, ag_grid_community_1._setAriaActiveDescendant)(this.richSelectWrapper, idForParent);
                this.richSelectWrapper.setAttribute('data-active-option', idForParent);
            }
        });
    }
    getIndicesForValues(values) {
        const { currentList } = this;
        if (!currentList || currentList.length === 0 || values == null) {
            return [];
        }
        if (!Array.isArray(values)) {
            values = [values];
        }
        if (values.length === 0) {
            return [];
        }
        const positions = [];
        for (let i = 0; i < values.length; i++) {
            const idx = currentList.indexOf(values[i]);
            if (idx >= 0) {
                positions.push(idx);
            }
        }
        return positions;
    }
    toggleListItemSelection(value) {
        if (this.selectedItems.has(value)) {
            this.selectedItems.delete(value);
        }
        else {
            this.selectedItems.add(value);
        }
        this.refreshSelectedItems();
        this.dispatchValueSelected();
    }
    refreshSelectedItems() {
        this.forEachRenderedRow((cmp) => {
            const selected = this.selectedItems.has(cmp.getValue());
            cmp.updateSelected(selected);
        });
    }
    createLoadingElement() {
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        const translate = this.getLocaleTextFunc();
        const el = eDocument.createElement('div');
        el.classList.add('ag-loading-text');
        el.innerText = translate('loadingOoo', 'Loading...');
        this.eLoading = el;
    }
    createRowComponent(value, listItemElement) {
        const row = new agRichSelectRow_1.RichSelectRow(this.params);
        listItemElement.setAttribute('id', `${ROW_COMPONENT_NAME}-${row.getCompId()}`);
        row.setParentComponent(this);
        this.createBean(row);
        row.setState(value);
        const { highlightMatch, searchType = 'fuzzy' } = this.params;
        if (highlightMatch && searchType !== 'fuzzy') {
            row.highlightString(this.getSearchString());
        }
        return row;
    }
    getRowForMouseEvent(e) {
        const eGui = this.getGui();
        const rect = eGui.getBoundingClientRect();
        const scrollTop = this.getScrollTop();
        const mouseY = e.clientY - rect.top + scrollTop;
        return Math.floor(mouseY / this.getRowHeight());
    }
    onMouseMove(e) {
        const row = this.getRowForMouseEvent(e);
        if (row !== -1 && row != this.lastRowHovered) {
            this.lastRowHovered = row;
            this.highlightIndex(row, true);
        }
    }
    onMouseDown(e) {
        // this prevents the list from receiving focus as it
        // should be controlled by the agRichSelect component
        e.preventDefault();
    }
    onMouseOut(e) {
        if (!this.getGui().contains(e.relatedTarget)) {
            this.highlightIndex(-1);
        }
    }
    onClick(e) {
        const { multiSelect } = this.params;
        if (!this.currentList) {
            return;
        }
        const row = this.getRowForMouseEvent(e);
        const item = this.currentList[row];
        if (multiSelect) {
            this.toggleListItemSelection(item);
        }
        else {
            this.selectListItems([item]);
            this.dispatchValueSelected();
        }
    }
    dispatchValueSelected() {
        this.dispatchLocalEvent({
            type: 'richSelectListRowSelected',
            fromEnterKey: false,
            value: this.selectedItems,
        });
    }
    destroy() {
        super.destroy();
        this.eLoading = undefined;
    }
}
exports.AgRichSelectList = AgRichSelectList;


/***/ }),

/***/ 7793:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RichSelectRow = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class RichSelectRow extends ag_grid_community_1.Component {
    wireBeans(beans) {
        this.userCompFactory = beans.userCompFactory;
        this.registry = beans.registry;
    }
    constructor(params) {
        super(/* html */ `<div class="ag-rich-select-row" role="presentation"></div>`);
        this.params = params;
    }
    postConstruct() {
        this.tooltipFeature = this.createOptionalManagedBean(this.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
            shouldDisplayTooltip: () => this.shouldDisplayTooltip?.() ?? true,
        }));
    }
    setState(value) {
        let formattedValue = '';
        const { params } = this;
        if (params.valueFormatter) {
            formattedValue = params.valueFormatter(value);
        }
        const rendererSuccessful = this.populateWithRenderer(value, formattedValue);
        if (!rendererSuccessful) {
            this.populateWithoutRenderer(value, formattedValue);
        }
        this.value = value;
    }
    highlightString(matchString) {
        const { parsedValue } = this;
        if (this.params.cellRenderer || !(0, ag_grid_community_1._exists)(parsedValue)) {
            return;
        }
        let hasMatch = (0, ag_grid_community_1._exists)(matchString);
        if (hasMatch) {
            const index = parsedValue?.toLocaleLowerCase().indexOf(matchString.toLocaleLowerCase());
            if (index >= 0) {
                const highlightEndIndex = index + matchString.length;
                const startPart = (0, ag_grid_community_1._escapeString)(parsedValue.slice(0, index), true);
                const highlightedPart = (0, ag_grid_community_1._escapeString)(parsedValue.slice(index, highlightEndIndex), true);
                const endPart = (0, ag_grid_community_1._escapeString)(parsedValue.slice(highlightEndIndex));
                this.renderValueWithoutRenderer(
                /* html */ `${startPart}<span class="ag-rich-select-row-text-highlight">${highlightedPart}</span>${endPart}`);
            }
            else {
                hasMatch = false;
            }
        }
        if (!hasMatch) {
            this.renderValueWithoutRenderer(parsedValue);
        }
    }
    updateSelected(selected) {
        const eGui = this.getGui();
        (0, ag_grid_community_1._setAriaSelected)(eGui.parentElement, selected);
        this.addOrRemoveCssClass('ag-rich-select-row-selected', selected);
    }
    getValue() {
        return this.value;
    }
    toggleHighlighted(highlighted) {
        this.addOrRemoveCssClass('ag-rich-select-row-highlighted', highlighted);
    }
    populateWithoutRenderer(value, valueFormatted) {
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        const eGui = this.getGui();
        const span = eDocument.createElement('span');
        span.style.overflow = 'hidden';
        span.style.textOverflow = 'ellipsis';
        const parsedValue = (0, ag_grid_community_1._escapeString)((0, ag_grid_community_1._exists)(valueFormatted) ? valueFormatted : value, true);
        this.parsedValue = (0, ag_grid_community_1._exists)(parsedValue) ? parsedValue : null;
        eGui.appendChild(span);
        this.renderValueWithoutRenderer(parsedValue);
        this.shouldDisplayTooltip = (0, ag_grid_community_1._shouldDisplayTooltip)(() => span);
        this.tooltipFeature?.setTooltipAndRefresh(this.parsedValue);
    }
    renderValueWithoutRenderer(value) {
        const span = this.getGui().querySelector('span');
        if (!span) {
            return;
        }
        span.innerHTML = (0, ag_grid_community_1._exists)(value) ? value : '&nbsp;';
    }
    populateWithRenderer(value, valueFormatted) {
        // bad coder here - we are not populating all values of the cellRendererParams
        let cellRendererPromise;
        let userCompDetails;
        if (this.params.cellRenderer) {
            const richSelect = this.getParentComponent()?.getParentComponent();
            userCompDetails = (0, ag_grid_community_1._getEditorRendererDetails)(this.userCompFactory, this.params, {
                value,
                valueFormatted,
                getValue: () => richSelect?.getValue(),
                setValue: (value) => {
                    richSelect?.setValue(value, true);
                },
                setTooltip: (value, shouldDisplayTooltip) => {
                    this.gos.assertModuleRegistered('Tooltip', 3);
                    this.shouldDisplayTooltip = shouldDisplayTooltip;
                    this.tooltipFeature?.setTooltipAndRefresh(value);
                },
            });
        }
        if (userCompDetails) {
            cellRendererPromise = userCompDetails.newAgStackInstance();
        }
        if (cellRendererPromise) {
            (0, ag_grid_community_1._bindCellRendererToHtmlElement)(cellRendererPromise, this.getGui());
        }
        if (cellRendererPromise) {
            cellRendererPromise.then((childComponent) => {
                this.addDestroyFunc(() => {
                    this.destroyBean(childComponent);
                });
            });
            return true;
        }
        return false;
    }
}
exports.RichSelectRow = RichSelectRow;


/***/ }),

/***/ 7685:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.menuCSS = void 0;
exports.menuCSS = `.ag-menu-list{cursor:default;display:table;padding:var(--ag-spacing) 0;width:100%}.ag-menu-option,.ag-menu-separator{display:table-row}.ag-menu-option-part,.ag-menu-separator-part{display:table-cell;vertical-align:middle}.ag-menu-option{cursor:pointer;font-weight:500}:where(.ag-ltr) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:right}:where(.ag-rtl) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:left}.ag-menu-option-text{white-space:nowrap}.ag-menu-option-custom{display:contents}.ag-compact-menu-option{display:flex;flex-wrap:nowrap;width:100%}.ag-compact-menu-option-text{flex:1 1 auto;white-space:nowrap}.ag-menu-separator{height:calc(var(--ag-spacing)*2 + 1px)}.ag-menu-separator-part:after{border-top:1px solid var(--ag-menu-separator-color);content:"";display:block}.ag-compact-menu-option-active,.ag-menu-option-active{background-color:var(--ag-row-hover-color)}.ag-compact-menu-option-part,.ag-menu-option-part{line-height:var(--ag-icon-size);padding:calc(var(--ag-spacing) + 2px) 0}.ag-compact-menu-option-disabled,.ag-menu-option-disabled{cursor:not-allowed;opacity:.5}.ag-compact-menu-option-icon,.ag-menu-option-icon{width:var(--ag-icon-size)}:where(.ag-ltr) .ag-compact-menu-option-icon,:where(.ag-ltr) .ag-menu-option-icon{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-compact-menu-option-icon,:where(.ag-rtl) .ag-menu-option-icon{padding-right:calc(var(--ag-spacing)*2)}.ag-compact-menu-option-text,.ag-menu-option-text{padding-left:calc(var(--ag-spacing)*2);padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-compact-menu-option-shortcut,:where(.ag-ltr) .ag-menu-option-shortcut{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-shortcut,:where(.ag-rtl) .ag-menu-option-shortcut{padding-left:var(--ag-spacing)}:where(.ag-ltr) .ag-compact-menu-option-popup-pointer,:where(.ag-ltr) .ag-menu-option-popup-pointer{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-popup-pointer,:where(.ag-rtl) .ag-menu-option-popup-pointer{padding-left:var(--ag-spacing)}.ag-menu-column-select-wrapper{height:265px;overflow:auto;:where(.ag-column-select){height:100%}}.ag-menu:where(.ag-tabs){min-width:290px}.ag-context-menu-loading-icon{pointer-events:none;position:absolute}`;


/***/ }),

/***/ 3375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuItemModule = void 0;
const version_1 = __webpack_require__(7205);
const agMenuItemRenderer_1 = __webpack_require__(3360);
const menu_css_GENERATED_1 = __webpack_require__(7685);
/**
 * @internal
 */
exports.MenuItemModule = {
    moduleName: 'MenuItem',
    version: version_1.VERSION,
    userComponents: {
        agMenuItem: agMenuItemRenderer_1.AgMenuItemRenderer,
    },
    icons: {
        // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
        check: 'tick',
        // icon for sub menu item
        subMenuOpen: 'small-right',
        // version of subMenuOpen used in RTL mode
        subMenuOpenRtl: 'small-left',
    },
    css: [menu_css_GENERATED_1.menuCSS],
};


/***/ }),

/***/ 3173:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PillDragComp = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
class PillDragComp extends ag_grid_community_1.Component {
    constructor(dragSourceDropTarget, ghost, horizontal, template, agComponents) {
        super();
        this.dragSourceDropTarget = dragSourceDropTarget;
        this.ghost = ghost;
        this.horizontal = horizontal;
        this.template = template;
        this.agComponents = agComponents;
        this.eText = ag_grid_community_1.RefPlaceholder;
        this.eDragHandle = ag_grid_community_1.RefPlaceholder;
        this.eButton = ag_grid_community_1.RefPlaceholder;
    }
    postConstruct() {
        this.setTemplate(this.template ??
            /* html */ `
            <span role="option">
              <span data-ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
              <span data-ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
              <span data-ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
            </span>`, this.agComponents);
        const eGui = this.getGui();
        const { beans, eDragHandle, eText, eButton } = this;
        this.addElementClasses(eGui);
        this.addElementClasses(eDragHandle, 'drag-handle');
        this.addElementClasses(eText, 'text');
        this.addElementClasses(eButton, 'button');
        eDragHandle.appendChild((0, ag_grid_community_1._createIconNoSpan)('columnDrag', beans));
        eButton.appendChild((0, ag_grid_community_1._createIconNoSpan)('cancel', beans));
        this.tooltipFeature = this.createOptionalManagedBean(beans.registry.createDynamicBean('tooltipFeature', false, {
            getGui: () => this.getGui(),
        }));
        this.setupComponents();
        if (!this.ghost && this.isDraggable()) {
            this.addDragSource();
        }
        this.setupAria();
        this.setupTooltip();
        this.activateTabIndex();
        this.refreshDraggable();
    }
    isDraggable() {
        return true;
    }
    refreshDraggable() {
        this.eDragHandle.classList.toggle('ag-column-select-column-readonly', !this.isDraggable());
    }
    setupAria() {
        const translate = this.getLocaleTextFunc();
        const ariaInstructions = [this.getAriaDisplayName()];
        this.addAdditionalAriaInstructions(ariaInstructions, translate);
        (0, ag_grid_community_1._setAriaLabel)(this.getGui(), ariaInstructions.join('. '));
    }
    addAdditionalAriaInstructions(ariaInstructions, translate) {
        if (this.isRemovable()) {
            const deleteAria = translate('ariaDropZoneColumnComponentDescription', 'Press DELETE to remove');
            ariaInstructions.push(deleteAria);
        }
    }
    setupTooltip() {
        const refresh = () => this.tooltipFeature?.setTooltipAndRefresh(this.getTooltip());
        refresh();
        this.addManagedEventListeners({ newColumnsLoaded: refresh });
    }
    getDragSourceId() {
        return undefined;
    }
    getDefaultIconName() {
        return 'notAllowed';
    }
    addDragSource() {
        const { beans: { dragAndDrop }, eDragHandle, } = this;
        const getDragItem = this.createGetDragItem();
        const defaultIconName = this.getDefaultIconName();
        const dragSource = {
            type: this.getDragSourceType(),
            sourceId: this.getDragSourceId(),
            eElement: eDragHandle,
            getDefaultIconName: () => defaultIconName,
            getDragItem,
            dragItemName: this.getDisplayName(),
        };
        dragAndDrop?.addDragSource(dragSource, true);
        this.addDestroyFunc(() => dragAndDrop?.removeDragSource(dragSource));
    }
    setupComponents() {
        this.setTextValue();
        this.setupRemove();
        if (this.ghost) {
            this.addCssClass('ag-column-drop-cell-ghost');
        }
    }
    isRemovable() {
        return true;
    }
    refreshRemove() {
        (0, ag_grid_community_1._setDisplayed)(this.eButton, this.isRemovable());
    }
    setupRemove() {
        this.refreshRemove();
        const agEvent = { type: 'columnRemove' };
        this.addGuiEventListener('keydown', (e) => this.onKeyDown(e));
        this.addManagedElementListeners(this.eButton, {
            click: (mouseEvent) => {
                this.dispatchLocalEvent(agEvent);
                mouseEvent.stopPropagation();
            },
        });
        const touchListener = new ag_grid_community_1.TouchListener(this.eButton);
        this.addManagedListeners(touchListener, {
            tap: () => this.dispatchLocalEvent(agEvent),
        });
        this.addDestroyFunc(touchListener.destroy.bind(touchListener));
    }
    onKeyDown(e) {
        const isDelete = e.key === ag_grid_community_1.KeyCode.DELETE;
        if (isDelete) {
            if (this.isRemovable()) {
                e.preventDefault();
                this.dispatchLocalEvent({ type: 'columnRemove' });
            }
        }
    }
    getDisplayValue() {
        return this.getDisplayName();
    }
    setTextValue() {
        const displayValue = this.getDisplayValue();
        const displayValueSanitised = (0, ag_grid_community_1._escapeString)(displayValue);
        this.eText.innerHTML = displayValueSanitised;
    }
    addElementClasses(el, suffix) {
        suffix = suffix ? `-${suffix}` : '';
        const direction = this.horizontal ? 'horizontal' : 'vertical';
        el.classList.add(`ag-column-drop-cell${suffix}`, `ag-column-drop-${direction}-cell${suffix}`);
    }
    destroy() {
        super.destroy();
        this.dragSourceDropTarget = null;
    }
}
exports.PillDragComp = PillDragComp;


/***/ }),

/***/ 7496:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pillDropZonePanelCSS = void 0;
exports.pillDropZonePanelCSS = `.ag-column-drop{align-items:center;display:inline-flex;overflow:auto;position:relative;width:100%}.ag-column-drop-list{align-items:center;display:flex}.ag-column-drop-cell{align-items:center;background-color:var(--ag-column-drop-cell-background-color);border:var(--ag-column-drop-cell-border);border-radius:500px;color:var(--ag-column-drop-cell-text-color);display:flex;padding:calc(var(--ag-spacing)*.25);position:relative;&:focus-visible{box-shadow:var(--ag-focus-shadow)}:where(.ag-drag-handle){color:var(--ag-column-drop-cell-drag-handle-color)}}:where(.ag-ltr) .ag-column-drop-cell{padding-left:calc(var(--ag-spacing)*.75)}:where(.ag-rtl) .ag-column-drop-cell{padding-right:calc(var(--ag-spacing)*.75)}.ag-column-drop-cell-text{flex:1 1 auto;margin:0 var(--ag-spacing);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-drop-vertical{align-items:stretch;display:flex;flex-direction:column;min-height:75px;overflow:hidden}.ag-column-drop-vertical-title-bar{align-items:center;display:flex;flex:none;padding:var(--ag-widget-container-vertical-padding) calc(var(--ag-spacing)*2) 0}.ag-column-drop-vertical-list{align-items:stretch;flex-direction:column;flex-grow:1;overflow-x:auto;padding-bottom:var(--ag-spacing);padding-left:var(--ag-spacing);padding-right:var(--ag-spacing);position:relative;>*{flex:none}}:where(.ag-column-drop-empty) .ag-column-drop-vertical-list{overflow:hidden}.ag-column-drop-vertical-empty-message{align-items:center;border:1px dashed;border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}.ag-column-drop-cell-button{cursor:pointer;min-width:0;opacity:.75;&:hover{opacity:1}}.ag-column-drop-wrapper{display:flex}.ag-column-drop-horizontal-half-width{width:50%!important}.ag-column-drop-cell-ghost{opacity:.5}.ag-column-drop-horizontal{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;white-space:nowrap}:where(.ag-ltr) .ag-column-drop-horizontal{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-column-drop-horizontal{padding-right:var(--ag-cell-horizontal-padding)}.ag-column-drop-horizontal-list{gap:var(--ag-cell-widget-spacing)}.ag-column-drop-vertical-cell{margin-top:var(--ag-spacing)}:where(.ag-ltr) .ag-column-drop-vertical-icon{margin-right:var(--ag-widget-horizontal-spacing)}:where(.ag-rtl) .ag-column-drop-vertical-icon{margin-left:var(--ag-widget-horizontal-spacing)}.ag-select-agg-func-popup{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);height:calc(var(--ag-spacing)*5*3.5);padding:0;position:absolute}.ag-select-agg-func-virtual-list-item{cursor:default;&:hover{background-color:var(--ag-selected-row-background-color)}}:where(.ag-ltr) .ag-select-agg-func-virtual-list-item{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-select-agg-func-virtual-list-item{padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-left:1px solid var(--ag-border-color)}`;


/***/ }),

/***/ 9733:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PillDropZonePanel = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const pillDropZonePanel_css_GENERATED_1 = __webpack_require__(7496);
function _insertArrayIntoArray(dest, src, toIndex) {
    if (dest == null || src == null) {
        return;
    }
    dest.splice(toIndex, 0, ...src);
}
class PillDropZonePanel extends ag_grid_community_1.Component {
    constructor(horizontal) {
        super(/* html */ `<div class="ag-unselectable" role="presentation"></div>`);
        this.horizontal = horizontal;
        this.state = 'notDragging';
        this.guiDestroyFunctions = [];
        this.childPillComponents = [];
        this.resizeEnabled = false;
        this.addElementClasses(this.getGui());
        this.ePillDropList = document.createElement('div');
        this.addElementClasses(this.ePillDropList, 'list');
        (0, ag_grid_community_1._setAriaRole)(this.ePillDropList, 'listbox');
        this.registerCSS(pillDropZonePanel_css_GENERATED_1.pillDropZonePanelCSS);
    }
    toggleResizable(resizable) {
        this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
        this.resizeEnabled = resizable;
    }
    isSourceEventFromTarget(draggingEvent) {
        const { dropZoneTarget, dragSource } = draggingEvent;
        return dropZoneTarget.contains(dragSource.eElement);
    }
    destroy() {
        this.destroyGui();
        super.destroy();
    }
    destroyGui() {
        this.guiDestroyFunctions.forEach((func) => func());
        this.guiDestroyFunctions.length = 0;
        this.childPillComponents.length = 0;
        (0, ag_grid_community_1._clearElement)(this.getGui());
        (0, ag_grid_community_1._clearElement)(this.ePillDropList);
    }
    init(params) {
        this.params = params ?? {};
        this.createManagedBean(new ag_grid_community_1.ManagedFocusFeature(this.getFocusableElement(), {
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.onKeyDown.bind(this),
        }));
        this.setupDropTarget();
        this.positionableFeature = new ag_grid_community_1.PositionableFeature(this.getGui());
        this.createManagedBean(this.positionableFeature);
        this.refreshGui();
        (0, ag_grid_community_1._setAriaLabel)(this.ePillDropList, this.getAriaLabel());
    }
    onTabKeyDown(e) {
        const focusableElements = (0, ag_grid_community_1._findFocusableElements)(this.getFocusableElement(), null, true);
        const len = focusableElements.length;
        if (len === 0) {
            return;
        }
        const { shiftKey } = e;
        const activeEl = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        const isFirstFocused = activeEl === focusableElements[0];
        const isLastFocused = activeEl === (0, ag_grid_community_1._last)(focusableElements);
        const shouldAllowDefaultTab = len === 1 || (isFirstFocused && shiftKey) || (isLastFocused && !shiftKey);
        if (!shouldAllowDefaultTab) {
            focusableElements[shiftKey ? 0 : len - 1].focus();
        }
    }
    onKeyDown(e) {
        const { key } = e;
        const isVertical = !this.horizontal;
        let isNext = key === ag_grid_community_1.KeyCode.DOWN;
        let isPrevious = key === ag_grid_community_1.KeyCode.UP;
        if (!isVertical) {
            const isRtl = this.gos.get('enableRtl');
            isNext = (!isRtl && key === ag_grid_community_1.KeyCode.RIGHT) || (isRtl && key === ag_grid_community_1.KeyCode.LEFT);
            isPrevious = (!isRtl && key === ag_grid_community_1.KeyCode.LEFT) || (isRtl && key === ag_grid_community_1.KeyCode.RIGHT);
        }
        if (!isNext && !isPrevious) {
            return;
        }
        const el = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, this.getFocusableElement(), false, isPrevious);
        if (el) {
            e.preventDefault();
            el.focus();
        }
    }
    addElementClasses(el, suffix) {
        suffix = suffix ? `-${suffix}` : '';
        const direction = this.horizontal ? 'horizontal' : 'vertical';
        el.classList.add(`ag-column-drop${suffix}`, `ag-column-drop-${direction}${suffix}`);
    }
    setupDropTarget() {
        this.dropTarget = {
            getContainer: this.getGui.bind(this),
            getIconName: this.getIconName.bind(this),
            onDragging: this.onDragging.bind(this),
            onDragEnter: this.onDragEnter.bind(this),
            onDragLeave: this.onDragLeave.bind(this),
            onDragStop: this.onDragStop.bind(this),
            onDragCancel: this.onDragCancel.bind(this),
            isInterestedIn: this.isInterestedIn.bind(this),
        };
        this.beans.dragAndDrop?.addDropTarget(this.dropTarget);
    }
    minimumAllowedNewInsertIndex() {
        return 0;
    }
    checkInsertIndex(draggingEvent) {
        const newIndex = this.getNewInsertIndex(draggingEvent);
        // <0 happens when drag is no a direction we are interested in, eg drag is up/down but in horizontal panel
        if (newIndex < 0) {
            return false;
        }
        const minimumAllowedIndex = this.minimumAllowedNewInsertIndex();
        const newAdjustedIndex = Math.max(minimumAllowedIndex, newIndex);
        const changed = newAdjustedIndex !== this.insertIndex;
        if (changed) {
            this.insertIndex = newAdjustedIndex;
        }
        return changed;
    }
    getNewInsertIndex(draggingEvent) {
        const mouseEvent = draggingEvent.event;
        const mouseLocation = this.horizontal ? mouseEvent.clientX : mouseEvent.clientY;
        const boundsList = this.childPillComponents.map((comp) => comp.getGui().getBoundingClientRect());
        // find the non-ghost component we're hovering
        const hoveredIndex = boundsList.findIndex((rect) => this.horizontal
            ? rect.right > mouseLocation && rect.left < mouseLocation
            : rect.top < mouseLocation && rect.bottom > mouseLocation);
        // not hovering a non-ghost component
        if (hoveredIndex === -1) {
            const enableRtl = this.gos.get('enableRtl');
            // if mouse is below or right of all components then new index should be placed last
            const isLast = boundsList.every((rect) => mouseLocation > (this.horizontal ? rect.right : rect.bottom));
            if (isLast) {
                return enableRtl && this.horizontal ? 0 : this.childPillComponents.length;
            }
            // if mouse is above or left of all components, new index is first
            const isFirst = boundsList.every((rect) => mouseLocation < (this.horizontal ? rect.left : rect.top));
            if (isFirst) {
                return enableRtl && this.horizontal ? this.childPillComponents.length : 0;
            }
            // must be hovering a ghost, don't change the index
            return this.insertIndex;
        }
        // if the old index is equal to or less than the index of our new target
        // we need to shift right, to insert after rather than before
        if (this.insertIndex <= hoveredIndex) {
            return hoveredIndex + 1;
        }
        return hoveredIndex;
    }
    checkDragStartedBySelf(draggingEvent) {
        if (this.state !== 'notDragging') {
            return;
        }
        this.state = 'rearrangeItems';
        this.potentialDndItems = this.getItems(draggingEvent.dragSource.getDragItem());
        this.refreshGui();
        this.checkInsertIndex(draggingEvent);
        this.refreshGui();
    }
    onDragging(draggingEvent) {
        this.checkDragStartedBySelf(draggingEvent);
        if (this.checkInsertIndex(draggingEvent)) {
            this.refreshGui();
        }
    }
    handleDragEnterEnd(_) { }
    onDragEnter(draggingEvent) {
        // this will contain all items that are potential drops
        const dragItems = this.getItems(draggingEvent.dragSource.getDragItem());
        this.state = 'newItemsIn';
        // take out items that are not droppable
        const goodDragItems = dragItems.filter((item) => this.isItemDroppable(item, draggingEvent));
        const alreadyPresent = goodDragItems.every((item) => this.childPillComponents.map((cmp) => cmp.getItem()).indexOf(item) !== -1);
        if (goodDragItems.length === 0) {
            return;
        }
        this.potentialDndItems = goodDragItems;
        if (alreadyPresent) {
            this.state = 'notDragging';
            return;
        }
        this.handleDragEnterEnd(draggingEvent);
        this.checkInsertIndex(draggingEvent);
        this.refreshGui();
    }
    isPotentialDndItems() {
        return !!this.potentialDndItems?.length;
    }
    handleDragLeaveEnd(_) { }
    onDragLeave(draggingEvent) {
        // if the dragging started from us, we remove the group, however if it started
        // some place else, then we don't, as it was only 'asking'
        if (this.state === 'rearrangeItems') {
            const items = this.getItems(draggingEvent.dragSource.getDragItem());
            this.removeItems(items);
        }
        if (this.isPotentialDndItems()) {
            this.handleDragLeaveEnd(draggingEvent);
            this.potentialDndItems = [];
            this.refreshGui();
        }
        this.state = 'notDragging';
    }
    onDragCancel(draggingEvent) {
        if (this.isPotentialDndItems()) {
            if (this.state === 'newItemsIn') {
                this.handleDragLeaveEnd(draggingEvent);
            }
            this.potentialDndItems = [];
            this.refreshGui();
        }
        this.state = 'notDragging';
    }
    onDragStop() {
        if (this.isPotentialDndItems()) {
            if (this.state === 'newItemsIn') {
                this.addItems(this.potentialDndItems);
            }
            else {
                this.rearrangeItems(this.potentialDndItems);
            }
            this.potentialDndItems = [];
            this.refreshGui();
        }
        this.state = 'notDragging';
    }
    removeItems(itemsToRemove) {
        const newItemList = this.getExistingItems().filter((item) => !itemsToRemove.includes(item));
        this.updateItems(newItemList);
    }
    addItems(itemsToAdd) {
        if (!itemsToAdd) {
            return;
        }
        const newItemList = this.getExistingItems().slice();
        const itemsToAddNoDuplicates = itemsToAdd.filter((item) => newItemList.indexOf(item) < 0);
        _insertArrayIntoArray(newItemList, itemsToAddNoDuplicates, this.insertIndex);
        this.updateItems(newItemList);
    }
    addItem(item) {
        this.insertIndex = this.getExistingItems().length;
        this.addItems([item]);
        this.refreshGui();
    }
    rearrangeItems(itemsToAdd) {
        const newItemList = this.getNonGhostItems().slice();
        _insertArrayIntoArray(newItemList, itemsToAdd, this.insertIndex);
        if ((0, ag_grid_community_1._areEqual)(newItemList, this.getExistingItems())) {
            return false;
        }
        this.updateItems(newItemList);
        return true;
    }
    refreshGui() {
        // we reset the scroll position after the refresh.
        // if we don't do this, then the list will always scroll to the top
        // each time we refresh it. this is because part of the refresh empties
        // out the list which sets scroll to zero. so the user could be just
        // reordering the list - we want to prevent the resetting of the scroll.
        // this is relevant for vertical display only (as horizontal has no scroll)
        const scrollTop = this.ePillDropList.scrollTop;
        const resizeEnabled = this.resizeEnabled;
        const focusedIndex = this.getFocusedItem();
        const { eGridDiv } = this.beans;
        let alternateElement = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, eGridDiv);
        if (!alternateElement) {
            alternateElement = (0, ag_grid_community_1._findNextFocusableElement)(this.beans, eGridDiv, false, true);
        }
        this.toggleResizable(false);
        this.destroyGui();
        this.addIconAndTitleToGui();
        this.addEmptyMessageToGui();
        this.addItemsToGui();
        if (!this.horizontal) {
            this.ePillDropList.scrollTop = scrollTop;
        }
        if (resizeEnabled) {
            this.toggleResizable(resizeEnabled);
        }
        // focus should only be restored when keyboard mode
        // otherwise mouse clicks will cause containers to scroll
        // without no apparent reason.
        if ((0, ag_grid_community_1._isKeyboardMode)()) {
            this.restoreFocus(focusedIndex, alternateElement);
        }
    }
    getFocusedItem() {
        const eGui = this.getGui();
        const activeElement = (0, ag_grid_community_1._getActiveDomElement)(this.beans);
        if (!eGui.contains(activeElement)) {
            return -1;
        }
        const items = Array.from(eGui.querySelectorAll('.ag-column-drop-cell'));
        return items.indexOf(activeElement);
    }
    restoreFocus(index, alternateElement) {
        const eGui = this.getGui();
        const items = Array.from(eGui.querySelectorAll('.ag-column-drop-cell'));
        if (index === -1) {
            return;
        }
        if (items.length === 0) {
            alternateElement.focus();
        }
        const indexToFocus = Math.min(items.length - 1, index);
        const el = items[indexToFocus];
        if (el) {
            el.focus();
        }
    }
    focusList(fromBottom) {
        const index = fromBottom ? this.childPillComponents.length - 1 : 0;
        this.restoreFocus(index, this.getFocusableElement());
    }
    getNonGhostItems() {
        const existingItems = this.getExistingItems();
        if (this.isPotentialDndItems()) {
            return existingItems.filter((item) => !this.potentialDndItems.includes(item));
        }
        return existingItems;
    }
    addItemsToGui() {
        const nonGhostItems = this.getNonGhostItems();
        const itemsToAddToGui = nonGhostItems.map((item) => this.createItemComponent(item, false));
        if (this.isPotentialDndItems()) {
            const dndItems = this.potentialDndItems.map((item) => this.createItemComponent(item, true));
            if (this.insertIndex >= itemsToAddToGui.length) {
                itemsToAddToGui.push(...dndItems);
            }
            else {
                itemsToAddToGui.splice(this.insertIndex, 0, ...dndItems);
            }
        }
        this.appendChild(this.ePillDropList);
        itemsToAddToGui.forEach((itemComponent, index) => {
            if (index > 0) {
                this.addArrow(this.ePillDropList);
            }
            this.ePillDropList.appendChild(itemComponent.getGui());
        });
        this.addAriaLabelsToComponents();
    }
    addAriaLabelsToComponents() {
        this.childPillComponents.forEach((comp, idx) => {
            const eGui = comp.getGui();
            (0, ag_grid_community_1._setAriaPosInSet)(eGui, idx + 1);
            (0, ag_grid_community_1._setAriaSetSize)(eGui, this.childPillComponents.length);
        });
    }
    createItemComponent(item, ghost) {
        const itemComponent = this.createPillComponent(item, this.dropTarget, ghost, this.horizontal);
        itemComponent.addEventListener('columnRemove', this.removeItems.bind(this, [item]));
        this.createBean(itemComponent);
        this.guiDestroyFunctions.push(() => this.destroyBean(itemComponent));
        if (!ghost) {
            this.childPillComponents.push(itemComponent);
        }
        return itemComponent;
    }
    addIconAndTitleToGui() {
        const { title, icon: eGroupIcon } = this.params;
        if (!title || !eGroupIcon) {
            return;
        }
        const eTitleBar = document.createElement('div');
        (0, ag_grid_community_1._setAriaHidden)(eTitleBar, true);
        this.addElementClasses(eTitleBar, 'title-bar');
        this.addElementClasses(eGroupIcon, 'icon');
        this.addOrRemoveCssClass('ag-column-drop-empty', this.isExistingItemsEmpty());
        eTitleBar.appendChild(eGroupIcon);
        if (!this.horizontal) {
            const eTitle = document.createElement('span');
            this.addElementClasses(eTitle, 'title');
            eTitle.innerHTML = title;
            eTitleBar.appendChild(eTitle);
        }
        this.appendChild(eTitleBar);
    }
    isExistingItemsEmpty() {
        return this.getExistingItems().length === 0;
    }
    addEmptyMessageToGui() {
        const { emptyMessage } = this.params;
        if (!emptyMessage || !this.isExistingItemsEmpty() || this.isPotentialDndItems()) {
            return;
        }
        const eMessage = document.createElement('span');
        eMessage.innerHTML = emptyMessage;
        this.addElementClasses(eMessage, 'empty-message');
        this.ePillDropList.appendChild(eMessage);
    }
    addArrow(eParent) {
        // only add the arrows if the layout is horizontal
        if (this.horizontal) {
            // for RTL it's a left arrow, otherwise it's a right arrow
            const enableRtl = this.gos.get('enableRtl');
            const icon = (0, ag_grid_community_1._createIconNoSpan)(enableRtl ? 'panelDelimiterRtl' : 'panelDelimiter', this.beans);
            this.addElementClasses(icon, 'cell-separator');
            eParent.appendChild(icon);
        }
    }
}
exports.PillDropZonePanel = PillDropZonePanel;


/***/ }),

/***/ 5875:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabbedLayout = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
const enterpriseFocusUtils_1 = __webpack_require__(6242);
function getTabbedLayoutTemplate(cssClass) {
    return /* html */ `<div class="ag-tabs ${cssClass}">
        <div data-ref="eHeader"></div>
        <div data-ref="eBody" role="presentation" class="ag-tabs-body ${cssClass ? `${cssClass}-body` : ''}"></div>
    </div>`;
}
class TabbedLayout extends ag_grid_community_1.TabGuardComp {
    constructor(params) {
        super(getTabbedLayoutTemplate(params.cssClass));
        this.eHeader = ag_grid_community_1.RefPlaceholder;
        this.eBody = ag_grid_community_1.RefPlaceholder;
        this.items = [];
        this.tabbedItemScrollMap = new Map();
        this.params = params;
    }
    postConstruct() {
        this.setupHeader();
        if (this.params.items) {
            this.params.items.forEach((item) => this.addItem(item));
        }
        this.initialiseTabGuard({
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            focusInnerElement: this.focusInnerElement.bind(this),
            focusTrapActive: true,
        });
        this.addDestroyFunc(() => this.activeItem?.tabbedItem?.afterDetachedCallback?.());
    }
    setupHeader() {
        const { enableCloseButton, cssClass } = this.params;
        const addCssClasses = (el, suffix) => {
            el.classList.add(`ag-tabs-${suffix}`);
            if (cssClass) {
                el.classList.add(`${cssClass}-${suffix}`);
            }
        };
        if (enableCloseButton) {
            this.setupCloseButton(addCssClasses);
            this.eTabHeader = (0, ag_grid_community_1._getDocument)(this.beans).createElement('div');
            addCssClasses(this.eHeader, 'header-wrapper');
            (0, ag_grid_community_1._setAriaRole)(this.eHeader, 'presentation');
            this.eHeader.appendChild(this.eTabHeader);
        }
        else {
            this.eTabHeader = this.eHeader;
        }
        (0, ag_grid_community_1._setAriaRole)(this.eTabHeader, 'tablist');
        addCssClasses(this.eTabHeader, 'header');
    }
    setupCloseButton(addCssClasses) {
        const eDocument = (0, ag_grid_community_1._getDocument)(this.beans);
        const eCloseButton = eDocument.createElement('button');
        addCssClasses(eCloseButton, 'close-button');
        const eIcon = (0, ag_grid_community_1._createIconNoSpan)('close', this.beans);
        (0, ag_grid_community_1._setAriaLabel)(eCloseButton, this.params.closeButtonAriaLabel);
        eCloseButton.appendChild(eIcon);
        this.addManagedElementListeners(eCloseButton, { click: () => this.params.onCloseClicked?.() });
        const eCloseButtonWrapper = eDocument.createElement('div');
        addCssClasses(eCloseButtonWrapper, 'close-button-wrapper');
        (0, ag_grid_community_1._setAriaRole)(eCloseButtonWrapper, 'presentation');
        eCloseButtonWrapper.appendChild(eCloseButton);
        this.eHeader.appendChild(eCloseButtonWrapper);
        this.eCloseButton = eCloseButton;
    }
    handleKeyDown(e) {
        switch (e.key) {
            case ag_grid_community_1.KeyCode.RIGHT:
            case ag_grid_community_1.KeyCode.LEFT: {
                if (!this.eTabHeader.contains((0, ag_grid_community_1._getActiveDomElement)(this.beans))) {
                    return;
                }
                const isRightKey = e.key === ag_grid_community_1.KeyCode.RIGHT;
                const isRtl = this.gos.get('enableRtl');
                const currentPosition = this.items.indexOf(this.activeItem);
                const nextPosition = isRightKey !== isRtl
                    ? Math.min(currentPosition + 1, this.items.length - 1)
                    : Math.max(currentPosition - 1, 0);
                if (currentPosition === nextPosition) {
                    return;
                }
                e.preventDefault();
                const nextItem = this.items[nextPosition];
                this.showItemWrapper(nextItem);
                nextItem.eHeaderButton.focus();
                break;
            }
            case ag_grid_community_1.KeyCode.UP:
            case ag_grid_community_1.KeyCode.DOWN:
                e.stopPropagation();
                break;
        }
    }
    onTabKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        const { beans, eHeader, eBody, activeItem, params } = this;
        const { suppressTrapFocus, enableCloseButton } = params;
        const activeElement = (0, ag_grid_community_1._getActiveDomElement)(beans);
        const target = e.target;
        const backwards = e.shiftKey;
        if (eHeader.contains(activeElement)) {
            e.preventDefault();
            if (enableCloseButton && backwards && !this.eCloseButton?.contains(activeElement)) {
                this.eCloseButton?.focus();
            }
            else if (suppressTrapFocus && backwards) {
                (0, enterpriseFocusUtils_1.findFocusableElementBeforeTabGuard)((0, ag_grid_community_1._getDocument)(beans).body, target)?.focus();
            }
            else {
                // focus is in header, move into body of popup
                this.focusBody(e.shiftKey);
            }
            return;
        }
        let nextEl = null;
        if ((0, enterpriseFocusUtils_1.isTargetUnderManagedComponent)(eBody, target)) {
            if (backwards) {
                nextEl = (0, enterpriseFocusUtils_1.findFocusableElementBeforeTabGuard)(eBody, target);
            }
            if (!nextEl && !suppressTrapFocus) {
                nextEl = activeItem.eHeaderButton;
            }
        }
        if (!nextEl && eBody.contains(activeElement)) {
            nextEl = (0, ag_grid_community_1._findNextFocusableElement)(beans, eBody, false, backwards);
            if (!nextEl) {
                if (suppressTrapFocus && !backwards) {
                    this.forceFocusOutOfContainer(backwards);
                }
                else if (enableCloseButton && !backwards) {
                    e.preventDefault();
                    this.eCloseButton?.focus();
                }
                else {
                    e.preventDefault();
                    this.focusHeader();
                }
                return;
            }
        }
        if (nextEl) {
            e.preventDefault();
            nextEl.focus();
        }
    }
    focusInnerElement(fromBottom) {
        if (fromBottom) {
            this.focusBody(true);
        }
        else {
            this.focusHeader();
        }
    }
    focusHeader(preventScroll) {
        this.activeItem.eHeaderButton.focus({ preventScroll });
    }
    focusBody(fromBottom) {
        (0, ag_grid_community_1._focusInto)(this.eBody, fromBottom);
    }
    setAfterAttachedParams(params) {
        this.afterAttachedParams = params;
    }
    showFirstItem() {
        if (this.items.length > 0) {
            this.showItemWrapper(this.items[0]);
        }
    }
    addItem(item) {
        const eHeaderButton = document.createElement('span');
        (0, ag_grid_community_1._setAriaRole)(eHeaderButton, 'tab');
        eHeaderButton.setAttribute('tabindex', '-1');
        eHeaderButton.appendChild(item.title);
        eHeaderButton.classList.add('ag-tab');
        this.eTabHeader.appendChild(eHeaderButton);
        (0, ag_grid_community_1._setAriaLabel)(eHeaderButton, item.titleLabel);
        const wrapper = {
            tabbedItem: item,
            eHeaderButton: eHeaderButton,
        };
        this.items.push(wrapper);
        eHeaderButton.addEventListener('click', this.showItemWrapper.bind(this, wrapper));
    }
    showItem(tabbedItem) {
        const itemWrapper = this.items.find((wrapper) => wrapper.tabbedItem === tabbedItem);
        if (itemWrapper) {
            this.showItemWrapper(itemWrapper);
        }
    }
    showItemWrapper(wrapper) {
        const { tabbedItem, eHeaderButton } = wrapper;
        this.params.onItemClicked?.({ item: tabbedItem });
        if (this.activeItem === wrapper) {
            this.params.onActiveItemClicked?.();
            return;
        }
        if (this.lastScrollListener) {
            this.lastScrollListener = this.lastScrollListener();
        }
        (0, ag_grid_community_1._clearElement)(this.eBody);
        tabbedItem.bodyPromise.then((body) => {
            this.eBody.appendChild(body);
            const onlyUnmanaged = !(0, ag_grid_community_1._isKeyboardMode)();
            if (!this.params.suppressFocusBodyOnOpen) {
                (0, ag_grid_community_1._focusInto)(this.eBody, false, onlyUnmanaged);
            }
            if (tabbedItem.afterAttachedCallback) {
                tabbedItem.afterAttachedCallback(this.afterAttachedParams);
            }
            if (this.params.keepScrollPosition) {
                const scrollableContainer = (tabbedItem.getScrollableContainer && tabbedItem.getScrollableContainer()) || body;
                [this.lastScrollListener] = this.addManagedElementListeners(scrollableContainer, {
                    scroll: () => {
                        this.tabbedItemScrollMap.set(tabbedItem.name, scrollableContainer.scrollTop);
                    },
                });
                const scrollPosition = this.tabbedItemScrollMap.get(tabbedItem.name);
                if (scrollPosition !== undefined) {
                    // Safari needs a small timeout or it will fire a scroll event to position 0
                    setTimeout(() => {
                        scrollableContainer.scrollTop = scrollPosition;
                    }, 0);
                }
            }
        });
        if (this.activeItem) {
            this.activeItem.eHeaderButton.classList.remove('ag-tab-selected');
            this.activeItem.tabbedItem.afterDetachedCallback?.();
        }
        eHeaderButton.classList.add('ag-tab-selected');
        this.activeItem = wrapper;
    }
}
exports.TabbedLayout = TabbedLayout;


/***/ }),

/***/ 7904:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VirtualList = void 0;
const ag_grid_community_1 = __webpack_require__(6624);
function getVirtualListTemplate(cssIdentifier) {
    return (
    /* html */
    `<div class="ag-virtual-list-viewport ag-${cssIdentifier}-virtual-list-viewport" role="presentation">
            <div class="ag-virtual-list-container ag-${cssIdentifier}-virtual-list-container" data-ref="eContainer"></div>
        </div>`);
}
class VirtualList extends ag_grid_community_1.TabGuardComp {
    wireBeans(beans) {
        this.environment = beans.environment;
    }
    constructor(params) {
        super(getVirtualListTemplate(params?.cssIdentifier || 'default'));
        this.renderedRows = new Map();
        this.rowHeight = 20;
        this.pageSize = -1;
        this.isScrolling = false;
        this.isHeightFromTheme = true;
        this.eContainer = ag_grid_community_1.RefPlaceholder;
        this.awaitStableCallbacks = [];
        const { cssIdentifier = 'default', ariaRole = 'listbox', listName } = params || {};
        this.cssIdentifier = cssIdentifier;
        this.ariaRole = ariaRole;
        this.listName = listName;
    }
    postConstruct() {
        this.addScrollListener();
        this.rowHeight = this.getItemHeight();
        this.addResizeObserver();
        this.initialiseTabGuard({
            onFocusIn: (e) => this.onFocusIn(e),
            onFocusOut: (e) => this.onFocusOut(e),
            focusInnerElement: (fromBottom) => this.focusInnerElement(fromBottom),
            onTabKeyDown: (e) => this.onTabKeyDown(e),
            handleKeyDown: (e) => this.handleKeyDown(e),
        });
        this.setAriaProperties();
        this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanged.bind(this) });
    }
    onGridStylesChanged(e) {
        if (e.listItemHeightChanged) {
            this.rowHeight = this.getItemHeight();
            this.refresh();
        }
    }
    setAriaProperties() {
        const translate = this.getLocaleTextFunc();
        const listName = translate('ariaDefaultListName', this.listName || 'List');
        const ariaEl = this.eContainer;
        (0, ag_grid_community_1._setAriaRole)(ariaEl, this.ariaRole);
        (0, ag_grid_community_1._setAriaLabel)(ariaEl, listName);
    }
    addResizeObserver() {
        // do this in an animation frame to prevent loops
        const listener = () => (0, ag_grid_community_1._requestAnimationFrame)(this.beans, () => this.drawVirtualRows());
        const destroyObserver = (0, ag_grid_community_1._observeResize)(this.beans, this.getGui(), listener);
        this.addDestroyFunc(destroyObserver);
    }
    focusInnerElement(fromBottom) {
        this.focusRow(fromBottom ? this.model.getRowCount() - 1 : 0);
    }
    onFocusIn(e) {
        const target = e.target;
        if (target.classList.contains('ag-virtual-list-item')) {
            this.lastFocusedRowIndex = (0, ag_grid_community_1._getAriaPosInSet)(target) - 1;
        }
    }
    onFocusOut(e) {
        if (!this.getFocusableElement().contains(e.relatedTarget)) {
            this.lastFocusedRowIndex = null;
        }
    }
    handleKeyDown(e) {
        switch (e.key) {
            case ag_grid_community_1.KeyCode.UP:
            case ag_grid_community_1.KeyCode.DOWN:
                e.preventDefault();
                this.navigate(e.key === ag_grid_community_1.KeyCode.UP);
                break;
            case ag_grid_community_1.KeyCode.PAGE_HOME:
            case ag_grid_community_1.KeyCode.PAGE_END:
            case ag_grid_community_1.KeyCode.PAGE_UP:
            case ag_grid_community_1.KeyCode.PAGE_DOWN:
                if (this.navigateToPage(e.key) !== null) {
                    e.preventDefault();
                }
                break;
        }
    }
    onTabKeyDown(e) {
        (0, ag_grid_community_1._stopPropagationForAgGrid)(e);
        this.forceFocusOutOfContainer(e.shiftKey);
    }
    navigate(up) {
        if (this.lastFocusedRowIndex == null) {
            return;
        }
        const nextRow = this.lastFocusedRowIndex + (up ? -1 : 1);
        if (nextRow < 0 || nextRow >= this.model.getRowCount()) {
            return;
        }
        this.focusRow(nextRow);
    }
    navigateToPage(key, fromItem = 'focused') {
        let hasFocus = false;
        if (fromItem === 'focused') {
            fromItem = this.getLastFocusedRow();
            hasFocus = true;
        }
        const rowCount = this.model.getRowCount() - 1;
        let newIndex = -1;
        if (key === ag_grid_community_1.KeyCode.PAGE_HOME) {
            newIndex = 0;
        }
        else if (key === ag_grid_community_1.KeyCode.PAGE_END) {
            newIndex = rowCount;
        }
        else if (key === ag_grid_community_1.KeyCode.PAGE_DOWN) {
            newIndex = Math.min(fromItem + this.pageSize, rowCount);
        }
        else if (key === ag_grid_community_1.KeyCode.PAGE_UP) {
            newIndex = Math.max(fromItem - this.pageSize, 0);
        }
        if (newIndex === -1) {
            return null;
        }
        if (hasFocus) {
            this.focusRow(newIndex);
        }
        else {
            this.ensureIndexVisible(newIndex);
        }
        return newIndex;
    }
    getLastFocusedRow() {
        return this.lastFocusedRowIndex;
    }
    focusRow(rowNumber) {
        if (this.isScrolling) {
            return;
        }
        this.isScrolling = true;
        this.ensureIndexVisible(rowNumber);
        (0, ag_grid_community_1._requestAnimationFrame)(this.beans, () => {
            this.isScrolling = false;
            if (!this.isAlive()) {
                return;
            }
            const renderedRow = this.renderedRows.get(rowNumber);
            if (renderedRow) {
                renderedRow.eDiv.focus();
            }
        });
    }
    getComponentAt(rowIndex) {
        const comp = this.renderedRows.get(rowIndex);
        return comp && comp.rowComponent;
    }
    forEachRenderedRow(func) {
        this.renderedRows.forEach((value, key) => func(value.rowComponent, key));
    }
    getItemHeight() {
        if (!this.isHeightFromTheme) {
            return this.rowHeight;
        }
        return this.environment.getDefaultListItemHeight();
    }
    /**
     * Returns true if the view had to be scrolled, otherwise, false.
     */
    ensureIndexVisible(index, scrollPartialIntoView = true) {
        const lastRow = this.model.getRowCount();
        if (typeof index !== 'number' || index < 0 || index >= lastRow) {
            (0, ag_grid_community_1._warn)(229, { index });
            return false;
        }
        const rowTopPixel = index * this.rowHeight;
        const rowBottomPixel = rowTopPixel + this.rowHeight;
        const eGui = this.getGui();
        const viewportTopPixel = eGui.scrollTop;
        const viewportHeight = eGui.offsetHeight;
        const viewportBottomPixel = viewportTopPixel + viewportHeight;
        const diff = scrollPartialIntoView ? 0 : this.rowHeight;
        const viewportScrolledPastRow = viewportTopPixel > rowTopPixel + diff;
        const viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel - diff;
        if (viewportScrolledPastRow) {
            // if row is before, scroll up with row at top
            eGui.scrollTop = rowTopPixel;
            return true;
        }
        if (viewportScrolledBeforeRow) {
            // if row is below, scroll down with row at bottom
            const newScrollPosition = rowBottomPixel - viewportHeight;
            eGui.scrollTop = newScrollPosition;
            return true;
        }
        return false;
    }
    setComponentCreator(componentCreator) {
        this.componentCreator = componentCreator;
    }
    setComponentUpdater(componentUpdater) {
        this.componentUpdater = componentUpdater;
    }
    getRowHeight() {
        return this.rowHeight;
    }
    getScrollTop() {
        return this.getGui().scrollTop;
    }
    setRowHeight(rowHeight) {
        this.isHeightFromTheme = false;
        this.rowHeight = rowHeight;
        this.refresh();
    }
    refresh(softRefresh) {
        if (this.model == null || !this.isAlive()) {
            return;
        }
        const rowCount = this.model.getRowCount();
        this.eContainer.style.height = `${rowCount * this.rowHeight}px`;
        // ensure height is applied before attempting to redraw rows
        this.awaitStable(() => {
            if (!this.isAlive()) {
                return;
            }
            if (this.canSoftRefresh(softRefresh)) {
                this.drawVirtualRows(true);
            }
            else {
                this.clearVirtualRows();
                this.drawVirtualRows();
            }
        });
    }
    awaitStable(callback) {
        this.awaitStableCallbacks.push(callback);
        if (this.awaitStableCallbacks.length > 1) {
            return;
        }
        const rowCount = this.model.getRowCount();
        (0, ag_grid_community_1._waitUntil)(() => this.eContainer.clientHeight >= rowCount * this.rowHeight, () => {
            if (!this.isAlive()) {
                return;
            }
            const callbacks = this.awaitStableCallbacks;
            this.awaitStableCallbacks = [];
            callbacks.forEach((c) => c());
        });
    }
    canSoftRefresh(softRefresh) {
        return !!(softRefresh &&
            this.renderedRows.size &&
            typeof this.model.areRowsEqual === 'function' &&
            this.componentUpdater);
    }
    clearVirtualRows() {
        this.renderedRows.forEach((_, rowIndex) => this.removeRow(rowIndex));
    }
    drawVirtualRows(softRefresh) {
        if (!this.isAlive() || !this.model) {
            return;
        }
        const gui = this.getGui();
        const topPixel = gui.scrollTop;
        const bottomPixel = topPixel + gui.offsetHeight;
        const firstRow = Math.floor(topPixel / this.rowHeight);
        const lastRow = Math.floor(bottomPixel / this.rowHeight);
        this.pageSize = Math.floor((bottomPixel - topPixel) / this.rowHeight);
        this.ensureRowsRendered(firstRow, lastRow, softRefresh);
    }
    ensureRowsRendered(start, finish, softRefresh) {
        // remove any rows that are no longer required
        this.renderedRows.forEach((_, rowIndex) => {
            if ((rowIndex < start || rowIndex > finish) && rowIndex !== this.lastFocusedRowIndex) {
                this.removeRow(rowIndex);
            }
        });
        if (softRefresh) {
            // refresh any existing rows
            this.refreshRows();
        }
        // insert any required new rows
        for (let rowIndex = start; rowIndex <= finish; rowIndex++) {
            if (this.renderedRows.has(rowIndex)) {
                continue;
            }
            // check this row actually exists (in case overflow buffer window exceeds real data)
            if (rowIndex < this.model.getRowCount()) {
                this.insertRow(rowIndex);
            }
        }
    }
    insertRow(rowIndex) {
        const value = this.model.getRow(rowIndex);
        const eDiv = document.createElement('div');
        eDiv.classList.add('ag-virtual-list-item', `ag-${this.cssIdentifier}-virtual-list-item`);
        (0, ag_grid_community_1._setAriaRole)(eDiv, this.ariaRole === 'tree' ? 'treeitem' : 'option');
        (0, ag_grid_community_1._setAriaSetSize)(eDiv, this.model.getRowCount());
        (0, ag_grid_community_1._setAriaPosInSet)(eDiv, rowIndex + 1);
        eDiv.setAttribute('tabindex', '-1');
        eDiv.style.height = `${this.rowHeight}px`;
        eDiv.style.top = `${this.rowHeight * rowIndex}px`;
        const rowComponent = this.componentCreator(value, eDiv);
        rowComponent.addGuiEventListener('focusin', () => (this.lastFocusedRowIndex = rowIndex));
        eDiv.appendChild(rowComponent.getGui());
        // keep the DOM order consistent with the order of the rows
        if (this.renderedRows.has(rowIndex - 1)) {
            this.renderedRows.get(rowIndex - 1).eDiv.insertAdjacentElement('afterend', eDiv);
        }
        else if (this.renderedRows.has(rowIndex + 1)) {
            this.renderedRows.get(rowIndex + 1).eDiv.insertAdjacentElement('beforebegin', eDiv);
        }
        else {
            this.eContainer.appendChild(eDiv);
        }
        this.renderedRows.set(rowIndex, { rowComponent, eDiv, value });
    }
    removeRow(rowIndex) {
        const component = this.renderedRows.get(rowIndex);
        this.eContainer.removeChild(component.eDiv);
        this.destroyBean(component.rowComponent);
        this.renderedRows.delete(rowIndex);
    }
    refreshRows() {
        const rowCount = this.model.getRowCount();
        this.renderedRows.forEach((row, rowIndex) => {
            if (rowIndex >= rowCount) {
                this.removeRow(rowIndex);
            }
            else {
                const newValue = this.model.getRow(rowIndex);
                if (this.model.areRowsEqual?.(row.value, newValue)) {
                    this.componentUpdater(newValue, row.rowComponent);
                }
                else {
                    // to be replaced later
                    this.removeRow(rowIndex);
                }
            }
        });
    }
    addScrollListener() {
        this.addGuiEventListener('scroll', () => this.drawVirtualRows(), { passive: true });
    }
    setModel(model) {
        this.model = model;
    }
    getAriaElement() {
        return this.eContainer;
    }
    destroy() {
        if (!this.isAlive()) {
            return;
        }
        this.clearVirtualRows();
        this.awaitStableCallbacks.length = 0;
        super.destroy();
    }
}
exports.VirtualList = VirtualList;


/***/ }),

/***/ 6624:
/***/ (function(module) {

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// packages/ag-grid-community/src/main.ts
var main_exports = {};
__export(main_exports, {
  ALWAYS_SYNC_GLOBAL_EVENTS: () => ALWAYS_SYNC_GLOBAL_EVENTS,
  AbstractClientSideNodeManager: () => AbstractClientSideNodeManager,
  AgAbstractInputField: () => AgAbstractInputField,
  AgAbstractLabel: () => AgAbstractLabel,
  AgCheckbox: () => AgCheckbox,
  AgCheckboxSelector: () => AgCheckboxSelector,
  AgColumn: () => AgColumn,
  AgColumnGroup: () => AgColumnGroup,
  AgInputDateField: () => AgInputDateField,
  AgInputNumberField: () => AgInputNumberField,
  AgInputNumberFieldSelector: () => AgInputNumberFieldSelector,
  AgInputTextArea: () => AgInputTextArea,
  AgInputTextField: () => AgInputTextField,
  AgInputTextFieldSelector: () => AgInputTextFieldSelector,
  AgPickerField: () => AgPickerField,
  AgPromise: () => AgPromise,
  AgProvidedColumnGroup: () => AgProvidedColumnGroup,
  AgRadioButton: () => AgRadioButton,
  AgSelect: () => AgSelect,
  AgSelectSelector: () => AgSelectSelector,
  AgToggleButton: () => AgToggleButton,
  AgToggleButtonSelector: () => AgToggleButtonSelector,
  AlignedGridsModule: () => AlignedGridsModule,
  AllCommunityModule: () => AllCommunityModule,
  AutoScrollService: () => AutoScrollService,
  BaseColsService: () => BaseColsService,
  BaseComponentWrapper: () => BaseComponentWrapper,
  BaseCreator: () => BaseCreator,
  BaseGridSerializingSession: () => BaseGridSerializingSession,
  BaseSelectionService: () => BaseSelectionService,
  BeanStub: () => BeanStub,
  CellApiModule: () => CellApiModule,
  CellRangeType: () => CellRangeType,
  CellStyleModule: () => CellStyleModule,
  ChangedPath: () => ChangedPath,
  CheckboxEditorModule: () => CheckboxEditorModule,
  ClientSideRowModelApiModule: () => ClientSideRowModelApiModule,
  ClientSideRowModelModule: () => ClientSideRowModelModule,
  ColumnApiModule: () => ColumnApiModule,
  ColumnAutoSizeModule: () => ColumnAutoSizeModule,
  ColumnHoverModule: () => ColumnHoverModule,
  ColumnKeyCreator: () => ColumnKeyCreator,
  Component: () => Component,
  CssClassManager: () => CssClassManager,
  CsvExportModule: () => CsvExportModule,
  CustomEditorModule: () => CustomEditorModule,
  CustomFilterModule: () => CustomFilterModule,
  DateEditorModule: () => DateEditorModule,
  DateFilterModule: () => DateFilterModule,
  DragAndDropModule: () => DragAndDropModule,
  DragSourceType: () => DragSourceType,
  EventApiModule: () => EventApiModule,
  ExternalFilterModule: () => ExternalFilterModule,
  FakeHScrollComp: () => FakeHScrollComp,
  FakeVScrollComp: () => FakeVScrollComp,
  FilterWrapperComp: () => FilterWrapperComp,
  GROUP_AUTO_COLUMN_ID: () => GROUP_AUTO_COLUMN_ID,
  GridBodyCtrl: () => GridBodyCtrl,
  GridCoreCreator: () => GridCoreCreator,
  GridCtrl: () => GridCtrl,
  GridHeaderCtrl: () => GridHeaderCtrl,
  GridStateModule: () => GridStateModule,
  GroupInstanceIdCreator: () => GroupInstanceIdCreator,
  HeaderRowContainerCtrl: () => HeaderRowContainerCtrl,
  HighlightChangesModule: () => HighlightChangesModule,
  InfiniteRowModelModule: () => InfiniteRowModelModule,
  KeyCode: () => KeyCode,
  LargeTextEditorModule: () => LargeTextEditorModule,
  LocalEventService: () => LocalEventService,
  LocaleModule: () => LocaleModule,
  LocaleService: () => LocaleService,
  ManagedFocusFeature: () => ManagedFocusFeature,
  ModuleRegistry: () => ModuleRegistry,
  NumberEditorModule: () => NumberEditorModule,
  NumberFilterModule: () => NumberFilterModule,
  PaginationModule: () => PaginationModule,
  PinnedRowModule: () => PinnedRowModule,
  PopupComponent: () => PopupComponent,
  PositionableFeature: () => PositionableFeature,
  ProvidedFilter: () => ProvidedFilter,
  QuickFilterModule: () => QuickFilterModule,
  RefPlaceholder: () => RefPlaceholder,
  RenderApiModule: () => RenderApiModule,
  RowApiModule: () => RowApiModule,
  RowAutoHeightModule: () => RowAutoHeightModule,
  RowContainerCtrl: () => RowContainerCtrl,
  RowDragModule: () => RowDragModule,
  RowNode: () => RowNode,
  RowSelectionModule: () => RowSelectionModule,
  RowStyleModule: () => RowStyleModule,
  ScrollApiModule: () => ScrollApiModule,
  SelectEditorModule: () => SelectEditorModule,
  ServerSideTransactionResultStatus: () => ServerSideTransactionResultStatus,
  TabGuardClassNames: () => TabGuardClassNames,
  TabGuardComp: () => TabGuardComp,
  TabGuardCtrl: () => TabGuardCtrl,
  TabGuardFeature: () => TabGuardFeature,
  TextEditorModule: () => TextEditorModule,
  TextFilterModule: () => TextFilterModule,
  TooltipFeature: () => TooltipFeature,
  TooltipModule: () => TooltipModule,
  TouchListener: () => TouchListener,
  UndoRedoEditModule: () => UndoRedoEditModule,
  ValidationModule: () => ValidationModule,
  ValueCacheModule: () => ValueCacheModule,
  VanillaFrameworkOverrides: () => VanillaFrameworkOverrides,
  _ALL_EVENTS: () => _ALL_EVENTS,
  _ALL_GRID_OPTIONS: () => _ALL_GRID_OPTIONS,
  _BOOLEAN_MIXED_GRID_OPTIONS: () => _BOOLEAN_MIXED_GRID_OPTIONS,
  _ColumnFilterModule: () => ColumnFilterModule,
  _ColumnGroupModule: () => ColumnGroupModule,
  _ColumnMoveModule: () => ColumnMoveModule,
  _CsrmSsrmSharedApiModule: () => CsrmSsrmSharedApiModule,
  _DragModule: () => DragModule,
  _EditCoreModule: () => EditCoreModule,
  _EmptyArray: () => _EmptyArray,
  _EmptyBean: () => EmptyBean,
  _FOCUS_MANAGED_CLASS: () => FOCUS_MANAGED_CLASS,
  _FilterCoreModule: () => FilterCoreModule,
  _FilterValueModule: () => FilterValueModule,
  _HorizontalResizeModule: () => HorizontalResizeModule,
  _KeyboardNavigationModule: () => KeyboardNavigationModule,
  _PUBLIC_EVENTS: () => _PUBLIC_EVENTS,
  _PopupModule: () => PopupModule,
  _ROW_ID_PREFIX_ROW_GROUP: () => ROW_ID_PREFIX_ROW_GROUP,
  _SharedDragAndDropModule: () => SharedDragAndDropModule,
  _SharedExportModule: () => SharedExportModule,
  _SharedMenuModule: () => SharedMenuModule,
  _SharedRowSelectionModule: () => SharedRowSelectionModule,
  _SortModule: () => SortModule,
  _SsrmInfiniteSharedApiModule: () => SsrmInfiniteSharedApiModule,
  _addColumnDefaultAndTypes: () => _addColumnDefaultAndTypes,
  _addFocusableContainerListener: () => _addFocusableContainerListener,
  _anchorElementToMouseMoveEvent: () => _anchorElementToMouseMoveEvent,
  _applyColumnState: () => _applyColumnState,
  _areCellsEqual: () => _areCellsEqual,
  _areColIdsEqual: () => _areColIdsEqual,
  _areEqual: () => _areEqual,
  _asThemeImpl: () => _asThemeImpl,
  _bindCellRendererToHtmlElement: () => _bindCellRendererToHtmlElement,
  _canSkipShowingRowGroup: () => _canSkipShowingRowGroup,
  _clearElement: () => _clearElement,
  _columnsMatch: () => _columnsMatch,
  _combineAttributesAndGridOptions: () => _combineAttributesAndGridOptions,
  _convertColumnEventSourceType: () => _convertColumnEventSourceType,
  _createCellId: () => _createCellId,
  _createColumnTree: () => _createColumnTree,
  _createGlobalRowEvent: () => _createGlobalRowEvent,
  _createIcon: () => _createIcon,
  _createIconNoSpan: () => _createIconNoSpan,
  _debounce: () => _debounce,
  _defaultComparator: () => _defaultComparator,
  _destroyColumnTree: () => _destroyColumnTree,
  _doOnce: () => _doOnce,
  _downloadFile: () => _downloadFile,
  _errMsg: () => _errMsg,
  _error: () => _error,
  _escapeString: () => _escapeString,
  _exists: () => _exists,
  _findFocusableElements: () => _findFocusableElements,
  _findNextFocusableElement: () => _findNextFocusableElement,
  _findTabbableParent: () => _findTabbableParent,
  _focusGridInnerElement: () => _focusGridInnerElement,
  _focusInto: () => _focusInto,
  _focusNextGridCoreContainer: () => _focusNextGridCoreContainer,
  _formatNumberCommas: () => _formatNumberCommas,
  _fuzzySuggestions: () => _fuzzySuggestions,
  _getAbsoluteHeight: () => _getAbsoluteHeight,
  _getAbsoluteWidth: () => _getAbsoluteWidth,
  _getActiveDomElement: () => _getActiveDomElement,
  _getAriaPosInSet: () => _getAriaPosInSet,
  _getCallbackForEvent: () => _getCallbackForEvent,
  _getCellByPosition: () => _getCellByPosition,
  _getCellCtrlForEventTarget: () => _getCellCtrlForEventTarget,
  _getCellPositionForEvent: () => _getCellPositionForEvent,
  _getCellRendererDetails: () => _getCellRendererDetails,
  _getCheckboxLocation: () => _getCheckboxLocation,
  _getCheckboxes: () => _getCheckboxes,
  _getClientSideRowModel: () => _getClientSideRowModel,
  _getColumnsFromTree: () => _getColumnsFromTree,
  _getDefaultFloatingFilterType: () => _getDefaultFloatingFilterType,
  _getDocument: () => _getDocument,
  _getEditorRendererDetails: () => _getEditorRendererDetails,
  _getFillHandle: () => _getFillHandle,
  _getFilterDetails: () => _getFilterDetails,
  _getFloatingFilterCompDetails: () => _getFloatingFilterCompDetails,
  _getFloatingFiltersHeight: () => getFloatingFiltersHeight,
  _getGlobalGridOption: () => _getGlobalGridOption,
  _getGrandTotalRow: () => _getGrandTotalRow,
  _getGridRegisteredModules: () => _getGridRegisteredModules,
  _getGroupAggFiltering: () => _getGroupAggFiltering,
  _getGroupSelection: () => _getGroupSelection,
  _getGroupSelectsDescendants: () => _getGroupSelectsDescendants,
  _getGroupTotalRowCallback: () => _getGroupTotalRowCallback,
  _getHeaderCheckbox: () => _getHeaderCheckbox,
  _getHeaderClassesFromColDef: () => _getHeaderClassesFromColDef,
  _getHeaderRowCount: () => getHeaderRowCount,
  _getInnerCellRendererDetails: () => _getInnerCellRendererDetails,
  _getInnerHeight: () => _getInnerHeight,
  _getInnerWidth: () => _getInnerWidth,
  _getIsRowSelectable: () => _getIsRowSelectable,
  _getLocaleTextFunc: () => _getLocaleTextFunc,
  _getMaxConcurrentDatasourceRequests: () => _getMaxConcurrentDatasourceRequests,
  _getNormalisedMousePosition: () => _getNormalisedMousePosition,
  _getPageBody: () => _getPageBody,
  _getRootNode: () => _getRootNode,
  _getRowContainerOptions: () => _getRowContainerOptions,
  _getRowHeightAsNumber: () => _getRowHeightAsNumber,
  _getRowHeightForNode: () => _getRowHeightForNode,
  _getRowIdCallback: () => _getRowIdCallback,
  _getRowNode: () => _getRowNode,
  _getRowSelectionMode: () => _getRowSelectionMode,
  _getServerSideRowModel: () => _getServerSideRowModel,
  _getShouldDisplayTooltip: () => _getShouldDisplayTooltip,
  _getSuppressMultiRanges: () => _getSuppressMultiRanges,
  _getToolPanelClassesFromColDef: () => _getToolPanelClassesFromColDef,
  _isAnimateRows: () => _isAnimateRows,
  _isCellSelectionEnabled: () => _isCellSelectionEnabled,
  _isClientSideRowModel: () => _isClientSideRowModel,
  _isColumnMenuAnchoringEnabled: () => _isColumnMenuAnchoringEnabled,
  _isColumnsSortingCoupledToGroup: () => _isColumnsSortingCoupledToGroup,
  _isDomLayout: () => _isDomLayout,
  _isElementInEventPath: () => _isElementInEventPath,
  _isEventFromPrintableCharacter: () => _isEventFromPrintableCharacter,
  _isGetRowHeightFunction: () => _isGetRowHeightFunction,
  _isGroupMultiAutoColumn: () => _isGroupMultiAutoColumn,
  _isGroupRowsSticky: () => _isGroupRowsSticky,
  _isGroupUseEntireRow: () => _isGroupUseEntireRow,
  _isIOSUserAgent: () => _isIOSUserAgent,
  _isKeyboardMode: () => _isKeyboardMode,
  _isLegacyMenuEnabled: () => _isLegacyMenuEnabled,
  _isMultiRowSelection: () => _isMultiRowSelection,
  _isNodeOrElement: () => _isNodeOrElement,
  _isNothingFocused: () => _isNothingFocused,
  _isPromise: () => _isPromise,
  _isRowBefore: () => _isRowBefore,
  _isRowSelection: () => _isRowSelection,
  _isSameRow: () => _isSameRow,
  _isServerSideRowModel: () => _isServerSideRowModel,
  _isShowTooltipWhenTruncated: () => _isShowTooltipWhenTruncated,
  _isStopPropagationForAgGrid: () => _isStopPropagationForAgGrid,
  _isUsingNewCellSelectionAPI: () => _isUsingNewCellSelectionAPI,
  _isUsingNewRowSelectionAPI: () => _isUsingNewRowSelectionAPI,
  _isVisible: () => _isVisible,
  _jsonEquals: () => _jsonEquals,
  _last: () => _last,
  _loadTemplate: () => _loadTemplate,
  _makeNull: () => _makeNull,
  _mergeDeep: () => _mergeDeep,
  _missing: () => _missing,
  _observeResize: () => _observeResize,
  _parseDateTimeFromString: () => _parseDateTimeFromString,
  _preInitErrMsg: () => _preInitErrMsg,
  _processOnChange: () => _processOnChange,
  _radioCssClass: () => _radioCssClass,
  _removeAriaExpanded: () => _removeAriaExpanded,
  _removeAriaSort: () => _removeAriaSort,
  _removeFromArray: () => _removeFromArray,
  _removeFromParent: () => _removeFromParent,
  _requestAnimationFrame: () => _requestAnimationFrame,
  _resetColumnState: () => _resetColumnState,
  _serialiseDate: () => _serialiseDate,
  _setAriaActiveDescendant: () => _setAriaActiveDescendant,
  _setAriaChecked: () => _setAriaChecked,
  _setAriaColCount: () => _setAriaColCount,
  _setAriaColIndex: () => _setAriaColIndex,
  _setAriaColSpan: () => _setAriaColSpan,
  _setAriaControls: () => _setAriaControls,
  _setAriaDescribedBy: () => _setAriaDescribedBy,
  _setAriaDisabled: () => _setAriaDisabled,
  _setAriaExpanded: () => _setAriaExpanded,
  _setAriaHidden: () => _setAriaHidden,
  _setAriaLabel: () => _setAriaLabel,
  _setAriaLabelledBy: () => _setAriaLabelledBy,
  _setAriaLevel: () => _setAriaLevel,
  _setAriaPosInSet: () => _setAriaPosInSet,
  _setAriaRole: () => _setAriaRole,
  _setAriaRowCount: () => _setAriaRowCount,
  _setAriaRowIndex: () => _setAriaRowIndex,
  _setAriaSelected: () => _setAriaSelected,
  _setAriaSetSize: () => _setAriaSetSize,
  _setAriaSort: () => _setAriaSort,
  _setColMenuVisible: () => _setColMenuVisible,
  _setDisabled: () => _setDisabled,
  _setDisplayed: () => _setDisplayed,
  _setFixedWidth: () => _setFixedWidth,
  _setVisible: () => _setVisible,
  _shouldDisplayTooltip: () => _shouldDisplayTooltip,
  _shouldUpdateColVisibilityAfterGroup: () => _shouldUpdateColVisibilityAfterGroup,
  _stopPropagationForAgGrid: () => _stopPropagationForAgGrid,
  _toStringOrNull: () => _toStringOrNull,
  _unwrapUserComp: () => _unwrapUserComp,
  _updateColsMap: () => _updateColsMap,
  _updateColumnState: () => _updateColumnState,
  _waitUntil: () => _waitUntil,
  _warn: () => _warn,
  _warnOnce: () => _warnOnce,
  checkboxStyleDefault: () => checkboxStyleDefault,
  colorSchemeDark: () => colorSchemeDark,
  colorSchemeDarkBlue: () => colorSchemeDarkBlue,
  colorSchemeDarkWarm: () => colorSchemeDarkWarm,
  colorSchemeLight: () => colorSchemeLight,
  colorSchemeLightCold: () => colorSchemeLightCold,
  colorSchemeLightWarm: () => colorSchemeLightWarm,
  colorSchemeVariable: () => colorSchemeVariable,
  createGrid: () => createGrid,
  createPart: () => createPart,
  createTheme: () => createTheme,
  iconOverrides: () => iconOverrides,
  iconSetAlpine: () => iconSetAlpine,
  iconSetMaterial: () => iconSetMaterial,
  iconSetQuartz: () => iconSetQuartz,
  iconSetQuartzBold: () => iconSetQuartzBold,
  iconSetQuartzLight: () => iconSetQuartzLight,
  iconSetQuartzRegular: () => iconSetQuartzRegular,
  inputStyleBase: () => inputStyleBase,
  inputStyleBordered: () => inputStyleBordered,
  inputStyleUnderlined: () => inputStyleUnderlined,
  isColumn: () => isColumn,
  isColumnGroup: () => isColumnGroup2,
  isColumnGroupAutoCol: () => isColumnGroupAutoCol,
  isColumnSelectionCol: () => isColumnSelectionCol,
  isProvidedColumnGroup: () => isProvidedColumnGroup,
  provideGlobalGridOptions: () => provideGlobalGridOptions,
  tabStyleAlpine: () => tabStyleAlpine,
  tabStyleBase: () => tabStyleBase,
  tabStyleMaterial: () => tabStyleMaterial,
  tabStyleQuartz: () => tabStyleQuartz,
  tabStyleRolodex: () => tabStyleRolodex,
  themeAlpine: () => themeAlpine,
  themeBalham: () => themeBalham,
  themeQuartz: () => themeQuartz
});
module.exports = __toCommonJS(main_exports);

// packages/ag-grid-community/src/localEventService.ts
var LocalEventService = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map();
    this.allAsyncListeners = /* @__PURE__ */ new Map();
    this.globalSyncListeners = /* @__PURE__ */ new Set();
    this.globalAsyncListeners = /* @__PURE__ */ new Set();
    this.asyncFunctionsQueue = [];
    this.scheduled = false;
    // using an object performs better than a Set for the number of different events we have
    this.firedEvents = {};
  }
  setFrameworkOverrides(frameworkOverrides) {
    this.frameworkOverrides = frameworkOverrides;
  }
  getListeners(eventType, async, autoCreateListenerCollection) {
    const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
    let listeners = listenerMap.get(eventType);
    if (!listeners && autoCreateListenerCollection) {
      listeners = /* @__PURE__ */ new Set();
      listenerMap.set(eventType, listeners);
    }
    return listeners;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(eventType, listener, async = false) {
    this.getListeners(eventType, async, true).add(listener);
  }
  removeEventListener(eventType, listener, async = false) {
    const listeners = this.getListeners(eventType, async, false);
    if (!listeners) {
      return;
    }
    listeners.delete(listener);
    if (listeners.size === 0) {
      const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
      listenerMap.delete(eventType);
    }
  }
  addGlobalListener(listener, async = false) {
    (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);
  }
  removeGlobalListener(listener, async = false) {
    (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);
  }
  dispatchEvent(event) {
    const agEvent = event;
    this.dispatchToListeners(agEvent, true);
    this.dispatchToListeners(agEvent, false);
    this.firedEvents[agEvent.type] = true;
  }
  dispatchEventOnce(event) {
    if (!this.firedEvents[event.type]) {
      this.dispatchEvent(event);
    }
  }
  dispatchToListeners(event, async) {
    const eventType = event.type;
    if (async && "event" in event) {
      const browserEvent = event.event;
      if (browserEvent instanceof Event) {
        event.eventPath = browserEvent.composedPath();
      }
    }
    const processEventListeners = (listeners2, originalListeners2) => listeners2.forEach((listener) => {
      if (!originalListeners2.has(listener)) {
        return;
      }
      const callback = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => listener(event)) : () => listener(event);
      if (async) {
        this.dispatchAsync(callback);
      } else {
        callback();
      }
    });
    const originalListeners = this.getListeners(eventType, async, false) ?? /* @__PURE__ */ new Set();
    const listeners = new Set(originalListeners);
    if (listeners.size > 0) {
      processEventListeners(listeners, originalListeners);
    }
    const globalListeners = new Set(
      async ? this.globalAsyncListeners : this.globalSyncListeners
    );
    globalListeners.forEach((listener) => {
      const callback = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => listener(eventType, event)) : () => listener(eventType, event);
      if (async) {
        this.dispatchAsync(callback);
      } else {
        callback();
      }
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(func) {
    this.asyncFunctionsQueue.push(func);
    if (!this.scheduled) {
      const flush = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(flush) : flush();
      this.scheduled = true;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = false;
    const queueCopy = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [];
    queueCopy.forEach((func) => func());
  }
};

// packages/ag-grid-community/src/misc/locale/localeUtils.ts
function defaultLocaleTextFunc(_key, defaultValue) {
  return defaultValue;
}
function _getLocaleTextFunc(localeSvc) {
  return localeSvc?.getLocaleTextFunc() ?? defaultLocaleTextFunc;
}

// packages/ag-grid-community/src/utils/aria.ts
function _toggleAriaAttribute(element, attribute, value) {
  if (value == null || typeof value === "string" && value == "") {
    _removeAriaAttribute(element, attribute);
  } else {
    _setAriaAttribute(element, attribute, value);
  }
}
function _setAriaAttribute(element, attribute, value) {
  element.setAttribute(_ariaAttributeName(attribute), value.toString());
}
function _removeAriaAttribute(element, attribute) {
  element.removeAttribute(_ariaAttributeName(attribute));
}
function _ariaAttributeName(attribute) {
  return `aria-${attribute}`;
}
function _setAriaRole(element, role) {
  if (role) {
    element.setAttribute("role", role);
  } else {
    element.removeAttribute("role");
  }
}
function _getAriaSortState(sortDirection) {
  let sort;
  if (sortDirection === "asc") {
    sort = "ascending";
  } else if (sortDirection === "desc") {
    sort = "descending";
  } else if (sortDirection === "mixed") {
    sort = "other";
  } else {
    sort = "none";
  }
  return sort;
}
function _getAriaPosInSet(element) {
  return parseInt(element.getAttribute("aria-posinset"), 10);
}
function _getAriaLabel(element) {
  return element.getAttribute("aria-label");
}
function _setAriaLabel(element, label) {
  _toggleAriaAttribute(element, "label", label);
}
function _setAriaLabelledBy(element, labelledBy) {
  _toggleAriaAttribute(element, "labelledby", labelledBy);
}
function _setAriaDescribedBy(element, describedby) {
  _toggleAriaAttribute(element, "describedby", describedby);
}
function _setAriaLive(element, live) {
  _toggleAriaAttribute(element, "live", live);
}
function _setAriaAtomic(element, atomic) {
  _toggleAriaAttribute(element, "atomic", atomic);
}
function _setAriaRelevant(element, relevant) {
  _toggleAriaAttribute(element, "relevant", relevant);
}
function _setAriaLevel(element, level) {
  _toggleAriaAttribute(element, "level", level);
}
function _setAriaDisabled(element, disabled) {
  _toggleAriaAttribute(element, "disabled", disabled);
}
function _setAriaHidden(element, hidden) {
  _toggleAriaAttribute(element, "hidden", hidden);
}
function _setAriaActiveDescendant(element, descendantId) {
  _toggleAriaAttribute(element, "activedescendant", descendantId);
}
function _setAriaExpanded(element, expanded) {
  _setAriaAttribute(element, "expanded", expanded);
}
function _removeAriaExpanded(element) {
  _removeAriaAttribute(element, "expanded");
}
function _setAriaSetSize(element, setsize) {
  _setAriaAttribute(element, "setsize", setsize);
}
function _setAriaPosInSet(element, position) {
  _setAriaAttribute(element, "posinset", position);
}
function _setAriaMultiSelectable(element, multiSelectable) {
  _setAriaAttribute(element, "multiselectable", multiSelectable);
}
function _setAriaRowCount(element, rowCount) {
  _setAriaAttribute(element, "rowcount", rowCount);
}
function _setAriaRowIndex(element, rowIndex) {
  _setAriaAttribute(element, "rowindex", rowIndex);
}
function _setAriaColCount(element, colCount) {
  _setAriaAttribute(element, "colcount", colCount);
}
function _setAriaColIndex(element, colIndex) {
  _setAriaAttribute(element, "colindex", colIndex);
}
function _setAriaColSpan(element, colSpan) {
  _setAriaAttribute(element, "colspan", colSpan);
}
function _setAriaSort(element, sort) {
  _setAriaAttribute(element, "sort", sort);
}
function _removeAriaSort(element) {
  _removeAriaAttribute(element, "sort");
}
function _setAriaSelected(element, selected) {
  _toggleAriaAttribute(element, "selected", selected);
}
function _setAriaChecked(element, checked) {
  _setAriaAttribute(element, "checked", checked === void 0 ? "mixed" : checked);
}
function _setAriaControls(controllerElement, controlledElement) {
  _toggleAriaAttribute(controllerElement, "controls", controlledElement.id);
  _setAriaLabelledBy(controlledElement, controllerElement.id);
}
function _getAriaCheckboxStateName(translate, state) {
  return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
}

// packages/ag-grid-community/src/utils/browser.ts
var isSafari;
var isChrome;
var isFirefox;
var isMacOs;
var isIOS;
var invisibleScrollbar;
var browserScrollbarWidth;
var maxDivHeight;
function _isBrowserSafari() {
  if (isSafari === void 0) {
    isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
  return isSafari;
}
function _isBrowserChrome() {
  if (isChrome === void 0) {
    const win = window;
    isChrome = !!win.chrome && (!!win.chrome.webstore || !!win.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return isChrome;
}
function _isBrowserFirefox() {
  if (isFirefox === void 0) {
    isFirefox = /(firefox)/i.test(navigator.userAgent);
  }
  return isFirefox;
}
function _isMacOsUserAgent() {
  if (isMacOs === void 0) {
    isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
  }
  return isMacOs;
}
function _isIOSUserAgent() {
  if (isIOS === void 0) {
    isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  }
  return isIOS;
}
function _getTabIndex(el) {
  if (!el) {
    return null;
  }
  const numberTabIndex = el.tabIndex;
  const tabIndex = el.getAttribute("tabIndex");
  if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !_isBrowserFirefox())) {
    return null;
  }
  return numberTabIndex.toString();
}
function _getMaxDivHeight() {
  if (maxDivHeight !== void 0) {
    return maxDivHeight;
  }
  if (!document.body) {
    return -1;
  }
  let res = 1e6;
  const testUpTo = _isBrowserFirefox() ? 6e6 : 1e9;
  const div = document.createElement("div");
  document.body.appendChild(div);
  while (true) {
    const test = res * 2;
    div.style.height = test + "px";
    if (test > testUpTo || div.clientHeight !== test) {
      break;
    } else {
      res = test;
    }
  }
  document.body.removeChild(div);
  maxDivHeight = res;
  return res;
}
function _getScrollbarWidth() {
  if (browserScrollbarWidth == null) {
    initScrollbarWidthAndVisibility();
  }
  return browserScrollbarWidth;
}
function initScrollbarWidthAndVisibility() {
  const body = document.body;
  const div = document.createElement("div");
  div.style.width = div.style.height = "100px";
  div.style.opacity = "0";
  div.style.overflow = "scroll";
  div.style.msOverflowStyle = "scrollbar";
  div.style.position = "absolute";
  body.appendChild(div);
  let width = div.offsetWidth - div.clientWidth;
  if (width === 0 && div.clientWidth === 0) {
    width = null;
  }
  if (div.parentNode) {
    div.parentNode.removeChild(div);
  }
  if (width != null) {
    browserScrollbarWidth = width;
    invisibleScrollbar = width === 0;
  }
}
function _isInvisibleScrollbar() {
  if (invisibleScrollbar == null) {
    initScrollbarWidthAndVisibility();
  }
  return invisibleScrollbar;
}

// packages/ag-grid-community/src/utils/dom.ts
var rtlNegativeScroll;
function _radioCssClass(element, elementClass, otherElementClass) {
  const parent = element.parentElement;
  let sibling = parent && parent.firstChild;
  while (sibling) {
    if (elementClass) {
      sibling.classList.toggle(elementClass, sibling === element);
    }
    if (otherElementClass) {
      sibling.classList.toggle(otherElementClass, sibling !== element);
    }
    sibling = sibling.nextSibling;
  }
}
var FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
var FOCUSABLE_EXCLUDE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function _isFocusableFormField(element) {
  const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
  const inputSelector = "input, select, button, textarea";
  const isFocusable = matches.call(element, inputSelector);
  const isNotFocusable = matches.call(element, FOCUSABLE_EXCLUDE);
  const isElementVisible = _isVisible(element);
  const focusable = isFocusable && !isNotFocusable && isElementVisible;
  return focusable;
}
function _setDisplayed(element, displayed, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-hidden", !displayed);
  if (!skipAriaHidden) {
    _setAriaHidden(element, !displayed);
  }
}
function _setVisible(element, visible, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-invisible", !visible);
  if (!skipAriaHidden) {
    _setAriaHidden(element, !visible);
  }
}
function _setDisabled(element, disabled) {
  const attributeName = "disabled";
  const addOrRemoveDisabledAttribute = disabled ? (e) => e.setAttribute(attributeName, "") : (e) => e.removeAttribute(attributeName);
  addOrRemoveDisabledAttribute(element);
  _nodeListForEach(element.querySelectorAll("input"), (input) => addOrRemoveDisabledAttribute(input));
}
function _isElementChildOfClass(element, cls, maxNest) {
  let counter = 0;
  while (element) {
    if (element.classList.contains(cls)) {
      return true;
    }
    element = element.parentElement;
    if (typeof maxNest == "number") {
      if (++counter > maxNest) {
        break;
      }
    } else if (element === maxNest) {
      break;
    }
  }
  return false;
}
function _getElementSize(el) {
  const {
    height,
    width,
    borderTopWidth,
    borderRightWidth,
    borderBottomWidth,
    borderLeftWidth,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    boxSizing
  } = window.getComputedStyle(el);
  return {
    height: parseFloat(height || "0"),
    width: parseFloat(width || "0"),
    borderTopWidth: parseFloat(borderTopWidth || "0"),
    borderRightWidth: parseFloat(borderRightWidth || "0"),
    borderBottomWidth: parseFloat(borderBottomWidth || "0"),
    borderLeftWidth: parseFloat(borderLeftWidth || "0"),
    paddingTop: parseFloat(paddingTop || "0"),
    paddingRight: parseFloat(paddingRight || "0"),
    paddingBottom: parseFloat(paddingBottom || "0"),
    paddingLeft: parseFloat(paddingLeft || "0"),
    marginTop: parseFloat(marginTop || "0"),
    marginRight: parseFloat(marginRight || "0"),
    marginBottom: parseFloat(marginBottom || "0"),
    marginLeft: parseFloat(marginLeft || "0"),
    boxSizing
  };
}
function _getInnerHeight(el) {
  const size = _getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.height - size.paddingTop - size.paddingBottom;
  }
  return size.height;
}
function _getInnerWidth(el) {
  const size = _getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.width - size.paddingLeft - size.paddingRight;
  }
  return size.width;
}
function _getAbsoluteHeight(el) {
  const { height, marginBottom, marginTop } = _getElementSize(el);
  return Math.floor(height + marginBottom + marginTop);
}
function _getAbsoluteWidth(el) {
  const { width, marginLeft, marginRight } = _getElementSize(el);
  return Math.floor(width + marginLeft + marginRight);
}
function _getElementRectWithOffset(el) {
  const offsetElementRect = el.getBoundingClientRect();
  const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth } = _getElementSize(el);
  return {
    top: offsetElementRect.top + (borderTopWidth || 0),
    left: offsetElementRect.left + (borderLeftWidth || 0),
    right: offsetElementRect.right + (borderRightWidth || 0),
    bottom: offsetElementRect.bottom + (borderBottomWidth || 0)
  };
}
function _isRtlNegativeScroll() {
  if (typeof rtlNegativeScroll === "boolean") {
    return rtlNegativeScroll;
  }
  const template = document.createElement("div");
  template.style.direction = "rtl";
  template.style.width = "1px";
  template.style.height = "1px";
  template.style.position = "fixed";
  template.style.top = "0px";
  template.style.overflow = "hidden";
  template.dir = "rtl";
  template.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`;
  document.body.appendChild(template);
  template.scrollLeft = 1;
  rtlNegativeScroll = Math.floor(template.scrollLeft) === 0;
  document.body.removeChild(template);
  return rtlNegativeScroll;
}
function _getScrollLeft(element, rtl) {
  let scrollLeft = element.scrollLeft;
  if (rtl) {
    scrollLeft = Math.abs(scrollLeft);
    if (_isBrowserChrome() && !_isRtlNegativeScroll()) {
      scrollLeft = element.scrollWidth - element.getBoundingClientRect().width - scrollLeft;
    }
  }
  return scrollLeft;
}
function _setScrollLeft(element, value, rtl) {
  if (rtl) {
    if (_isRtlNegativeScroll()) {
      value *= -1;
    } else if (_isBrowserSafari() || _isBrowserChrome()) {
      value = element.scrollWidth - element.getBoundingClientRect().width - value;
    }
  }
  element.scrollLeft = value;
}
function _clearElement(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
function _removeFromParent(node) {
  if (node && node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function _isInDOM(element) {
  return !!element.offsetParent;
}
function _isVisible(element) {
  const el = element;
  if (el.checkVisibility) {
    return el.checkVisibility({ checkVisibilityCSS: true });
  }
  const isHidden = !_isInDOM(element) || window.getComputedStyle(element).visibility !== "visible";
  return !isHidden;
}
function _loadTemplate(template) {
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = (template || "").trim();
  return tempDiv.firstChild;
}
function _ensureDomOrder(eContainer, eChild, eChildBefore) {
  if (eChildBefore && eChildBefore.nextSibling === eChild) {
    return;
  }
  if (eChildBefore) {
    if (eChildBefore.nextSibling) {
      eContainer.insertBefore(eChild, eChildBefore.nextSibling);
    } else {
      eContainer.appendChild(eChild);
    }
  } else {
    if (eContainer.firstChild && eContainer.firstChild !== eChild) {
      eContainer.insertAdjacentElement("afterbegin", eChild);
    }
  }
}
function _setDomChildOrder(eContainer, orderedChildren) {
  for (let i = 0; i < orderedChildren.length; i++) {
    const correctCellAtIndex = orderedChildren[i];
    const actualCellAtIndex = eContainer.children[i];
    if (actualCellAtIndex !== correctCellAtIndex) {
      eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
    }
  }
}
function _insertWithDomOrder(eContainer, eToInsert, eChildBefore) {
  if (eChildBefore) {
    eChildBefore.insertAdjacentElement("afterend", eToInsert);
  } else {
    if (eContainer.firstChild) {
      eContainer.insertAdjacentElement("afterbegin", eToInsert);
    } else {
      eContainer.appendChild(eToInsert);
    }
  }
}
function _camelCaseToHyphenated(camelCase) {
  return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
}
function _addStylesToElement(eElement, styles) {
  if (!styles) {
    return;
  }
  for (const [key, value] of Object.entries(styles)) {
    if (!key || !key.length || value == null) {
      continue;
    }
    const parsedKey = _camelCaseToHyphenated(key);
    const valueAsString = value.toString();
    const parsedValue = valueAsString.replace(/\s*!important/g, "");
    const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
    eElement.style.setProperty(parsedKey, parsedValue, priority);
  }
}
function _isHorizontalScrollShowing(element) {
  return element.clientWidth < element.scrollWidth;
}
function _isVerticalScrollShowing(element) {
  return element.clientHeight < element.scrollHeight;
}
function _setElementWidth(element, width) {
  if (width === "flex") {
    element.style.removeProperty("width");
    element.style.removeProperty("minWidth");
    element.style.removeProperty("maxWidth");
    element.style.flex = "1 1 auto";
  } else {
    _setFixedWidth(element, width);
  }
}
function _setFixedWidth(element, width) {
  width = _formatSize(width);
  element.style.width = width.toString();
  element.style.maxWidth = width.toString();
  element.style.minWidth = width.toString();
}
function _setFixedHeight(element, height) {
  height = _formatSize(height);
  element.style.height = height.toString();
  element.style.maxHeight = height.toString();
  element.style.minHeight = height.toString();
}
function _formatSize(size) {
  if (typeof size === "number") {
    return `${size}px`;
  }
  return size;
}
function _isNodeOrElement(o) {
  return o instanceof Node || o instanceof HTMLElement;
}
function _copyNodeList(nodeList) {
  if (nodeList == null) {
    return [];
  }
  const result = [];
  _nodeListForEach(nodeList, (node) => result.push(node));
  return result;
}
function _iterateNamedNodeMap(map, callback) {
  if (!map) {
    return;
  }
  for (let i = 0; i < map.length; i++) {
    const attr = map[i];
    callback(attr.name, attr.value);
  }
}
function _addOrRemoveAttribute(element, name, value) {
  if (value == null || value === "") {
    element.removeAttribute(name);
  } else {
    element.setAttribute(name, value.toString());
  }
}
function _nodeListForEach(nodeList, action) {
  if (nodeList == null) {
    return;
  }
  for (let i = 0; i < nodeList.length; i++) {
    action(nodeList[i]);
  }
}
function _bindCellRendererToHtmlElement(cellRendererPromise, eTarget) {
  cellRendererPromise.then((cellRenderer) => {
    const gui = cellRenderer.getGui();
    if (gui != null) {
      if (typeof gui === "object") {
        eTarget.appendChild(gui);
      } else {
        eTarget.innerHTML = gui;
      }
    }
  });
}
function _observeResize(beans, element, callback) {
  const win = _getWindow(beans);
  const ResizeObserverImpl = win.ResizeObserver;
  const resizeObserver = ResizeObserverImpl ? new ResizeObserverImpl(callback) : null;
  resizeObserver?.observe(element);
  return () => resizeObserver?.disconnect();
}

// packages/ag-grid-community/src/utils/generic.ts
function _makeNull(value) {
  if (value == null || value === "") {
    return null;
  }
  return value;
}
function _exists(value) {
  return value != null && value !== "";
}
function _missing(value) {
  return !_exists(value);
}
function _toStringOrNull(value) {
  return value != null && typeof value.toString === "function" ? value.toString() : null;
}
function _jsonEquals(val1, val2) {
  const val1Json = val1 ? JSON.stringify(val1) : null;
  const val2Json = val2 ? JSON.stringify(val2) : null;
  return val1Json === val2Json;
}
function _defaultComparator(valueA, valueB, accentedCompare = false) {
  const valueAMissing = valueA == null;
  const valueBMissing = valueB == null;
  if (valueA && valueA.toNumber) {
    valueA = valueA.toNumber();
  }
  if (valueB && valueB.toNumber) {
    valueB = valueB.toNumber();
  }
  if (valueAMissing && valueBMissing) {
    return 0;
  }
  if (valueAMissing) {
    return -1;
  }
  if (valueBMissing) {
    return 1;
  }
  function doQuickCompare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  if (typeof valueA !== "string") {
    return doQuickCompare(valueA, valueB);
  }
  if (!accentedCompare) {
    return doQuickCompare(valueA, valueB);
  }
  try {
    return valueA.localeCompare(valueB);
  } catch (e) {
    return doQuickCompare(valueA, valueB);
  }
}

// packages/ag-grid-community/src/baseUrl.ts
var BASE_URL = "https://www.ag-grid.com";

// packages/ag-grid-community/src/utils/function.ts
var doOnceFlags = {};
function _doOnce(func, key) {
  if (doOnceFlags[key]) {
    return;
  }
  func();
  doOnceFlags[key] = true;
}
function _logIfDebug(gos, message, ...args) {
  if (gos.get("debug")) {
    console.log("AG Grid: " + message, ...args);
  }
}
function _warnOnce(msg, ...args) {
  _doOnce(() => console.warn("AG Grid: " + msg, ...args), msg + args?.join(""));
}
function _errorOnce(msg, ...args) {
  _doOnce(() => console.error("AG Grid: " + msg, ...args), msg + args?.join(""));
}
var executeNextVMTurnFuncs = [];
var executeNextVMTurnPending = false;
function _executeNextVMTurn(func) {
  executeNextVMTurnFuncs.push(func);
  if (executeNextVMTurnPending) {
    return;
  }
  executeNextVMTurnPending = true;
  window.setTimeout(() => {
    const funcsCopy = executeNextVMTurnFuncs.slice();
    executeNextVMTurnFuncs.length = 0;
    executeNextVMTurnPending = false;
    funcsCopy.forEach((func2) => func2());
  }, 0);
}
function _debounce(bean, func, delay) {
  let timeout;
  return function(...args) {
    const context = this;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(function() {
      if (bean.isAlive()) {
        func.apply(context, args);
      }
    }, delay);
  };
}
function _throttle(func, wait) {
  let previousCall = 0;
  return function(...args) {
    const context = this;
    const currentCall = (/* @__PURE__ */ new Date()).getTime();
    if (currentCall - previousCall < wait) {
      return;
    }
    previousCall = currentCall;
    func.apply(context, args);
  };
}
function _waitUntil(condition, callback, timeout = 100, timeoutMessage) {
  const timeStamp = (/* @__PURE__ */ new Date()).getTime();
  let interval = null;
  let executed = false;
  const internalCallback = () => {
    const reachedTimeout = (/* @__PURE__ */ new Date()).getTime() - timeStamp > timeout;
    if (condition() || reachedTimeout) {
      callback();
      executed = true;
      if (interval != null) {
        window.clearInterval(interval);
        interval = null;
      }
      if (reachedTimeout && timeoutMessage) {
        _warnOnce(timeoutMessage);
      }
    }
  };
  internalCallback();
  if (!executed) {
    interval = window.setInterval(internalCallback, 10);
  }
}

// packages/ag-grid-community/src/version.ts
var VERSION = "33.0.3";

// packages/ag-grid-community/src/validation/logging.ts
var MAX_URL_LENGTH = 2e3;
var MIN_PARAM_LENGTH = 100;
var VERSION_PARAM_NAME = "_version_";
var validation = null;
var suppressAllLogging = false;
var baseDocLink = `${BASE_URL}/javascript-data-grid`;
function provideValidationServiceLogger(logger) {
  validation = logger;
}
function setValidationDocLink(docLink) {
  baseDocLink = docLink;
}
function getErrorParts(id, args, defaultMessage) {
  return validation?.getConsoleMessage(id, args) ?? [minifiedLog(id, args, defaultMessage)];
}
function getMsgOrDefault(logger, id, args, defaultMessage) {
  if (suppressAllLogging)
    return;
  logger(`error #${id}`, ...getErrorParts(id, args, defaultMessage));
}
function stringifyObject(inputObj) {
  if (!inputObj)
    return String(inputObj);
  const object = {};
  for (const prop of Object.keys(inputObj)) {
    if (typeof inputObj[prop] !== "object" && typeof inputObj[prop] !== "function") {
      object[prop] = inputObj[prop];
    }
  }
  return JSON.stringify(object);
}
function stringifyValue(value) {
  let output = value;
  if (value instanceof Error) {
    output = value.toString();
  } else if (typeof value === "object") {
    output = stringifyObject(value);
  }
  return output;
}
function toStringWithNullUndefined(str) {
  return str === void 0 ? "undefined" : str === null ? "null" : str;
}
function getParamsUrl(baseUrl, params) {
  return `${baseUrl}?${params.toString()}`;
}
function truncateUrl(baseUrl, params, maxLength) {
  const sortedParams = Array.from(params.entries()).sort((a, b) => b[1].length - a[1].length);
  let url = getParamsUrl(baseUrl, params);
  for (const [key, value] of sortedParams) {
    if (key === VERSION_PARAM_NAME) {
      continue;
    }
    const excessLength = url.length - maxLength;
    if (excessLength <= 0) {
      break;
    }
    const ellipse = "...";
    const truncateAmount = excessLength + ellipse.length;
    const truncatedValue = value.length - truncateAmount > MIN_PARAM_LENGTH ? value.slice(0, value.length - truncateAmount) + ellipse : value.slice(0, MIN_PARAM_LENGTH) + ellipse;
    params.set(key, truncatedValue);
    url = getParamsUrl(baseUrl, params);
  }
  return url;
}
function getErrorLink(errorNum, args) {
  const params = new URLSearchParams();
  params.append(VERSION_PARAM_NAME, VERSION);
  if (args) {
    Object.entries(args).forEach(([key, value]) => {
      params.append(key, stringifyValue(value));
    });
  }
  const baseUrl = `${baseDocLink}/errors/${errorNum}`;
  const url = getParamsUrl(baseUrl, params);
  return url.length <= MAX_URL_LENGTH ? url : truncateUrl(baseUrl, params, MAX_URL_LENGTH);
}
var minifiedLog = (errorNum, args, defaultMessage) => {
  const errorLink = getErrorLink(errorNum, args);
  return `${defaultMessage ? defaultMessage + " \n" : ""}Visit ${errorLink}${defaultMessage ? "" : " \n  Alternatively register the ValidationModule to see the full message in the console."}`;
};
function _warn(...args) {
  getMsgOrDefault(_warnOnce, args[0], args[1]);
}
function _error(...args) {
  getMsgOrDefault(_errorOnce, args[0], args[1]);
}
function _logPreInitErr(id, args, defaultMessage) {
  getMsgOrDefault(_errorOnce, id, args, defaultMessage);
}
function getErrMsg(defaultMessage, args) {
  const id = args[0];
  return `error #${id} ` + getErrorParts(id, args[1], defaultMessage).join(" ");
}
function _errMsg(...args) {
  return getErrMsg(void 0, args);
}
function _preInitErrMsg(...args) {
  return getErrMsg("\n", args);
}

// packages/ag-grid-community/src/gridOptionsUtils.ts
function isRowModelType(gos, rowModelType) {
  return gos.get("rowModelType") === rowModelType;
}
function _isClientSideRowModel(gos, rowModel) {
  return isRowModelType(gos, "clientSide");
}
function _isServerSideRowModel(gos, rowModel) {
  return isRowModelType(gos, "serverSide");
}
function _isDomLayout(gos, domLayout) {
  return gos.get("domLayout") === domLayout;
}
function _isRowSelection(gos) {
  return _getRowSelectionMode(gos) !== void 0;
}
function _isGetRowHeightFunction(gos) {
  return typeof gos.get("getRowHeight") === "function";
}
function _shouldMaintainColumnOrder(gos, isPivotColumns) {
  if (isPivotColumns) {
    return !gos.get("enableStrictPivotColumnOrder");
  }
  return gos.get("maintainColumnOrder");
}
function _getRowHeightForNode(beans, rowNode, allowEstimate = false, defaultRowHeight) {
  const { gos, environment } = beans;
  if (defaultRowHeight == null) {
    defaultRowHeight = environment.getDefaultRowHeight();
  }
  if (_isGetRowHeightFunction(gos)) {
    if (allowEstimate) {
      return { height: defaultRowHeight, estimated: true };
    }
    const params = {
      node: rowNode,
      data: rowNode.data
    };
    const height = gos.getCallback("getRowHeight")(params);
    if (isNumeric(height)) {
      if (height === 0) {
        _warn(23);
      }
      return { height: Math.max(1, height), estimated: false };
    }
  }
  if (rowNode.detail && gos.get("masterDetail")) {
    return getMasterDetailRowHeight(gos);
  }
  const gridOptionsRowHeight = gos.get("rowHeight");
  const rowHeight = gridOptionsRowHeight && isNumeric(gridOptionsRowHeight) ? gridOptionsRowHeight : defaultRowHeight;
  return { height: rowHeight, estimated: false };
}
function getMasterDetailRowHeight(gos) {
  if (gos.get("detailRowAutoHeight")) {
    return { height: 1, estimated: false };
  }
  const defaultRowHeight = gos.get("detailRowHeight");
  if (isNumeric(defaultRowHeight)) {
    return { height: defaultRowHeight, estimated: false };
  }
  return { height: 300, estimated: false };
}
function _getRowHeightAsNumber(beans) {
  const { environment, gos } = beans;
  const gridOptionsRowHeight = gos.get("rowHeight");
  if (!gridOptionsRowHeight || _missing(gridOptionsRowHeight)) {
    return environment.getDefaultRowHeight();
  }
  const rowHeight = environment.refreshRowHeightVariable();
  if (rowHeight !== -1) {
    return rowHeight;
  }
  _warn(24);
  return environment.getDefaultRowHeight();
}
function isNumeric(value) {
  return !isNaN(value) && typeof value === "number" && isFinite(value);
}
function _getDomData(gos, element, key) {
  const domData = element[gos.getDomDataKey()];
  return domData ? domData[key] : void 0;
}
function _setDomData(gos, element, key, value) {
  const domDataKey = gos.getDomDataKey();
  let domData = element[domDataKey];
  if (_missing(domData)) {
    domData = {};
    element[domDataKey] = domData;
  }
  domData[key] = value;
}
function _getDocument(beans) {
  const { gos, eGridDiv } = beans;
  let result = null;
  const gridOptionsGetDocument = gos.get("getDocument");
  if (gridOptionsGetDocument && _exists(gridOptionsGetDocument)) {
    result = gridOptionsGetDocument();
  } else if (eGridDiv) {
    result = eGridDiv.ownerDocument;
  }
  if (result && _exists(result)) {
    return result;
  }
  return document;
}
function _getWindow(beans) {
  const eDocument = _getDocument(beans);
  return eDocument.defaultView || window;
}
function _getRootNode(beans) {
  return beans.eGridDiv.getRootNode();
}
function _getActiveDomElement(beans) {
  return _getRootNode(beans).activeElement;
}
function _getPageBody(beans) {
  let rootNode = null;
  let targetEl = null;
  try {
    rootNode = _getDocument(beans).fullscreenElement;
  } catch (e) {
  } finally {
    if (!rootNode) {
      rootNode = _getRootNode(beans);
    }
    const body = rootNode.querySelector("body");
    if (body) {
      targetEl = body;
    } else if (rootNode instanceof ShadowRoot) {
      targetEl = rootNode;
    } else if (rootNode instanceof Document) {
      targetEl = rootNode?.documentElement;
    } else {
      targetEl = rootNode;
    }
  }
  return targetEl;
}
function _getBodyWidth(beans) {
  const body = _getPageBody(beans);
  return body?.clientWidth ?? (window.innerHeight || -1);
}
function _getBodyHeight(beans) {
  const body = _getPageBody(beans);
  return body?.clientHeight ?? (window.innerHeight || -1);
}
function _anchorElementToMouseMoveEvent(element, mouseMoveEvent, beans) {
  const eRect = element.getBoundingClientRect();
  const height = eRect.height;
  const browserWidth = _getBodyWidth(beans) - 2;
  const browserHeight = _getBodyHeight(beans) - 2;
  const offsetParent = element.offsetParent;
  if (!offsetParent) {
    return;
  }
  const offsetParentSize = _getElementRectWithOffset(element.offsetParent);
  const { clientY, clientX } = mouseMoveEvent;
  let top = clientY - offsetParentSize.top - height / 2;
  let left = clientX - offsetParentSize.left - 10;
  const eDocument = _getDocument(beans);
  const win = eDocument.defaultView || window;
  const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
  const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
  if (browserWidth > 0 && left + element.clientWidth > browserWidth + windowScrollX) {
    left = browserWidth + windowScrollX - element.clientWidth;
  }
  if (left < 0) {
    left = 0;
  }
  if (browserHeight > 0 && top + element.clientHeight > browserHeight + windowScrollY) {
    top = browserHeight + windowScrollY - element.clientHeight;
  }
  if (top < 0) {
    top = 0;
  }
  element.style.left = `${left}px`;
  element.style.top = `${top}px`;
}
function _isNothingFocused(beans) {
  const eDocument = _getDocument(beans);
  const activeEl = _getActiveDomElement(beans);
  return activeEl === null || activeEl === eDocument.body;
}
function _isAnimateRows(gos) {
  if (gos.get("ensureDomOrder")) {
    return false;
  }
  return gos.get("animateRows");
}
function _isGroupRowsSticky(gos) {
  if (gos.get("paginateChildRows") || gos.get("groupHideOpenParents") || _isDomLayout(gos, "print")) {
    return false;
  }
  return true;
}
function _isColumnsSortingCoupledToGroup(gos) {
  const autoGroupColumnDef = gos.get("autoGroupColumnDef");
  return !autoGroupColumnDef?.comparator && !gos.get("treeData");
}
function _getGroupAggFiltering(gos) {
  const userValue = gos.get("groupAggFiltering");
  if (typeof userValue === "function") {
    return gos.getCallback("groupAggFiltering");
  }
  if (userValue === true) {
    return () => true;
  }
  return void 0;
}
function _getGrandTotalRow(gos) {
  return gos.get("grandTotalRow");
}
function _getGroupTotalRowCallback(gos) {
  const userValue = gos.get("groupTotalRow");
  if (typeof userValue === "function") {
    return gos.getCallback("groupTotalRow");
  }
  return () => userValue ?? void 0;
}
function _isGroupMultiAutoColumn(gos) {
  if (gos.exists("groupDisplayType")) {
    return gos.get("groupDisplayType") === "multipleColumns";
  }
  return gos.get("groupHideOpenParents");
}
function _isGroupUseEntireRow(gos, pivotMode) {
  if (pivotMode) {
    return false;
  }
  return gos.get("groupDisplayType") === "groupRows";
}
function _getRowIdCallback(gos) {
  const getRowId = gos.getCallback("getRowId");
  if (getRowId === void 0) {
    return getRowId;
  }
  return (params) => {
    let id = getRowId(params);
    if (typeof id !== "string") {
      _warn(25, { id });
      id = String(id);
    }
    return id;
  };
}
function _canSkipShowingRowGroup(gos, node) {
  const isSkippingGroups = gos.get("groupHideParentOfSingleChild");
  if (isSkippingGroups === true) {
    return true;
  }
  if (isSkippingGroups === "leafGroupsOnly" && node.leafGroup) {
    return true;
  }
  if (gos.get("groupRemoveSingleChildren")) {
    return true;
  }
  if (gos.get("groupRemoveLowestSingleChildren") && node.leafGroup) {
    return true;
  }
  return false;
}
function _getMaxConcurrentDatasourceRequests(gos) {
  const res = gos.get("maxConcurrentDatasourceRequests");
  return res > 0 ? res : void 0;
}
function _shouldUpdateColVisibilityAfterGroup(gos, isGrouped) {
  const preventVisibilityChanges = gos.get("suppressGroupChangesColumnVisibility");
  if (preventVisibilityChanges === true) {
    return false;
  }
  if (isGrouped && preventVisibilityChanges === "suppressHideOnGroup") {
    return false;
  }
  if (!isGrouped && preventVisibilityChanges === "suppressShowOnUngroup") {
    return false;
  }
  const legacySuppressOnGroup = gos.get("suppressRowGroupHidesColumns");
  if (isGrouped && legacySuppressOnGroup === true) {
    return false;
  }
  const legacySuppressOnUngroup = gos.get("suppressMakeColumnVisibleAfterUnGroup");
  if (!isGrouped && legacySuppressOnUngroup === true) {
    return false;
  }
  return true;
}
function _getCheckboxes(selection) {
  return selection?.checkboxes ?? true;
}
function _getHeaderCheckbox(selection) {
  return selection?.mode === "multiRow" && (selection.headerCheckbox ?? true);
}
function _getCheckboxLocation(rowSelection) {
  if (typeof rowSelection !== "object") {
    return void 0;
  }
  return rowSelection.checkboxLocation ?? "selectionColumn";
}
function _getHideDisabledCheckboxes(selection) {
  return selection?.hideDisabledCheckboxes ?? false;
}
function _isUsingNewRowSelectionAPI(gos) {
  const rowSelection = gos.get("rowSelection");
  return typeof rowSelection !== "string";
}
function _isUsingNewCellSelectionAPI(gos) {
  return gos.get("cellSelection") !== void 0;
}
function _getSuppressMultiRanges(gos) {
  const selection = gos.get("cellSelection");
  const useNewAPI = selection !== void 0;
  if (!useNewAPI) {
    return gos.get("suppressMultiRangeSelection");
  }
  return typeof selection !== "boolean" ? selection?.suppressMultiRanges ?? false : false;
}
function _isCellSelectionEnabled(gos) {
  const selection = gos.get("cellSelection");
  const useNewAPI = selection !== void 0;
  return useNewAPI ? !!selection : gos.get("enableRangeSelection");
}
function _getFillHandle(gos) {
  const selection = gos.get("cellSelection");
  const useNewAPI = selection !== void 0;
  if (!useNewAPI) {
    return {
      mode: "fill",
      setFillValue: gos.get("fillOperation"),
      direction: gos.get("fillHandleDirection"),
      suppressClearOnFillReduction: gos.get("suppressClearOnFillReduction")
    };
  }
  return typeof selection !== "boolean" && selection.handle?.mode === "fill" ? selection.handle : void 0;
}
function _getEnableClickSelection(gos) {
  const selection = gos.get("rowSelection") ?? "single";
  if (typeof selection === "string") {
    const suppressRowClickSelection = gos.get("suppressRowClickSelection");
    const suppressRowDeselection = gos.get("suppressRowDeselection");
    if (suppressRowClickSelection && suppressRowDeselection) {
      return false;
    } else if (suppressRowClickSelection) {
      return "enableDeselection";
    } else if (suppressRowDeselection) {
      return "enableSelection";
    } else {
      return true;
    }
  }
  return selection.mode === "singleRow" || selection.mode === "multiRow" ? selection.enableClickSelection ?? false : false;
}
function _getEnableSelection(gos) {
  const enableClickSelection = _getEnableClickSelection(gos);
  return enableClickSelection === true || enableClickSelection === "enableSelection";
}
function _getEnableDeselection(gos) {
  const enableClickSelection = _getEnableClickSelection(gos);
  return enableClickSelection === true || enableClickSelection === "enableDeselection";
}
function _getIsRowSelectable(gos) {
  const selection = gos.get("rowSelection");
  if (typeof selection === "string") {
    return gos.get("isRowSelectable");
  }
  return selection?.isRowSelectable;
}
function _getRowSelectionMode(gos) {
  const selection = gos.get("rowSelection");
  if (typeof selection === "string") {
    switch (selection) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  }
  switch (selection?.mode) {
    case "multiRow":
    case "singleRow":
      return selection.mode;
    default:
      return;
  }
}
function _isMultiRowSelection(gos) {
  const mode = _getRowSelectionMode(gos);
  return mode === "multiRow";
}
function _getEnableSelectionWithoutKeys(gos) {
  const selection = gos.get("rowSelection");
  if (typeof selection === "string") {
    return gos.get("rowMultiSelectWithClick");
  }
  return selection?.enableSelectionWithoutKeys ?? false;
}
function _getGroupSelection(gos) {
  const selection = gos.get("rowSelection");
  if (typeof selection === "string") {
    const groupSelectsChildren = gos.get("groupSelectsChildren");
    const groupSelectsFiltered = gos.get("groupSelectsFiltered");
    if (groupSelectsChildren && groupSelectsFiltered) {
      return "filteredDescendants";
    } else if (groupSelectsChildren) {
      return "descendants";
    } else {
      return "self";
    }
  }
  return selection?.mode === "multiRow" ? selection.groupSelects : void 0;
}
function _getSelectAll(gos, defaultValue = true) {
  const rowSelection = gos.get("rowSelection");
  if (typeof rowSelection !== "object") {
    return defaultValue ? "all" : void 0;
  }
  return rowSelection.mode === "multiRow" ? rowSelection.selectAll : "all";
}
function _getGroupSelectsDescendants(gos) {
  const groupSelection = _getGroupSelection(gos);
  return groupSelection === "descendants" || groupSelection === "filteredDescendants";
}
function _isSetFilterByDefault(gos) {
  return gos.isModuleRegistered("SetFilter") && !gos.get("suppressSetFilterByDefault");
}
function _isLegacyMenuEnabled(gos) {
  return gos.get("columnMenu") === "legacy";
}
function _isColumnMenuAnchoringEnabled(gos) {
  return !_isLegacyMenuEnabled(gos);
}
function _getCallbackForEvent(eventName) {
  if (!eventName || eventName.length < 2) {
    return eventName;
  }
  return "on" + eventName[0].toUpperCase() + eventName.substring(1);
}
function _combineAttributesAndGridOptions(gridOptions, component, gridOptionsKeys) {
  if (typeof gridOptions !== "object") {
    gridOptions = {};
  }
  const mergedOptions = { ...gridOptions };
  gridOptionsKeys.forEach((key) => {
    const value = component[key];
    if (typeof value !== "undefined") {
      mergedOptions[key] = value;
    }
  });
  return mergedOptions;
}
function _processOnChange(changes, api) {
  if (!changes) {
    return;
  }
  const gridChanges = {};
  let hasChanges = false;
  Object.keys(changes).forEach((key) => {
    gridChanges[key] = changes[key];
    hasChanges = true;
  });
  if (!hasChanges) {
    return;
  }
  const internalUpdateEvent = {
    type: "gridOptionsChanged",
    options: gridChanges
  };
  api.dispatchEvent(internalUpdateEvent);
  const event = {
    type: "componentStateChanged",
    ...gridChanges
  };
  api.dispatchEvent(event);
}

// packages/ag-grid-community/src/utils/event.ts
var AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
var PASSIVE_EVENTS = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"];
var NON_PASSIVE_EVENTS = ["wheel"];
var supports = {};
function _stopPropagationForAgGrid(event) {
  event[AG_GRID_STOP_PROPAGATION] = true;
}
function _isStopPropagationForAgGrid(event) {
  return event[AG_GRID_STOP_PROPAGATION] === true;
}
var _isEventSupported = /* @__PURE__ */ (() => {
  const tags = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  const eventChecker = (eventName) => {
    if (typeof supports[eventName] === "boolean") {
      return supports[eventName];
    }
    const el = document.createElement(tags[eventName] || "div");
    eventName = "on" + eventName;
    return supports[eventName] = eventName in el;
  };
  return eventChecker;
})();
function _getCtrlForEventTarget(gos, eventTarget, type) {
  let sourceElement = eventTarget;
  while (sourceElement) {
    const renderedComp = _getDomData(gos, sourceElement, type);
    if (renderedComp) {
      return renderedComp;
    }
    sourceElement = sourceElement.parentElement;
  }
  return null;
}
function _isElementInEventPath(element, event) {
  if (!event || !element) {
    return false;
  }
  return _getEventPath(event).indexOf(element) >= 0;
}
function _createEventPath(event) {
  const res = [];
  let pointer = event.target;
  while (pointer) {
    res.push(pointer);
    pointer = pointer.parentElement;
  }
  return res;
}
function _getEventPath(event) {
  const eventNoType = event;
  if (eventNoType.path) {
    return eventNoType.path;
  }
  if (eventNoType.composedPath) {
    return eventNoType.composedPath();
  }
  return _createEventPath(eventNoType);
}
function _addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
  const passive = getPassiveStateForEvent(event);
  let options;
  if (passive != null) {
    options = { passive };
  }
  if (frameworkOverrides && frameworkOverrides.addEventListener) {
    frameworkOverrides.addEventListener(eElement, event, listener, options);
  }
}
var getPassiveStateForEvent = (event) => {
  const isPassive = PASSIVE_EVENTS.includes(event);
  const isNonPassive = NON_PASSIVE_EVENTS.includes(event);
  if (isPassive) {
    return true;
  }
  if (isNonPassive) {
    return false;
  }
};

// packages/ag-grid-community/src/context/beanStub.ts
var BeanStub = class {
  constructor() {
    // not named context to allow children to use 'context' as a variable name
    this.destroyFunctions = [];
    this.destroyed = false;
    // for vue 3 - prevents Vue from trying to make this (and obviously any sub classes) from being reactive
    // prevents vue from creating proxies for created objects and prevents identity related issues
    this.__v_skip = true;
    this.propertyListenerId = 0;
    // Enable multiple grid properties to be updated together by the user but only trigger shared logic once.
    // Closely related to logic in GridOptionsUtils.ts _processOnChange
    this.lastChangeSetIdLookup = {};
    this.isAlive = () => !this.destroyed;
  }
  preWireBeans(beans) {
    this.beans = beans;
    this.stubContext = beans.context;
    this.eventSvc = beans.eventSvc;
    this.gos = beans.gos;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  destroy() {
    const { destroyFunctions } = this;
    for (let i = 0; i < destroyFunctions.length; i++) {
      destroyFunctions[i]();
    }
    destroyFunctions.length = 0;
    this.destroyed = true;
    this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventSvc to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(eventType, listener, async) {
    if (!this.localEventService) {
      this.localEventService = new LocalEventService();
    }
    this.localEventService.addEventListener(eventType, listener, async);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(eventType, listener, async) {
    this.localEventService?.removeEventListener(eventType, listener, async);
  }
  dispatchLocalEvent(event) {
    this.localEventService?.dispatchEvent(event);
  }
  addManagedElementListeners(object, handlers) {
    return this._setupListeners(object, handlers);
  }
  addManagedEventListeners(handlers) {
    return this._setupListeners(this.eventSvc, handlers);
  }
  addManagedListeners(object, handlers) {
    return this._setupListeners(object, handlers);
  }
  _setupListeners(object, handlers) {
    const destroyFuncs = [];
    for (const k of Object.keys(handlers)) {
      const handler = handlers[k];
      if (handler) {
        destroyFuncs.push(this._setupListener(object, k, handler));
      }
    }
    return destroyFuncs;
  }
  _setupListener(object, event, listener) {
    if (this.destroyed) {
      return () => null;
    }
    if (object instanceof HTMLElement) {
      _addSafePassiveEventListener(this.beans.frameworkOverrides, object, event, listener);
    } else {
      object.addEventListener(event, listener);
    }
    const destroyFunc = () => {
      object.removeEventListener(event, listener);
      return null;
    };
    this.destroyFunctions.push(destroyFunc);
    return () => {
      destroyFunc();
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(event, listener) {
    const { gos } = this;
    gos.addPropertyEventListener(event, listener);
    const destroyFunc = () => {
      gos.removePropertyEventListener(event, listener);
      return null;
    };
    this.destroyFunctions.push(destroyFunc);
    return () => {
      destroyFunc();
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(event, listener) {
    if (this.destroyed) {
      return () => null;
    }
    return this.setupGridOptionListener(event, listener);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(events, listener) {
    if (this.destroyed) {
      return;
    }
    const eventsKey = events.join("-") + this.propertyListenerId++;
    const wrappedListener = (event) => {
      if (event.changeSet) {
        if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) {
          return;
        }
        this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
      }
      const propertiesChangeEvent = {
        type: "gridPropertyChanged",
        changeSet: event.changeSet,
        source: event.source
      };
      listener(propertiesChangeEvent);
    };
    events.forEach((event) => this.setupGridOptionListener(event, wrappedListener));
  }
  getLocaleTextFunc() {
    return _getLocaleTextFunc(this.beans.localeSvc);
  }
  addDestroyFunc(func) {
    if (this.isAlive()) {
      this.destroyFunctions.push(func);
    } else {
      func();
    }
  }
  /** doesn't throw an error if `bean` is undefined */
  createOptionalManagedBean(bean, context) {
    return bean ? this.createManagedBean(bean, context) : void 0;
  }
  createManagedBean(bean, context) {
    const res = this.createBean(bean, context);
    this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
    return res;
  }
  createBean(bean, context, afterPreCreateCallback) {
    return (context || this.stubContext).createBean(bean, afterPreCreateCallback);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(bean, context) {
    return (context || this.stubContext).destroyBean(bean);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(beans, context) {
    return (context || this.stubContext).destroyBeans(beans);
  }
};

// packages/ag-grid-community/src/utils/object.ts
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function _iterateObject(object, callback) {
  if (object == null) {
    return;
  }
  if (Array.isArray(object)) {
    for (let i = 0; i < object.length; i++) {
      callback(i.toString(), object[i]);
    }
    return;
  }
  for (const [key, value] of Object.entries(object)) {
    callback(key, value);
  }
}
function _mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
  if (!_exists(source)) {
    return;
  }
  _iterateObject(source, (key, sourceValue) => {
    if (SKIP_JS_BUILTINS.has(key)) {
      return;
    }
    let destValue = dest[key];
    if (destValue === sourceValue) {
      return;
    }
    if (makeCopyOfSimpleObjects) {
      const objectIsDueToBeCopied = destValue == null && sourceValue != null;
      if (objectIsDueToBeCopied) {
        const doNotCopyAsSourceIsSimpleObject = typeof sourceValue === "object" && sourceValue.constructor === Object;
        if (doNotCopyAsSourceIsSimpleObject) {
          destValue = {};
          dest[key] = destValue;
        }
      }
    }
    if (_isNonNullObject(sourceValue) && _isNonNullObject(destValue) && !Array.isArray(destValue)) {
      _mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
    } else if (copyUndefined || sourceValue !== void 0) {
      dest[key] = sourceValue;
    }
  });
}
function _getValueUsingField(data, field, fieldContainsDots) {
  if (!field || !data) {
    return;
  }
  if (!fieldContainsDots) {
    return data[field];
  }
  const fields = field.split(".");
  let currentObject = data;
  for (let i = 0; i < fields.length; i++) {
    if (currentObject == null) {
      return void 0;
    }
    currentObject = currentObject[fields[i]];
  }
  return currentObject;
}
function _isNonNullObject(value) {
  return typeof value === "object" && value !== null;
}

// packages/ag-grid-community/src/entities/agColumn.ts
var COL_DEF_DEFAULTS = {
  resizable: true,
  sortable: true
};
var instanceIdSequence = 0;
function getNextColInstanceId() {
  return instanceIdSequence++;
}
function isColumn(col) {
  return col instanceof AgColumn;
}
var AgColumn = class extends BeanStub {
  constructor(colDef, userProvidedColDef, colId, primary) {
    super();
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.colId = colId;
    this.primary = primary;
    this.isColumn = true;
    // used by React (and possibly other frameworks) as key for rendering. also used to
    // identify old vs new columns for destroying cols when no longer used.
    this.instanceId = getNextColInstanceId();
    // The measured height of this column's header when autoHeaderHeight is enabled
    this.autoHeaderHeight = null;
    this.moving = false;
    this.menuVisible = false;
    this.lastLeftPinned = false;
    this.firstRightPinned = false;
    this.filterActive = false;
    this.colEventSvc = new LocalEventService();
    this.tooltipEnabled = false;
    this.rowGroupActive = false;
    this.pivotActive = false;
    this.aggregationActive = false;
    this.flex = null;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState() {
    const {
      colDef,
      beans: { sortSvc, pinnedCols, colFlex }
    } = this;
    sortSvc?.initCol(this);
    const hide = colDef.hide;
    if (hide !== void 0) {
      this.visible = !hide;
    } else {
      this.visible = !colDef.initialHide;
    }
    pinnedCols?.initCol(this);
    colFlex?.initCol(this);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(colDef, userProvidedColDef, source) {
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.initMinAndMaxWidths();
    this.initDotNotation();
    this.initTooltip();
    this.dispatchColEvent("colDefChanged", source);
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  getParent() {
    return this.parent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.setState();
    this.initMinAndMaxWidths();
    this.resetActualWidth("gridInitializing");
    this.initDotNotation();
    this.initTooltip();
  }
  initDotNotation() {
    const {
      gos,
      colDef: { field, tooltipField }
    } = this;
    const suppressDotNotation = gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = _exists(field) && field.indexOf(".") >= 0 && !suppressDotNotation;
    this.tooltipFieldContainsDots = _exists(tooltipField) && tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
  }
  initMinAndMaxWidths() {
    const colDef = this.colDef;
    this.minWidth = colDef.minWidth ?? this.beans.environment.getDefaultColumnMinWidth();
    this.maxWidth = colDef.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.beans.tooltipSvc?.initCol(this);
  }
  resetActualWidth(source) {
    const initialWidth = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(initialWidth, source, true);
  }
  calculateColInitialWidth(colDef) {
    let width;
    const colDefWidth = colDef.width;
    const colDefInitialWidth = colDef.initialWidth;
    if (colDefWidth != null) {
      width = colDefWidth;
    } else if (colDefInitialWidth != null) {
      width = colDefInitialWidth;
    } else {
      width = 200;
    }
    return Math.max(Math.min(width, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return false;
  }
  isRowGroupDisplayed(colId) {
    return this.beans.showRowGroupCols?.isRowGroupDisplayed(this, colId) ?? false;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    const filterDefined = !!this.colDef.filter;
    return filterDefined;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  addEventListener(eventType, userListener) {
    this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(
      this.frameworkEventListenerService,
      this.colEventSvc
    );
    const listener = this.frameworkEventListenerService?.wrap(userListener) ?? userListener;
    this.colEventSvc.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, userListener) {
    const listener = this.frameworkEventListenerService?.unwrap(userListener) ?? userListener;
    this.colEventSvc.removeEventListener(eventType, listener);
  }
  createColumnFunctionCallbackParams(rowNode) {
    return this.gos.addGridCommonParams({
      node: rowNode,
      data: rowNode.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(rowNode) {
    return this.beans.cellNavigation?.isSuppressNavigable(this, rowNode) ?? false;
  }
  isCellEditable(rowNode) {
    return this.beans.editSvc?.isCellEditable(this, rowNode) ?? false;
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.rowDrag);
  }
  isDndSource(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.dndSource);
  }
  isCellCheckboxSelection(rowNode) {
    return this.beans.selectionSvc?.isCellCheckboxSelection(this, rowNode) ?? false;
  }
  isSuppressPaste(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef?.suppressPaste ?? null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(key) {
    return this.colDef[key] ?? COL_DEF_DEFAULTS[key];
  }
  isColumnFunc(rowNode, value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "function") {
      const params = this.createColumnFunctionCallbackParams(rowNode);
      const editableFunc = value;
      return editableFunc(params);
    }
    return false;
  }
  createColumnEvent(type, source) {
    return this.gos.addGridCommonParams({
      type,
      column: this,
      columns: [this],
      source
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return _missing(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return _exists(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(left, source) {
    this.oldLeft = this.left;
    if (this.left !== left) {
      this.left = left;
      this.dispatchColEvent("leftChanged", source);
    }
  }
  isFilterActive() {
    return this.filterActive;
  }
  /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
  isHovered() {
    _warn(261);
    return !!this.beans.colHover?.isHovered(this);
  }
  setFirstRightPinned(firstRightPinned, source) {
    if (this.firstRightPinned !== firstRightPinned) {
      this.firstRightPinned = firstRightPinned;
      this.dispatchColEvent("firstRightPinnedChanged", source);
    }
  }
  setLastLeftPinned(lastLeftPinned, source) {
    if (this.lastLeftPinned !== lastLeftPinned) {
      this.lastLeftPinned = lastLeftPinned;
      this.dispatchColEvent("lastLeftPinnedChanged", source);
    }
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(visible, source) {
    const newValue = visible === true;
    if (this.visible !== newValue) {
      this.visible = newValue;
      this.dispatchColEvent("visibleChanged", source);
    }
    this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const colDef = this.getColDef();
    return !colDef.suppressSpanHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let parent = this.getParent();
    if (!parent || !parent.isPadding()) {
      return { numberOfParents: 0, isSpanningTotal: false };
    }
    const numberOfParents = parent.getPaddingLevel() + 1;
    let isSpanningTotal = true;
    while (parent) {
      if (!parent.isPadding()) {
        isSpanningTotal = false;
        break;
      }
      parent = parent.getParent();
    }
    return { numberOfParents, isSpanningTotal };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(height) {
    const changed = height !== this.autoHeaderHeight;
    this.autoHeaderHeight = height;
    return changed;
  }
  createBaseColDefParams(rowNode) {
    const params = this.gos.addGridCommonParams({
      node: rowNode,
      data: rowNode.data,
      colDef: this.colDef,
      column: this
    });
    return params;
  }
  getColSpan(rowNode) {
    if (_missing(this.colDef.colSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const colSpan = this.colDef.colSpan(params);
    return Math.max(colSpan, 1);
  }
  getRowSpan(rowNode) {
    if (_missing(this.colDef.rowSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const rowSpan = this.colDef.rowSpan(params);
    return Math.max(rowSpan, 1);
  }
  setActualWidth(actualWidth, source, silent = false) {
    actualWidth = Math.max(actualWidth, this.minWidth);
    actualWidth = Math.min(actualWidth, this.maxWidth);
    if (this.actualWidth !== actualWidth) {
      this.actualWidth = actualWidth;
      if (this.flex && source !== "flex" && source !== "gridInitializing") {
        this.flex = null;
      }
      if (!silent) {
        this.fireColumnWidthChangedEvent(source);
      }
    }
    this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(source) {
    this.dispatchColEvent("widthChanged", source);
  }
  isGreaterThanMax(width) {
    return width > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex;
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === true;
  }
  isAllowValue() {
    return this.colDef.enableValue === true;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === true;
  }
  dispatchColEvent(type, source, additionalEventAttributes) {
    const colEvent = this.createColumnEvent(type, source);
    if (additionalEventAttributes) {
      _mergeDeep(colEvent, additionalEventAttributes);
    }
    this.colEventSvc.dispatchEvent(colEvent);
  }
  dispatchStateUpdatedEvent(key) {
    this.colEventSvc.dispatchEvent({
      type: "columnStateUpdated",
      key
    });
  }
};

// packages/ag-grid-community/src/entities/agProvidedColumnGroup.ts
function isProvidedColumnGroup(col) {
  return col instanceof AgProvidedColumnGroup;
}
var AgProvidedColumnGroup = class extends BeanStub {
  constructor(colGroupDef, groupId, padding, level) {
    super();
    this.colGroupDef = colGroupDef;
    this.groupId = groupId;
    this.padding = padding;
    this.level = level;
    this.isColumn = false;
    this.expandable = false;
    // used by React (and possibly other frameworks) as key for rendering. also used to
    // identify old vs new columns for destroying cols when no longer used.
    this.instanceId = getNextColInstanceId();
    this.expandableListenerRemoveCallback = null;
    this.expanded = !!colGroupDef?.openByDefault;
  }
  destroy() {
    if (this.expandableListenerRemoveCallback) {
      this.reset(null, void 0);
    }
    super.destroy();
  }
  reset(colGroupDef, level) {
    this.colGroupDef = colGroupDef;
    this.level = level;
    this.originalParent = null;
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    this.children = void 0;
    this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    if (this.children) {
      return this.children.some((child) => child.isVisible());
    }
    return false;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(expanded) {
    this.expanded = expanded === void 0 ? false : expanded;
    this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(children) {
    this.children = children;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  addLeafColumns(leafColumns) {
    if (!this.children) {
      return;
    }
    this.children.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isProvidedColumnGroup(child)) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getColumnGroupShow() {
    const colGroupDef = this.colGroupDef;
    if (!colGroupDef) {
      return;
    }
    return colGroupDef.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable();
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    const listener = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((col) => col.addEventListener("visibleChanged", listener));
    this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((col) => col.removeEventListener("visibleChanged", listener));
      this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding()) {
      return;
    }
    let atLeastOneShowingWhenOpen = false;
    let atLeastOneShowingWhenClosed = false;
    let atLeastOneChangeable = false;
    const children = this.findChildrenRemovingPadding();
    for (let i = 0, j = children.length; i < j; i++) {
      const abstractColumn = children[i];
      if (!abstractColumn.isVisible()) {
        continue;
      }
      const headerGroupShow = abstractColumn.getColumnGroupShow();
      if (headerGroupShow === "open") {
        atLeastOneShowingWhenOpen = true;
        atLeastOneChangeable = true;
      } else if (headerGroupShow === "closed") {
        atLeastOneShowingWhenClosed = true;
        atLeastOneChangeable = true;
      } else {
        atLeastOneShowingWhenOpen = true;
        atLeastOneShowingWhenClosed = true;
      }
    }
    const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
    if (this.expandable !== expandable) {
      this.expandable = expandable;
      this.dispatchLocalEvent({ type: "expandableChanged" });
    }
  }
  findChildrenRemovingPadding() {
    const res = [];
    const process = (items) => {
      items.forEach((item) => {
        const skipBecausePadding = isProvidedColumnGroup(item) && item.isPadding();
        if (skipBecausePadding) {
          process(item.children);
        } else {
          res.push(item);
        }
      });
    };
    process(this.children);
    return res;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
};

// packages/ag-grid-community/src/entities/defaultColumnTypes.ts
var DefaultColumnTypes = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};

// packages/ag-grid-community/src/columns/columnKeyCreator.ts
var ColumnKeyCreator = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(keys) {
    for (let i = 0; i < keys.length; i++) {
      this.existingKeys[keys[i]] = true;
    }
  }
  getUniqueKey(colId, colField) {
    colId = _toStringOrNull(colId);
    let count = 0;
    while (true) {
      let idToTry = colId ?? colField;
      if (idToTry) {
        if (count !== 0) {
          idToTry += "_" + count;
        }
      } else {
        idToTry = count;
      }
      if (!this.existingKeys[idToTry]) {
        this.existingKeys[idToTry] = true;
        return String(idToTry);
      }
      count++;
    }
  }
};

// packages/ag-grid-community/src/utils/array.ts
var _EmptyArray = Object.freeze([]);
function _last(arr) {
  if (!arr?.length) {
    return;
  }
  return arr[arr.length - 1];
}
function _areEqual(a, b, comparator) {
  if (a == null && b == null) {
    return true;
  }
  return a != null && b != null && a.length === b.length && a.every((value, index) => comparator ? comparator(value, b[index]) : b[index] === value);
}
function _sortNumerically(array) {
  return array.sort((a, b) => a - b);
}
function _removeFromArray(array, object) {
  const index = array.indexOf(object);
  if (index >= 0) {
    array.splice(index, 1);
  }
}
function _moveInArray(array, objectsToMove, toIndex) {
  for (let i = 0; i < objectsToMove.length; i++) {
    _removeFromArray(array, objectsToMove[i]);
  }
  for (let i = objectsToMove.length - 1; i >= 0; i--) {
    array.splice(toIndex, 0, objectsToMove[i]);
  }
}

// packages/ag-grid-community/src/columnMove/columnMoveUtils.ts
function placeLockedColumns(cols, gos) {
  const left = [];
  const normal = [];
  const right = [];
  cols.forEach((col) => {
    const position = col.getColDef().lockPosition;
    if (position === "right") {
      right.push(col);
    } else if (position === "left" || position === true) {
      left.push(col);
    } else {
      normal.push(col);
    }
  });
  const isRtl = gos.get("enableRtl");
  if (isRtl) {
    return [...right, ...normal, ...left];
  }
  return [...left, ...normal, ...right];
}
function doesMovePassMarryChildren(allColumnsCopy, gridBalancedTree) {
  let rulePassed = true;
  depthFirstOriginalTreeSearch(null, gridBalancedTree, (child) => {
    if (!isProvidedColumnGroup(child)) {
      return;
    }
    const columnGroup = child;
    const colGroupDef = columnGroup.getColGroupDef();
    const marryChildren = colGroupDef && colGroupDef.marryChildren;
    if (!marryChildren) {
      return;
    }
    const newIndexes = [];
    columnGroup.getLeafColumns().forEach((col) => {
      const newColIndex = allColumnsCopy.indexOf(col);
      newIndexes.push(newColIndex);
    });
    const maxIndex = Math.max.apply(Math, newIndexes);
    const minIndex = Math.min.apply(Math, newIndexes);
    const spread = maxIndex - minIndex;
    const maxSpread = columnGroup.getLeafColumns().length - 1;
    if (spread > maxSpread) {
      rulePassed = false;
    }
  });
  return rulePassed;
}

// packages/ag-grid-community/src/columns/columnEventUtils.ts
function getCommonValue(cols, valueGetter) {
  if (!cols || cols.length == 0) {
    return void 0;
  }
  const firstValue = valueGetter(cols[0]);
  for (let i = 1; i < cols.length; i++) {
    if (firstValue !== valueGetter(cols[i])) {
      return void 0;
    }
  }
  return firstValue;
}
function dispatchColumnPinnedEvent(eventSvc, changedColumns, source) {
  if (!changedColumns.length) {
    return;
  }
  const column = changedColumns.length === 1 ? changedColumns[0] : null;
  const pinned = getCommonValue(changedColumns, (col) => col.getPinned());
  eventSvc.dispatchEvent({
    type: "columnPinned",
    // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
    pinned: pinned != null ? pinned : null,
    columns: changedColumns,
    column,
    source
  });
}
function dispatchColumnVisibleEvent(eventSvc, changedColumns, source) {
  if (!changedColumns.length) {
    return;
  }
  const column = changedColumns.length === 1 ? changedColumns[0] : null;
  const visible = getCommonValue(changedColumns, (col) => col.isVisible());
  eventSvc.dispatchEvent({
    type: "columnVisible",
    visible,
    columns: changedColumns,
    column,
    source
  });
}
function dispatchColumnChangedEvent(eventSvc, type, columns, source) {
  eventSvc.dispatchEvent({
    type,
    columns,
    column: columns && columns.length == 1 ? columns[0] : null,
    source
  });
}
function dispatchColumnResizedEvent(eventSvc, columns, finished, source, flexColumns = null) {
  if (columns?.length) {
    eventSvc.dispatchEvent({
      type: "columnResized",
      columns,
      column: columns.length === 1 ? columns[0] : null,
      flexColumns,
      finished,
      source
    });
  }
}

// packages/ag-grid-community/src/columns/columnStateUtils.ts
function _applyColumnState(beans, params, source) {
  const {
    colModel,
    rowGroupColsSvc,
    pivotColsSvc,
    autoColSvc,
    selectionColSvc,
    colAnimation,
    visibleCols,
    pivotResultCols,
    environment,
    valueColsSvc,
    eventSvc,
    gos
  } = beans;
  const providedCols = colModel.getColDefCols() || [];
  if (!providedCols?.length) {
    return false;
  }
  if (params?.state && !params.state.forEach) {
    _warn(32);
    return false;
  }
  const syncColumnWithStateItem = (column, stateItem, rowGroupIndexes, pivotIndexes, autoCol) => {
    if (!column) {
      return;
    }
    const getValue = getValueFactory(stateItem, params.defaultState);
    const flex = getValue("flex").value1;
    updateSomeColumnState(
      beans,
      column,
      getValue("hide").value1,
      getValue("sort").value1,
      getValue("sortIndex").value1,
      getValue("pinned").value1,
      flex,
      source
    );
    if (flex == null) {
      const width = getValue("width").value1;
      if (width != null) {
        const minColWidth = column.getColDef().minWidth ?? environment.getDefaultColumnMinWidth();
        if (minColWidth != null && width >= minColWidth) {
          column.setActualWidth(width, source);
        }
      }
    }
    if (autoCol || !column.isPrimary()) {
      return;
    }
    valueColsSvc?.syncColumnWithState(column, source, getValue);
    rowGroupColsSvc?.syncColumnWithState(column, source, getValue, rowGroupIndexes);
    pivotColsSvc?.syncColumnWithState(column, source, getValue, pivotIndexes);
  };
  const applyStates = (states, existingColumns, getById2) => {
    const dispatchEventsFunc = _compareColumnStatesAndDispatchEvents(beans, source);
    const columnsWithNoState = existingColumns.slice();
    const rowGroupIndexes = {};
    const pivotIndexes = {};
    const autoColStates = [];
    const selectionColStates = [];
    const unmatchedAndAutoStates2 = [];
    let unmatchedCount2 = 0;
    const previousRowGroupCols = rowGroupColsSvc?.columns.slice() ?? [];
    const previousPivotCols = pivotColsSvc?.columns.slice() ?? [];
    states.forEach((state) => {
      const colId = state.colId;
      const isAutoGroupColumn = colId.startsWith(GROUP_AUTO_COLUMN_ID);
      if (isAutoGroupColumn) {
        autoColStates.push(state);
        unmatchedAndAutoStates2.push(state);
        return;
      }
      if (isColumnSelectionCol(colId)) {
        selectionColStates.push(state);
        unmatchedAndAutoStates2.push(state);
        return;
      }
      const column = getById2(colId);
      if (!column) {
        unmatchedAndAutoStates2.push(state);
        unmatchedCount2 += 1;
      } else {
        syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, false);
        _removeFromArray(columnsWithNoState, column);
      }
    });
    const applyDefaultsFunc = (col) => syncColumnWithStateItem(col, null, rowGroupIndexes, pivotIndexes, false);
    columnsWithNoState.forEach(applyDefaultsFunc);
    rowGroupColsSvc?.sortColumns(comparatorByIndex.bind(rowGroupColsSvc, rowGroupIndexes, previousRowGroupCols));
    pivotColsSvc?.sortColumns(comparatorByIndex.bind(pivotColsSvc, pivotIndexes, previousPivotCols));
    colModel.refreshCols(false);
    const syncColStates = (getCol, colStates, columns = []) => {
      colStates.forEach((stateItem) => {
        const col = getCol(stateItem.colId);
        _removeFromArray(columns, col);
        syncColumnWithStateItem(col, stateItem, null, null, true);
      });
      columns.forEach(applyDefaultsFunc);
    };
    syncColStates(
      (colId) => autoColSvc?.getAutoCol(colId) ?? null,
      autoColStates,
      autoColSvc?.getAutoCols()?.slice()
    );
    syncColStates(
      (colId) => selectionColSvc?.getSelectionCol(colId) ?? null,
      selectionColStates,
      selectionColSvc?.getSelectionCols()?.slice()
    );
    orderLiveColsLikeState(params, colModel, gos);
    visibleCols.refresh(source);
    eventSvc.dispatchEvent({
      type: "columnEverythingChanged",
      source
    });
    dispatchEventsFunc();
    return { unmatchedAndAutoStates: unmatchedAndAutoStates2, unmatchedCount: unmatchedCount2 };
  };
  colAnimation?.start();
  let { unmatchedAndAutoStates, unmatchedCount } = applyStates(
    params.state || [],
    providedCols,
    (id) => colModel.getColDefCol(id)
  );
  if (unmatchedAndAutoStates.length > 0 || _exists(params.defaultState)) {
    const pivotResultColsList = pivotResultCols?.getPivotResultCols()?.list ?? [];
    unmatchedCount = applyStates(
      unmatchedAndAutoStates,
      pivotResultColsList,
      (id) => pivotResultCols?.getPivotResultCol(id) ?? null
    ).unmatchedCount;
  }
  colAnimation?.finish();
  return unmatchedCount === 0;
}
function _resetColumnState(beans, source) {
  const { colModel, autoColSvc } = beans;
  const primaryCols = colModel.getColDefCols();
  if (!primaryCols?.length) {
    return;
  }
  const primaryColumnTree = colModel.getColDefColTree();
  const primaryColumns = _getColumnsFromTree(primaryColumnTree);
  const columnStates = [];
  let letRowGroupIndex = 1e3;
  let letPivotIndex = 1e3;
  let colsToProcess = [];
  const groupAutoCols = autoColSvc?.getAutoCols();
  if (groupAutoCols) {
    colsToProcess = colsToProcess.concat(groupAutoCols);
  }
  if (primaryColumns) {
    colsToProcess = colsToProcess.concat(primaryColumns);
  }
  colsToProcess.forEach((column) => {
    const stateItem = getColumnStateFromColDef(column);
    if (_missing(stateItem.rowGroupIndex) && stateItem.rowGroup) {
      stateItem.rowGroupIndex = letRowGroupIndex++;
    }
    if (_missing(stateItem.pivotIndex) && stateItem.pivot) {
      stateItem.pivotIndex = letPivotIndex++;
    }
    columnStates.push(stateItem);
  });
  _applyColumnState(beans, { state: columnStates, applyOrder: true }, source);
}
function _compareColumnStatesAndDispatchEvents(beans, source) {
  const { rowGroupColsSvc, pivotColsSvc, valueColsSvc, colModel, sortSvc, eventSvc } = beans;
  const startState = {
    rowGroupColumns: rowGroupColsSvc?.columns.slice() ?? [],
    pivotColumns: pivotColsSvc?.columns.slice() ?? [],
    valueColumns: valueColsSvc?.columns.slice() ?? []
  };
  const columnStateBefore = _getColumnState(beans);
  const columnStateBeforeMap = {};
  columnStateBefore.forEach((col) => {
    columnStateBeforeMap[col.colId] = col;
  });
  return () => {
    const colsForState = colModel.getAllCols();
    const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
      const beforeList = colsBefore.map(idMapper);
      const afterList = colsAfter.map(idMapper);
      const unchanged = _areEqual(beforeList, afterList);
      if (unchanged) {
        return;
      }
      const changes = new Set(colsBefore);
      colsAfter.forEach((id) => {
        if (!changes.delete(id)) {
          changes.add(id);
        }
      });
      const changesArr = [...changes];
      eventSvc.dispatchEvent({
        type: eventType,
        columns: changesArr,
        column: changesArr.length === 1 ? changesArr[0] : null,
        source
      });
    };
    const getChangedColumns = (changedPredicate) => {
      const changedColumns2 = [];
      colsForState.forEach((column) => {
        const colStateBefore = columnStateBeforeMap[column.getColId()];
        if (colStateBefore && changedPredicate(colStateBefore, column)) {
          changedColumns2.push(column);
        }
      });
      return changedColumns2;
    };
    const columnIdMapper = (c) => c.getColId();
    dispatchWhenListsDifferent(
      "columnRowGroupChanged",
      startState.rowGroupColumns,
      rowGroupColsSvc?.columns ?? [],
      columnIdMapper
    );
    dispatchWhenListsDifferent(
      "columnPivotChanged",
      startState.pivotColumns,
      pivotColsSvc?.columns ?? [],
      columnIdMapper
    );
    const valueChangePredicate = (cs, c) => {
      const oldActive = cs.aggFunc != null;
      const activeChanged = oldActive != c.isValueActive();
      const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
      return activeChanged || aggFuncChanged;
    };
    const changedValues = getChangedColumns(valueChangePredicate);
    if (changedValues.length > 0) {
      dispatchColumnChangedEvent(eventSvc, "columnValueChanged", changedValues, source);
    }
    const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
    dispatchColumnResizedEvent(eventSvc, getChangedColumns(resizeChangePredicate), true, source);
    const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
    dispatchColumnPinnedEvent(eventSvc, getChangedColumns(pinnedChangePredicate), source);
    const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
    dispatchColumnVisibleEvent(eventSvc, getChangedColumns(visibilityChangePredicate), source);
    const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
    const changedColumns = getChangedColumns(sortChangePredicate);
    if (changedColumns.length > 0) {
      sortSvc?.dispatchSortChangedEvents(source, changedColumns);
    }
    const colStateAfter = _getColumnState(beans);
    normaliseColumnMovedEventForColumnState(columnStateBefore, colStateAfter, source, colModel, eventSvc);
  };
}
function _getColumnState(beans) {
  const { colModel, rowGroupColsSvc, pivotColsSvc } = beans;
  const primaryCols = colModel.getColDefCols();
  if (_missing(primaryCols) || !colModel.isAlive()) {
    return [];
  }
  const colsForState = colModel.getAllCols();
  const rowGroupColumns = rowGroupColsSvc?.columns;
  const pivotColumns = pivotColsSvc?.columns;
  const createStateItemFromColumn = (column) => {
    const rowGroupIndex = column.isRowGroupActive() && rowGroupColumns ? rowGroupColumns.indexOf(column) : null;
    const pivotIndex = column.isPivotActive() && pivotColumns ? pivotColumns.indexOf(column) : null;
    const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
    const sort = column.getSort() != null ? column.getSort() : null;
    const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
    const res2 = {
      colId: column.getColId(),
      width: column.getActualWidth(),
      hide: !column.isVisible(),
      pinned: column.getPinned(),
      sort,
      sortIndex,
      aggFunc,
      rowGroup: column.isRowGroupActive(),
      rowGroupIndex,
      pivot: column.isPivotActive(),
      pivotIndex,
      flex: column.getFlex() ?? null
    };
    return res2;
  };
  const res = colsForState.map((col) => createStateItemFromColumn(col));
  const colIdToGridIndexMap = new Map(
    colModel.getCols().map((col, index) => [col.getColId(), index])
  );
  res.sort((itemA, itemB) => {
    const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
    const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
    return posA - posB;
  });
  return res;
}
function getColumnStateFromColDef(column) {
  const getValueOrNull = (a, b) => a != null ? a : b != null ? b : null;
  const colDef = column.getColDef();
  const sort = getValueOrNull(colDef.sort, colDef.initialSort);
  const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
  const hide = getValueOrNull(colDef.hide, colDef.initialHide);
  const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
  const width = getValueOrNull(colDef.width, colDef.initialWidth);
  const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
  let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
  let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
  if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
    rowGroupIndex = null;
    rowGroup = null;
  }
  let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
  let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
  if (pivotIndex == null && (pivot == null || pivot == false)) {
    pivotIndex = null;
    pivot = null;
  }
  const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
  return {
    colId: column.getColId(),
    sort,
    sortIndex,
    hide,
    pinned,
    width,
    flex,
    rowGroup,
    rowGroupIndex,
    pivot,
    pivotIndex,
    aggFunc
  };
}
function orderLiveColsLikeState(params, colModel, gos) {
  if (!params.applyOrder || !params.state) {
    return;
  }
  const colIds = [];
  params.state.forEach((item) => {
    if (item.colId != null) {
      colIds.push(item.colId);
    }
  });
  sortColsLikeKeys(colModel.cols, colIds, colModel, gos);
}
function sortColsLikeKeys(cols, colIds, colModel, gos) {
  if (cols == null) {
    return;
  }
  let newOrder = [];
  const processedColIds = {};
  colIds.forEach((colId) => {
    if (processedColIds[colId]) {
      return;
    }
    const col = cols.map[colId];
    if (col) {
      newOrder.push(col);
      processedColIds[colId] = true;
    }
  });
  let autoGroupInsertIndex = 0;
  cols.list.forEach((col) => {
    const colId = col.getColId();
    const alreadyProcessed = processedColIds[colId] != null;
    if (alreadyProcessed) {
      return;
    }
    const isAutoGroupCol = colId.startsWith(GROUP_AUTO_COLUMN_ID);
    if (isAutoGroupCol) {
      newOrder.splice(autoGroupInsertIndex++, 0, col);
    } else {
      newOrder.push(col);
    }
  });
  newOrder = placeLockedColumns(newOrder, gos);
  if (!doesMovePassMarryChildren(newOrder, colModel.getColTree())) {
    _warn(39);
    return;
  }
  cols.list = newOrder;
}
function normaliseColumnMovedEventForColumnState(colStateBefore, colStateAfter, source, colModel, eventSvc) {
  const colStateAfterMapped = {};
  colStateAfter.forEach((s) => colStateAfterMapped[s.colId] = s);
  const colsIntersectIds = {};
  colStateBefore.forEach((s) => {
    if (colStateAfterMapped[s.colId]) {
      colsIntersectIds[s.colId] = true;
    }
  });
  const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
  const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
  const movedColumns = [];
  afterFiltered.forEach((csAfter, index) => {
    const csBefore = beforeFiltered && beforeFiltered[index];
    if (csBefore && csBefore.colId !== csAfter.colId) {
      const gridCol = colModel.getCol(csBefore.colId);
      if (gridCol) {
        movedColumns.push(gridCol);
      }
    }
  });
  if (!movedColumns.length) {
    return;
  }
  eventSvc.dispatchEvent({
    type: "columnMoved",
    columns: movedColumns,
    column: movedColumns.length === 1 ? movedColumns[0] : null,
    finished: true,
    source
  });
}
var comparatorByIndex = (indexes, oldList, colA, colB) => {
  const indexA = indexes[colA.getId()];
  const indexB = indexes[colB.getId()];
  const aHasIndex = indexA != null;
  const bHasIndex = indexB != null;
  if (aHasIndex && bHasIndex) {
    return indexA - indexB;
  }
  if (aHasIndex) {
    return -1;
  }
  if (bHasIndex) {
    return 1;
  }
  const oldIndexA = oldList.indexOf(colA);
  const oldIndexB = oldList.indexOf(colB);
  const aHasOldIndex = oldIndexA >= 0;
  const bHasOldIndex = oldIndexB >= 0;
  if (aHasOldIndex && bHasOldIndex) {
    return oldIndexA - oldIndexB;
  }
  if (aHasOldIndex) {
    return -1;
  }
  return 1;
};

// packages/ag-grid-community/src/columns/selectionColService.ts
var CONTROLS_COLUMN_ID_PREFIX = "ag-Grid-SelectionColumn";
var SelectionColService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "selectionColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener("rowSelection", (event) => {
      this.onSelectionOptionsChanged(
        event.currentValue,
        event.previousValue,
        _convertColumnEventSourceType(event.source)
      );
    });
  }
  addSelectionCols(cols) {
    const selectionCols = this.selectionCols;
    if (selectionCols == null) {
      return;
    }
    cols.list = selectionCols.list.concat(cols.list);
    cols.tree = selectionCols.tree.concat(cols.tree);
    _updateColsMap(cols);
  }
  createSelectionCols(cols, updateOrders) {
    const destroyCollection = () => {
      _destroyColumnTree(this.beans, this.selectionCols?.tree);
      this.selectionCols = null;
    };
    const newTreeDepth = cols.treeDepth;
    const oldTreeDepth = this.selectionCols?.treeDepth ?? -1;
    const treeDeptSame = oldTreeDepth == newTreeDepth;
    const list = this.generateSelectionCols();
    const areSame = _areColIdsEqual(list, this.selectionCols?.list ?? []);
    if (areSame && treeDeptSame) {
      return;
    }
    destroyCollection();
    const { colGroupSvc } = this.beans;
    const treeDepth = colGroupSvc?.findDepth(cols.tree) ?? 0;
    const tree = colGroupSvc?.balanceTreeForAutoCols(list, treeDepth) ?? [];
    this.selectionCols = {
      list,
      tree,
      treeDepth,
      map: {}
    };
    const putSelectionColsFirstInList = (cols2) => {
      if (!cols2) {
        return null;
      }
      const colsFiltered = cols2.filter((col) => !isColumnSelectionCol(col));
      return [...list, ...colsFiltered];
    };
    updateOrders(putSelectionColsFirstInList);
  }
  isSelectionColumnEnabled() {
    const { gos, beans } = this;
    const rowSelection = gos.get("rowSelection");
    if (typeof rowSelection !== "object" || !_isRowSelection(gos)) {
      return false;
    }
    const hasAutoCols = (beans.autoColSvc?.getAutoCols()?.length ?? 0) > 0;
    if (rowSelection.checkboxLocation === "autoGroupColumn" && hasAutoCols) {
      return false;
    }
    const checkboxes = !!_getCheckboxes(rowSelection);
    const headerCheckbox = _getHeaderCheckbox(rowSelection);
    return checkboxes || headerCheckbox;
  }
  generateSelectionCols() {
    if (!this.isSelectionColumnEnabled()) {
      return [];
    }
    const { gos, validation: validation2 } = this.beans;
    const selectionColumnDef = gos.get("selectionColumnDef");
    const enableRTL = gos.get("enableRtl");
    const colDef = {
      // overridable properties
      width: 50,
      resizable: false,
      suppressHeaderMenuButton: true,
      sortable: false,
      suppressMovable: true,
      lockPosition: enableRTL ? "right" : "left",
      comparator(valueA, valueB, nodeA, nodeB) {
        const aSelected = nodeA.isSelected();
        const bSelected = nodeB.isSelected();
        return aSelected === bSelected ? 0 : aSelected ? 1 : -1;
      },
      editable: false,
      suppressFillHandle: true,
      // overrides
      ...selectionColumnDef,
      // non-overridable properties
      colId: CONTROLS_COLUMN_ID_PREFIX
    };
    const colId = colDef.colId;
    validation2?.validateColDef(colDef, colId, true);
    const col = new AgColumn(colDef, null, colId, false);
    this.createBean(col);
    return [col];
  }
  putSelectionColsFirstInList(list, cols) {
    if (!cols) {
      return null;
    }
    const colsFiltered = cols.filter((col) => !isColumnSelectionCol(col));
    return [...list, ...colsFiltered];
  }
  getSelectionCol(key) {
    return this.selectionCols?.list.find((col) => _columnsMatch(col, key)) ?? null;
  }
  getSelectionCols() {
    return this.selectionCols?.list ?? null;
  }
  onSelectionOptionsChanged(current, prev, source) {
    const prevCheckbox = prev && typeof prev !== "string" ? _getCheckboxes(prev) : void 0;
    const currCheckbox = current && typeof current !== "string" ? _getCheckboxes(current) : void 0;
    const checkboxHasChanged = prevCheckbox !== currCheckbox;
    const prevHeaderCheckbox = prev && typeof prev !== "string" ? _getHeaderCheckbox(prev) : void 0;
    const currHeaderCheckbox = current && typeof current !== "string" ? _getHeaderCheckbox(current) : void 0;
    const headerCheckboxHasChanged = prevHeaderCheckbox !== currHeaderCheckbox;
    const currLocation = _getCheckboxLocation(current);
    const prevLocation = _getCheckboxLocation(prev);
    const locationChanged = currLocation !== prevLocation;
    if (checkboxHasChanged || headerCheckboxHasChanged || locationChanged) {
      this.beans.colModel.refreshAll(source);
    }
  }
  destroy() {
    _destroyColumnTree(this.beans, this.selectionCols?.tree);
    super.destroy();
  }
  refreshVisibility(source) {
    if (!this.isSelectionColumnEnabled()) {
      return;
    }
    const beans = this.beans;
    const visibleColumns = beans.visibleCols.getAllTrees() ?? [];
    if (visibleColumns.length === 0) {
      return;
    }
    if (!visibleColumns.some(isLeafColumnSelectionCol)) {
      const existingState = _getColumnState(beans).find((state) => isColumnSelectionCol(state.colId));
      if (existingState) {
        _applyColumnState(
          beans,
          {
            state: [{ colId: existingState.colId, hide: !existingState.hide }]
          },
          source
        );
      }
    }
    if (visibleColumns.length === 1) {
      const firstColumn = visibleColumns[0];
      const leafSelectionCol = getLeafColumnSelectionCol(firstColumn);
      if (!leafSelectionCol) {
        return;
      }
      _applyColumnState(beans, { state: [{ colId: leafSelectionCol.getColId(), hide: true }] }, source);
    }
  }
};
var isLeafColumnSelectionCol = (c) => c.isColumn ? isColumnSelectionCol(c) : c.getChildren()?.some(isLeafColumnSelectionCol) ?? false;
function getLeafColumnSelectionCol(c) {
  if (c.isColumn) {
    return isColumnSelectionCol(c) ? c : null;
  }
  const children = c.getChildren() ?? [];
  for (const child of children) {
    const selCol = getLeafColumnSelectionCol(child);
    if (selCol) {
      return selCol;
    }
  }
  return null;
}

// packages/ag-grid-community/src/columns/columnUtils.ts
var GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn";
function _getColumnsFromTree(rootColumns) {
  const result = [];
  const recursiveFindColumns = (childColumns) => {
    for (let i = 0; i < childColumns.length; i++) {
      const child = childColumns[i];
      if (isColumn(child)) {
        result.push(child);
      } else if (isProvidedColumnGroup(child)) {
        recursiveFindColumns(child.getChildren());
      }
    }
  };
  recursiveFindColumns(rootColumns);
  return result;
}
function getWidthOfColsInList(columnList) {
  return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
}
function _destroyColumnTree(beans, oldTree, newTree) {
  const oldObjectsById = {};
  if (!oldTree) {
    return;
  }
  depthFirstOriginalTreeSearch(null, oldTree, (child) => {
    oldObjectsById[child.getInstanceId()] = child;
  });
  if (newTree) {
    depthFirstOriginalTreeSearch(null, newTree, (child) => {
      oldObjectsById[child.getInstanceId()] = null;
    });
  }
  const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
  beans.context.destroyBeans(colsToDestroy);
}
function isColumnGroupAutoCol(col) {
  const colId = col.getId();
  return colId.startsWith(GROUP_AUTO_COLUMN_ID);
}
function isColumnSelectionCol(col) {
  const id = typeof col === "string" ? col : "getColId" in col ? col.getColId() : col.colId;
  return id?.startsWith(CONTROLS_COLUMN_ID_PREFIX) ?? false;
}
function convertColumnTypes(type) {
  let typeKeys = [];
  if (type instanceof Array) {
    typeKeys = type;
  } else if (typeof type === "string") {
    typeKeys = type.split(",");
  }
  return typeKeys;
}
function _areColIdsEqual(colsA, colsB) {
  return _areEqual(colsA, colsB, (a, b) => a.getColId() === b.getColId());
}
function _updateColsMap(cols) {
  cols.map = {};
  cols.list.forEach((col) => cols.map[col.getId()] = col);
}
function _convertColumnEventSourceType(source) {
  return source === "gridOptionsUpdated" ? "gridOptionsChanged" : source;
}
function _columnsMatch(column, key) {
  const columnMatches = column === key;
  const colDefMatches = column.getColDef() === key;
  const idMatches = column.getColId() == key;
  return columnMatches || colDefMatches || idMatches;
}
var getValueFactory = (stateItem, defaultState) => (key1, key2) => {
  const obj = {
    value1: void 0,
    value2: void 0
  };
  let calculated = false;
  if (stateItem) {
    if (stateItem[key1] !== void 0) {
      obj.value1 = stateItem[key1];
      calculated = true;
    }
    if (_exists(key2) && stateItem[key2] !== void 0) {
      obj.value2 = stateItem[key2];
      calculated = true;
    }
  }
  if (!calculated && defaultState) {
    if (defaultState[key1] !== void 0) {
      obj.value1 = defaultState[key1];
    }
    if (_exists(key2) && defaultState[key2] !== void 0) {
      obj.value2 = defaultState[key2];
    }
  }
  return obj;
};

// packages/ag-grid-community/src/columns/columnFactoryUtils.ts
function _createColumnTree(beans, defs = null, primaryColumns, existingTree, source) {
  const columnKeyCreator = new ColumnKeyCreator();
  const { existingCols, existingGroups, existingColKeys } = extractExistingTreeData(existingTree);
  columnKeyCreator.addExistingKeys(existingColKeys);
  const unbalancedTree = _recursivelyCreateColumns(
    beans,
    defs,
    0,
    primaryColumns,
    existingCols,
    columnKeyCreator,
    existingGroups,
    source
  );
  const { colGroupSvc } = beans;
  const treeDept = colGroupSvc?.findMaxDepth(unbalancedTree, 0) ?? 0;
  const columnTree = colGroupSvc ? colGroupSvc.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator) : unbalancedTree;
  const deptFirstCallback = (child, parent) => {
    if (isProvidedColumnGroup(child)) {
      child.setupExpandable();
    }
    child.originalParent = parent;
  };
  depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);
  return {
    columnTree,
    treeDept
  };
}
function extractExistingTreeData(existingTree) {
  const existingCols = [];
  const existingGroups = [];
  const existingColKeys = [];
  if (existingTree) {
    depthFirstOriginalTreeSearch(null, existingTree, (item) => {
      if (isProvidedColumnGroup(item)) {
        const group = item;
        existingGroups.push(group);
      } else {
        const col = item;
        existingColKeys.push(col.getId());
        existingCols.push(col);
      }
    });
  }
  return { existingCols, existingGroups, existingColKeys };
}
function _recursivelyCreateColumns(beans, defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
  if (!defs)
    return [];
  const { colGroupSvc } = beans;
  const result = new Array(defs.length);
  for (let i = 0; i < result.length; i++) {
    const def = defs[i];
    if (colGroupSvc && isColumnGroup(def)) {
      result[i] = colGroupSvc.createProvidedColumnGroup(
        primaryColumns,
        def,
        level,
        existingColsCopy,
        columnKeyCreator,
        existingGroups,
        source
      );
    } else {
      result[i] = createColumn(beans, primaryColumns, def, existingColsCopy, columnKeyCreator, source);
    }
  }
  return result;
}
function createColumn(beans, primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
  const existingColAndIndex = findExistingColumn(colDef, existingColsCopy);
  if (existingColAndIndex) {
    existingColsCopy?.splice(existingColAndIndex.idx, 1);
  }
  let column = existingColAndIndex?.column;
  if (!column) {
    const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
    const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, colId);
    column = new AgColumn(colDefMerged, colDef, colId, primaryColumns);
    beans.context.createBean(column);
  } else {
    const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, column.getColId());
    column.setColDef(colDefMerged, colDef, source);
    _updateColumnState(beans, column, colDefMerged, source);
  }
  beans.dataTypeSvc?.addColumnListeners(column);
  return column;
}
function updateSomeColumnState(beans, column, hide, sort, sortIndex, pinned, flex, source) {
  const { sortSvc, pinnedCols, colFlex } = beans;
  if (hide !== void 0) {
    column.setVisible(!hide, source);
  }
  if (sortSvc) {
    sortSvc.updateColSort(column, sort, source);
    if (sortIndex !== void 0) {
      sortSvc.setColSortIndex(column, sortIndex);
    }
  }
  if (pinned !== void 0) {
    pinnedCols?.setColPinned(column, pinned);
  }
  if (flex !== void 0) {
    colFlex?.setColFlex(column, flex);
  }
}
function _updateColumnState(beans, column, colDef, source) {
  updateSomeColumnState(
    beans,
    column,
    colDef.hide,
    colDef.sort,
    colDef.sortIndex,
    colDef.pinned,
    colDef.flex,
    source
  );
  const colFlex = column.getFlex();
  if (colFlex != null && colFlex > 0) {
    return;
  }
  if (colDef.width != null) {
    column.setActualWidth(colDef.width, source);
  } else {
    const widthBeforeUpdate = column.getActualWidth();
    column.setActualWidth(widthBeforeUpdate, source);
  }
}
function findExistingColumn(newColDef, existingColsCopy) {
  if (!existingColsCopy)
    return void 0;
  for (let i = 0; i < existingColsCopy.length; i++) {
    const def = existingColsCopy[i].getUserProvidedColDef();
    if (!def)
      continue;
    const newHasId = newColDef.colId != null;
    if (newHasId) {
      if (existingColsCopy[i].getId() === newColDef.colId) {
        return { idx: i, column: existingColsCopy[i] };
      }
      continue;
    }
    const newHasField = newColDef.field != null;
    if (newHasField) {
      if (def.field === newColDef.field) {
        return { idx: i, column: existingColsCopy[i] };
      }
      continue;
    }
    if (def === newColDef) {
      return { idx: i, column: existingColsCopy[i] };
    }
  }
  return void 0;
}
function _addColumnDefaultAndTypes(beans, colDef, colId, isAutoCol) {
  const { gos, dataTypeSvc, validation: validation2 } = beans;
  const res = {};
  const defaultColDef = gos.get("defaultColDef");
  _mergeDeep(res, defaultColDef, false, true);
  const columnType = updateColDefAndGetColumnType(beans, res, colDef, colId);
  if (columnType) {
    assignColumnTypes(beans, columnType, res);
  }
  _mergeDeep(res, colDef, false, true);
  const autoGroupColDef = gos.get("autoGroupColumnDef");
  const isSortingCoupled = _isColumnsSortingCoupledToGroup(gos);
  if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) {
    _mergeDeep(
      res,
      { sort: autoGroupColDef.sort, initialSort: autoGroupColDef.initialSort },
      false,
      true
    );
  }
  dataTypeSvc?.validateColDef(res);
  validation2?.validateColDef(res, colId, isAutoCol);
  return res;
}
function updateColDefAndGetColumnType(beans, colDef, userColDef, colId) {
  const dataTypeDefinitionColumnType = beans.dataTypeSvc?.updateColDefAndGetColumnType(colDef, userColDef, colId);
  const columnTypes = userColDef.type ?? dataTypeDefinitionColumnType ?? colDef.type;
  colDef.type = columnTypes;
  return columnTypes ? convertColumnTypes(columnTypes) : void 0;
}
function assignColumnTypes(beans, typeKeys, colDefMerged) {
  if (!typeKeys.length) {
    return;
  }
  const allColumnTypes = Object.assign({}, DefaultColumnTypes);
  const userTypes = beans.gos.get("columnTypes") || {};
  for (const [key, value] of Object.entries(userTypes)) {
    if (key in allColumnTypes) {
      _warn(34, { key });
    } else {
      const colType = value;
      if (colType.type) {
        _warn(35);
      }
      allColumnTypes[key] = value;
    }
  }
  typeKeys.forEach((t) => {
    const typeColDef = allColumnTypes[t.trim()];
    if (typeColDef) {
      _mergeDeep(colDefMerged, typeColDef, false, true);
    } else {
      _warn(36, { t });
    }
  });
}
function isColumnGroup(abstractColDef) {
  return abstractColDef.children !== void 0;
}
function depthFirstOriginalTreeSearch(parent, tree, callback) {
  if (!tree) {
    return;
  }
  for (let i = 0; i < tree.length; i++) {
    const child = tree[i];
    if (isProvidedColumnGroup(child)) {
      depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
    }
    callback(child, parent);
  }
}

// packages/ag-grid-community/src/columns/columnModel.ts
var ColumnModel = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colModel";
    // if pivotMode is on, however pivot results are NOT shown if no pivot columns are set
    this.pivotMode = false;
    this.ready = false;
    this.changeEventsDispatching = false;
  }
  postConstruct() {
    this.pivotMode = this.gos.get("pivotMode");
    this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (event) => this.refreshAll(_convertColumnEventSourceType(event.source))
    );
    this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      (event) => this.recreateColumnDefs(_convertColumnEventSourceType(event.source))
    );
    this.addManagedPropertyListener(
      "pivotMode",
      (event) => this.setPivotMode(this.gos.get("pivotMode"), _convertColumnEventSourceType(event.source))
    );
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(source) {
    const { beans } = this;
    const {
      valueCache,
      colAutosize,
      rowGroupColsSvc,
      pivotColsSvc,
      valueColsSvc,
      visibleCols,
      colViewport,
      eventSvc
    } = beans;
    const dispatchEventsFunc = this.colDefs ? _compareColumnStatesAndDispatchEvents(beans, source) : void 0;
    valueCache?.expire();
    const oldCols = this.colDefCols?.list;
    const oldTree = this.colDefCols?.tree;
    const newTree = _createColumnTree(beans, this.colDefs, true, oldTree, source);
    _destroyColumnTree(beans, this.colDefCols?.tree, newTree.columnTree);
    const tree = newTree.columnTree;
    const treeDepth = newTree.treeDept;
    const list = _getColumnsFromTree(tree);
    const map = {};
    list.forEach((col) => map[col.getId()] = col);
    this.colDefCols = { tree, treeDepth, list, map };
    rowGroupColsSvc?.extractCols(source, oldCols);
    pivotColsSvc?.extractCols(source, oldCols);
    valueColsSvc?.extractCols(source, oldCols);
    this.ready = true;
    this.refreshCols(true);
    visibleCols.refresh(source);
    colViewport.checkViewportColumns();
    eventSvc.dispatchEvent({
      type: "columnEverythingChanged",
      source
    });
    if (dispatchEventsFunc) {
      this.changeEventsDispatching = true;
      dispatchEventsFunc();
      this.changeEventsDispatching = false;
    }
    eventSvc.dispatchEvent({
      type: "newColumnsLoaded",
      source
    });
    if (source === "gridInitializing") {
      colAutosize?.applyAutosizeStrategy();
    }
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultCols.setPivotResultCols
  refreshCols(newColDefs) {
    if (!this.colDefCols) {
      return;
    }
    const prevColTree = this.cols?.tree;
    this.saveColOrder();
    const {
      autoColSvc,
      selectionColSvc,
      quickFilter,
      pivotResultCols,
      showRowGroupCols,
      rowAutoHeight,
      visibleCols,
      colViewport,
      eventSvc
    } = this.beans;
    const cols = this.selectCols(pivotResultCols, this.colDefCols);
    autoColSvc?.createAutoCols(cols, (updateOrder) => {
      this.lastOrder = updateOrder(this.lastOrder);
      this.lastPivotOrder = updateOrder(this.lastPivotOrder);
    });
    autoColSvc?.addAutoCols(cols);
    selectionColSvc?.createSelectionCols(cols, (updateOrder) => {
      this.lastOrder = updateOrder(this.lastOrder) ?? null;
      this.lastPivotOrder = updateOrder(this.lastPivotOrder) ?? null;
    });
    selectionColSvc?.addSelectionCols(cols);
    const shouldSortNewColDefs = _shouldMaintainColumnOrder(this.gos, this.showingPivotResult);
    if (!newColDefs || shouldSortNewColDefs) {
      this.restoreColOrder(cols);
    }
    this.positionLockedCols(cols);
    showRowGroupCols?.refresh();
    quickFilter?.refreshCols();
    this.setColSpanActive();
    rowAutoHeight?.setAutoHeightActive(cols);
    visibleCols.clear();
    colViewport.clear();
    const dispatchChangedEvent = !_areEqual(prevColTree, this.cols.tree);
    if (dispatchChangedEvent) {
      eventSvc.dispatchEvent({
        type: "gridColumnsChanged"
      });
    }
  }
  selectCols(pivotResultColsSvc, colDefCols) {
    const pivotResultCols = pivotResultColsSvc?.getPivotResultCols() ?? null;
    this.showingPivotResult = pivotResultCols != null;
    const { map, list, tree, treeDepth } = pivotResultCols ?? colDefCols;
    this.cols = {
      list: list.slice(),
      map: { ...map },
      tree: tree.slice(),
      treeDepth
    };
    if (pivotResultCols) {
      const hasSameColumns = pivotResultCols.list.some((col) => this.cols?.map[col.getColId()] !== void 0);
      if (!hasSameColumns) {
        this.lastPivotOrder = null;
      }
    }
    return this.cols;
  }
  getColsToShow() {
    if (!this.cols) {
      return [];
    }
    const showAutoGroupAndValuesOnly = this.isPivotMode() && !this.showingPivotResult;
    const valueColumns = this.beans.valueColsSvc?.columns;
    const res = this.cols.list.filter((col) => {
      const isAutoGroupCol = isColumnGroupAutoCol(col);
      if (showAutoGroupAndValuesOnly) {
        const isValueCol = valueColumns?.includes(col);
        return isAutoGroupCol || isValueCol;
      } else {
        return isAutoGroupCol || col.isVisible();
      }
    });
    return res;
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(source) {
    if (!this.ready) {
      return;
    }
    this.refreshCols(false);
    this.beans.visibleCols.refresh(source);
  }
  setColsVisible(keys, visible = false, source) {
    _applyColumnState(
      this.beans,
      {
        state: keys.map((key) => ({
          colId: typeof key === "string" ? key : key.getColId(),
          hide: !visible
        }))
      },
      source
    );
  }
  restoreColOrder(cols) {
    const lastOrder = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!lastOrder) {
      return;
    }
    const lastOrderMapped = new Map(lastOrder.map((col, index) => [col, index]));
    const noColsFound = !cols.list.some((col) => lastOrderMapped.has(col));
    if (noColsFound) {
      return;
    }
    const colsMap = new Map(cols.list.map((col) => [col, true]));
    const lastOrderFiltered = lastOrder.filter((col) => colsMap.has(col));
    const lastOrderFilteredMap = new Map(lastOrderFiltered.map((col) => [col, true]));
    const missingFromLastOrder = cols.list.filter((col) => !lastOrderFilteredMap.has(col));
    const res = lastOrderFiltered.slice();
    missingFromLastOrder.forEach((newCol) => {
      let parent = newCol.getOriginalParent();
      if (!parent) {
        res.push(newCol);
        return;
      }
      const siblings = [];
      while (!siblings.length && parent) {
        const leafCols = parent.getLeafColumns();
        leafCols.forEach((leafCol) => {
          const presentInNewCols = res.indexOf(leafCol) >= 0;
          const notYetInSiblings = siblings.indexOf(leafCol) < 0;
          if (presentInNewCols && notYetInSiblings) {
            siblings.push(leafCol);
          }
        });
        parent = parent.getOriginalParent();
      }
      if (!siblings.length) {
        res.push(newCol);
        return;
      }
      const indexes = siblings.map((col) => res.indexOf(col));
      const lastIndex = Math.max(...indexes);
      res.splice(lastIndex + 1, 0, newCol);
    });
    cols.list = res;
  }
  positionLockedCols(cols) {
    cols.list = placeLockedColumns(cols.list, this.gos);
  }
  saveColOrder() {
    if (this.showingPivotResult) {
      this.lastPivotOrder = this.cols?.list ?? null;
    } else {
      this.lastOrder = this.cols?.list ?? null;
    }
  }
  getColumnDefs() {
    return this.colDefCols ? this.beans.colDefFactory?.getColumnDefs(
      this.colDefCols.list,
      this.showingPivotResult,
      this.lastOrder,
      this.cols?.list ?? []
    ) : void 0;
  }
  setColSpanActive() {
    this.colSpanActive = !!this.cols?.list.some((col) => col.getColDef().colSpan != null);
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(pivotMode, source) {
    if (pivotMode === this.pivotMode) {
      return;
    }
    this.pivotMode = pivotMode;
    if (!this.ready) {
      return;
    }
    this.refreshCols(false);
    const { visibleCols, eventSvc } = this.beans;
    visibleCols.refresh(source);
    eventSvc.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  // + clientSideRowModel
  isPivotActive() {
    const pivotColumns = this.beans.pivotColsSvc?.columns;
    return this.pivotMode && !!pivotColumns?.length;
  }
  // called when dataTypes change
  recreateColumnDefs(source) {
    if (!this.cols) {
      return;
    }
    this.beans.autoColSvc?.updateAutoCols(source);
    this.createColsFromColDefs(source);
  }
  setColumnDefs(columnDefs, source) {
    this.colDefs = columnDefs;
    this.createColsFromColDefs(source);
  }
  destroy() {
    _destroyColumnTree(this.beans, this.colDefCols?.tree);
    super.destroy();
  }
  getColTree() {
    return this.cols?.tree ?? [];
  }
  // + columnSelectPanel
  getColDefColTree() {
    return this.colDefCols?.tree ?? [];
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    return this.colDefCols?.list ?? null;
  }
  // + moveColumnController
  getCols() {
    return this.cols?.list ?? [];
  }
  // returns colDefCols, pivotResultCols and autoCols
  getAllCols() {
    const { pivotResultCols, autoColSvc, selectionColSvc } = this.beans;
    const pivotResultColsList = pivotResultCols?.getPivotResultCols()?.list;
    return [
      this.colDefCols?.list ?? [],
      autoColSvc?.autoCols?.list ?? [],
      selectionColSvc?.selectionCols?.list ?? [],
      pivotResultColsList ?? []
    ].flat();
  }
  getColsForKeys(keys) {
    if (!keys) {
      return [];
    }
    return keys.map((key) => this.getCol(key)).filter((col) => col != null);
  }
  getColDefCol(key) {
    if (!this.colDefCols?.list) {
      return null;
    }
    return this.getColFromCollection(key, this.colDefCols);
  }
  getCol(key) {
    if (key == null) {
      return null;
    }
    return this.getColFromCollection(key, this.cols);
  }
  getColFromCollection(key, cols) {
    if (cols == null) {
      return null;
    }
    const { map, list } = cols;
    if (typeof key == "string" && map[key]) {
      return map[key];
    }
    for (let i = 0; i < list.length; i++) {
      if (_columnsMatch(list[i], key)) {
        return list[i];
      }
    }
    return this.beans.autoColSvc?.getAutoCol(key) ?? null;
  }
};

// packages/ag-grid-community/src/columns/baseColsService.ts
var BaseColsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.dispatchColumnChangedEvent = dispatchColumnChangedEvent;
    this.columns = [];
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
    this.aggFuncSvc = beans.aggFuncSvc;
    this.visibleCols = beans.visibleCols;
  }
  sortColumns(compareFn) {
    this.columns.sort(compareFn);
  }
  setColumns(colKeys, source) {
    this.setColList(colKeys, this.columns, this.eventName, true, true, this.columnProcessors.set, source);
  }
  addColumns(colKeys, source) {
    this.updateColList(colKeys, this.columns, true, true, this.columnProcessors.add, this.eventName, source);
  }
  removeColumns(colKeys, source) {
    this.updateColList(colKeys, this.columns, false, true, this.columnProcessors.remove, this.eventName, source);
  }
  setColList(colKeys = [], masterList, eventName, detectOrderChange, autoGroupsNeedBuilding, columnCallback, source) {
    const gridColumns = this.colModel.getCols();
    if (!gridColumns || gridColumns.length === 0) {
      return;
    }
    const changes = /* @__PURE__ */ new Map();
    masterList.forEach((col, idx) => changes.set(col, idx));
    masterList.length = 0;
    if (_exists(colKeys)) {
      colKeys.forEach((key) => {
        const column = this.colModel.getColDefCol(key);
        if (column) {
          masterList.push(column);
        }
      });
    }
    masterList.forEach((col, idx) => {
      const oldIndex = changes.get(col);
      if (oldIndex === void 0) {
        changes.set(col, 0);
        return;
      }
      if (detectOrderChange && oldIndex !== idx) {
        return;
      }
      changes.delete(col);
    });
    const primaryCols = this.colModel.getColDefCols();
    (primaryCols || []).forEach((column) => {
      const added = masterList.indexOf(column) >= 0;
      columnCallback(column, added, source);
    });
    autoGroupsNeedBuilding && this.colModel.refreshCols(false);
    this.visibleCols.refresh(source);
    this.dispatchColumnChangedEvent(this.eventSvc, eventName, [...changes.keys()], source);
  }
  updateColList(keys = [], masterList, actionIsAdd, autoGroupsNeedBuilding, columnCallback, eventType, source) {
    if (!keys || keys.length === 0) {
      return;
    }
    let atLeastOne = false;
    const updatedCols = /* @__PURE__ */ new Set();
    keys.forEach((key) => {
      if (!key) {
        return;
      }
      const columnToAdd = this.colModel.getColDefCol(key);
      if (!columnToAdd) {
        return;
      }
      updatedCols.add(columnToAdd);
      if (actionIsAdd) {
        if (masterList.indexOf(columnToAdd) >= 0) {
          return;
        }
        masterList.push(columnToAdd);
      } else {
        const currentIndex = masterList.indexOf(columnToAdd);
        if (currentIndex < 0) {
          return;
        }
        for (let i = currentIndex + 1; i < masterList.length; i++) {
          updatedCols.add(masterList[i]);
        }
        _removeFromArray(masterList, columnToAdd);
      }
      columnCallback(columnToAdd, actionIsAdd, source);
      atLeastOne = true;
    });
    if (!atLeastOne) {
      return;
    }
    if (autoGroupsNeedBuilding) {
      this.colModel.refreshCols(false);
    }
    this.visibleCols.refresh(source);
    const eventColumns = Array.from(updatedCols);
    this.eventSvc.dispatchEvent({
      type: eventType,
      columns: eventColumns,
      column: eventColumns.length === 1 ? eventColumns[0] : null,
      source
    });
  }
  extractCols(source, oldProvidedCols = []) {
    const previousCols = this.columns;
    const colsWithIndex = [];
    const colsWithValue = [];
    const { setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc } = this.columnExtractors;
    const primaryCols = this.colModel.getColDefCols() || [];
    primaryCols.forEach((col) => {
      const colIsNew = oldProvidedCols.indexOf(col) < 0;
      const colDef = col.getColDef();
      const value = getValueFunc(colDef);
      const initialValue = getInitialValueFunc(colDef);
      const index = getIndexFunc(colDef);
      const initialIndex = getInitialIndexFunc(colDef);
      let include;
      const valuePresent = value !== void 0;
      const indexPresent = index !== void 0;
      const initialValuePresent = initialValue !== void 0;
      const initialIndexPresent = initialIndex !== void 0;
      if (valuePresent) {
        include = value;
      } else if (indexPresent) {
        if (index === null) {
          include = false;
        } else {
          include = index >= 0;
        }
      } else {
        if (colIsNew) {
          if (initialValuePresent) {
            include = initialValue;
          } else if (initialIndexPresent) {
            include = initialIndex != null && initialIndex >= 0;
          } else {
            include = false;
          }
        } else {
          include = previousCols.indexOf(col) >= 0;
        }
      }
      if (include) {
        const useIndex = colIsNew ? index != null || initialIndex != null : index != null;
        useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);
      }
    });
    const getIndexForCol = (col) => {
      const index = getIndexFunc(col.getColDef());
      const defaultIndex = getInitialIndexFunc(col.getColDef());
      return index != null ? index : defaultIndex;
    };
    colsWithIndex.sort((colA, colB) => {
      const indexA = getIndexForCol(colA);
      const indexB = getIndexForCol(colB);
      if (indexA === indexB) {
        return 0;
      }
      if (indexA < indexB) {
        return -1;
      }
      return 1;
    });
    const res = [].concat(colsWithIndex);
    previousCols.forEach((col) => {
      if (colsWithValue.indexOf(col) >= 0) {
        res.push(col);
      }
    });
    colsWithValue.forEach((col) => {
      if (res.indexOf(col) < 0) {
        res.push(col);
      }
    });
    previousCols.forEach((col) => {
      if (res.indexOf(col) < 0) {
        setFlagFunc(col, false, source);
      }
    });
    res.forEach((col) => {
      if (previousCols.indexOf(col) < 0) {
        setFlagFunc(col, true, source);
      }
    });
    return this.columns = res;
  }
  restoreColumnOrder(columnStateAccumulator, incomingColumnState) {
    const colList = this.columns;
    const primaryCols = this.colModel.getColDefCols();
    if (!colList.length || !primaryCols) {
      return columnStateAccumulator;
    }
    const updatedColIdArray = Object.keys(incomingColumnState);
    const updatedColIds = new Set(updatedColIdArray);
    const newColIds = new Set(updatedColIdArray);
    const allColIds = new Set(
      colList.map((column) => {
        const colId = column.getColId();
        newColIds.delete(colId);
        return colId;
      }).concat(updatedColIdArray)
    );
    const colIdsInOriginalOrder = [];
    const originalOrderMap = {};
    let orderIndex = 0;
    for (let i = 0; i < primaryCols.length; i++) {
      const colId = primaryCols[i].getColId();
      if (allColIds.has(colId)) {
        colIdsInOriginalOrder.push(colId);
        originalOrderMap[colId] = orderIndex++;
      }
    }
    let index = 1e3;
    let hasAddedNewCols = false;
    let lastIndex = 0;
    const enableProp = this.columnOrdering.enableProp;
    const initialEnableProp = this.columnOrdering.initialEnableProp;
    const indexProp = this.columnOrdering.indexProp;
    const initialIndexProp = this.columnOrdering.initialIndexProp;
    const processPrecedingNewCols = (colId) => {
      const originalOrderIndex = originalOrderMap[colId];
      for (let i = lastIndex; i < originalOrderIndex; i++) {
        const newColId = colIdsInOriginalOrder[i];
        if (newColIds.has(newColId)) {
          incomingColumnState[newColId][indexProp] = index++;
          newColIds.delete(newColId);
        }
      }
      lastIndex = originalOrderIndex;
    };
    colList.forEach((column) => {
      const colId = column.getColId();
      if (updatedColIds.has(colId)) {
        processPrecedingNewCols(colId);
        incomingColumnState[colId][indexProp] = index++;
      } else {
        const colDef = column.getColDef();
        const missingIndex = colDef[indexProp] === null || colDef[indexProp] === void 0 && colDef[initialIndexProp] == null;
        if (missingIndex) {
          if (!hasAddedNewCols) {
            const propEnabled = colDef[enableProp] || colDef[enableProp] === void 0 && colDef[initialEnableProp];
            if (propEnabled) {
              processPrecedingNewCols(colId);
            } else {
              newColIds.forEach((newColId) => {
                incomingColumnState[newColId][indexProp] = index + originalOrderMap[newColId];
              });
              index += colIdsInOriginalOrder.length;
              hasAddedNewCols = true;
            }
          }
          if (!columnStateAccumulator[colId]) {
            columnStateAccumulator[colId] = { colId };
          }
          columnStateAccumulator[colId][indexProp] = index++;
        }
      }
    });
    return columnStateAccumulator;
  }
};

// packages/ag-grid-community/src/columns/groupInstanceIdCreator.ts
var GroupInstanceIdCreator = class {
  constructor() {
    // this map contains keys to numbers, so we remember what the last call was
    this.existingIds = {};
  }
  getInstanceIdForKey(key) {
    const lastResult = this.existingIds[key];
    let result;
    if (typeof lastResult !== "number") {
      result = 0;
    } else {
      result = lastResult + 1;
    }
    this.existingIds[key] = result;
    return result;
  }
};

// packages/ag-grid-community/src/components/emptyBean.ts
var EmptyBean = class extends BeanStub {
};
function setupCompBean(ctrl, ctx, compBean) {
  if (compBean) {
    ctrl.addDestroyFunc(() => ctx.destroyBean(compBean));
  }
  return compBean ?? ctrl;
}

// packages/ag-grid-community/src/rendering/cssClassManager.ts
var CssClassManager = class {
  constructor(getGui) {
    // to minimise DOM hits, we only apply CSS classes if they have changed. as adding a CSS class that is already
    // there, or removing one that wasn't present, all takes CPU.
    this.cssClassStates = {};
    this.getGui = getGui;
  }
  addCssClass(className) {
    this.addOrRemoveCssClass(className, true);
  }
  removeCssClass(className) {
    this.addOrRemoveCssClass(className, false);
  }
  containsCssClass(className) {
    const eGui = this.getGui();
    if (!eGui) {
      return false;
    }
    return eGui.classList.contains(className);
  }
  addOrRemoveCssClass(className, addOrRemove) {
    if (!className) {
      return;
    }
    if (className.indexOf(" ") >= 0) {
      const list = (className || "").split(" ");
      if (list.length > 1) {
        list.forEach((cls) => this.addOrRemoveCssClass(cls, addOrRemove));
        return;
      }
    }
    const updateNeeded = this.cssClassStates[className] !== addOrRemove;
    if (updateNeeded && className.length) {
      const eGui = this.getGui();
      if (eGui) {
        eGui.classList.toggle(className, addOrRemove);
      }
      this.cssClassStates[className] = addOrRemove;
    }
  }
};

// packages/ag-grid-community/src/widgets/component.ts
var compIdSequence = 0;
var RefPlaceholder = null;
var Component = class extends BeanStub {
  constructor(template, componentSelectors) {
    super();
    this.suppressDataRefValidation = false;
    // if false, then CSS class "ag-hidden" is applied, which sets "display: none"
    this.displayed = true;
    // if false, then CSS class "ag-invisible" is applied, which sets "visibility: hidden"
    this.visible = true;
    // unique id for this row component. this is used for getting a reference to the HTML dom.
    // we cannot use the RowNode id as this is not unique (due to animation, old rows can be lying
    // around as we create a new rowComp instance for the same row node).
    this.compId = compIdSequence++;
    this.cssClassManager = new CssClassManager(() => this.eGui);
    this.componentSelectors = new Map((componentSelectors ?? []).map((comp) => [comp.selector, comp]));
    if (template) {
      this.setTemplate(template);
    }
  }
  preConstruct() {
    this.wireTemplate(this.getGui());
    const debugId = "component-" + Object.getPrototypeOf(this)?.constructor?.name;
    this.css?.forEach((css) => this.beans.environment.addGlobalCSS(css, debugId));
  }
  wireTemplate(element, paramsMap) {
    if (element && this.gos) {
      this.applyElementsToComponent(element);
      this.createChildComponentsFromTags(element, paramsMap);
    }
  }
  getCompId() {
    return this.compId;
  }
  getDataRefAttribute(element) {
    if (element.getAttribute) {
      return element.getAttribute("data-ref");
    }
    return null;
  }
  applyElementsToComponent(element, elementRef, paramsMap, newComponent = null) {
    if (elementRef === void 0) {
      elementRef = this.getDataRefAttribute(element);
    }
    if (elementRef) {
      const current = this[elementRef];
      if (current === RefPlaceholder) {
        this[elementRef] = newComponent ?? element;
      } else {
        const usedAsParamRef = paramsMap && paramsMap[elementRef];
        if (!this.suppressDataRefValidation && !usedAsParamRef) {
          throw new Error(`data-ref: ${elementRef} on ${this.constructor.name} with ${current}`);
        }
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(parentNode, paramsMap) {
    const childNodeList = _copyNodeList(parentNode.childNodes);
    childNodeList.forEach((childNode) => {
      if (!(childNode instanceof HTMLElement)) {
        return;
      }
      const childComp = this.createComponentFromElement(
        childNode,
        (childComp2) => {
          const childGui = childComp2.getGui();
          if (childGui) {
            this.copyAttributesFromNode(childNode, childComp2.getGui());
          }
        },
        paramsMap
      );
      if (childComp) {
        if (childComp.addItems && childNode.children.length) {
          this.createChildComponentsFromTags(childNode, paramsMap);
          const items = Array.prototype.slice.call(childNode.children);
          childComp.addItems(items);
        }
        this.swapComponentForNode(childComp, parentNode, childNode);
      } else if (childNode.childNodes) {
        this.createChildComponentsFromTags(childNode, paramsMap);
      }
    });
  }
  createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
    const key = element.nodeName;
    const elementRef = this.getDataRefAttribute(element);
    const isAgGridComponent = key.indexOf("AG-") === 0;
    const componentSelector = isAgGridComponent ? this.componentSelectors.get(key) : null;
    let newComponent = null;
    if (componentSelector) {
      const componentParams = paramsMap && elementRef ? paramsMap[elementRef] : void 0;
      newComponent = new componentSelector.component(componentParams);
      newComponent.setParentComponent(this);
      this.createBean(newComponent, null, afterPreCreateCallback);
    } else if (isAgGridComponent) {
      throw new Error(`selector: ${key}`);
    }
    this.applyElementsToComponent(element, elementRef, paramsMap, newComponent);
    return newComponent;
  }
  copyAttributesFromNode(source, dest) {
    _iterateNamedNodeMap(source.attributes, (name, value) => dest.setAttribute(name, value));
  }
  swapComponentForNode(newComponent, parentNode, childNode) {
    const eComponent = newComponent.getGui();
    parentNode.replaceChild(eComponent, childNode);
    parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
    this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
  }
  activateTabIndex(elements) {
    const tabIndex = this.gos.get("tabIndex");
    if (!elements) {
      elements = [];
    }
    if (!elements.length) {
      elements.push(this.getGui());
    }
    elements.forEach((el) => el.setAttribute("tabindex", tabIndex.toString()));
  }
  setTemplate(template, componentSelectors, paramsMap) {
    const eGui = _loadTemplate(template);
    this.setTemplateFromElement(eGui, componentSelectors, paramsMap);
  }
  setTemplateFromElement(element, components, paramsMap, suppressDataRefValidation = false) {
    this.eGui = element;
    this.suppressDataRefValidation = suppressDataRefValidation;
    if (components) {
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        this.componentSelectors.set(component.selector, component);
      }
    }
    this.wireTemplate(element, paramsMap);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(component) {
    this.parentComponent = component;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(eGui) {
    this.eGui = eGui;
  }
  queryForHtmlElement(cssSelector) {
    return this.eGui.querySelector(cssSelector);
  }
  getContainerAndElement(newChild, container) {
    let parent = container;
    if (newChild == null) {
      return null;
    }
    if (!parent) {
      parent = this.eGui;
    }
    if (_isNodeOrElement(newChild)) {
      return {
        element: newChild,
        parent
      };
    }
    return {
      element: newChild.getGui(),
      parent
    };
  }
  prependChild(newChild, container) {
    const { element, parent } = this.getContainerAndElement(newChild, container) || {};
    if (!element || !parent) {
      return;
    }
    parent.insertAdjacentElement("afterbegin", element);
  }
  appendChild(newChild, container) {
    const { element, parent } = this.getContainerAndElement(newChild, container) || {};
    if (!element || !parent) {
      return;
    }
    parent.appendChild(element);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(visible, options = {}) {
    if (visible !== this.visible) {
      this.visible = visible;
      const { skipAriaHidden } = options;
      _setVisible(this.eGui, visible, { skipAriaHidden });
    }
  }
  setDisplayed(displayed, options = {}) {
    if (displayed !== this.displayed) {
      this.displayed = displayed;
      const { skipAriaHidden } = options;
      _setDisplayed(this.eGui, displayed, { skipAriaHidden });
      const event = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(event);
    }
  }
  destroy() {
    if (this.parentComponent) {
      this.parentComponent = void 0;
    }
    super.destroy();
  }
  addGuiEventListener(event, listener, options) {
    this.eGui.addEventListener(event, listener, options);
    this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
  }
  addCssClass(className) {
    this.cssClassManager.addCssClass(className);
  }
  removeCssClass(className) {
    this.cssClassManager.removeCssClass(className);
  }
  containsCssClass(className) {
    return this.cssClassManager.containsCssClass(className);
  }
  addOrRemoveCssClass(className, addOrRemove) {
    this.cssClassManager.addOrRemoveCssClass(className, addOrRemove);
  }
  registerCSS(css) {
    this.css || (this.css = []);
    this.css.push(css);
  }
};

// packages/ag-grid-community/src/utils/promise.ts
function _isPromise(fn) {
  if (typeof fn.then === "function") {
    return true;
  }
  return false;
}
var AgPromise = class _AgPromise {
  constructor(callback) {
    this.status = 0 /* IN_PROGRESS */;
    this.resolution = null;
    this.waiters = [];
    callback(
      (value) => this.onDone(value),
      (params) => this.onReject(params)
    );
  }
  static all(promises) {
    return promises.length ? new _AgPromise((resolve) => {
      let remainingToResolve = promises.length;
      const combinedValues = new Array(remainingToResolve);
      promises.forEach((promise, index) => {
        promise.then((value) => {
          combinedValues[index] = value;
          remainingToResolve--;
          if (remainingToResolve === 0) {
            resolve(combinedValues);
          }
        });
      });
    }) : _AgPromise.resolve();
  }
  static resolve(value = null) {
    return new _AgPromise((resolve) => resolve(value));
  }
  then(func) {
    return new _AgPromise((resolve) => {
      if (this.status === 1 /* RESOLVED */) {
        resolve(func(this.resolution));
      } else {
        this.waiters.push((value) => resolve(func(value)));
      }
    });
  }
  onDone(value) {
    this.status = 1 /* RESOLVED */;
    this.resolution = value;
    this.waiters.forEach((waiter) => waiter(value));
  }
  onReject(_) {
  }
};

// packages/ag-grid-community/src/components/framework/userComponentFactory.ts
function doesImplementIComponent(candidate) {
  if (!candidate) {
    return false;
  }
  return candidate.prototype && "getGui" in candidate.prototype;
}
function _getUserCompKeys(frameworkOverrides, defObject, type, params) {
  const { name } = type;
  let compName;
  let jsComp;
  let fwComp;
  let paramsFromSelector;
  let popupFromSelector;
  let popupPositionFromSelector;
  if (defObject) {
    const defObjectAny = defObject;
    const selectorFunc = defObjectAny[name + "Selector"];
    const selectorRes = selectorFunc ? selectorFunc(params) : null;
    const assignComp = (providedJsComp) => {
      if (typeof providedJsComp === "string") {
        compName = providedJsComp;
      } else if (providedJsComp != null && providedJsComp !== true) {
        const isFwkComp = frameworkOverrides.isFrameworkComponent(providedJsComp);
        if (isFwkComp) {
          fwComp = providedJsComp;
        } else {
          jsComp = providedJsComp;
        }
      }
    };
    if (selectorRes) {
      assignComp(selectorRes.component);
      paramsFromSelector = selectorRes.params;
      popupFromSelector = selectorRes.popup;
      popupPositionFromSelector = selectorRes.popupPosition;
    } else {
      assignComp(defObjectAny[name]);
    }
  }
  return { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector };
}
var UserComponentFactory = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "userCompFactory";
  }
  wireBeans(beans) {
    this.agCompUtils = beans.agCompUtils;
    this.registry = beans.registry;
    this.frameworkCompWrapper = beans.frameworkCompWrapper;
    this.gridOptions = beans.gridOptions;
  }
  getCompDetailsFromGridOptions(type, defaultName, params, mandatory = false) {
    return this.getCompDetails(this.gridOptions, type, defaultName, params, mandatory);
  }
  getCompDetails(defObject, type, defaultName, params, mandatory = false) {
    const { name, cellRenderer } = type;
    let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = _getUserCompKeys(this.beans.frameworkOverrides, defObject, type, params);
    let defaultCompParams;
    const lookupFromRegistry = (key) => {
      const item = this.registry.getUserComponent(name, key);
      if (item) {
        jsComp = !item.componentFromFramework ? item.component : void 0;
        fwComp = item.componentFromFramework ? item.component : void 0;
        defaultCompParams = item.params;
      }
    };
    if (compName != null) {
      lookupFromRegistry(compName);
    }
    if (jsComp == null && fwComp == null && defaultName != null) {
      lookupFromRegistry(defaultName);
    }
    if (jsComp && cellRenderer && !doesImplementIComponent(jsComp)) {
      jsComp = this.agCompUtils?.adaptFunction(type, jsComp);
    }
    if (!jsComp && !fwComp) {
      const { validation: validation2 } = this.beans;
      if (mandatory && (compName !== defaultName || !defaultName)) {
        if (compName) {
          if (!validation2?.isProvidedUserComp(compName)) {
            _error(50, { compName });
          }
        } else {
          if (defaultName) {
            if (!validation2) {
              _error(260, {
                ...this.gos.getModuleErrorParams(),
                propName: name,
                compName: defaultName
              });
            }
          } else {
            _error(216, { name });
          }
        }
      } else if (defaultName && !validation2) {
        _error(146, { comp: defaultName });
      }
      return;
    }
    const paramsMerged = this.mergeParams(defObject, type, params, paramsFromSelector, defaultCompParams);
    const componentFromFramework = jsComp == null;
    const componentClass = jsComp ?? fwComp;
    return {
      componentFromFramework,
      componentClass,
      params: paramsMerged,
      type,
      popupFromSelector,
      popupPositionFromSelector,
      newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
    };
  }
  newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
    const jsComponent = !componentFromFramework;
    let instance;
    if (jsComponent) {
      instance = new ComponentClass();
    } else {
      instance = this.frameworkCompWrapper.wrap(
        ComponentClass,
        type.mandatoryMethods,
        type.optionalMethods,
        type
      );
    }
    this.createBean(instance);
    const deferredInit = instance.init?.(params);
    if (deferredInit == null) {
      return AgPromise.resolve(instance);
    }
    return deferredInit.then(() => instance);
  }
  /**
   * merges params with application provided params
   * used by Floating Filter
   */
  mergeParams(defObject, type, paramsFromGrid, paramsFromSelector = null, defaultCompParams) {
    const params = this.gos.getGridCommonParams();
    _mergeDeep(params, paramsFromGrid);
    if (defaultCompParams) {
      _mergeDeep(params, defaultCompParams);
    }
    const defObjectAny = defObject;
    const userParams = defObjectAny && defObjectAny[type.name + "Params"];
    if (typeof userParams === "function") {
      const userParamsFromFunc = userParams(paramsFromGrid);
      _mergeDeep(params, userParamsFromFunc);
    } else if (typeof userParams === "object") {
      _mergeDeep(params, userParams);
    }
    _mergeDeep(params, paramsFromSelector);
    return params;
  }
};

// packages/ag-grid-community/src/components/framework/userCompUtils.ts
var DateComponent = {
  name: "dateComponent",
  mandatoryMethods: ["getDate", "setDate"],
  optionalMethods: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "refresh"]
};
var DragAndDropImageComponent = {
  name: "dragAndDropImageComponent",
  mandatoryMethods: ["setIcon", "setLabel"]
};
var HeaderComponent = { name: "headerComponent", optionalMethods: ["refresh"] };
var InnerHeaderComponent = { name: "innerHeaderComponent" };
var InnerHeaderGroupComponent = { name: "innerHeaderGroupComponent" };
var HeaderGroupComponent = { name: "headerGroupComponent" };
var InnerCellRendererComponent = {
  name: "innerRenderer",
  cellRenderer: true,
  optionalMethods: ["afterGuiAttached"]
};
var CellRendererComponent = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: true
};
var EditorRendererComponent = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"]
};
var LoadingCellRendererComponent = { name: "loadingCellRenderer", cellRenderer: true };
var CellEditorComponent = {
  name: "cellEditor",
  mandatoryMethods: ["getValue"],
  optionalMethods: [
    "isPopup",
    "isCancelBeforeStart",
    "isCancelAfterEnd",
    "getPopupPosition",
    "focusIn",
    "focusOut",
    "afterGuiAttached",
    "refresh"
  ]
};
var LoadingOverlayComponent = { name: "loadingOverlayComponent", optionalMethods: ["refresh"] };
var NoRowsOverlayComponent = { name: "noRowsOverlayComponent", optionalMethods: ["refresh"] };
var TooltipComponent = { name: "tooltipComponent" };
var FilterComponent = {
  name: "filter",
  mandatoryMethods: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
  optionalMethods: [
    "afterGuiAttached",
    "afterGuiDetached",
    "onNewRowsLoaded",
    "getModelAsString",
    "onFloatingFilterChanged",
    "onAnyFilterChanged",
    "refresh"
  ]
};
var FloatingFilterComponent = {
  name: "floatingFilterComponent",
  mandatoryMethods: ["onParentModelChanged"],
  optionalMethods: ["afterGuiAttached", "refresh"]
};
var FullWidth = {
  name: "fullWidthCellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: true
};
var FullWidthLoading = { name: "loadingCellRenderer", cellRenderer: true };
var FullWidthGroup = {
  name: "groupRowRenderer",
  optionalMethods: ["afterGuiAttached"],
  cellRenderer: true
};
var FullWidthDetail = { name: "detailCellRenderer", optionalMethods: ["refresh"], cellRenderer: true };
function _getDragAndDropImageCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(DragAndDropImageComponent, "agDragAndDropImage", params, true);
}
function _getInnerCellRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, InnerCellRendererComponent, void 0, params);
}
function _getHeaderCompDetails(userCompFactory, colDef, params) {
  return userCompFactory.getCompDetails(colDef, HeaderComponent, "agColumnHeader", params);
}
function _getInnerHeaderCompDetails(userCompFactory, headerCompParams, params) {
  return userCompFactory.getCompDetails(headerCompParams, InnerHeaderComponent, void 0, params);
}
function _getHeaderGroupCompDetails(userCompFactory, params) {
  const colGroupDef = params.columnGroup.getColGroupDef();
  return userCompFactory.getCompDetails(colGroupDef, HeaderGroupComponent, "agColumnGroupHeader", params);
}
function _getInnerHeaderGroupCompDetails(userCompFactory, headerGroupCompParams, params) {
  return userCompFactory.getCompDetails(headerGroupCompParams, InnerHeaderGroupComponent, void 0, params);
}
function _getFullWidthCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidth, void 0, params, true);
}
function _getFullWidthLoadingCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthLoading, "agLoadingCellRenderer", params, true);
}
function _getFullWidthGroupCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthGroup, "agGroupRowRenderer", params, true);
}
function _getFullWidthDetailCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthDetail, "agDetailCellRenderer", params, true);
}
function _getCellRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, CellRendererComponent, void 0, params);
}
function _getEditorRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(
    def,
    EditorRendererComponent,
    void 0,
    params
  );
}
function _getLoadingCellRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, LoadingCellRendererComponent, "agSkeletonCellRenderer", params, true);
}
function _getCellEditorDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, CellEditorComponent, "agCellEditor", params, true);
}
function _getFilterDetails(userCompFactory, def, params, defaultFilter) {
  return userCompFactory.getCompDetails(def, FilterComponent, defaultFilter, params, true);
}
function _getDateCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(DateComponent, "agDateInput", params, true);
}
function _getLoadingOverlayCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(LoadingOverlayComponent, "agLoadingOverlay", params, true);
}
function _getNoRowsOverlayCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(NoRowsOverlayComponent, "agNoRowsOverlay", params, true);
}
function _getTooltipCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetails(params.colDef, TooltipComponent, "agTooltipComponent", params, true);
}
function _getFloatingFilterCompDetails(userCompFactory, def, params, defaultFloatingFilter) {
  return userCompFactory.getCompDetails(def, FloatingFilterComponent, defaultFloatingFilter, params);
}
function _getFilterCompKeys(frameworkOverrides, def) {
  return _getUserCompKeys(frameworkOverrides, def, FilterComponent);
}
function _mergeFilterParamsWithApplicationProvidedParams(userCompFactory, defObject, paramsFromGrid) {
  return userCompFactory.mergeParams(defObject, FilterComponent, paramsFromGrid);
}

// packages/ag-grid-community/src/components/framework/unwrapUserComp.ts
function _unwrapUserComp(comp) {
  const compAsAny = comp;
  const isProxy = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
  return isProxy ? compAsAny.getFrameworkComponentInstance() : comp;
}

// packages/ag-grid-community/src/modules/moduleRegistry.ts
var allRegisteredModules = /* @__PURE__ */ new Set();
var globalModulesMap = {};
var gridModulesMap = {};
var currentModuleVersion;
var areGridScopedModules = false;
function isValidModuleVersion(module2) {
  const [moduleMajor, moduleMinor] = module2.version.split(".") || [];
  const [currentModuleMajor, currentModuleMinor] = currentModuleVersion.split(".") || [];
  return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
}
function runVersionChecks(module2) {
  if (!currentModuleVersion) {
    currentModuleVersion = module2.version;
  }
  const errorMsg = (details) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${details} Please update all modules to the same version.`;
  if (!module2.version) {
    _errorOnce(errorMsg(`'${module2.moduleName}' is incompatible.`));
  } else if (!isValidModuleVersion(module2)) {
    _errorOnce(
      errorMsg(
        `'${module2.moduleName}' is version ${module2.version} but the other modules are version ${currentModuleVersion}.`
      )
    );
  }
  if (module2.validate) {
    const result = module2.validate();
    if (!result.isValid) {
      const errorResult = result;
      _errorOnce(`${errorResult.message}`);
    }
  }
}
function _registerModule(module2, gridId) {
  runVersionChecks(module2);
  const rowModels = module2.rowModels ?? ["all"];
  allRegisteredModules.add(module2);
  let moduleStore;
  if (gridId !== void 0) {
    areGridScopedModules = true;
    if (gridModulesMap[gridId] === void 0) {
      gridModulesMap[gridId] = {};
    }
    moduleStore = gridModulesMap[gridId];
  } else {
    moduleStore = globalModulesMap;
  }
  rowModels.forEach((rowModel) => {
    if (moduleStore[rowModel] === void 0) {
      moduleStore[rowModel] = {};
    }
    moduleStore[rowModel][module2.moduleName] = module2;
  });
  if (module2.dependsOn) {
    module2.dependsOn.forEach((dependency) => _registerModule(dependency, gridId));
  }
}
function _unRegisterGridModules(gridId) {
  delete gridModulesMap[gridId];
}
function _isModuleRegistered(moduleName, gridId, rowModel) {
  const isRegisteredForRowModel = (model) => !!globalModulesMap[model]?.[moduleName] || !!gridModulesMap[gridId]?.[model]?.[moduleName];
  return isRegisteredForRowModel(rowModel) || isRegisteredForRowModel("all");
}
function _areModulesGridScoped() {
  return areGridScopedModules;
}
function _getRegisteredModules(gridId, rowModel) {
  const gridModules = gridModulesMap[gridId] ?? {};
  return [
    ...Object.values(globalModulesMap["all"] ?? {}),
    ...Object.values(gridModules["all"] ?? {}),
    ...Object.values(globalModulesMap[rowModel] ?? {}),
    ...Object.values(gridModules[rowModel] ?? {})
  ];
}
function _getAllRegisteredModules() {
  return new Set(allRegisteredModules);
}
function _getGridRegisteredModules(gridId, rowModel) {
  const gridModules = gridModulesMap[gridId] ?? {};
  return [...Object.values(gridModules["all"] ?? {}), ...Object.values(gridModules[rowModel] ?? {})];
}
var ModuleRegistry = class {
  /**
   * @deprecated v33 Use `registerModules([module])` instead.
   */
  static register(module2) {
    _registerModule(module2, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(modules) {
    modules.forEach((module2) => _registerModule(module2, void 0));
  }
};

// packages/ag-grid-community/src/context/genericContext.ts
var GenericContext = class {
  constructor(params) {
    this.beans = {};
    this.createdBeans = [];
    this.destroyed = false;
    if (!params || !params.beanClasses) {
      return;
    }
    this.beanDestroyComparator = params.beanDestroyComparator;
    this.init(params);
  }
  init(params) {
    Object.entries(params.providedBeanInstances).forEach(([beanName, beanInstance]) => {
      this.beans[beanName] = beanInstance;
    });
    params.beanClasses.forEach((BeanClass) => {
      const instance = new BeanClass();
      if (instance.beanName) {
        this.beans[instance.beanName] = instance;
      } else {
        console.error(`Bean ${BeanClass.name} is missing beanName`);
      }
      this.createdBeans.push(instance);
    });
    params.derivedBeans?.forEach((beanFunc) => {
      const { beanName, bean } = beanFunc(this);
      this.beans[beanName] = bean;
      this.createdBeans.push(bean);
    });
    if (params.beanInitComparator) {
      this.createdBeans.sort(params.beanInitComparator);
    }
    this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(bean, afterPreCreateCallback) {
    if (!bean) {
      throw Error("null bean");
    }
    this.initBeans([bean], afterPreCreateCallback);
    return bean;
  }
  initBeans(beanInstances, afterPreCreateCallback) {
    beanInstances.forEach((instance) => {
      instance.preWireBeans?.(this.beans);
      instance.wireBeans?.(this.beans);
    });
    beanInstances.forEach((instance) => instance.preConstruct?.());
    if (afterPreCreateCallback) {
      beanInstances.forEach(afterPreCreateCallback);
    }
    beanInstances.forEach((instance) => instance.postConstruct?.());
  }
  getBeans() {
    return this.beans;
  }
  getBean(name) {
    return this.beans[name];
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    const beanInstances = this.getBeanInstances();
    if (this.beanDestroyComparator) {
      beanInstances.sort(this.beanDestroyComparator);
    }
    this.destroyBeans(beanInstances);
    this.beans = {};
    this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(bean) {
    bean?.destroy?.();
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(beans) {
    if (beans) {
      for (let i = 0; i < beans.length; i++) {
        this.destroyBean(beans[i]);
      }
    }
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
};

// packages/ag-grid-community/src/context/context.ts
var Context = class extends GenericContext {
  init(params) {
    this.gridId = params.gridId;
    this.beans.context = this;
    this.destroyCallback = params.destroyCallback;
    super.init(params);
  }
  destroy() {
    super.destroy();
    _unRegisterGridModules(this.gridId);
    this.destroyCallback?.();
  }
  getGridId() {
    return this.gridId;
  }
};

// packages/ag-grid-community/src/headerRendering/cells/cssClassApplier.ts
var CSS_FIRST_COLUMN = "ag-column-first";
var CSS_LAST_COLUMN = "ag-column-last";
function _getHeaderClassesFromColDef(abstractColDef, gos, column, columnGroup) {
  if (_missing(abstractColDef)) {
    return [];
  }
  return getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gos, column, columnGroup);
}
function _getToolPanelClassesFromColDef(abstractColDef, gos, column, columnGroup) {
  if (_missing(abstractColDef)) {
    return [];
  }
  return getColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, gos, column, columnGroup);
}
function refreshFirstAndLastStyles(comp, column, presentedColsService) {
  comp.addOrRemoveCssClass(CSS_FIRST_COLUMN, presentedColsService.isColAtEdge(column, "first"));
  comp.addOrRemoveCssClass(CSS_LAST_COLUMN, presentedColsService.isColAtEdge(column, "last"));
}
function getClassParams(abstractColDef, gos, column, columnGroup) {
  return gos.addGridCommonParams({
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: abstractColDef,
    column,
    columnGroup
  });
}
function getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
  if (_missing(classesOrFunc)) {
    return [];
  }
  let classToUse;
  if (typeof classesOrFunc === "function") {
    const params = getClassParams(abstractColDef, gos, column, columnGroup);
    classToUse = classesOrFunc(params);
  } else {
    classToUse = classesOrFunc;
  }
  if (typeof classToUse === "string") {
    return [classToUse];
  }
  if (Array.isArray(classToUse)) {
    return [...classToUse];
  }
  return [];
}

// packages/ag-grid-community/src/misc/animationFrameService.ts
function _requestAnimationFrame(beans, callback) {
  const win = _getWindow(beans);
  if (win.requestAnimationFrame) {
    win.requestAnimationFrame(callback);
  } else if (win.webkitRequestAnimationFrame) {
    win.webkitRequestAnimationFrame(callback);
  } else {
    win.setTimeout(callback, 0);
  }
}
var AnimationFrameService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "animationFrameSvc";
    // p1 and p2 are create tasks are to do with row and cell creation.
    // for them we want to execute according to row order, so we use
    // TaskItem so we know what index the item is for.
    this.createTasksP1 = { list: [], sorted: false };
    // eg drawing back-ground of rows
    this.createTasksP2 = { list: [], sorted: false };
    // eg cell renderers, adding hover functionality
    // destroy tasks are to do with row removal. they are done after row creation as the user will need to see new
    // rows first (as blank is scrolled into view), when we remove the old rows (no longer in view) is not as
    // important.
    this.destroyTasks = [];
    this.ticking = false;
    // we need to know direction of scroll, to build up rows in the direction of
    // the scroll. eg if user scrolls down, we extend the rows by building down.
    this.scrollGoingDown = true;
    this.lastPage = 0;
    this.lastScrollTop = 0;
    this.taskCount = 0;
    this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  setScrollTop(scrollTop) {
    const { gos, pagination } = this.beans;
    const isPaginationActive = gos.get("pagination");
    this.scrollGoingDown = scrollTop >= this.lastScrollTop;
    if (isPaginationActive && scrollTop === 0) {
      const currentPage = pagination?.getCurrentPage() ?? 0;
      if (currentPage !== this.lastPage) {
        this.lastPage = currentPage;
        this.scrollGoingDown = true;
      }
    }
    this.lastScrollTop = scrollTop;
  }
  postConstruct() {
    this.active = !this.gos.get("suppressAnimationFrame");
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(methodName) {
    if (this.active === false) {
      _warn(92, { methodName });
    }
  }
  createTask(task, index, list) {
    this.verifyAnimationFrameOn(list);
    const taskItem = { task, index, createOrder: ++this.taskCount };
    this.addTaskToList(this[list], taskItem);
    this.schedule();
  }
  cancelTask(task) {
    this.cancelledTasks.add(task);
  }
  addTaskToList(taskList, task) {
    taskList.list.push(task);
    taskList.sorted = false;
  }
  sortTaskList(taskList) {
    if (taskList.sorted) {
      return;
    }
    const sortDirection = this.scrollGoingDown ? 1 : -1;
    taskList.list.sort(
      (a, b) => a.index !== b.index ? sortDirection * (b.index - a.index) : b.createOrder - a.createOrder
    );
    taskList.sorted = true;
  }
  addDestroyTask(task) {
    this.verifyAnimationFrameOn("createTasksP3");
    this.destroyTasks.push(task);
    this.schedule();
  }
  executeFrame(millis) {
    this.verifyAnimationFrameOn("executeFrame");
    const p1TaskList = this.createTasksP1;
    const p1Tasks = p1TaskList.list;
    const p2TaskList = this.createTasksP2;
    const p2Tasks = p2TaskList.list;
    const destroyTasks = this.destroyTasks;
    const frameStart = (/* @__PURE__ */ new Date()).getTime();
    let duration = (/* @__PURE__ */ new Date()).getTime() - frameStart;
    const noMaxMillis = millis <= 0;
    const scrollFeature = this.beans.ctrlsSvc.getScrollFeature();
    while (noMaxMillis || duration < millis) {
      const gridBodyDidSomething = scrollFeature.scrollGridIfNeeded();
      if (!gridBodyDidSomething) {
        let task;
        if (p1Tasks.length) {
          this.sortTaskList(p1TaskList);
          task = p1Tasks.pop().task;
        } else if (p2Tasks.length) {
          this.sortTaskList(p2TaskList);
          task = p2Tasks.pop().task;
        } else if (destroyTasks.length) {
          task = destroyTasks.pop();
        } else {
          this.cancelledTasks.clear();
          break;
        }
        if (!this.cancelledTasks.has(task)) {
          task();
        }
      }
      duration = (/* @__PURE__ */ new Date()).getTime() - frameStart;
    }
    if (p1Tasks.length || p2Tasks.length || destroyTasks.length) {
      this.requestFrame();
    } else {
      this.ticking = false;
    }
  }
  flushAllFrames() {
    if (!this.active) {
      return;
    }
    this.executeFrame(-1);
  }
  schedule() {
    if (!this.active) {
      return;
    }
    if (!this.ticking) {
      this.ticking = true;
      this.requestFrame();
    }
  }
  requestFrame() {
    const callback = this.executeFrame.bind(this, 60);
    _requestAnimationFrame(this.beans, callback);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
};

// packages/ag-grid-community/src/constants/keyCode.ts
var KeyCode = {
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  DELETE: "Delete",
  F2: "F2",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PAGE_HOME: "Home",
  PAGE_END: "End",
  // these should be used with `event.code` instead of `event.key`
  // as `event.key` changes when non-latin keyboards are used
  A: "KeyA",
  C: "KeyC",
  D: "KeyD",
  V: "KeyV",
  X: "KeyX",
  Y: "KeyY",
  Z: "KeyZ"
};

// packages/ag-grid-community/src/utils/focus.ts
var keyboardModeActive = false;
var instanceCount = 0;
function addKeyboardModeEvents(doc) {
  if (instanceCount > 0) {
    return;
  }
  doc.addEventListener("keydown", toggleKeyboardMode);
  doc.addEventListener("mousedown", toggleKeyboardMode);
}
function removeKeyboardModeEvents(doc) {
  if (instanceCount > 0)
    return;
  doc.removeEventListener("keydown", toggleKeyboardMode);
  doc.removeEventListener("mousedown", toggleKeyboardMode);
}
function toggleKeyboardMode(event) {
  const isKeyboardActive = keyboardModeActive;
  const isKeyboardEvent = event.type === "keydown";
  if (isKeyboardEvent) {
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return;
    }
  }
  if (isKeyboardActive === isKeyboardEvent) {
    return;
  }
  keyboardModeActive = isKeyboardEvent;
}
function _registerKeyboardFocusEvents(beans) {
  const eDocument = _getDocument(beans);
  addKeyboardModeEvents(eDocument);
  instanceCount++;
  return () => {
    instanceCount--;
    removeKeyboardModeEvents(eDocument);
  };
}
function _isKeyboardMode() {
  return keyboardModeActive;
}
function _addFocusableContainerListener(beans, comp, eGui) {
  comp.addManagedElementListeners(eGui, {
    keydown: (e) => {
      if (!e.defaultPrevented && e.key === KeyCode.TAB) {
        const backwards = e.shiftKey;
        if (!_findNextFocusableElement(beans, eGui, false, backwards)) {
          if (_focusNextGridCoreContainer(beans, backwards)) {
            e.preventDefault();
          }
        }
      }
    }
  });
}
function _findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
  const focusableString = FOCUSABLE_SELECTOR;
  let excludeString = FOCUSABLE_EXCLUDE;
  if (exclude) {
    excludeString += ", " + exclude;
  }
  if (onlyUnmanaged) {
    excludeString += ', [tabindex="-1"]';
  }
  const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)).filter((node) => {
    return _isVisible(node);
  });
  const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
  if (!excludeNodes.length) {
    return nodes;
  }
  const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
  return diff(nodes, excludeNodes);
}
function _focusInto(rootNode, up = false, onlyUnmanaged = false) {
  const focusableElements = _findFocusableElements(rootNode, null, onlyUnmanaged);
  const toFocus = up ? _last(focusableElements) : focusableElements[0];
  if (toFocus) {
    toFocus.focus({ preventScroll: true });
    return true;
  }
  return false;
}
function _findNextFocusableElement(beans, rootNode, onlyManaged, backwards) {
  const focusable = _findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
  const activeEl = _getActiveDomElement(beans);
  let currentIndex;
  if (onlyManaged) {
    currentIndex = focusable.findIndex((el) => el.contains(activeEl));
  } else {
    currentIndex = focusable.indexOf(activeEl);
  }
  const nextIndex = currentIndex + (backwards ? -1 : 1);
  if (nextIndex < 0 || nextIndex >= focusable.length) {
    return null;
  }
  return focusable[nextIndex];
}
function _findTabbableParent(node, limit = 5) {
  let counter = 0;
  while (node && _getTabIndex(node) === null && ++counter <= limit) {
    node = node.parentElement;
  }
  if (_getTabIndex(node) === null) {
    return null;
  }
  return node;
}
function _focusGridInnerElement(beans, fromBottom) {
  return beans.ctrlsSvc.get("gridCtrl").focusInnerElement(fromBottom);
}
function _isHeaderFocusSuppressed(beans) {
  return beans.gos.get("suppressHeaderFocus") || !!beans.overlays?.isExclusive();
}
function _isCellFocusSuppressed(beans) {
  return beans.gos.get("suppressCellFocus") || !!beans.overlays?.isExclusive();
}
function _focusNextGridCoreContainer(beans, backwards, forceOut = false) {
  const gridCtrl = beans.ctrlsSvc.get("gridCtrl");
  if (!forceOut && gridCtrl.focusNextInnerContainer(backwards)) {
    return true;
  }
  if (forceOut || !backwards && !gridCtrl.isDetailGrid()) {
    gridCtrl.forceFocusOutOfContainer(backwards);
  }
  return false;
}

// packages/ag-grid-community/src/utils/string.ts
var reUnescapedHtml = /[&<>"']/g;
var HTML_ESCAPES = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function _escapeString(toEscape, skipEscapingHtmlChars) {
  if (toEscape == null) {
    return null;
  }
  const stringResult = toEscape.toString().toString();
  if (skipEscapingHtmlChars) {
    return stringResult;
  }
  return stringResult.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr]);
}

// packages/ag-grid-community/src/rendering/cell/cellKeyboardListenerFeature.ts
function _isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
  if (key === KeyCode.DELETE) {
    return true;
  }
  if (!alwaysReturnFalseOnBackspace && key === KeyCode.BACKSPACE) {
    return _isMacOsUserAgent();
  }
  return false;
}
var CellKeyboardListenerFeature = class extends BeanStub {
  constructor(cellCtrl, beans, rowNode, rowCtrl) {
    super();
    this.cellCtrl = cellCtrl;
    this.rowNode = rowNode;
    this.rowCtrl = rowCtrl;
    this.beans = beans;
  }
  setComp(eGui) {
    this.eGui = eGui;
  }
  onKeyDown(event) {
    const key = event.key;
    switch (key) {
      case KeyCode.ENTER:
        this.onEnterKeyDown(event);
        break;
      case KeyCode.F2:
        this.onF2KeyDown(event);
        break;
      case KeyCode.ESCAPE:
        this.onEscapeKeyDown(event);
        break;
      case KeyCode.TAB:
        this.onTabKeyDown(event);
        break;
      case KeyCode.BACKSPACE:
      case KeyCode.DELETE:
        this.onBackspaceOrDeleteKeyDown(key, event);
        break;
      case KeyCode.DOWN:
      case KeyCode.UP:
      case KeyCode.RIGHT:
      case KeyCode.LEFT:
        this.onNavigationKeyDown(event, key);
        break;
    }
  }
  onNavigationKeyDown(event, key) {
    if (this.cellCtrl.editing) {
      return;
    }
    if (event.shiftKey && this.cellCtrl.isRangeSelectionEnabled()) {
      this.onShiftRangeSelect(event);
    } else {
      this.beans.navigation?.navigateToNextCell(event, key, this.cellCtrl.cellPosition, true);
    }
    event.preventDefault();
  }
  onShiftRangeSelect(event) {
    const { rangeSvc, navigation } = this.beans;
    if (!rangeSvc) {
      return;
    }
    const endCell = rangeSvc.extendLatestRangeInDirection(event);
    if (endCell) {
      navigation?.ensureCellVisible(endCell);
    }
  }
  onTabKeyDown(event) {
    this.beans.navigation?.onTabKeyDown(this.cellCtrl, event);
  }
  onBackspaceOrDeleteKeyDown(key, event) {
    const { cellCtrl, beans, rowNode } = this;
    const { gos, rangeSvc, eventSvc } = beans;
    if (cellCtrl.editing) {
      return;
    }
    eventSvc.dispatchEvent({ type: "keyShortcutChangedCellStart" });
    if (_isDeleteKey(key, gos.get("enableCellEditingOnBackspace"))) {
      if (rangeSvc && _isCellSelectionEnabled(gos)) {
        rangeSvc.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: "deleteKey" });
      } else if (cellCtrl.isCellEditable()) {
        const { column } = cellCtrl;
        const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
        rowNode.setDataValue(column, emptyValue, "cellClear");
      }
    } else {
      beans.editSvc?.startRowOrCellEdit(cellCtrl, key, event);
    }
    eventSvc.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
  }
  onEnterKeyDown(e) {
    const { cellCtrl, beans } = this;
    if (cellCtrl.editing || this.rowCtrl.editing) {
      cellCtrl.stopEditingAndFocus(false, e.shiftKey);
    } else {
      if (beans.gos.get("enterNavigatesVertically")) {
        const key = e.shiftKey ? KeyCode.UP : KeyCode.DOWN;
        beans.navigation?.navigateToNextCell(null, key, cellCtrl.cellPosition, false);
      } else {
        beans.editSvc?.startRowOrCellEdit(cellCtrl, KeyCode.ENTER, e);
        if (cellCtrl.editing) {
          e.preventDefault();
        }
      }
    }
  }
  onF2KeyDown(event) {
    const { cellCtrl, beans } = this;
    if (!cellCtrl.editing) {
      beans.editSvc?.startRowOrCellEdit(cellCtrl, KeyCode.F2, event);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(event) {
    const { cellCtrl, beans } = this;
    if (cellCtrl.editing) {
      beans.editSvc?.stopRowOrCellEdit(cellCtrl, true);
      cellCtrl.focusCell(true);
    }
  }
  processCharacter(event) {
    const eventTarget = event.target;
    const eventOnChildComponent = eventTarget !== this.eGui;
    if (eventOnChildComponent || this.cellCtrl.editing) {
      return;
    }
    const key = event.key;
    if (key === KeyCode.SPACE) {
      this.onSpaceKeyDown(event);
    } else {
      if (this.beans.editSvc?.startRowOrCellEdit(this.cellCtrl, key, event)) {
        event.preventDefault();
      }
    }
  }
  onSpaceKeyDown(event) {
    const { gos } = this.beans;
    if (!this.cellCtrl.editing && _isRowSelection(gos)) {
      this.beans.selectionSvc?.handleSelectionEvent(event, this.rowNode, "spaceKey");
    }
    event.preventDefault();
  }
  destroy() {
    super.destroy();
  }
};

// packages/ag-grid-community/src/rendering/cell/cellMouseListenerFeature.ts
var CellMouseListenerFeature = class extends BeanStub {
  constructor(cellCtrl, beans, column) {
    super();
    this.cellCtrl = cellCtrl;
    this.column = column;
    this.beans = beans;
  }
  onMouseEvent(eventName, mouseEvent) {
    if (_isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    switch (eventName) {
      case "click":
        this.onCellClicked(mouseEvent);
        break;
      case "mousedown":
      case "touchstart":
        this.onMouseDown(mouseEvent);
        break;
      case "dblclick":
        this.onCellDoubleClicked(mouseEvent);
        break;
      case "mouseout":
        this.onMouseOut(mouseEvent);
        break;
      case "mouseover":
        this.onMouseOver(mouseEvent);
        break;
    }
  }
  onCellClicked(mouseEvent) {
    if (this.beans.touchSvc?.handleCellDoubleClick(this, mouseEvent)) {
      return;
    }
    const { eventSvc, rangeSvc, gos, editSvc } = this.beans;
    const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
    if (rangeSvc && isMultiKey) {
      if (rangeSvc.getCellRangeCount(this.cellCtrl.cellPosition) > 1) {
        rangeSvc.intersectLastRange(true);
      }
    }
    const cellClickedEvent = this.cellCtrl.createEvent(mouseEvent, "cellClicked");
    eventSvc.dispatchEvent(cellClickedEvent);
    const colDef = this.column.getColDef();
    if (colDef.onCellClicked) {
      window.setTimeout(() => {
        this.beans.frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellClicked(cellClickedEvent);
        });
      }, 0);
    }
    const editOnSingleClick = (gos.get("singleClickEdit") || colDef.singleClickEdit) && !gos.get("suppressClickEdit");
    if (editOnSingleClick && !(mouseEvent.shiftKey && rangeSvc?.getCellRanges().length != 0)) {
      editSvc?.startRowOrCellEdit(this.cellCtrl);
    }
  }
  onCellDoubleClicked(mouseEvent) {
    const { column, beans, cellCtrl } = this;
    const { eventSvc, frameworkOverrides, gos, editSvc } = beans;
    const colDef = column.getColDef();
    const cellDoubleClickedEvent = cellCtrl.createEvent(mouseEvent, "cellDoubleClicked");
    eventSvc.dispatchEvent(cellDoubleClickedEvent);
    if (typeof colDef.onCellDoubleClicked === "function") {
      window.setTimeout(() => {
        frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellDoubleClicked(cellDoubleClickedEvent);
        });
      }, 0);
    }
    const editOnDoubleClick = !gos.get("singleClickEdit") && !gos.get("suppressClickEdit");
    if (editOnDoubleClick) {
      editSvc?.startRowOrCellEdit(cellCtrl, null, mouseEvent);
    }
  }
  onMouseDown(mouseEvent) {
    const { ctrlKey, metaKey, shiftKey } = mouseEvent;
    const target = mouseEvent.target;
    const { cellCtrl, beans } = this;
    const { eventSvc, rangeSvc, focusSvc, gos } = beans;
    if (this.isRightClickInExistingRange(mouseEvent)) {
      return;
    }
    const hasRanges = rangeSvc && !rangeSvc.isEmpty();
    const containsWidget = this.containsWidget(target);
    const { cellPosition } = cellCtrl;
    if (!shiftKey || !hasRanges) {
      const isEnableCellTextSelection = gos.get("enableCellTextSelection");
      const shouldFocus = isEnableCellTextSelection && mouseEvent.defaultPrevented;
      const forceBrowserFocus = (_isBrowserSafari() || shouldFocus) && !cellCtrl.editing && !_isFocusableFormField(target) && !containsWidget;
      cellCtrl.focusCell(forceBrowserFocus);
    }
    if (shiftKey && hasRanges && !focusSvc.isCellFocused(cellPosition)) {
      mouseEvent.preventDefault();
      const focusedCellPosition = focusSvc.getFocusedCell();
      if (focusedCellPosition) {
        const { column, rowIndex, rowPinned } = focusedCellPosition;
        const focusedRowCtrl = beans.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
        const focusedCellCtrl = focusedRowCtrl?.getCellCtrl(column);
        if (focusedCellCtrl?.editing) {
          focusedCellCtrl.stopEditing();
        }
        focusSvc.setFocusedCell({
          column,
          rowIndex,
          rowPinned,
          forceBrowserFocus: true,
          preventScrollOnBrowserFocus: true
        });
      }
    }
    if (containsWidget) {
      return;
    }
    if (rangeSvc) {
      if (shiftKey) {
        rangeSvc.extendLatestRangeToCell(cellPosition);
      } else {
        const isMultiKey = ctrlKey || metaKey;
        rangeSvc.setRangeToCell(cellPosition, isMultiKey);
      }
    }
    eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseDown"));
  }
  isRightClickInExistingRange(mouseEvent) {
    const { rangeSvc } = this.beans;
    if (rangeSvc) {
      const cellInRange = rangeSvc.isCellInAnyRange(this.cellCtrl.cellPosition);
      const isRightClick = mouseEvent.button === 2 || mouseEvent.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (cellInRange && isRightClick) {
        return true;
      }
    }
    return false;
  }
  containsWidget(target) {
    return _isElementChildOfClass(target, "ag-selection-checkbox", 3) || _isElementChildOfClass(target, "ag-drag-handle", 3);
  }
  onMouseOut(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const { eventSvc, colHover } = this.beans;
    eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOut"));
    colHover?.clearMouseOver();
  }
  onMouseOver(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const { eventSvc, colHover } = this.beans;
    eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOver"));
    colHover?.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget) {
      return false;
    }
    const { eGui } = this.cellCtrl;
    const cellContainsTarget = eGui.contains(e.target);
    const cellContainsRelatedTarget = eGui.contains(e.relatedTarget);
    return cellContainsTarget && cellContainsRelatedTarget;
  }
  destroy() {
    super.destroy();
  }
};

// packages/ag-grid-community/src/rendering/cell/cellPositionFeature.ts
var CellPositionFeature = class extends BeanStub {
  constructor(cellCtrl, beans) {
    super();
    this.cellCtrl = cellCtrl;
    this.beans = beans;
    this.column = cellCtrl.column;
    this.rowNode = cellCtrl.rowNode;
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode);
    this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(eGui) {
    this.eGui = eGui;
    this.setupColSpan();
    this.setupRowSpan();
    this.onLeftChanged();
    this.onWidthChanged();
    this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const rowSpan = this.column.getRowSpan(this.rowNode);
    if (this.rowSpan === rowSpan) {
      return;
    }
    this.rowSpan = rowSpan;
    this.applyRowSpan(true);
  }
  onDisplayColumnsChanged() {
    const colsSpanning = this.getColSpanningList();
    if (!_areEqual(this.colsSpanning, colsSpanning)) {
      this.colsSpanning = colsSpanning;
      this.onWidthChanged();
      this.onLeftChanged();
    }
  }
  setupColSpan() {
    if (this.column.getColDef().colSpan == null) {
      return;
    }
    this.colsSpanning = this.getColSpanningList();
    this.addManagedListeners(this.beans.eventSvc, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    });
  }
  onWidthChanged() {
    if (!this.eGui) {
      return;
    }
    const width = this.getCellWidth();
    this.eGui.style.width = `${width}px`;
  }
  getCellWidth() {
    if (!this.colsSpanning) {
      return this.column.getActualWidth();
    }
    return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
  }
  getColSpanningList() {
    const { column, rowNode } = this;
    const colSpan = column.getColSpan(rowNode);
    const colsSpanning = [];
    if (colSpan === 1) {
      colsSpanning.push(column);
    } else {
      let pointer = column;
      const pinned = column.getPinned();
      for (let i = 0; pointer && i < colSpan; i++) {
        colsSpanning.push(pointer);
        pointer = this.beans.visibleCols.getColAfter(pointer);
        if (!pointer || _missing(pointer)) {
          break;
        }
        if (pinned !== pointer.getPinned()) {
          break;
        }
      }
    }
    return colsSpanning;
  }
  onLeftChanged() {
    if (!this.eGui) {
      return;
    }
    const left = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = left + "px";
  }
  getCellLeft() {
    let mostLeftCol;
    if (this.beans.gos.get("enableRtl") && this.colsSpanning) {
      mostLeftCol = _last(this.colsSpanning);
    } else {
      mostLeftCol = this.column;
    }
    return mostLeftCol.getLeft();
  }
  modifyLeftForPrintLayout(leftPosition) {
    if (!this.cellCtrl.printLayout || this.column.getPinned() === "left") {
      return leftPosition;
    }
    const { visibleCols } = this.beans;
    const leftWidth = visibleCols.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const bodyWidth = visibleCols.bodyWidth;
      return leftWidth + bodyWidth + (leftPosition || 0);
    }
    return leftWidth + (leftPosition || 0);
  }
  applyRowSpan(force) {
    if (this.rowSpan === 1 && !force) {
      return;
    }
    const singleRowHeight = _getRowHeightAsNumber(this.beans);
    const totalRowHeight = singleRowHeight * this.rowSpan;
    this.eGui.style.height = `${totalRowHeight}px`;
    this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
};

// packages/ag-grid-community/src/rendering/cell/cellCtrl.ts
var CSS_CELL = "ag-cell";
var CSS_AUTO_HEIGHT = "ag-cell-auto-height";
var CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
var CSS_CELL_FOCUS = "ag-cell-focus";
var CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
var CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
var CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
var CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
var DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
function _getCellCtrlForEventTarget(gos, eventTarget) {
  return _getCtrlForEventTarget(gos, eventTarget, DOM_DATA_KEY_CELL_CTRL);
}
var instanceIdSequence2 = 0;
var CellCtrl = class extends BeanStub {
  constructor(column, rowNode, beans, rowCtrl) {
    super();
    this.column = column;
    this.rowNode = rowNode;
    this.rowCtrl = rowCtrl;
    this.rangeFeature = void 0;
    this.positionFeature = void 0;
    this.customStyleFeature = void 0;
    this.tooltipFeature = void 0;
    this.mouseListener = void 0;
    this.keyboardListener = void 0;
    this.suppressRefreshCell = false;
    this.onCompAttachedFuncs = [];
    this.onEditorAttachedFuncs = [];
    this.beans = beans;
    this.instanceId = column.getId() + "-" + instanceIdSequence2++;
    this.colIdSanitised = _escapeString(this.column.getId());
    this.createCellPosition();
    this.updateAndFormatValue(false);
  }
  shouldRestoreFocus() {
    return this.beans.focusSvc.shouldRestoreFocus(this.cellPosition);
  }
  onFocusOut() {
    this.beans.focusSvc.clearRestoreFocus();
  }
  addFeatures() {
    const { beans } = this;
    this.positionFeature = new CellPositionFeature(this, beans);
    this.customStyleFeature = beans.cellStyles?.createCellCustomStyleFeature(this, beans);
    this.mouseListener = new CellMouseListenerFeature(this, beans, this.column);
    this.keyboardListener = new CellKeyboardListenerFeature(this, beans, this.rowNode, this.rowCtrl);
    if (this.column.isTooltipEnabled()) {
      this.enableTooltipFeature();
    }
    const { rangeSvc } = beans;
    const cellSelectionEnabled = rangeSvc && _isCellSelectionEnabled(beans.gos);
    if (cellSelectionEnabled) {
      this.rangeFeature = rangeSvc.createCellRangeFeature(beans, this);
    }
  }
  removeFeatures() {
    const context = this.beans.context;
    this.positionFeature = context.destroyBean(this.positionFeature);
    this.customStyleFeature = context.destroyBean(this.customStyleFeature);
    this.mouseListener = context.destroyBean(this.mouseListener);
    this.keyboardListener = context.destroyBean(this.keyboardListener);
    this.rangeFeature = context.destroyBean(this.rangeFeature);
    this.disableTooltipFeature();
  }
  enableTooltipFeature(value, shouldDisplayTooltip) {
    this.tooltipFeature = this.beans.tooltipSvc?.enableCellTooltipFeature(this, value, shouldDisplayTooltip);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  setComp(comp, eGui, eCellWrapper, printLayout, startEditing, compBean) {
    this.comp = comp;
    this.eGui = eGui;
    this.printLayout = printLayout;
    compBean ?? (compBean = this);
    this.addDomData(compBean);
    this.addFeatures();
    compBean.addDestroyFunc(() => this.removeFeatures());
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
    this.onCellFocused(this.focusEventToRestore);
    this.applyStaticCssClasses();
    this.setWrapText();
    this.onFirstRightPinnedChanged();
    this.onLastLeftPinnedChanged();
    this.onColumnHover();
    this.setupControlComps();
    this.setupAutoHeight(eCellWrapper, compBean);
    this.refreshFirstAndLastStyles();
    this.refreshAriaColIndex();
    this.positionFeature?.setComp(eGui);
    this.customStyleFeature?.setComp(comp);
    this.tooltipFeature?.refreshTooltip();
    this.keyboardListener?.setComp(this.eGui);
    if (this.rangeFeature) {
      this.rangeFeature.setComp(comp, eGui);
    }
    if (startEditing && this.isCellEditable()) {
      this.beans.editSvc?.startEditing(this);
    } else {
      this.showValue();
    }
    if (this.onCompAttachedFuncs.length) {
      this.onCompAttachedFuncs.forEach((func) => func());
      this.onCompAttachedFuncs = [];
    }
  }
  setupAutoHeight(eCellWrapper, compBean) {
    this.isAutoHeight = this.column.isAutoHeight();
    if (!this.isAutoHeight || !eCellWrapper) {
      return;
    }
    this.beans.rowAutoHeight?.setupCellAutoHeight(this, eCellWrapper, compBean);
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const colDef = this.column.getColDef();
    return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(forceNewCellRendererInstance = false) {
    const { beans, column, rowNode, rangeFeature } = this;
    const { userCompFactory } = beans;
    const valueToDisplay = this.getValueToDisplay();
    let compDetails;
    const isSsrmLoading = rowNode.stub && rowNode.groupData?.[column.getId()] == null;
    if (isSsrmLoading) {
      const params = this.createCellRendererParams();
      compDetails = _getLoadingCellRendererDetails(userCompFactory, column.getColDef(), params);
    } else if (this.isCellRenderer()) {
      const params = this.createCellRendererParams();
      compDetails = _getCellRendererDetails(userCompFactory, column.getColDef(), params);
    }
    this.comp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
    if (rangeFeature) {
      _requestAnimationFrame(beans, () => rangeFeature?.refreshHandle());
    }
  }
  setupControlComps() {
    const colDef = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(colDef));
    this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
    this.includeDndSource = this.isIncludeControl(colDef.dndSource);
    this.comp.setIncludeSelection(this.includeSelection);
    this.comp.setIncludeDndSource(this.includeDndSource);
    this.comp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    const forceWrapper = this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
    return forceWrapper;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(value) {
    const rowNodePinned = this.rowNode.rowPinned != null;
    const isFunc = typeof value === "function";
    const res = rowNodePinned ? false : isFunc || value === true;
    return res;
  }
  isCheckboxSelection(colDef) {
    const { rowSelection } = this.beans.gridOptions;
    return colDef.checkboxSelection || isColumnSelectionCol(this.column) && rowSelection && typeof rowSelection !== "string" && _getCheckboxes(rowSelection);
  }
  refreshShouldDestroy() {
    const colDef = this.column.getColDef();
    const selectionChanged = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(colDef));
    const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
    const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
    const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
    return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
  }
  onPopupEditorClosed() {
    if (!this.editing) {
      return;
    }
    this.stopEditingAndFocus();
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(cancel = false) {
    return this.beans.editSvc?.stopEditing(this, cancel) ?? false;
  }
  createCellRendererParams() {
    const {
      value,
      valueFormatted,
      column,
      rowNode,
      comp,
      eGui,
      beans: { valueSvc, gos }
    } = this;
    const res = gos.addGridCommonParams({
      value,
      valueFormatted,
      getValue: () => valueSvc.getValueForDisplay(column, rowNode),
      setValue: (value2) => valueSvc.setValue(rowNode, column, value2),
      formatValue: this.formatValue.bind(this),
      data: rowNode.data,
      node: rowNode,
      pinned: column.getPinned(),
      colDef: column.getColDef(),
      column,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: eGui,
      eParentOfValue: comp.getParentOfValue(),
      registerRowDragger: (rowDraggerElement, dragStartPixels, value2, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
      setTooltip: (value2, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        if (this.tooltipFeature) {
          this.disableTooltipFeature();
        }
        this.enableTooltipFeature(value2, shouldDisplayTooltip);
        this.tooltipFeature?.refreshTooltip();
      }
    });
    return res;
  }
  onCellChanged(event) {
    const eventImpactsThisCell = event.column === this.column;
    if (eventImpactsThisCell) {
      this.refreshCell({});
    }
  }
  refreshOrDestroyCell(params) {
    if (this.refreshShouldDestroy()) {
      this.rowCtrl?.recreateCell(this);
    } else {
      this.refreshCell(params);
    }
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(params) {
    if (this.suppressRefreshCell || this.editing) {
      return;
    }
    const colDef = this.column.getColDef();
    const newData = params != null && !!params.newData;
    const suppressFlash = params != null && !!params.suppressFlash;
    const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
    const forceRefresh = params && params.forceRefresh || noValueProvided || newData;
    const isCellCompReady = !!this.comp;
    const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
    const dataNeedsUpdating = forceRefresh || valuesDifferent;
    if (!isCellCompReady) {
      return;
    }
    if (dataNeedsUpdating) {
      this.showValue(newData);
      const processingFilterChange = this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering();
      const flashCell = !suppressFlash && !processingFilterChange && colDef.enableCellChangeFlash;
      if (flashCell) {
        this.beans.cellFlashSvc?.flashCell(this);
      }
      this.customStyleFeature?.applyUserStyles();
      this.customStyleFeature?.applyClassesFromColDef();
    }
    this.tooltipFeature?.refreshTooltip();
    this.customStyleFeature?.applyCellClassRules();
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(suppressNavigateAfterEdit = false, shiftKey = false) {
    this.beans.editSvc?.stopEditingAndFocus(this, suppressNavigateAfterEdit, shiftKey);
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  formatValue(value) {
    return this.callValueFormatter(value) ?? value;
  }
  callValueFormatter(value) {
    return this.beans.valueSvc.formatValue(this.column, this.rowNode, value);
  }
  updateAndFormatValue(compareValues) {
    const oldValue = this.value;
    const oldValueFormatted = this.valueFormatted;
    this.value = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode);
    this.valueFormatted = this.callValueFormatter(this.value);
    if (compareValues) {
      return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
    }
    return true;
  }
  valuesAreEqual(val1, val2) {
    const colDef = this.column.getColDef();
    return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
  }
  addDomData(compBean) {
    const element = this.eGui;
    _setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, this);
    compBean.addDestroyFunc(() => _setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(domEvent, eventType) {
    const { rowNode, column, value } = this;
    const event = this.beans.gos.addGridCommonParams({
      type: eventType,
      node: rowNode,
      data: rowNode.data,
      value,
      column,
      colDef: column.getColDef(),
      rowPinned: rowNode.rowPinned,
      event: domEvent,
      rowIndex: rowNode.rowIndex
    });
    return event;
  }
  processCharacter(event) {
    this.keyboardListener?.processCharacter(event);
  }
  onKeyDown(event) {
    this.keyboardListener?.onKeyDown(event);
  }
  onMouseEvent(eventName, mouseEvent) {
    this.mouseListener?.onMouseEvent(eventName, mouseEvent);
  }
  getColSpanningList() {
    return this.positionFeature.getColSpanningList();
  }
  onLeftChanged() {
    if (!this.comp) {
      return;
    }
    this.positionFeature?.onLeftChanged();
  }
  onDisplayedColumnsChanged() {
    if (!this.eGui) {
      return;
    }
    this.refreshAriaColIndex();
    this.refreshFirstAndLastStyles();
  }
  refreshFirstAndLastStyles() {
    const { comp, column, beans } = this;
    refreshFirstAndLastStyles(comp, column, beans.visibleCols);
  }
  refreshAriaColIndex() {
    const colIdx = this.beans.visibleCols.getAriaColIndex(this.column);
    _setAriaColIndex(this.eGui, colIdx);
  }
  onWidthChanged() {
    return this.positionFeature?.onWidthChanged();
  }
  getRowPosition() {
    const { rowIndex, rowPinned } = this.cellPosition;
    return {
      rowIndex,
      rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    if (!this.comp) {
      return;
    }
    this.rangeFeature?.updateRangeBordersIfRangeCount();
  }
  onCellSelectionChanged() {
    if (!this.comp) {
      return;
    }
    this.rangeFeature?.onCellSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.rangeFeature != null;
  }
  focusCell(forceBrowserFocus = false) {
    this.beans.focusSvc.setFocusedCell({
      rowIndex: this.cellPosition.rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus
    });
  }
  onRowIndexChanged() {
    this.createCellPosition();
    this.onCellFocused();
    this.rangeFeature?.onCellSelectionChanged();
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    if (!this.eGui) {
      return;
    }
    _addOrRemoveAttribute(this.eGui, "tabindex", suppressCellFocus ? void 0 : -1);
  }
  onFirstRightPinnedChanged() {
    if (!this.comp) {
      return;
    }
    const firstRightPinned = this.column.isFirstRightPinned();
    this.comp.addOrRemoveCssClass(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
  }
  onLastLeftPinnedChanged() {
    if (!this.comp) {
      return;
    }
    const lastLeftPinned = this.column.isLastLeftPinned();
    this.comp.addOrRemoveCssClass(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
  }
  onCellFocused(event) {
    const { beans } = this;
    if (_isCellFocusSuppressed(beans)) {
      return;
    }
    const cellFocused = beans.focusSvc.isCellFocused(this.cellPosition);
    if (!this.comp) {
      if (cellFocused && event?.forceBrowserFocus) {
        this.focusEventToRestore = event;
      }
      return;
    }
    this.focusEventToRestore = void 0;
    this.comp.addOrRemoveCssClass(CSS_CELL_FOCUS, cellFocused);
    if (cellFocused && event && event.forceBrowserFocus) {
      let focusEl = this.comp.getFocusableElement();
      if (this.editing) {
        const focusableEls = _findFocusableElements(focusEl, null, true);
        if (focusableEls.length) {
          focusEl = focusableEls[0];
        }
      }
      focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
    }
    const fullRowEdit = beans.gos.get("editType") === "fullRow";
    if (!cellFocused && !fullRowEdit && this.editing) {
      beans.editSvc?.stopRowOrCellEdit(this);
    }
    if (cellFocused) {
      this.rowCtrl.announceDescription();
    }
  }
  createCellPosition() {
    const { rowIndex, rowPinned } = this.rowNode;
    this.cellPosition = {
      rowIndex,
      rowPinned: _makeNull(rowPinned),
      column: this.column
    };
  }
  setInlineEditingCss() {
    this.beans.editSvc?.setInlineEditingCss(this.rowCtrl);
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    const { comp } = this;
    comp.addOrRemoveCssClass(CSS_CELL, true);
    comp.addOrRemoveCssClass(CSS_CELL_NOT_INLINE_EDITING, true);
    const autoHeight = this.column.isAutoHeight() == true;
    comp.addOrRemoveCssClass(CSS_AUTO_HEIGHT, autoHeight);
    comp.addOrRemoveCssClass(CSS_NORMAL_HEIGHT, !autoHeight);
  }
  onColumnHover() {
    this.beans.colHover?.onCellColumnHover(this.column, this.comp);
  }
  onColDefChanged() {
    if (!this.comp) {
      return;
    }
    if (this.column.isTooltipEnabled()) {
      this.disableTooltipFeature();
      this.enableTooltipFeature();
    } else {
      this.disableTooltipFeature();
    }
    this.setWrapText();
    if (!this.editing) {
      this.refreshOrDestroyCell({ forceRefresh: true, suppressFlash: true });
    } else {
      this.beans.editSvc?.handleColDefChanged(this);
    }
  }
  setWrapText() {
    const value = this.column.getColDef().wrapText == true;
    this.comp.addOrRemoveCssClass(CSS_CELL_WRAP_TEXT, value);
  }
  dispatchCellContextMenuEvent(event) {
    const colDef = this.column.getColDef();
    const cellContextMenuEvent = this.createEvent(event, "cellContextMenu");
    const { beans } = this;
    beans.eventSvc.dispatchEvent(cellContextMenuEvent);
    if (colDef.onCellContextMenu) {
      window.setTimeout(() => {
        beans.frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellContextMenu(cellContextMenuEvent);
        });
      }, 0);
    }
  }
  getCellRenderer() {
    return this.comp?.getCellRenderer() ?? null;
  }
  destroy() {
    this.onCompAttachedFuncs = [];
    this.onEditorAttachedFuncs = [];
    super.destroy();
  }
  createSelectionCheckbox() {
    const cbSelectionComponent = this.beans.selectionSvc?.createCheckboxSelectionComponent();
    if (!cbSelectionComponent) {
      return void 0;
    }
    this.beans.context.createBean(cbSelectionComponent);
    cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column });
    return cbSelectionComponent;
  }
  createDndSource() {
    const dndSourceComp = this.beans.registry.createDynamicBean(
      "dndSourceComp",
      false,
      this.rowNode,
      this.column,
      this.eGui
    );
    if (dndSourceComp) {
      this.beans.context.createBean(dndSourceComp);
    }
    return dndSourceComp;
  }
  registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(customElement, dragStartPixels);
      return;
    }
    const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
    if (newComp) {
      this.customRowDragComp = newComp;
      this.addDestroyFunc(() => {
        this.beans.context.destroyBean(newComp);
        this.customRowDragComp = null;
      });
    }
  }
  createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
    const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForCell(
      this.rowNode,
      this.column,
      () => this.value,
      customElement,
      dragStartPixels,
      suppressVisibilityChange
    );
    if (!rowDragComp) {
      return void 0;
    }
    this.beans.context.createBean(rowDragComp);
    return rowDragComp;
  }
  cellEditorAttached() {
    this.onEditorAttachedFuncs.forEach((func) => func());
    this.onEditorAttachedFuncs = [];
  }
};

// packages/ag-grid-community/src/gridBodyComp/mouseEventUtils.ts
var GRID_DOM_KEY = "__ag_grid_instance";
function _stampTopLevelGridCompWithGridInstance(gos, eGridDiv) {
  eGridDiv[GRID_DOM_KEY] = gos.gridInstanceId;
}
function _isEventFromThisGrid(gos, event) {
  const res = _isElementInThisGrid(gos, event.target);
  return res;
}
function _isElementInThisGrid(gos, element) {
  let pointer = element;
  while (pointer) {
    const instanceId = pointer[GRID_DOM_KEY];
    if (_exists(instanceId)) {
      const eventFromThisGrid = instanceId === gos.gridInstanceId;
      return eventFromThisGrid;
    }
    pointer = pointer.parentElement;
  }
  return false;
}
function _getCellPositionForEvent(gos, event) {
  return _getCellCtrlForEventTarget(gos, event.target)?.cellPosition ?? null;
}
function _getNormalisedMousePosition(beans, event) {
  const gridPanelHasScrolls = _isDomLayout(beans.gos, "normal");
  const e = event;
  let x;
  let y;
  if (e.clientX != null || e.clientY != null) {
    x = e.clientX;
    y = e.clientY;
  } else {
    x = e.x;
    y = e.y;
  }
  if (gridPanelHasScrolls) {
    const scrollFeature = beans.ctrlsSvc.getScrollFeature();
    const vRange = scrollFeature.getVScrollPosition();
    const hRange = scrollFeature.getHScrollPosition();
    x += hRange.left;
    y += vRange.top;
  }
  return { x, y };
}

// packages/ag-grid-community/src/dragAndDrop/dragAndDropService.ts
var DragSourceType = /* @__PURE__ */ ((DragSourceType2) => {
  DragSourceType2[DragSourceType2["ToolPanel"] = 0] = "ToolPanel";
  DragSourceType2[DragSourceType2["HeaderCell"] = 1] = "HeaderCell";
  DragSourceType2[DragSourceType2["RowDrag"] = 2] = "RowDrag";
  DragSourceType2[DragSourceType2["ChartPanel"] = 3] = "ChartPanel";
  DragSourceType2[DragSourceType2["AdvancedFilterBuilder"] = 4] = "AdvancedFilterBuilder";
  return DragSourceType2;
})(DragSourceType || {});
var DragAndDropService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dragAndDrop";
    this.dragSourceAndParamsList = [];
    this.dropTargets = [];
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.dragSvc = beans.dragSvc;
    this.environment = beans.environment;
    this.userCompFactory = beans.userCompFactory;
  }
  addDragSource(dragSource, allowTouch = false) {
    const params = {
      eElement: dragSource.eElement,
      dragStartPixels: dragSource.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, dragSource),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: allowTouch
    };
    this.dragSourceAndParamsList.push({ params, dragSource });
    this.dragSvc.addDragSource(params);
  }
  getDragAndDropImageComponent() {
    const { dragAndDropImageComp } = this;
    if (!dragAndDropImageComp || !dragAndDropImageComp.comp) {
      return null;
    }
    return dragAndDropImageComp.comp;
  }
  removeDragSource(dragSource) {
    const { dragSourceAndParamsList, dragSvc } = this;
    const sourceAndParams = dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
    if (sourceAndParams) {
      dragSvc.removeDragSource(sourceAndParams.params);
      _removeFromArray(dragSourceAndParamsList, sourceAndParams);
    }
  }
  destroy() {
    const { dragSourceAndParamsList, dragSvc, dropTargets } = this;
    dragSourceAndParamsList.forEach((sourceAndParams) => dragSvc.removeDragSource(sourceAndParams.params));
    dragSourceAndParamsList.length = 0;
    dropTargets.length = 0;
    this.clearDragAndDropProperties();
    super.destroy();
  }
  nudge() {
    if (this.dragging) {
      this.onDragging(this.eventLastTime, true);
    }
  }
  onDragStart(dragSource, mouseEvent) {
    this.dragging = true;
    this.dragSource = dragSource;
    this.eventLastTime = mouseEvent;
    this.dragItem = dragSource.getDragItem();
    dragSource.onDragStarted?.();
    this.createDragAndDropImageComponent();
  }
  onDragStop(mouseEvent) {
    this.dragSource?.onDragStopped?.();
    const { lastDropTarget } = this;
    if (lastDropTarget?.onDragStop) {
      const draggingEvent = this.createDropTargetEvent(lastDropTarget, mouseEvent, null, null, false);
      lastDropTarget.onDragStop(draggingEvent);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    const { dragSource, lastDropTarget } = this;
    dragSource?.onDragCancelled?.();
    if (lastDropTarget?.onDragCancel) {
      lastDropTarget.onDragCancel(
        this.createDropTargetEvent(lastDropTarget, this.eventLastTime, null, null, false)
      );
    }
    this.clearDragAndDropProperties();
  }
  clearDragAndDropProperties() {
    this.eventLastTime = null;
    this.dragging = false;
    this.lastDropTarget = void 0;
    this.dragItem = null;
    this.dragSource = null;
    this.removeDragAndDropImageComponent();
  }
  onDragging(mouseEvent, fromNudge = false) {
    const hDirection = this.getHorizontalDirection(mouseEvent);
    const vDirection = this.getVerticalDirection(mouseEvent);
    this.eventLastTime = mouseEvent;
    this.positionDragAndDropImageComp(mouseEvent);
    const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
    const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
    const { lastDropTarget, dragSource, dragAndDropImageComp, dragItem } = this;
    if (dropTarget !== lastDropTarget) {
      this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
      if (lastDropTarget !== null && dropTarget === null) {
        dragSource?.onGridExit?.(dragItem);
      }
      if (lastDropTarget === null && dropTarget !== null) {
        dragSource?.onGridEnter?.(dragItem);
      }
      this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      if (dropTarget && dragAndDropImageComp) {
        const { comp, promise } = dragAndDropImageComp;
        if (comp) {
          comp.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
        } else {
          promise.then((resolvedComponent) => {
            if (resolvedComponent) {
              resolvedComponent.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
            }
          });
        }
      }
      this.lastDropTarget = dropTarget;
    } else if (dropTarget && dropTarget.onDragging) {
      const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
      dropTarget.onDragging(draggingEvent);
    }
  }
  getAllContainersFromDropTarget(dropTarget) {
    const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
    const containers = [[dropTarget.getContainer()]];
    return secondaryContainers ? containers.concat(secondaryContainers) : containers;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(mouseEvent, dropTarget) {
    const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
    let mouseOverTarget = false;
    const allContainersIntersect = (mouseEvent2, containers) => {
      for (const container of containers) {
        const { width, height, left, right, top, bottom } = container.getBoundingClientRect();
        if (width === 0 || height === 0) {
          return false;
        }
        const horizontalFit = mouseEvent2.clientX >= left && mouseEvent2.clientX < right;
        const verticalFit = mouseEvent2.clientY >= top && mouseEvent2.clientY < bottom;
        if (!horizontalFit || !verticalFit) {
          return false;
        }
      }
      return true;
    };
    for (const currentContainers of allContainersFromDropTarget) {
      if (allContainersIntersect(mouseEvent, currentContainers)) {
        mouseOverTarget = true;
        break;
      }
    }
    const { eElement, type } = this.dragSource;
    if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(eElement)) {
      return false;
    }
    return mouseOverTarget && dropTarget.isInterestedIn(type, eElement);
  }
  findCurrentDropTarget(mouseEvent, validDropTargets) {
    const len = validDropTargets.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return validDropTargets[0];
    }
    const rootNode = _getRootNode(this.beans);
    const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
    for (const el of elementStack) {
      for (const dropTarget of validDropTargets) {
        const containers = this.getAllContainersFromDropTarget(dropTarget).flatMap((a) => a);
        if (containers.indexOf(el) !== -1) {
          return dropTarget;
        }
      }
    }
    return null;
  }
  enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
    if (!dropTarget) {
      return;
    }
    if (dropTarget.onDragEnter) {
      const dragEnterEvent = this.createDropTargetEvent(
        dropTarget,
        mouseEvent,
        hDirection,
        vDirection,
        fromNudge
      );
      dropTarget.onDragEnter(dragEnterEvent);
    }
  }
  leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
    const { lastDropTarget } = this;
    if (!lastDropTarget) {
      return;
    }
    if (lastDropTarget.onDragLeave) {
      const dragLeaveEvent = this.createDropTargetEvent(
        lastDropTarget,
        mouseEvent,
        hDirection,
        vDirection,
        fromNudge
      );
      lastDropTarget.onDragLeave(dragLeaveEvent);
    }
    const dragAndDropImageComponent = this.getDragAndDropImageComponent();
    if (dragAndDropImageComponent) {
      dragAndDropImageComponent.setIcon(null, false);
    }
  }
  addDropTarget(dropTarget) {
    this.dropTargets.push(dropTarget);
  }
  removeDropTarget(dropTarget) {
    this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((zones) => zones.external);
  }
  findExternalZone(params) {
    const externalTargets = this.dropTargets.filter((target) => target.external);
    return externalTargets.find((zone) => zone.getContainer() === params.getContainer()) || null;
  }
  isDropZoneWithinThisGrid(draggingEvent) {
    const gridBodyCon = this.ctrlsSvc.getGridBodyCtrl();
    const gridGui = gridBodyCon.eGridBody;
    const { dropZoneTarget } = draggingEvent;
    return gridGui.contains(dropZoneTarget);
  }
  getHorizontalDirection(event) {
    const clientX = this.eventLastTime?.clientX;
    const eClientX = event.clientX;
    if (clientX === eClientX) {
      return null;
    }
    return clientX > eClientX ? "left" : "right";
  }
  getVerticalDirection(event) {
    const clientY = this.eventLastTime?.clientY;
    const eClientY = event.clientY;
    if (clientY === eClientY) {
      return null;
    }
    return clientY > eClientY ? "up" : "down";
  }
  createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
    const dropZoneTarget = dropTarget.getContainer();
    const rect = dropZoneTarget.getBoundingClientRect();
    const { dragItem, dragSource, gos } = this;
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    return gos.addGridCommonParams({
      event,
      x,
      y,
      vDirection,
      hDirection,
      dragSource,
      fromNudge,
      dragItem,
      dropZoneTarget
    });
  }
  positionDragAndDropImageComp(event) {
    const dragAndDropImageComponent = this.getDragAndDropImageComponent();
    if (!dragAndDropImageComponent) {
      return;
    }
    _anchorElementToMouseMoveEvent(dragAndDropImageComponent.getGui(), event, this.beans);
  }
  removeDragAndDropImageComponent() {
    const { dragAndDropImageComp } = this;
    if (dragAndDropImageComp) {
      const { comp } = dragAndDropImageComp;
      if (comp) {
        const eGui = comp.getGui();
        this.dragAndDropImageParent?.removeChild(eGui);
        this.destroyBean(comp);
      }
    }
    this.dragAndDropImageComp = null;
  }
  createDragAndDropImageComponent() {
    const { dragSource } = this;
    if (!dragSource) {
      return;
    }
    const userCompDetails = _getDragAndDropImageCompDetails(this.userCompFactory, {
      dragSource
    });
    if (!userCompDetails) {
      return;
    }
    const promise = userCompDetails.newAgStackInstance();
    this.dragAndDropImageComp = {
      promise
    };
    promise.then((comp) => {
      if (!comp || !this.isAlive()) {
        return;
      }
      this.processDragAndDropImageComponent(comp);
      this.dragAndDropImageComp.comp = comp;
    });
  }
  processDragAndDropImageComponent(dragAndDropImageComponent) {
    const { dragSource, environment } = this;
    if (!dragSource) {
      return;
    }
    const eGui = dragAndDropImageComponent.getGui();
    eGui.style.setProperty("position", "absolute");
    eGui.style.setProperty("z-index", "9999");
    _stampTopLevelGridCompWithGridInstance(this.gos, eGui);
    environment.applyThemeClasses(eGui);
    dragAndDropImageComponent.setIcon(null, false);
    let { dragItemName } = dragSource;
    if (typeof dragItemName === "function") {
      dragItemName = dragItemName();
    }
    dragAndDropImageComponent.setLabel(dragItemName || "");
    eGui.style.top = "20px";
    eGui.style.left = "20px";
    const targetEl = _getPageBody(this.beans);
    this.dragAndDropImageParent = targetEl;
    if (!targetEl) {
      _warn(54);
    } else {
      targetEl.appendChild(eGui);
    }
  }
  registerGridDropTarget(elementFn, ctrl) {
    const dropTarget = {
      getContainer: elementFn,
      isInterestedIn: (type) => type === 1 /* HeaderCell */ || type === 0 /* ToolPanel */,
      getIconName: () => "notAllowed"
    };
    this.addDropTarget(dropTarget);
    ctrl.addDestroyFunc(() => this.removeDropTarget(dropTarget));
  }
};

// packages/ag-grid-community/src/autoScrollService.ts
var AutoScrollService = class {
  constructor(params) {
    this.tickingInterval = null;
    this.onScrollCallback = null;
    this.scrollContainer = params.scrollContainer;
    this.scrollHorizontally = params.scrollAxis.indexOf("x") !== -1;
    this.scrollVertically = params.scrollAxis.indexOf("y") !== -1;
    this.scrollByTick = params.scrollByTick != null ? params.scrollByTick : 20;
    if (params.onScrollCallback) {
      this.onScrollCallback = params.onScrollCallback;
    }
    if (this.scrollVertically) {
      this.getVerticalPosition = params.getVerticalPosition;
      this.setVerticalPosition = params.setVerticalPosition;
    }
    if (this.scrollHorizontally) {
      this.getHorizontalPosition = params.getHorizontalPosition;
      this.setHorizontalPosition = params.setHorizontalPosition;
    }
    this.shouldSkipVerticalScroll = params.shouldSkipVerticalScroll || (() => false);
    this.shouldSkipHorizontalScroll = params.shouldSkipHorizontalScroll || (() => false);
  }
  check(mouseEvent, forceSkipVerticalScroll = false) {
    const skipVerticalScroll = forceSkipVerticalScroll || this.shouldSkipVerticalScroll();
    if (skipVerticalScroll && this.shouldSkipHorizontalScroll()) {
      return;
    }
    const rect = this.scrollContainer.getBoundingClientRect();
    const scrollTick = this.scrollByTick;
    this.tickLeft = mouseEvent.clientX < rect.left + scrollTick;
    this.tickRight = mouseEvent.clientX > rect.right - scrollTick;
    this.tickUp = mouseEvent.clientY < rect.top + scrollTick && !skipVerticalScroll;
    this.tickDown = mouseEvent.clientY > rect.bottom - scrollTick && !skipVerticalScroll;
    if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {
      this.ensureTickingStarted();
    } else {
      this.ensureCleared();
    }
  }
  ensureTickingStarted() {
    if (this.tickingInterval === null) {
      this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);
      this.tickCount = 0;
    }
  }
  doTick() {
    this.tickCount++;
    const tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const vScrollPosition = this.getVerticalPosition();
      if (this.tickUp) {
        this.setVerticalPosition(vScrollPosition - tickAmount);
      }
      if (this.tickDown) {
        this.setVerticalPosition(vScrollPosition + tickAmount);
      }
    }
    if (this.scrollHorizontally) {
      const hScrollPosition = this.getHorizontalPosition();
      if (this.tickLeft) {
        this.setHorizontalPosition(hScrollPosition - tickAmount);
      }
      if (this.tickRight) {
        this.setHorizontalPosition(hScrollPosition + tickAmount);
      }
    }
    if (this.onScrollCallback) {
      this.onScrollCallback();
    }
  }
  ensureCleared() {
    if (this.tickingInterval) {
      window.clearInterval(this.tickingInterval);
      this.tickingInterval = null;
    }
  }
};

// packages/ag-grid-community/src/entities/positionUtils.ts
function _createCellId(cellPosition) {
  const { rowIndex, rowPinned, column } = cellPosition;
  return `${rowIndex}.${rowPinned == null ? "null" : rowPinned}.${column.getId()}`;
}
function _areCellsEqual(cellA, cellB) {
  const colsMatch = cellA.column === cellB.column;
  const floatingMatch = cellA.rowPinned === cellB.rowPinned;
  const indexMatch = cellA.rowIndex === cellB.rowIndex;
  return colsMatch && floatingMatch && indexMatch;
}
function _isRowBefore(rowA, rowB) {
  switch (rowA.rowPinned) {
    case "top":
      if (rowB.rowPinned !== "top") {
        return true;
      }
      break;
    case "bottom":
      if (rowB.rowPinned !== "bottom") {
        return false;
      }
      break;
    default:
      if (_exists(rowB.rowPinned)) {
        return rowB.rowPinned !== "top";
      }
      break;
  }
  return rowA.rowIndex < rowB.rowIndex;
}
function _isSameRow(rowA, rowB) {
  if (!rowA && !rowB) {
    return true;
  }
  if (rowA && !rowB || !rowA && rowB) {
    return false;
  }
  return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
}
function _getFirstRow(beans) {
  let rowIndex = 0;
  let rowPinned;
  const { pinnedRowModel, rowModel, pageBounds } = beans;
  if (pinnedRowModel?.getPinnedTopRowCount()) {
    rowPinned = "top";
  } else if (rowModel.getRowCount()) {
    rowPinned = null;
    rowIndex = pageBounds.getFirstRow();
  } else if (pinnedRowModel?.getPinnedBottomRowCount()) {
    rowPinned = "bottom";
  }
  return rowPinned === void 0 ? null : { rowIndex, rowPinned };
}
function _getLastRow(beans) {
  let rowIndex;
  let rowPinned = null;
  const { pinnedRowModel, pageBounds } = beans;
  const pinnedBottomCount = pinnedRowModel?.getPinnedBottomRowCount();
  const pinnedTopCount = pinnedRowModel?.getPinnedTopRowCount();
  if (pinnedBottomCount) {
    rowPinned = "bottom";
    rowIndex = pinnedBottomCount - 1;
  } else if (beans.rowModel.getRowCount()) {
    rowPinned = null;
    rowIndex = pageBounds.getLastRow();
  } else if (pinnedTopCount) {
    rowPinned = "top";
    rowIndex = pinnedTopCount - 1;
  }
  return rowIndex === void 0 ? null : { rowIndex, rowPinned };
}
function _getRowNode(beans, gridRow) {
  switch (gridRow.rowPinned) {
    case "top":
      return beans.pinnedRowModel?.getPinnedTopRow(gridRow.rowIndex);
    case "bottom":
      return beans.pinnedRowModel?.getPinnedBottomRow(gridRow.rowIndex);
    default:
      return beans.rowModel.getRow(gridRow.rowIndex);
  }
}
function _getCellByPosition(beans, cellPosition) {
  const rowCtrl = beans.rowRenderer.getRowByPosition(cellPosition);
  if (!rowCtrl) {
    return null;
  }
  return rowCtrl.getCellCtrl(cellPosition.column);
}

// packages/ag-grid-community/src/dragAndDrop/rowDragFeature.ts
var RowDragFeature = class extends BeanStub {
  constructor(eContainer) {
    super();
    this.eContainer = eContainer;
  }
  postConstruct() {
    const { rowModel, gos, ctrlsSvc } = this.beans;
    if (_isClientSideRowModel(gos, rowModel)) {
      this.clientSideRowModel = rowModel;
    }
    ctrlsSvc.whenReady(this, (p) => {
      const gridBodyCon = p.gridBodyCtrl;
      this.autoScrollService = new AutoScrollService({
        scrollContainer: gridBodyCon.eBodyViewport,
        scrollAxis: "y",
        getVerticalPosition: () => gridBodyCon.scrollFeature.getVScrollPosition().top,
        setVerticalPosition: (position) => gridBodyCon.scrollFeature.setVerticalScrollPosition(position),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(type) {
    return type === 2 /* RowDrag */;
  }
  getIconName() {
    const managedDrag = this.gos.get("rowDragManaged");
    if (managedDrag && this.shouldPreventRowMove()) {
      return "notAllowed";
    }
    return "move";
  }
  shouldPreventRowMove() {
    const { rowGroupColsSvc, filterManager, sortSvc } = this.beans;
    const rowGroupCols = rowGroupColsSvc?.columns ?? [];
    if (rowGroupCols.length) {
      return true;
    }
    const isFilterPresent = filterManager?.isAnyFilterPresent();
    if (isFilterPresent) {
      return true;
    }
    const isSortActive = sortSvc?.isSortActive();
    if (isSortActive) {
      return true;
    }
    return false;
  }
  getRowNodes(draggingEvent) {
    if (!this.isFromThisGrid(draggingEvent)) {
      return draggingEvent.dragItem.rowNodes || [];
    }
    const currentNode = draggingEvent.dragItem.rowNode;
    const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
    if (isRowDragMultiRow) {
      const selectedNodes = [...this.beans.selectionSvc?.getSelectedNodes() ?? []].sort((a, b) => {
        if (a.rowIndex == null || b.rowIndex == null) {
          return 0;
        }
        return this.getRowIndexNumber(a) - this.getRowIndexNumber(b);
      });
      if (selectedNodes.indexOf(currentNode) !== -1) {
        return selectedNodes;
      }
    }
    return [currentNode];
  }
  onDragEnter(draggingEvent) {
    draggingEvent.dragItem.rowNodes = this.getRowNodes(draggingEvent);
    this.dispatchGridEvent("rowDragEnter", draggingEvent);
    this.getRowNodes(draggingEvent).forEach((rowNode) => {
      this.setRowNodeDragging(rowNode, true);
    });
    this.onEnterOrDragging(draggingEvent);
  }
  onDragging(draggingEvent) {
    this.onEnterOrDragging(draggingEvent);
  }
  isFromThisGrid(draggingEvent) {
    const { dragSourceDomDataKey } = draggingEvent.dragSource;
    return dragSourceDomDataKey === this.gos.getDomDataKey();
  }
  onEnterOrDragging(draggingEvent) {
    this.dispatchGridEvent("rowDragMove", draggingEvent);
    this.lastDraggingEvent = draggingEvent;
    const pixel = _getNormalisedMousePosition(this.beans, draggingEvent).y;
    const managedDrag = this.gos.get("rowDragManaged");
    if (managedDrag) {
      this.doManagedDrag(draggingEvent, pixel);
    }
    this.autoScrollService.check(draggingEvent.event);
  }
  doManagedDrag(draggingEvent, pixel) {
    const { dragAndDrop, gos } = this.beans;
    const isFromThisGrid = this.isFromThisGrid(draggingEvent);
    const managedDrag = gos.get("rowDragManaged");
    const rowNodes = draggingEvent.dragItem.rowNodes;
    if (managedDrag && this.shouldPreventRowMove()) {
      return;
    }
    if (gos.get("suppressMoveWhenRowDragging") || !isFromThisGrid) {
      if (dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
        this.clientSideRowModel.highlightRowAtPixel(rowNodes[0], pixel);
      }
    } else {
      this.moveRows(rowNodes, pixel);
    }
  }
  getRowIndexNumber(rowNode) {
    const rowIndexStr = rowNode.getRowIndexString();
    return parseInt(_last(rowIndexStr.split("-")), 10);
  }
  moveRowAndClearHighlight(draggingEvent) {
    const clientSideRowModel = this.clientSideRowModel;
    const lastHighlightedRowNode = clientSideRowModel.getLastHighlightedRowNode();
    const isBelow = lastHighlightedRowNode && lastHighlightedRowNode.highlighted === "Below";
    const pixel = _getNormalisedMousePosition(this.beans, draggingEvent).y;
    const rowNodes = draggingEvent.dragItem.rowNodes;
    let increment = isBelow ? 1 : 0;
    if (this.isFromThisGrid(draggingEvent)) {
      rowNodes.forEach((rowNode) => {
        if (rowNode.rowTop < pixel) {
          increment -= 1;
        }
      });
      this.moveRows(rowNodes, pixel, increment);
    } else {
      const getRowIdFunc = _getRowIdCallback(this.gos);
      let addIndex = clientSideRowModel.getRowIndexAtPixel(pixel) + 1;
      if (clientSideRowModel.getHighlightPosition(pixel) === "Above") {
        addIndex--;
      }
      clientSideRowModel.updateRowData({
        add: rowNodes.filter(
          (node) => !clientSideRowModel.getRowNode(
            getRowIdFunc?.({ data: node.data, level: 0, rowPinned: node.rowPinned }) ?? node.data.id
          )
        ).map((node) => node.data),
        addIndex
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(rowNodes, pixel, increment = 0) {
    const focusSvc = this.beans.focusSvc;
    const cellPosition = focusSvc.getFocusedCell();
    const cellCtrl = cellPosition && _getCellByPosition(this.beans, cellPosition);
    const rowWasMoved = this.clientSideRowModel.ensureRowsAtPixel(rowNodes, pixel, increment);
    if (rowWasMoved) {
      if (cellCtrl) {
        cellCtrl.focusCell();
      } else {
        focusSvc.clearFocusedCell();
      }
    }
  }
  addRowDropZone(params) {
    if (!params.getContainer()) {
      _warn(55);
      return;
    }
    const dragAndDrop = this.beans.dragAndDrop;
    if (dragAndDrop.findExternalZone(params)) {
      _warn(56);
      return;
    }
    let processedParams = {
      getContainer: params.getContainer
    };
    if (params.fromGrid) {
      processedParams = params;
    } else {
      if (params.onDragEnter) {
        processedParams.onDragEnter = (e) => {
          params.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", e));
        };
      }
      if (params.onDragLeave) {
        processedParams.onDragLeave = (e) => {
          params.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", e));
        };
      }
      if (params.onDragging) {
        processedParams.onDragging = (e) => {
          params.onDragging(this.draggingToRowDragEvent("rowDragMove", e));
        };
      }
      if (params.onDragStop) {
        processedParams.onDragStop = (e) => {
          params.onDragStop(this.draggingToRowDragEvent("rowDragEnd", e));
        };
      }
      if (params.onDragCancel) {
        processedParams.onDragCancel = (e) => {
          params.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", e));
        };
      }
    }
    const dropTarget = {
      isInterestedIn: (type) => type === 2 /* RowDrag */,
      getIconName: () => "move",
      external: true,
      ...processedParams
    };
    dragAndDrop.addDropTarget(dropTarget);
    this.addDestroyFunc(() => dragAndDrop.removeDropTarget(dropTarget));
  }
  getRowDropZone(events) {
    const getContainer = this.getContainer.bind(this);
    const onDragEnter = this.onDragEnter.bind(this);
    const onDragLeave = this.onDragLeave.bind(this);
    const onDragging = this.onDragging.bind(this);
    const onDragStop = this.onDragStop.bind(this);
    const onDragCancel = this.onDragCancel.bind(this);
    let params;
    if (!events) {
      params = {
        getContainer,
        onDragEnter,
        onDragLeave,
        onDragging,
        onDragStop,
        onDragCancel,
        /* @private */
        fromGrid: true
      };
    } else {
      params = {
        getContainer,
        onDragEnter: events.onDragEnter ? (e) => {
          onDragEnter(e);
          events.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", e));
        } : onDragEnter,
        onDragLeave: events.onDragLeave ? (e) => {
          onDragLeave(e);
          events.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", e));
        } : onDragLeave,
        onDragging: events.onDragging ? (e) => {
          onDragging(e);
          events.onDragging(this.draggingToRowDragEvent("rowDragMove", e));
        } : onDragging,
        onDragStop: events.onDragStop ? (e) => {
          onDragStop(e);
          events.onDragStop(this.draggingToRowDragEvent("rowDragEnd", e));
        } : onDragStop,
        onDragCancel: events.onDragCancel ? (e) => {
          onDragCancel(e);
          events.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", e));
        } : onDragCancel,
        fromGrid: true
      };
    }
    return params;
  }
  draggingToRowDragEvent(type, draggingEvent) {
    const beans = this.beans;
    const { pageBounds, rowModel, gos } = beans;
    const yNormalised = _getNormalisedMousePosition(beans, draggingEvent).y;
    const mouseIsPastLastRow = yNormalised > pageBounds.getCurrentPageHeight();
    let overIndex = -1;
    let overNode;
    if (!mouseIsPastLastRow) {
      overIndex = rowModel.getRowIndexAtPixel(yNormalised);
      overNode = rowModel.getRow(overIndex);
    }
    const event = gos.addGridCommonParams({
      type,
      event: draggingEvent.event,
      node: draggingEvent.dragItem.rowNode,
      nodes: draggingEvent.dragItem.rowNodes,
      overIndex,
      overNode,
      y: yNormalised,
      vDirection: draggingEvent.vDirection
    });
    return event;
  }
  dispatchGridEvent(type, draggingEvent) {
    const event = this.draggingToRowDragEvent(type, draggingEvent);
    this.eventSvc.dispatchEvent(event);
  }
  onDragLeave(draggingEvent) {
    this.dispatchGridEvent("rowDragLeave", draggingEvent);
    this.stopDragging(draggingEvent);
    if (this.gos.get("rowDragManaged")) {
      this.clearRowHighlight();
    }
  }
  onDragStop(draggingEvent) {
    this.dispatchGridEvent("rowDragEnd", draggingEvent);
    this.stopDragging(draggingEvent);
    const { dragAndDrop, gos } = this.beans;
    if (gos.get("rowDragManaged") && (gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(draggingEvent)) && dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
      this.moveRowAndClearHighlight(draggingEvent);
    }
  }
  onDragCancel(draggingEvent) {
    this.dispatchGridEvent("rowDragCancel", draggingEvent);
    this.stopDragging(draggingEvent);
    const { dragAndDrop, gos } = this.beans;
    if (gos.get("rowDragManaged") && (gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(draggingEvent)) && dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
      this.clearRowHighlight();
    }
  }
  stopDragging(draggingEvent) {
    this.autoScrollService.ensureCleared();
    this.getRowNodes(draggingEvent).forEach((rowNode) => {
      this.setRowNodeDragging(rowNode, false);
    });
  }
  setRowNodeDragging(rowNode, dragging) {
    if (rowNode.dragging !== dragging) {
      rowNode.dragging = dragging;
      rowNode.dispatchRowEvent("draggingChanged");
    }
  }
};

// packages/ag-grid-community/src/utils/mouse.ts
function _areEventsNear(e1, e2, pixelCount) {
  if (pixelCount === 0) {
    return false;
  }
  const diffX = Math.abs(e1.clientX - e2.clientX);
  const diffY = Math.abs(e1.clientY - e2.clientY);
  return Math.max(diffX, diffY) <= pixelCount;
}

// packages/ag-grid-community/src/dragAndDrop/dragService.ts
var DragService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dragSvc";
    this.dragEndFunctions = [];
    this.dragSources = [];
  }
  destroy() {
    const { dragSources } = this;
    dragSources.forEach(this.removeListener.bind(this));
    dragSources.length = 0;
    super.destroy();
  }
  removeListener(dragSourceAndListener) {
    const element = dragSourceAndListener.dragSource.eElement;
    const mouseDownListener = dragSourceAndListener.mouseDownListener;
    element.removeEventListener("mousedown", mouseDownListener);
    if (dragSourceAndListener.touchEnabled) {
      const touchStartListener = dragSourceAndListener.touchStartListener;
      element.removeEventListener("touchstart", touchStartListener, { passive: true });
    }
  }
  removeDragSource(params) {
    const { dragSources } = this;
    const dragSourceAndListener = dragSources.find((item) => item.dragSource === params);
    if (!dragSourceAndListener) {
      return;
    }
    this.removeListener(dragSourceAndListener);
    _removeFromArray(dragSources, dragSourceAndListener);
  }
  addDragSource(params) {
    const mouseListener = this.onMouseDown.bind(this, params);
    const { eElement, includeTouch, stopPropagationForTouch } = params;
    eElement.addEventListener("mousedown", mouseListener);
    let touchListener = null;
    const suppressTouch = this.gos.get("suppressTouch");
    if (includeTouch && !suppressTouch) {
      touchListener = (touchEvent) => {
        if (_isFocusableFormField(touchEvent.target)) {
          return;
        }
        if (stopPropagationForTouch) {
          touchEvent.stopPropagation();
        }
        this.onTouchStart(params, touchEvent);
      };
      eElement.addEventListener("touchstart", touchListener, { passive: false });
    }
    this.dragSources.push({
      dragSource: params,
      mouseDownListener: mouseListener,
      touchStartListener: touchListener,
      touchEnabled: !!includeTouch
    });
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(params, touchEvent) {
    this.currentDragParams = params;
    this.dragging = false;
    const touch = touchEvent.touches[0];
    this.touchLastTime = touch;
    this.touchStart = touch;
    const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
    const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
    const documentTouchMove = (e) => {
      if (e.cancelable) {
        e.preventDefault();
      }
    };
    const target = touchEvent.target;
    const events = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: _getRootNode(this.beans),
        type: "touchmove",
        listener: documentTouchMove,
        options: { passive: false }
      },
      { target, type: "touchmove", listener: touchMoveEvent, options: { passive: true } },
      { target, type: "touchend", listener: touchEndEvent, options: { passive: true } },
      { target, type: "touchcancel", listener: touchEndEvent, options: { passive: true } }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onCommonMove(touch, this.touchStart, params.eElement);
    }
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(params, mouseEvent) {
    const e = mouseEvent;
    if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) {
      return;
    }
    if (e._alreadyProcessedByDragService) {
      return;
    }
    e._alreadyProcessedByDragService = true;
    if (mouseEvent.button !== 0) {
      return;
    }
    if (this.shouldPreventMouseEvent(mouseEvent)) {
      mouseEvent.preventDefault();
    }
    this.currentDragParams = params;
    this.dragging = false;
    this.mouseStartEvent = mouseEvent;
    this.startTarget = mouseEvent.target;
    const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
    const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
    const contextEvent = (event) => event.preventDefault();
    const keydownEvent = (event) => {
      if (event.key === KeyCode.ESCAPE) {
        this.cancelDrag(params.eElement);
      }
    };
    const target = _getRootNode(this.beans);
    const events = [
      { target, type: "mousemove", listener: mouseMoveEvent },
      { target, type: "mouseup", listener: mouseUpEvent },
      { target, type: "contextmenu", listener: contextEvent },
      { target, type: "keydown", listener: keydownEvent }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onMouseMove(mouseEvent, params.eElement);
    }
  }
  addTemporaryEvents(events) {
    events.forEach((currentEvent) => {
      const { target, type, listener, options } = currentEvent;
      target.addEventListener(type, listener, options);
    });
    this.dragEndFunctions.push(() => {
      events.forEach((currentEvent) => {
        const { target, type, listener, options } = currentEvent;
        target.removeEventListener(type, listener, options);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(currentEvent, startEvent) {
    const { dragStartPixels } = this.currentDragParams;
    const requiredPixelDiff = _exists(dragStartPixels) ? dragStartPixels : 4;
    return _areEventsNear(currentEvent, startEvent, requiredPixelDiff);
  }
  getFirstActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      if (touchList[i].identifier === this.touchStart.identifier) {
        return touchList[i];
      }
    }
    return null;
  }
  onCommonMove(currentEvent, startEvent, el) {
    if (!this.dragging) {
      if (this.isEventNearStartEvent(currentEvent, startEvent)) {
        return;
      }
      this.dragging = true;
      this.eventSvc.dispatchEvent({
        type: "dragStarted",
        target: el
      });
      this.currentDragParams.onDragStart(startEvent);
      if (!this.currentDragParams) {
        this.dragging = false;
        return;
      }
      this.currentDragParams.onDragging(startEvent);
    }
    this.currentDragParams?.onDragging(currentEvent);
  }
  onTouchMove(touchEvent, el) {
    const touch = this.getFirstActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    this.onCommonMove(touch, this.touchStart, el);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(mouseEvent, el) {
    if (_isBrowserSafari()) {
      const eDocument = _getDocument(this.beans);
      eDocument.getSelection()?.removeAllRanges();
    }
    if (this.shouldPreventMouseEvent(mouseEvent)) {
      mouseEvent.preventDefault();
    }
    this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
  }
  shouldPreventMouseEvent(mouseEvent) {
    const { gos } = this;
    const isEnableCellTextSelect = gos.get("enableCellTextSelection");
    const isMouseMove = mouseEvent.type === "mousemove";
    const isOverFormFieldElement = (mouseEvent2) => {
      const el = mouseEvent2.target;
      const tagName = el?.tagName.toLocaleLowerCase();
      return !!tagName?.match("^a$|textarea|input|select|button");
    };
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      isEnableCellTextSelect && isMouseMove && mouseEvent.cancelable && _isEventFromThisGrid(gos, mouseEvent) && !isOverFormFieldElement(mouseEvent)
    );
  }
  onTouchUp(touchEvent, el) {
    let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
    if (!touch) {
      touch = this.touchLastTime;
    }
    this.onUpCommon(touch, el);
  }
  onMouseUp(mouseEvent, el) {
    this.onUpCommon(mouseEvent, el);
  }
  onUpCommon(eventOrTouch, el) {
    if (this.dragging) {
      this.dragging = false;
      this.currentDragParams.onDragStop(eventOrTouch);
      this.eventSvc.dispatchEvent({
        type: "dragStopped",
        target: el
      });
    }
    this.resetDragProperties();
  }
  cancelDrag(el) {
    this.eventSvc.dispatchEvent({
      type: "dragCancelled",
      target: el
    });
    this.currentDragParams?.onDragCancel?.();
    this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null;
    this.startTarget = null;
    this.touchStart = null;
    this.touchLastTime = null;
    this.currentDragParams = null;
    const { dragEndFunctions } = this;
    dragEndFunctions.forEach((func) => func());
    dragEndFunctions.length = 0;
  }
};

// packages/ag-grid-community/src/entities/agColumnGroup.ts
function createUniqueColumnGroupId(groupId, instanceId) {
  return groupId + "_" + instanceId;
}
function isColumnGroup2(col) {
  return col instanceof AgColumnGroup;
}
var AgColumnGroup = class extends BeanStub {
  constructor(providedColumnGroup, groupId, partId, pinned) {
    super();
    this.providedColumnGroup = providedColumnGroup;
    this.groupId = groupId;
    this.partId = partId;
    this.pinned = pinned;
    this.isColumn = false;
    // depends on the open/closed state of the group, only displaying columns are stored here
    this.displayedChildren = [];
    // The measured height of this column's header when autoHeaderHeight is enabled
    this.autoHeaderHeight = null;
    this.parent = null;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null;
    this.children = null;
    this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  getUniqueId() {
    return createUniqueColumnGroupId(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
    if (!allLeafColumns || allLeafColumns.length === 0) {
      return false;
    }
    return allLeafColumns.every((col) => col.isMoving());
  }
  checkLeft() {
    this.displayedChildren.forEach((child) => {
      if (isColumnGroup2(child)) {
        child.checkLeft();
      }
    });
    if (this.displayedChildren.length > 0) {
      if (this.gos.get("enableRtl")) {
        const lastChild = _last(this.displayedChildren);
        const lastChildLeft = lastChild.getLeft();
        this.setLeft(lastChildLeft);
      } else {
        const firstChildLeft = this.displayedChildren[0].getLeft();
        this.setLeft(firstChildLeft);
      }
    } else {
      this.setLeft(null);
    }
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(left) {
    this.oldLeft = this.left;
    if (this.left !== left) {
      this.left = left;
      this.dispatchLocalEvent({ type: "leftChanged" });
    }
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    let groupActualWidth = 0;
    this.displayedChildren?.forEach((child) => {
      groupActualWidth += child.getActualWidth();
    });
    return groupActualWidth;
  }
  isResizable() {
    if (!this.displayedChildren) {
      return false;
    }
    let result = false;
    this.displayedChildren.forEach((child) => {
      if (child.isResizable()) {
        result = true;
      }
    });
    return result;
  }
  getMinWidth() {
    let result = 0;
    this.displayedChildren.forEach((groupChild) => {
      result += groupChild.getMinWidth();
    });
    return result;
  }
  addChild(child) {
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  getDisplayedLeafColumns() {
    const result = [];
    this.addDisplayedLeafColumns(result);
    return result;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(expanded) {
    this.providedColumnGroup.setExpanded(expanded);
  }
  isAutoHeaderHeight() {
    return !!this.getColGroupDef()?.autoHeaderHeight;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(height) {
    const changed = height !== this.autoHeaderHeight;
    this.autoHeaderHeight = height;
    return changed;
  }
  addDisplayedLeafColumns(leafColumns) {
    this.displayedChildren.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isColumnGroup2(child)) {
        child.addDisplayedLeafColumns(leafColumns);
      }
    });
  }
  addLeafColumns(leafColumns) {
    this.children.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isColumnGroup2(child)) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const parent = this.getParent();
    if (!this.isPadding() || !parent || !parent.isPadding()) {
      return 0;
    }
    return 1 + parent.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let parentWithExpansion = this;
    while (parentWithExpansion != null && parentWithExpansion.isPadding()) {
      parentWithExpansion = parentWithExpansion.getParent();
    }
    const isExpandable = parentWithExpansion ? parentWithExpansion.getProvidedColumnGroup().isExpandable() : false;
    if (!isExpandable) {
      this.displayedChildren = this.children;
      this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((child) => {
      const emptyGroup = isColumnGroup2(child) && (!child.displayedChildren || !child.displayedChildren.length);
      if (emptyGroup) {
        return;
      }
      const headerGroupShow = child.getColumnGroupShow();
      switch (headerGroupShow) {
        case "open":
          if (parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        case "closed":
          if (!parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        default:
          this.displayedChildren.push(child);
          break;
      }
    });
    this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
};

// packages/ag-grid-community/src/entities/rowNode.ts
var ROW_ID_PREFIX_ROW_GROUP = "row-group-";
var ROW_ID_PREFIX_TOP_PINNED = "t-";
var ROW_ID_PREFIX_BOTTOM_PINNED = "b-";
var OBJECT_ID_SEQUENCE = 0;
var RowNode = class {
  constructor(beans) {
    /** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail) */
    this.master = false;
    /** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row)*/
    this.detail = void 0;
    /** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */
    this.rowIndex = null;
    /** The key for the group eg Ireland, UK, USA */
    this.key = null;
    /**
     * The index of the row in the source rowData array including any updates via transactions.
     * It does not change when sorting, filtering, grouping, pivoting or any other UI related operations.
     * If this is a filler node (a visual row created by AG Grid in tree data or grouping) the value will be `-1`.
     *
     * Generally readonly. It is modified only by:
     * - ClientSideNodeManager, cast to ClientSideNodeManagerRowNode
     * - ClientSideRowModel, cast to ClientSideRowModelRowNode
     */
    this.sourceRowIndex = -1;
    /**
     * Children mapped by the pivot columns.
     *
     * TODO: this field is currently used only by the GroupStrategy and Pivot.
     * TreeStrategy does not use it, and pivot cannot be enabled with tree data.
     * Creating a new object for every row when not pivoting and not grouping
     * consumes memory unnecessarily. Setting it to null however currently breaks
     * transactional updates in groups so this requires a deeper investigation on GroupStrategy.
     */
    this.childrenMapped = {};
    /** The TreeNode associated to this row. Used only with tree data. */
    this.treeNode = null;
    /** The flags associated to this node. Used only with tree data. */
    this.treeNodeFlags = 0;
    /**
     * This will be `true` if it has a rowIndex assigned, otherwise `false`.
     */
    this.displayed = false;
    /** The row top position in pixels. */
    this.rowTop = null;
    /** The top pixel for this row last time, makes sense if data set was ordered or filtered,
     * it is used so new rows can animate in from their old position. */
    this.oldRowTop = null;
    /** `true` by default - can be overridden via gridOptions.isRowSelectable(rowNode) */
    this.selectable = true;
    /**
     * Used by sorting service - to give deterministic sort to groups. Previously we
     * just id for this, however id is a string and had slower sorting compared to numbers.
     * If re-naming this property, you must also update `IGNORED_SIBLING_PROPERTIES`
     */
    this.__objectId = OBJECT_ID_SEQUENCE++;
    /** `true` when nodes with the same id are being removed and added as part of the same batch transaction */
    this.alreadyRendered = false;
    this.highlighted = null;
    this.hovered = false;
    this.__selected = false;
    this.beans = beans;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(data) {
    this.setDataCommon(data, false);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(data) {
    this.setDataCommon(data, true);
  }
  setDataCommon(data, update) {
    const oldData = this.data;
    this.data = data;
    this.beans.valueCache?.onDataChanged();
    this.updateDataOnDetailNode();
    this.beans.selectionSvc?.updateRowSelectable(this);
    this.resetQuickFilterAggregateText();
    const event = this.createDataChangedEvent(data, oldData, update);
    this.__localEventService?.dispatchEvent(event);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    if (this.detailNode) {
      this.detailNode.data = this.data;
    }
  }
  createDataChangedEvent(newData, oldData, update) {
    return {
      type: "dataChanged",
      node: this,
      oldData,
      newData,
      update
    };
  }
  getRowIndexString() {
    if (this.rowIndex == null) {
      _error(13);
      return null;
    }
    if (this.rowPinned === "top") {
      return ROW_ID_PREFIX_TOP_PINNED + this.rowIndex;
    }
    if (this.rowPinned === "bottom") {
      return ROW_ID_PREFIX_BOTTOM_PINNED + this.rowIndex;
    }
    return this.rowIndex.toString();
  }
  setDataAndId(data, id) {
    const { selectionSvc } = this.beans;
    const oldNode = selectionSvc?.createDaemonNode?.(this);
    const oldData = this.data;
    this.data = data;
    this.updateDataOnDetailNode();
    this.setId(id);
    if (selectionSvc) {
      selectionSvc.updateRowSelectable(this);
      selectionSvc.syncInRowNode(this, oldNode);
    }
    const event = this.createDataChangedEvent(data, oldData, false);
    this.__localEventService?.dispatchEvent(event);
  }
  setId(id) {
    const getRowIdFunc = _getRowIdCallback(this.beans.gos);
    if (getRowIdFunc) {
      if (this.data) {
        const parentKeys = this.parent?.getRoute() ?? [];
        this.id = getRowIdFunc({
          data: this.data,
          parentKeys: parentKeys.length > 0 ? parentKeys : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        });
        if (this.id.startsWith(ROW_ID_PREFIX_ROW_GROUP)) {
          _error(14, {
            groupPrefix: ROW_ID_PREFIX_ROW_GROUP
          });
        }
      } else {
        this.id = void 0;
      }
    } else {
      this.id = id;
    }
  }
  setRowTop(rowTop) {
    this.oldRowTop = this.rowTop;
    if (this.rowTop === rowTop) {
      return;
    }
    this.rowTop = rowTop;
    this.dispatchRowEvent("topChanged");
    this.setDisplayed(rowTop !== null);
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null;
    this.setRowTop(null);
    this.setRowIndex(null);
  }
  setHovered(hovered) {
    this.hovered = hovered;
  }
  isHovered() {
    return this.hovered;
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(rowHeight, estimated = false) {
    this.rowHeight = rowHeight;
    this.rowHeightEstimated = estimated;
    this.dispatchRowEvent("heightChanged");
  }
  setExpanded(expanded, e, forceSync) {
    this.beans.expansionSvc?.setExpanded(this, expanded, e, forceSync);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(colKey, newValue, eventSource) {
    const { colModel, valueSvc, gos, selectionSvc } = this.beans;
    const column = typeof colKey !== "string" ? colKey : colModel.getCol(colKey) ?? colModel.getColDefCol(colKey);
    if (!column) {
      return false;
    }
    const oldValue = valueSvc.getValueForDisplay(column, this);
    if (gos.get("readOnlyEdit")) {
      const {
        beans: { eventSvc },
        data,
        rowIndex,
        rowPinned
      } = this;
      eventSvc.dispatchEvent({
        type: "cellEditRequest",
        event: null,
        rowIndex,
        rowPinned,
        column,
        colDef: column.colDef,
        data,
        node: this,
        oldValue,
        newValue,
        value: newValue,
        source: eventSource
      });
      return false;
    }
    const valueChanged = valueSvc.setValue(this, column, newValue, eventSource);
    this.dispatchCellChangedEvent(column, newValue, oldValue);
    selectionSvc?.updateRowSelectable(this);
    return valueChanged;
  }
  updateHasChildren() {
    let newValue = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    const { rowChildrenSvc } = this.beans;
    if (rowChildrenSvc) {
      newValue = rowChildrenSvc.getHasChildrenValue(this);
    }
    if (newValue !== this.__hasChildren) {
      this.__hasChildren = !!newValue;
      this.dispatchRowEvent("hasChildrenChanged");
    }
  }
  hasChildren() {
    if (this.__hasChildren == null) {
      this.updateHasChildren();
    }
    return this.__hasChildren;
  }
  dispatchCellChangedEvent(column, newValue, oldValue) {
    const cellChangedEvent = {
      type: "cellChanged",
      node: this,
      column,
      newValue,
      oldValue
    };
    this.__localEventService?.dispatchEvent(cellChangedEvent);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    return this.beans.expansionSvc?.isExpandable(this) ?? false;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    if (this.footer) {
      return this.sibling.isSelected();
    }
    return this.__selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(callback) {
    this.childrenAfterGroup?.forEach((child) => child.depthFirstSearch(callback));
    callback(this);
  }
  dispatchRowEvent(type) {
    this.__localEventService?.dispatchEvent({
      type,
      node: this
    });
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(newValue, clearSelection = false, source = "api") {
    this.beans.selectionSvc?.setNodesSelected({
      nodes: [this],
      newValue,
      clearSelection,
      source
    });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return !!this.rowPinned;
  }
  /** Add an event listener. */
  addEventListener(eventType, userListener) {
    this.beans.validation?.checkRowEvents(eventType);
    if (!this.__localEventService) {
      this.__localEventService = new LocalEventService();
    }
    this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(
      this.frameworkEventListenerService,
      this.__localEventService
    );
    const listener = this.frameworkEventListenerService?.wrap(userListener) ?? userListener;
    this.__localEventService.addEventListener(eventType, listener);
  }
  /** Remove event listener. */
  removeEventListener(eventType, userListener) {
    if (!this.__localEventService) {
      return;
    }
    const listener = this.frameworkEventListenerService?.unwrap(userListener) ?? userListener;
    this.__localEventService.removeEventListener(eventType, listener);
    if (this.__localEventService.noRegisteredListenersExist()) {
      this.__localEventService = null;
    }
  }
  /**
   * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
   *
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    _warn(61);
    if (this.detail) {
      return true;
    }
    const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
    return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
  }
  /**
   * Returns the route of keys to the row node. Returns undefined if the node has no key.
   */
  getRoute() {
    if (this.level === -1) {
      return [];
    }
    if (this.key == null) {
      return void 0;
    }
    const res = [];
    let pointer = this;
    while (pointer && pointer.key != null) {
      res.push(pointer.key);
      pointer = pointer.parent;
    }
    return res.reverse();
  }
  setFirstChild(firstChild) {
    if (this.firstChild !== firstChild) {
      this.firstChild = firstChild;
      this.dispatchRowEvent("firstChildChanged");
    }
  }
  setDisplayed(displayed) {
    if (this.displayed !== displayed) {
      this.displayed = displayed;
      this.dispatchRowEvent("displayedChanged");
    }
  }
  setRowIndex(rowIndex) {
    if (this.rowIndex !== rowIndex) {
      this.rowIndex = rowIndex;
      this.dispatchRowEvent("rowIndexChanged");
    }
  }
  setAllChildrenCount(allChildrenCount) {
    if (this.allChildrenCount !== allChildrenCount) {
      this.allChildrenCount = allChildrenCount;
      this.dispatchRowEvent("allChildrenCountChanged");
    }
  }
  setUiLevel(uiLevel) {
    if (this.uiLevel !== uiLevel) {
      this.uiLevel = uiLevel;
      this.dispatchRowEvent("uiLevelChanged");
    }
  }
};

// packages/ag-grid-community/src/entities/rowNodeUtils.ts
function _createGlobalRowEvent(rowNode, gos, type) {
  return gos.addGridCommonParams({
    type,
    node: rowNode,
    data: rowNode.data,
    rowIndex: rowNode.rowIndex,
    rowPinned: rowNode.rowPinned
  });
}

// packages/ag-grid-community/src/filter/filterWrapperComp.ts
var FilterWrapperComp = class extends Component {
  constructor(column, source) {
    super(
      /* html */
      `<div class="ag-filter"></div>`
    );
    this.column = column;
    this.source = source;
    this.filterWrapper = null;
  }
  postConstruct() {
    this.createFilter(true);
    this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    return this.filterWrapper?.filterPromise ?? null;
  }
  afterInit() {
    return this.filterWrapper?.filterPromise?.then(() => {
    }) ?? AgPromise.resolve();
  }
  afterGuiAttached(params) {
    this.filterWrapper?.filterPromise?.then((filter) => {
      filter?.afterGuiAttached?.(params);
    });
  }
  afterGuiDetached() {
    this.filterWrapper?.filterPromise?.then((filter) => {
      filter?.afterGuiDetached?.();
    });
  }
  createFilter(init) {
    const { column, source } = this;
    this.filterWrapper = this.beans.filterManager?.getOrCreateFilterWrapper(column) ?? null;
    if (!this.filterWrapper?.filterPromise) {
      return;
    }
    this.filterWrapper.filterPromise.then((filter) => {
      const guiFromFilter = filter.getGui();
      if (!_exists(guiFromFilter)) {
        _warn(69, { guiFromFilter });
      }
      this.appendChild(guiFromFilter);
      if (init) {
        this.eventSvc.dispatchEvent({
          type: "filterOpened",
          column,
          source,
          eGui: this.getGui()
        });
      }
    });
  }
  onFilterDestroyed(event) {
    if ((event.source === "api" || event.source === "paramsUpdated") && event.column.getId() === this.column.getId() && this.beans.colModel.getColDefCol(this.column)) {
      _clearElement(this.getGui());
      this.createFilter();
    }
  }
  destroy() {
    this.filterWrapper = null;
    super.destroy();
  }
};

// packages/ag-grid-community/src/rendering/features/positionableFeature.ts
var RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
var makeDiv = (dataRefPrefix, classSuffix) => `<div data-ref="${dataRefPrefix}Resizer" class="ag-resizer ag-resizer-${classSuffix}"></div>`;
var RESIZE_TEMPLATE = (
  /* html */
  `<div class="${RESIZE_CONTAINER_STYLE}">
        ${makeDiv("eTopLeft", "topLeft")}
        ${makeDiv("eTop", "top")}
        ${makeDiv("eTopRight", "topRight")}
        ${makeDiv("eRight", "right")}
        ${makeDiv("eBottomRight", "bottomRight")}
        ${makeDiv("eBottom", "bottom")}
        ${makeDiv("eBottomLeft", "bottomLeft")}
        ${makeDiv("eLeft", "left")}
    </div>`
);
var PositionableFeature = class extends BeanStub {
  constructor(element, config) {
    super();
    this.element = element;
    this.dragStartPosition = {
      x: 0,
      y: 0
    };
    this.position = {
      x: 0,
      y: 0
    };
    this.lastSize = {
      width: -1,
      height: -1
    };
    this.positioned = false;
    this.resizersAdded = false;
    this.resizeListeners = [];
    this.boundaryEl = null;
    this.isResizing = false;
    this.isMoving = false;
    this.resizable = {};
    this.movable = false;
    this.currentResizer = null;
    this.config = Object.assign({}, { popup: false }, config);
  }
  wireBeans(beans) {
    this.popupSvc = beans.popupSvc;
    this.dragSvc = beans.dragSvc;
  }
  center() {
    const { clientHeight, clientWidth } = this.offsetParent;
    const x = clientWidth / 2 - this.getWidth() / 2;
    const y = clientHeight / 2 - this.getHeight() / 2;
    this.offsetElement(x, y);
  }
  initialisePosition() {
    if (this.positioned) {
      return;
    }
    const { centered, forcePopupParentAsOffsetParent, minWidth, width, minHeight, height, x, y } = this.config;
    if (!this.offsetParent) {
      this.setOffsetParent();
    }
    let computedMinHeight = 0;
    let computedMinWidth = 0;
    const isElementVisible = _isVisible(this.element);
    if (isElementVisible) {
      const boundaryEl = this.findBoundaryElement();
      const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
      if (offsetParentComputedStyles.minWidth != null) {
        const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
        computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
      }
      if (offsetParentComputedStyles.minHeight != null) {
        const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
        computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
      }
    }
    this.minHeight = minHeight || computedMinHeight;
    this.minWidth = minWidth || computedMinWidth;
    if (width) {
      this.setWidth(width);
    }
    if (height) {
      this.setHeight(height);
    }
    if (!width || !height) {
      this.refreshSize();
    }
    if (centered) {
      this.center();
    } else if (x || y) {
      this.offsetElement(x, y);
    } else if (isElementVisible && forcePopupParentAsOffsetParent) {
      let boundaryEl = this.boundaryEl;
      let initialisedDuringPositioning = true;
      if (!boundaryEl) {
        boundaryEl = this.findBoundaryElement();
        initialisedDuringPositioning = false;
      }
      if (boundaryEl) {
        const top = parseFloat(boundaryEl.style.top);
        const left = parseFloat(boundaryEl.style.left);
        if (initialisedDuringPositioning) {
          this.offsetElement(isNaN(left) ? 0 : left, isNaN(top) ? 0 : top);
        } else {
          this.setPosition(left, top);
        }
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(movable, moveElement) {
    if (!this.config.popup || movable === this.movable) {
      return;
    }
    this.movable = movable;
    const params = this.moveElementDragListener || {
      eElement: moveElement,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    if (movable) {
      this.dragSvc?.addDragSource(params);
      this.moveElementDragListener = params;
    } else {
      this.dragSvc?.removeDragSource(params);
      this.moveElementDragListener = void 0;
    }
  }
  setResizable(resizable) {
    this.clearResizeListeners();
    if (resizable) {
      this.addResizers();
    } else {
      this.removeResizers();
    }
    if (typeof resizable === "boolean") {
      if (resizable === false) {
        return;
      }
      resizable = {
        topLeft: resizable,
        top: resizable,
        topRight: resizable,
        right: resizable,
        bottomRight: resizable,
        bottom: resizable,
        bottomLeft: resizable,
        left: resizable
      };
    }
    Object.keys(resizable).forEach((side) => {
      const resizableStructure = resizable;
      const isSideResizable = !!resizableStructure[side];
      const resizerEl = this.getResizerElement(side);
      const params = {
        dragStartPixels: 0,
        eElement: resizerEl,
        onDragStart: (e) => this.onResizeStart(e, side),
        onDragging: this.onResize.bind(this),
        onDragStop: (e) => this.onResizeEnd(e, side)
      };
      if (isSideResizable || !this.isAlive() && !isSideResizable) {
        if (isSideResizable) {
          this.dragSvc?.addDragSource(params);
          this.resizeListeners.push(params);
          resizerEl.style.pointerEvents = "all";
        } else {
          resizerEl.style.pointerEvents = "none";
        }
        this.resizable[side] = isSideResizable;
      }
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height");
    this.element.style.removeProperty("width");
    this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height, width } = this.lastSize;
    if (width !== -1) {
      this.element.style.width = `${width}px`;
    }
    if (height !== -1) {
      this.element.style.height = `${height}px`;
    }
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(height) {
    const { popup } = this.config;
    const eGui = this.element;
    let isPercent = false;
    if (typeof height === "string" && height.indexOf("%") !== -1) {
      _setFixedHeight(eGui, height);
      height = _getAbsoluteHeight(eGui);
      isPercent = true;
    } else {
      height = Math.max(this.minHeight, height);
      if (this.positioned) {
        const availableHeight = this.getAvailableHeight();
        if (availableHeight && height > availableHeight) {
          height = availableHeight;
        }
      }
    }
    if (this.getHeight() === height) {
      return;
    }
    if (!isPercent) {
      if (popup) {
        _setFixedHeight(eGui, height);
      } else {
        eGui.style.height = `${height}px`;
        eGui.style.flex = "0 0 auto";
        this.lastSize.height = typeof height === "number" ? height : parseFloat(height);
      }
    } else {
      eGui.style.maxHeight = "unset";
      eGui.style.minHeight = "unset";
    }
  }
  getAvailableHeight() {
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    if (!this.positioned) {
      this.initialisePosition();
    }
    const { clientHeight } = this.offsetParent;
    if (!clientHeight) {
      return null;
    }
    const elRect = this.element.getBoundingClientRect();
    const offsetParentRect = this.offsetParent.getBoundingClientRect();
    const yPosition = popup ? this.position.y : elRect.top;
    const parentTop = popup ? 0 : offsetParentRect.top;
    let additionalHeight = 0;
    if (forcePopupParentAsOffsetParent) {
      const parentEl = this.element.parentElement;
      if (parentEl) {
        const { bottom } = parentEl.getBoundingClientRect();
        additionalHeight = bottom - elRect.bottom;
      }
    }
    const availableHeight = clientHeight + parentTop - yPosition - additionalHeight;
    return availableHeight;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(width) {
    const eGui = this.element;
    const { popup } = this.config;
    let isPercent = false;
    if (typeof width === "string" && width.indexOf("%") !== -1) {
      _setFixedWidth(eGui, width);
      width = _getAbsoluteWidth(eGui);
      isPercent = true;
    } else if (this.positioned) {
      width = Math.max(this.minWidth, width);
      const { clientWidth } = this.offsetParent;
      const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
      if (clientWidth && width + xPosition > clientWidth) {
        width = clientWidth - xPosition;
      }
    }
    if (this.getWidth() === width) {
      return;
    }
    if (!isPercent) {
      if (this.config.popup) {
        _setFixedWidth(eGui, width);
      } else {
        eGui.style.width = `${width}px`;
        eGui.style.flex = " unset";
        this.lastSize.width = typeof width === "number" ? width : parseFloat(width);
      }
    } else {
      eGui.style.maxWidth = "unset";
      eGui.style.minWidth = "unset";
    }
  }
  offsetElement(x = 0, y = 0) {
    const { forcePopupParentAsOffsetParent } = this.config;
    const ePopup = forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
    if (!ePopup) {
      return;
    }
    this.popupSvc?.positionPopup({
      ePopup,
      keepWithinBounds: true,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x, y })
    });
    this.setPosition(parseFloat(ePopup.style.left), parseFloat(ePopup.style.top));
  }
  constrainSizeToAvailableHeight(constrain) {
    if (!this.config.forcePopupParentAsOffsetParent) {
      return;
    }
    const applyMaxHeightToElement = () => {
      const availableHeight = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${availableHeight}px`);
    };
    if (constrain && this.popupSvc) {
      this.resizeObserverSubscriber = _observeResize(
        this.beans,
        this.popupSvc?.getPopupParent(),
        applyMaxHeightToElement
      );
    } else {
      this.element.style.removeProperty("max-height");
      if (this.resizeObserverSubscriber) {
        this.resizeObserverSubscriber();
        this.resizeObserverSubscriber = void 0;
      }
    }
  }
  setPosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }
  updateDragStartPosition(x, y) {
    this.dragStartPosition = { x, y };
  }
  calculateMouseMovement(params) {
    const { e, isLeft, isTop, anywhereWithin, topBuffer } = params;
    const xDiff = e.clientX - this.dragStartPosition.x;
    const yDiff = e.clientY - this.dragStartPosition.y;
    const movementX = this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff;
    const movementY = this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff;
    return { movementX, movementY };
  }
  shouldSkipX(e, isLeft, anywhereWithin, diff) {
    const elRect = this.element.getBoundingClientRect();
    const parentRect = this.offsetParent.getBoundingClientRect();
    const boundaryElRect = this.boundaryEl.getBoundingClientRect();
    const xPosition = this.config.popup ? this.position.x : elRect.left;
    let skipX = xPosition <= 0 && parentRect.left >= e.clientX || parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right;
    if (skipX) {
      return true;
    }
    if (isLeft) {
      skipX = // skip if we are moving to the left and the cursor
      // is positioned to the right of the left side anchor
      diff < 0 && e.clientX > xPosition + parentRect.left || // skip if we are moving to the right and the cursor
      // is positioned to the left of the dialog
      diff > 0 && e.clientX < xPosition + parentRect.left;
    } else {
      if (anywhereWithin) {
        skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < xPosition + parentRect.left;
      } else {
        skipX = // if the movement is bound to the right side of the dialog
        // we skip if we are moving to the left and the cursor
        // is to the right of the dialog
        diff < 0 && e.clientX > boundaryElRect.right || // or skip if we are moving to the right and the cursor
        // is to the left of the right side anchor
        diff > 0 && e.clientX < boundaryElRect.right;
      }
    }
    return skipX;
  }
  shouldSkipY(e, isTop, topBuffer = 0, diff) {
    const elRect = this.element.getBoundingClientRect();
    const parentRect = this.offsetParent.getBoundingClientRect();
    const boundaryElRect = this.boundaryEl.getBoundingClientRect();
    const yPosition = this.config.popup ? this.position.y : elRect.top;
    let skipY = yPosition <= 0 && parentRect.top >= e.clientY || parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom;
    if (skipY) {
      return true;
    }
    if (isTop) {
      skipY = // skip if we are moving to towards top and the cursor is
      // below the top anchor + topBuffer
      // note: topBuffer is used when moving the dialog using the title bar
      diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer || // skip if we are moving to the bottom and the cursor is
      // above the top anchor
      diff > 0 && e.clientY < yPosition + parentRect.top;
    } else {
      skipY = // skip if we are moving towards the top and the cursor
      // is below the bottom anchor
      diff < 0 && e.clientY > boundaryElRect.bottom || // skip if we are moving towards the bottom and the cursor
      // is above the bottom anchor
      diff > 0 && e.clientY < boundaryElRect.bottom;
    }
    return skipY;
  }
  createResizeMap() {
    const eGui = this.element;
    this.resizerMap = {
      topLeft: { element: eGui.querySelector("[data-ref=eTopLeftResizer]") },
      top: { element: eGui.querySelector("[data-ref=eTopResizer]") },
      topRight: { element: eGui.querySelector("[data-ref=eTopRightResizer]") },
      right: { element: eGui.querySelector("[data-ref=eRightResizer]") },
      bottomRight: { element: eGui.querySelector("[data-ref=eBottomRightResizer]") },
      bottom: { element: eGui.querySelector("[data-ref=eBottomResizer]") },
      bottomLeft: { element: eGui.querySelector("[data-ref=eBottomLeftResizer]") },
      left: { element: eGui.querySelector("[data-ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded) {
      return;
    }
    const eGui = this.element;
    if (!eGui) {
      return;
    }
    const parser = new DOMParser();
    const resizers = parser.parseFromString(RESIZE_TEMPLATE, "text/html").body;
    eGui.appendChild(resizers.firstChild);
    this.createResizeMap();
    this.resizersAdded = true;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const resizerEl = this.element.querySelector(`.${RESIZE_CONTAINER_STYLE}`);
    if (resizerEl) {
      this.element.removeChild(resizerEl);
    }
    this.resizersAdded = false;
  }
  getResizerElement(side) {
    return this.resizerMap[side].element;
  }
  onResizeStart(e, side) {
    this.boundaryEl = this.findBoundaryElement();
    if (!this.positioned) {
      this.initialisePosition();
    }
    this.currentResizer = {
      isTop: !!side.match(/top/i),
      isRight: !!side.match(/right/i),
      isBottom: !!side.match(/bottom/i),
      isLeft: !!side.match(/left/i)
    };
    this.element.classList.add("ag-resizing");
    this.resizerMap[side].element.classList.add("ag-active");
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    if (!popup && !forcePopupParentAsOffsetParent) {
      this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
    }
    this.isResizing = true;
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const element = this.element;
    const parent = element.parentElement;
    if (!parent) {
      return null;
    }
    return Array.prototype.slice.call(parent.children).filter((el) => !el.classList.contains("ag-hidden"));
  }
  getMinSizeOfSiblings() {
    const siblings = this.getSiblings() || [];
    let height = 0;
    let width = 0;
    for (let i = 0; i < siblings.length; i++) {
      const currentEl = siblings[i];
      const isFlex = !!currentEl.style.flex && currentEl.style.flex !== "0 0 auto";
      if (currentEl === this.element) {
        continue;
      }
      let nextHeight = this.minHeight || 0;
      let nextWidth = this.minWidth || 0;
      if (isFlex) {
        const computedStyle = window.getComputedStyle(currentEl);
        if (computedStyle.minHeight) {
          nextHeight = parseInt(computedStyle.minHeight, 10);
        }
        if (computedStyle.minWidth) {
          nextWidth = parseInt(computedStyle.minWidth, 10);
        }
      } else {
        nextHeight = currentEl.offsetHeight;
        nextWidth = currentEl.offsetWidth;
      }
      height += nextHeight;
      width += nextWidth;
    }
    return { height, width };
  }
  applySizeToSiblings(vertical) {
    let containerToFlex = null;
    const siblings = this.getSiblings();
    if (!siblings) {
      return;
    }
    for (let i = 0; i < siblings.length; i++) {
      const el = siblings[i];
      if (el === containerToFlex) {
        continue;
      }
      if (vertical) {
        el.style.height = `${el.offsetHeight}px`;
      } else {
        el.style.width = `${el.offsetWidth}px`;
      }
      el.style.flex = "0 0 auto";
      if (el === this.element) {
        containerToFlex = siblings[i + 1];
      }
    }
    if (containerToFlex) {
      containerToFlex.style.removeProperty("height");
      containerToFlex.style.removeProperty("min-height");
      containerToFlex.style.removeProperty("max-height");
      containerToFlex.style.flex = "1 1 auto";
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((value) => value);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer) {
      return;
    }
    const { popup, forcePopupParentAsOffsetParent } = this.config;
    const { isTop, isRight, isBottom, isLeft } = this.currentResizer;
    const isHorizontal = isRight || isLeft;
    const isVertical = isBottom || isTop;
    const { movementX, movementY } = this.calculateMouseMovement({ e, isLeft, isTop });
    const xPosition = this.position.x;
    const yPosition = this.position.y;
    let offsetLeft = 0;
    let offsetTop = 0;
    if (isHorizontal && movementX) {
      const direction = isLeft ? -1 : 1;
      const oldWidth = this.getWidth();
      const newWidth = oldWidth + movementX * direction;
      let skipWidth = false;
      if (isLeft) {
        offsetLeft = oldWidth - newWidth;
        if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
          skipWidth = true;
          offsetLeft = 0;
        }
      }
      if (!skipWidth) {
        this.setWidth(newWidth);
      }
    }
    if (isVertical && movementY) {
      const direction = isTop ? -1 : 1;
      const oldHeight = this.getHeight();
      const newHeight = oldHeight + movementY * direction;
      let skipHeight = false;
      if (isTop) {
        offsetTop = oldHeight - newHeight;
        if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
          skipHeight = true;
          offsetTop = 0;
        }
      } else {
        if (!this.config.popup && !this.config.forcePopupParentAsOffsetParent && oldHeight < newHeight && this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) {
          skipHeight = true;
        }
      }
      if (!skipHeight) {
        this.setHeight(newHeight);
      }
    }
    this.updateDragStartPosition(e.clientX, e.clientY);
    if ((popup || forcePopupParentAsOffsetParent) && offsetLeft || offsetTop) {
      this.offsetElement(xPosition + offsetLeft, yPosition + offsetTop);
    }
  }
  onResizeEnd(e, side) {
    this.isResizing = false;
    this.currentResizer = null;
    this.boundaryEl = null;
    this.element.classList.remove("ag-resizing");
    this.resizerMap[side].element.classList.remove("ag-active");
    this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const eGui = this.element;
    if (this.config.popup) {
      if (!this.config.width) {
        this.setWidth(eGui.offsetWidth);
      }
      if (!this.config.height) {
        this.setHeight(eGui.offsetHeight);
      }
    }
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement();
    if (!this.positioned) {
      this.initialisePosition();
    }
    this.isMoving = true;
    this.element.classList.add("ag-moving");
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving) {
      return;
    }
    const { x, y } = this.position;
    let topBuffer;
    if (this.config.calculateTopBuffer) {
      topBuffer = this.config.calculateTopBuffer();
    }
    const { movementX, movementY } = this.calculateMouseMovement({
      e,
      isTop: true,
      anywhereWithin: true,
      topBuffer
    });
    this.offsetElement(x + movementX, y + movementY);
    this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = false;
    this.boundaryEl = null;
    this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    if (this.config.forcePopupParentAsOffsetParent && this.popupSvc) {
      this.offsetParent = this.popupSvc.getPopupParent();
    } else {
      this.offsetParent = this.element.offsetParent;
    }
  }
  findBoundaryElement() {
    let el = this.element;
    while (el) {
      if (window.getComputedStyle(el).position !== "static") {
        return el;
      }
      el = el.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    while (this.resizeListeners.length) {
      const params = this.resizeListeners.pop();
      this.dragSvc?.removeDragSource(params);
    }
  }
  destroy() {
    super.destroy();
    if (this.moveElementDragListener) {
      this.dragSvc?.removeDragSource(this.moveElementDragListener);
    }
    this.constrainSizeToAvailableHeight(false);
    this.clearResizeListeners();
    this.removeResizers();
  }
};

// packages/ag-grid-community/src/widgets/managedFocusFeature.ts
var FOCUS_MANAGED_CLASS = "ag-focus-managed";
var ManagedFocusFeature = class extends BeanStub {
  constructor(eFocusable, callbacks = {}) {
    super();
    this.eFocusable = eFocusable;
    this.callbacks = callbacks;
    this.callbacks = {
      shouldStopEventPropagation: () => false,
      onTabKeyDown: (e) => {
        if (e.defaultPrevented) {
          return;
        }
        const nextRoot = _findNextFocusableElement(this.beans, this.eFocusable, false, e.shiftKey);
        if (!nextRoot) {
          return;
        }
        nextRoot.focus();
        e.preventDefault();
      },
      ...callbacks
    };
  }
  postConstruct() {
    const {
      eFocusable,
      callbacks: { onFocusIn, onFocusOut }
    } = this;
    eFocusable.classList.add(FOCUS_MANAGED_CLASS);
    this.addKeyDownListeners(eFocusable);
    if (onFocusIn) {
      this.addManagedElementListeners(eFocusable, { focusin: onFocusIn });
    }
    if (onFocusOut) {
      this.addManagedElementListeners(eFocusable, { focusout: onFocusOut });
    }
  }
  addKeyDownListeners(eGui) {
    this.addManagedElementListeners(eGui, {
      keydown: (e) => {
        if (e.defaultPrevented || _isStopPropagationForAgGrid(e)) {
          return;
        }
        const { callbacks } = this;
        if (callbacks.shouldStopEventPropagation(e)) {
          _stopPropagationForAgGrid(e);
          return;
        }
        if (e.key === KeyCode.TAB) {
          callbacks.onTabKeyDown(e);
        } else if (callbacks.handleKeyDown) {
          callbacks.handleKeyDown(e);
        }
      }
    });
  }
};

// packages/ag-grid-community/src/filter/filterLocaleText.ts
var FILTER_LOCALE_TEXT = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};

// packages/ag-grid-community/src/filter/floating/provided/providedFilterUtils.ts
function getDebounceMs(params, debounceDefault) {
  const { debounceMs } = params;
  if (isUseApplyButton(params)) {
    if (debounceMs != null) {
      _warn(71);
    }
    return 0;
  }
  return debounceMs ?? debounceDefault;
}
function isUseApplyButton(params) {
  return (params.buttons?.indexOf("apply") ?? -1) >= 0;
}

// packages/ag-grid-community/src/filter/provided/providedFilter.ts
var ProvidedFilter = class extends Component {
  constructor(filterNameKey) {
    super();
    this.filterNameKey = filterNameKey;
    this.applyActive = false;
    this.hidePopup = null;
    this.debouncePending = false;
    // after the user hits 'apply' the model gets copied to here. this is then the model that we use for
    // all filtering. so if user changes UI but doesn't hit apply, then the UI will be out of sync with this model.
    // this is what we want, as the UI should only become the 'active' filter once it's applied. when apply is
    // inactive, this model will be in sync (following the debounce ms). if the UI is not a valid filter
    // (eg the value is missing so nothing to filter on, or for set filter all checkboxes are checked so filter
    // not active) then this appliedModel will be null/undefined.
    this.appliedModel = null;
    this.eFilterBody = RefPlaceholder;
    this.buttonListeners = [];
    // subclasses can override this to provide alternative debounce defaults
    this.defaultDebounceMs = 0;
  }
  postConstruct() {
    this.resetTemplate();
    this.createManagedBean(
      new ManagedFocusFeature(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    );
    this.positionableFeature = new PositionableFeature(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: true
    });
    this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(paramsMap) {
    let eGui = this.getGui();
    if (eGui) {
      eGui.removeEventListener("submit", this.onFormSubmit);
    }
    const templateString = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(templateString, this.getAgComponents(), paramsMap);
    eGui = this.getGui();
    eGui?.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.params.readOnly;
  }
  init(params) {
    this.setParams(params);
    this.resetUiToDefaults(true).then(() => {
      this.updateUiVisibility();
      this.setupOnBtApplyDebounce();
    });
  }
  setParams(params) {
    this.params = params;
    this.applyActive = isUseApplyButton(params);
    this.resetButtonsPanel(params);
  }
  updateParams(params) {
    this.params = params;
    this.applyActive = isUseApplyButton(params);
    this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility();
      this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel(newParams, oldParams) {
    const { buttons: oldButtons, readOnly: oldReadOnly } = oldParams ?? {};
    const { buttons, readOnly } = newParams;
    if (oldReadOnly === readOnly && _jsonEquals(oldButtons, buttons)) {
      return;
    }
    const hasButtons = buttons && buttons.length > 0 && !this.isReadOnly();
    if (!this.eButtonsPanel) {
      if (hasButtons) {
        this.eButtonsPanel = document.createElement("div");
        this.eButtonsPanel.classList.add("ag-filter-apply-panel");
      }
    } else {
      _clearElement(this.eButtonsPanel);
      this.buttonListeners.forEach((destroyFunc) => destroyFunc());
      this.buttonListeners = [];
    }
    if (!hasButtons) {
      if (this.eButtonsPanel) {
        _removeFromParent(this.eButtonsPanel);
      }
      return;
    }
    const fragment = document.createDocumentFragment();
    const addButton = (type) => {
      let clickListener;
      const text = type ? this.translate(`${type}Filter`) : void 0;
      switch (type) {
        case "apply":
          clickListener = (e) => this.onBtApply(false, false, e);
          break;
        case "clear":
          clickListener = () => this.onBtClear();
          break;
        case "reset":
          clickListener = () => this.onBtReset();
          break;
        case "cancel":
          clickListener = (e) => {
            this.onBtCancel(e);
          };
          break;
        default:
          _warn(75);
          return;
      }
      const buttonType = type === "apply" ? "submit" : "button";
      const button = _loadTemplate(
        /* html */
        `<button
                    type="${buttonType}"
                    data-ref="${type}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${text}
                </button>`
      );
      this.buttonListeners.push(...this.addManagedElementListeners(button, { click: clickListener }));
      fragment.append(button);
    };
    buttons.forEach((type) => addButton(type));
    this.eButtonsPanel.append(fragment);
    this.getGui().appendChild(this.eButtonsPanel);
  }
  setupOnBtApplyDebounce() {
    const debounceMs = getDebounceMs(this.params, this.defaultDebounceMs);
    const debounceFunc = _debounce(this, this.checkApplyDebounce.bind(this), debounceMs);
    this.onBtApplyDebounce = () => {
      this.debouncePending = true;
      debounceFunc();
    };
  }
  checkApplyDebounce() {
    if (this.debouncePending) {
      this.debouncePending = false;
      this.onBtApply();
    }
  }
  getModel() {
    return this.appliedModel ?? null;
  }
  setModel(model) {
    const promise = model != null ? this.setModelIntoUi(model) : this.resetUiToDefaults();
    return promise.then(() => {
      this.updateUiVisibility();
      this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    if (this.params.closeOnApply) {
      this.close(e);
    }
  }
  resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
    const afterAppliedFunc = () => {
      this.onUiChanged(false, "prevent");
      afterUiUpdatedFunc?.();
    };
    if (currentModel != null) {
      this.setModelIntoUi(currentModel).then(afterAppliedFunc);
    } else {
      this.resetUiToDefaults().then(afterAppliedFunc);
    }
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear();
    this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(source = "api") {
    const newModel = this.getModelFromUi();
    if (!this.isModelValid(newModel)) {
      return false;
    }
    const previousModel = this.appliedModel;
    this.appliedModel = newModel;
    return !this.areModelsEqual(previousModel, newModel);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(model) {
    return true;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(afterFloatingFilter = false, afterDataChange = false, e) {
    if (e) {
      e.preventDefault();
    }
    if (this.applyModel(afterDataChange ? "rowDataUpdated" : "ui")) {
      const source = "columnFilter";
      this.params.filterChangedCallback({ afterFloatingFilter, afterDataChange, source });
    }
    const { closeOnApply } = this.params;
    if (closeOnApply && this.applyActive && !afterFloatingFilter && !afterDataChange) {
      this.close(e);
    }
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup) {
      return;
    }
    const keyboardEvent = e;
    const key = keyboardEvent && keyboardEvent.key;
    let params;
    if (key === "Enter" || key === "Space") {
      params = { keyboardEvent };
    }
    this.hidePopup(params);
    this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(fromFloatingFilter = false, apply) {
    this.updateUiVisibility();
    this.params.filterModifiedCallback();
    if (this.applyActive && !this.isReadOnly()) {
      const isValid = this.isModelValid(this.getModelFromUi());
      const applyFilterButton = this.queryForHtmlElement(`[data-ref="applyFilterButton"]`);
      if (applyFilterButton) {
        _setDisabled(applyFilterButton, !isValid);
      }
    }
    if (fromFloatingFilter && !apply || apply === "immediately") {
      this.onBtApply(fromFloatingFilter);
    } else if (!this.applyActive && !apply || apply === "debounce") {
      this.onBtApplyDebounce();
    }
  }
  afterGuiAttached(params) {
    if (params) {
      this.hidePopup = params.hidePopup;
    }
    this.refreshFilterResizer(params?.container);
  }
  refreshFilterResizer(containerType) {
    const { positionableFeature, gos } = this;
    if (!positionableFeature || containerType === "toolPanel") {
      return;
    }
    const isResizable = containerType === "floatingFilter" || containerType === "columnFilter";
    if (isResizable) {
      positionableFeature.restoreLastSize();
      positionableFeature.setResizable(
        gos.get("enableRtl") ? { bottom: true, bottomLeft: true, left: true } : { bottom: true, bottomRight: true, right: true }
      );
    } else {
      positionableFeature.removeSizeFromEl();
      positionableFeature.setResizable(false);
    }
    positionableFeature.constrainSizeToAvailableHeight(true);
  }
  afterGuiDetached() {
    this.checkApplyDebounce();
    this.positionableFeature?.constrainSizeToAvailableHeight(false);
  }
  refresh(newParams) {
    const oldParams = this.params;
    this.params = newParams;
    this.resetButtonsPanel(newParams, oldParams);
    return true;
  }
  destroy() {
    const eGui = this.getGui();
    if (eGui) {
      eGui.removeEventListener("submit", this.onFormSubmit);
    }
    this.hidePopup = null;
    if (this.positionableFeature) {
      this.positionableFeature = this.destroyBean(this.positionableFeature);
    }
    this.appliedModel = null;
    super.destroy();
  }
  translate(key) {
    return this.getLocaleTextFunc()(key, FILTER_LOCALE_TEXT[key]);
  }
  getCellValue(rowNode) {
    return this.params.getValue(rowNode);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
};

// packages/ag-grid-community/src/filter/floating/floatingFilterMapper.ts
function _getDefaultFloatingFilterType(frameworkOverrides, def, getFromDefault) {
  if (def == null) {
    return null;
  }
  let defaultFloatingFilterType = null;
  const { compName, jsComp, fwComp } = _getFilterCompKeys(frameworkOverrides, def);
  if (compName) {
    const floatingFilterTypeMap = {
      agSetColumnFilter: "agSetColumnFloatingFilter",
      agMultiColumnFilter: "agMultiColumnFloatingFilter",
      agGroupColumnFilter: "agGroupColumnFloatingFilter",
      agNumberColumnFilter: "agNumberColumnFloatingFilter",
      agDateColumnFilter: "agDateColumnFloatingFilter",
      agTextColumnFilter: "agTextColumnFloatingFilter"
    };
    defaultFloatingFilterType = floatingFilterTypeMap[compName];
  } else {
    const usingDefaultFilter = jsComp == null && fwComp == null && def.filter === true;
    if (usingDefaultFilter) {
      defaultFloatingFilterType = getFromDefault();
    }
  }
  return defaultFloatingFilterType;
}

// packages/ag-grid-community/src/styling/layoutFeature.ts
var LayoutCssClasses = {
  AUTO_HEIGHT: "ag-layout-auto-height",
  NORMAL: "ag-layout-normal",
  PRINT: "ag-layout-print"
};
var LayoutFeature = class extends BeanStub {
  constructor(view) {
    super();
    this.view = view;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
    this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const domLayout = this.gos.get("domLayout");
    const params = {
      autoHeight: domLayout === "autoHeight",
      normal: domLayout === "normal",
      print: domLayout === "print"
    };
    const cssClass = params.autoHeight ? LayoutCssClasses.AUTO_HEIGHT : params.print ? LayoutCssClasses.PRINT : LayoutCssClasses.NORMAL;
    this.view.updateLayoutClasses(cssClass, params);
  }
};

// packages/ag-grid-community/src/gridBodyComp/gridBodyScrollFeature.ts
var VIEWPORT = "Viewport";
var FAKE_V_SCROLLBAR = "fakeVScrollComp";
var HORIZONTAL_SOURCES = [
  "fakeHScrollComp",
  "centerHeader",
  "topCenter",
  "bottomCenter",
  "stickyTopCenter",
  "stickyBottomCenter"
];
var GridBodyScrollFeature = class extends BeanStub {
  constructor(eBodyViewport) {
    super();
    this.lastScrollSource = [null, null];
    this.scrollLeft = -1;
    this.nextScrollTop = -1;
    this.scrollTop = -1;
    // Used to provide approximate values of scrollTop and offsetHeight
    // without forcing the browser to recalculate styles.
    this.lastOffsetHeight = -1;
    this.lastScrollTop = -1;
    this.scrollTimer = 0;
    this.needsRefreshedScrollPosition = true;
    this.eBodyViewport = eBodyViewport;
    this.resetLastHScrollDebounced = _debounce(
      this,
      () => this.lastScrollSource[1 /* Horizontal */] = null,
      500
    );
    this.resetLastVScrollDebounced = _debounce(
      this,
      () => this.lastScrollSource[0 /* Vertical */] = null,
      500
    );
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.animationFrameSvc = beans.animationFrameSvc;
    this.visibleCols = beans.visibleCols;
  }
  destroy() {
    super.destroy();
    window.clearTimeout(this.scrollTimer);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    const requireUpdatedScrollPosition = this.requireUpdatedScrollPosition.bind(this);
    this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      gridSizeChanged: requireUpdatedScrollPosition
    });
    this.addManagedElementListeners(this.eBodyViewport, {
      scroll: requireUpdatedScrollPosition
    });
    this.ctrlsSvc.whenReady(this, (p) => {
      this.centerRowsCtrl = p.center;
      this.onDisplayedColumnsWidthChanged();
      this.addScrollListener();
    });
  }
  requireUpdatedScrollPosition() {
    this.needsRefreshedScrollPosition = true;
  }
  addScrollListener() {
    this.addHorizontalScrollListeners();
    this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
      scroll: this.onHScroll.bind(this, VIEWPORT)
    });
    for (const source of HORIZONTAL_SOURCES) {
      const scrollPartner = this.ctrlsSvc.get(source);
      this.registerScrollPartner(scrollPartner, this.onHScroll.bind(this, source));
    }
  }
  addVerticalScrollListeners() {
    const fakeVScrollComp = this.ctrlsSvc.get("fakeVScrollComp");
    const isDebounce = this.gos.get("debounceVerticalScrollbar");
    const onVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, VIEWPORT), 100) : this.onVScroll.bind(this, VIEWPORT);
    const onFakeVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, FAKE_V_SCROLLBAR), 100) : this.onVScroll.bind(this, FAKE_V_SCROLLBAR);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: onVScroll });
    this.registerScrollPartner(fakeVScrollComp, onFakeVScroll);
  }
  registerScrollPartner(comp, callback) {
    comp.onScrollCallback(callback);
  }
  onDisplayedColumnsWidthChanged() {
    if (this.enableRtl) {
      this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
    const notYetInitialised = this.centerRowsCtrl == null;
    if (notYetInitialised) {
      return;
    }
    if (scrollLeft === void 0) {
      scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
    }
    this.setScrollLeftForAllContainersExceptCurrent(Math.abs(scrollLeft));
  }
  setScrollLeftForAllContainersExceptCurrent(scrollLeft) {
    for (const container of [...HORIZONTAL_SOURCES, VIEWPORT]) {
      if (this.lastScrollSource[1 /* Horizontal */] === container) {
        continue;
      }
      const viewport = this.getViewportForSource(container);
      _setScrollLeft(viewport, scrollLeft, this.enableRtl);
    }
  }
  getViewportForSource(source) {
    if (source === VIEWPORT) {
      return this.centerRowsCtrl.eViewport;
    }
    return this.ctrlsSvc.get(source).eViewport;
  }
  isControllingScroll(source, direction) {
    if (this.lastScrollSource[direction] == null) {
      if (direction === 0 /* Vertical */) {
        this.lastScrollSource[0] = source;
      } else {
        this.lastScrollSource[1] = source;
      }
      return true;
    }
    return this.lastScrollSource[direction] === source;
  }
  onHScroll(source) {
    if (!this.isControllingScroll(source, 1 /* Horizontal */)) {
      return;
    }
    const centerContainerViewport = this.centerRowsCtrl.eViewport;
    const { scrollLeft } = centerContainerViewport;
    if (this.shouldBlockScrollUpdate(1 /* Horizontal */, scrollLeft, true)) {
      return;
    }
    const newScrollLeft = _getScrollLeft(this.getViewportForSource(source), this.enableRtl);
    this.doHorizontalScroll(newScrollLeft);
    this.resetLastHScrollDebounced();
  }
  onVScroll(source) {
    if (!this.isControllingScroll(source, 0 /* Vertical */)) {
      return;
    }
    let scrollTop;
    if (source === VIEWPORT) {
      scrollTop = this.eBodyViewport.scrollTop;
    } else {
      scrollTop = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition();
    }
    if (this.shouldBlockScrollUpdate(0 /* Vertical */, scrollTop, true)) {
      return;
    }
    const { animationFrameSvc } = this;
    animationFrameSvc?.setScrollTop(scrollTop);
    this.nextScrollTop = scrollTop;
    if (source === VIEWPORT) {
      this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(scrollTop);
    } else {
      this.eBodyViewport.scrollTop = scrollTop;
    }
    if (!animationFrameSvc || this.gos.get("suppressAnimationFrame")) {
      this.scrollGridIfNeeded();
    } else {
      animationFrameSvc.schedule();
    }
    this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(scrollLeft) {
    const fakeScrollLeft = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
    if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {
      return;
    }
    this.scrollLeft = scrollLeft;
    this.fireScrollEvent(1 /* Horizontal */);
    this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
    this.centerRowsCtrl.onHorizontalViewportChanged(true);
  }
  fireScrollEvent(direction) {
    const bodyScrollEvent = {
      type: "bodyScroll",
      direction: direction === 1 /* Horizontal */ ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventSvc.dispatchEvent(bodyScrollEvent);
    window.clearTimeout(this.scrollTimer);
    this.scrollTimer = window.setTimeout(() => {
      this.scrollTimer = 0;
      this.eventSvc.dispatchEvent({
        ...bodyScrollEvent,
        type: "bodyScrollEnd"
      });
    }, 100);
  }
  shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
    if (touchOnly && !_isIOSUserAgent()) {
      return false;
    }
    if (direction === 0 /* Vertical */) {
      return this.shouldBlockVerticalScroll(scrollTo);
    }
    return this.shouldBlockHorizontalScroll(scrollTo);
  }
  shouldBlockVerticalScroll(scrollTo) {
    const clientHeight = _getInnerHeight(this.eBodyViewport);
    const { scrollHeight } = this.eBodyViewport;
    if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {
      return true;
    }
    return false;
  }
  shouldBlockHorizontalScroll(scrollTo) {
    const clientWidth = this.centerRowsCtrl.getCenterWidth();
    const { scrollWidth } = this.centerRowsCtrl.eViewport;
    if (this.enableRtl && _isRtlNegativeScroll()) {
      if (scrollTo > 0) {
        return true;
      }
    } else if (scrollTo < 0) {
      return true;
    }
    if (Math.abs(scrollTo) + clientWidth > scrollWidth) {
      return true;
    }
    return false;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(0 /* Vertical */);
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    if (this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft()) {
      this.onHScroll(VIEWPORT);
    }
  }
  scrollGridIfNeeded() {
    const frameNeeded = this.scrollTop != this.nextScrollTop;
    if (frameNeeded) {
      this.scrollTop = this.nextScrollTop;
      this.redrawRowsAfterScroll();
    }
    return frameNeeded;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
    const minScrollLeft = 0;
    const maxScrollLeft = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
    if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(1 /* Horizontal */, hScrollPosition)) {
      if (this.enableRtl && _isRtlNegativeScroll()) {
        hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
      } else {
        hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
      }
    }
    _setScrollLeft(this.centerRowsCtrl.eViewport, Math.abs(hScrollPosition), this.enableRtl);
    this.doHorizontalScroll(hScrollPosition);
  }
  setVerticalScrollPosition(vScrollPosition) {
    this.eBodyViewport.scrollTop = vScrollPosition;
  }
  getVScrollPosition() {
    if (!this.needsRefreshedScrollPosition) {
      const { lastOffsetHeight, lastScrollTop } = this;
      return {
        top: lastScrollTop,
        bottom: lastScrollTop + lastOffsetHeight
      };
    }
    this.needsRefreshedScrollPosition = false;
    const { scrollTop, offsetHeight } = this.eBodyViewport;
    this.lastScrollTop = scrollTop;
    this.lastOffsetHeight = offsetHeight;
    return {
      top: scrollTop,
      bottom: scrollTop + offsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) {
      return {
        top: this.scrollTop,
        bottom: this.scrollTop + this.lastOffsetHeight
      };
    }
    return this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(pixels) {
    const oldScrollPosition = this.centerRowsCtrl.eViewport.scrollLeft;
    this.setHorizontalScrollPosition(oldScrollPosition + pixels);
    return this.centerRowsCtrl.eViewport.scrollLeft - oldScrollPosition;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(comparator, position = null) {
    const { rowModel } = this.beans;
    const rowCount = rowModel.getRowCount();
    let indexToSelect = -1;
    for (let i = 0; i < rowCount; i++) {
      const node = rowModel.getRow(i);
      if (typeof comparator === "function") {
        const predicate = comparator;
        if (node && predicate(node)) {
          indexToSelect = i;
          break;
        }
      } else {
        if (comparator === node || comparator === node.data) {
          indexToSelect = i;
          break;
        }
      }
    }
    if (indexToSelect >= 0) {
      this.ensureIndexVisible(indexToSelect, position);
    }
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(index, position) {
    if (_isDomLayout(this.gos, "print")) {
      return;
    }
    const { rowModel } = this.beans;
    const rowCount = rowModel.getRowCount();
    if (typeof index !== "number" || index < 0 || index >= rowCount) {
      _warn(88, { index });
      return;
    }
    const isPaging = this.gos.get("pagination");
    const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
    const {
      frameworkOverrides,
      pagination,
      pageBounds,
      rowContainerHeight: heightScaler,
      rowRenderer
    } = this.beans;
    frameworkOverrides.wrapIncoming(() => {
      if (!paginationPanelEnabled) {
        pagination?.goToPageWithIndex(index);
      }
      const gridBodyCtrl = this.ctrlsSvc.getGridBodyCtrl();
      const stickyTopHeight = gridBodyCtrl.stickyTopHeight;
      const stickyBottomHeight = gridBodyCtrl.stickyBottomHeight;
      const rowNode = rowModel.getRow(index);
      let rowGotShiftedDuringOperation;
      do {
        const startingRowTop = rowNode.rowTop;
        const startingRowHeight = rowNode.rowHeight;
        const paginationOffset = pageBounds.getPixelOffset();
        const rowTopPixel = rowNode.rowTop - paginationOffset;
        const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
        const scrollPosition = this.getVScrollPosition();
        const heightOffset = heightScaler.divStretchOffset;
        const vScrollTop = scrollPosition.top + heightOffset;
        const vScrollBottom = scrollPosition.bottom + heightOffset;
        const viewportHeight = vScrollBottom - vScrollTop;
        const pxTop = heightScaler.getScrollPositionForPixel(rowTopPixel);
        const pxBottom = heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
        const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
        const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
        const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
        let newScrollPosition = null;
        if (position === "top") {
          newScrollPosition = pxTop;
        } else if (position === "bottom") {
          newScrollPosition = pxBottom;
        } else if (position === "middle") {
          newScrollPosition = pxMiddle;
        } else if (rowAboveViewport) {
          newScrollPosition = pxTop - stickyTopHeight;
        } else if (rowBelowViewport) {
          newScrollPosition = pxBottom + stickyBottomHeight;
        }
        if (newScrollPosition !== null) {
          this.setVerticalScrollPosition(newScrollPosition);
          rowRenderer.redraw({ afterScroll: true });
        }
        rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
      } while (rowGotShiftedDuringOperation);
      this.animationFrameSvc?.flushAllFrames();
    });
  }
  ensureColumnVisible(key, position = "auto") {
    const { colModel, frameworkOverrides } = this.beans;
    const column = colModel.getCol(key);
    if (!column) {
      return;
    }
    if (column.isPinned()) {
      return;
    }
    if (!this.visibleCols.isColDisplayed(column)) {
      return;
    }
    const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
    frameworkOverrides.wrapIncoming(() => {
      if (newHorizontalScroll !== null) {
        this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
      }
      this.centerRowsCtrl.onHorizontalViewportChanged();
      this.animationFrameSvc?.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(column, position) {
    const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
    const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
    const viewportWidth = this.centerRowsCtrl.getCenterWidth();
    const isRtl = this.enableRtl;
    let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
    let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
    if (position !== "auto") {
      alignColToStart = position === "start";
      alignColToEnd = position === "end";
    }
    const isMiddle = position === "middle";
    if (alignColToStart || alignColToEnd || isMiddle) {
      const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
      if (isMiddle) {
        return colMiddle - viewportWidth / 2;
      }
      if (alignColToStart) {
        return isRtl ? colRight : colLeft;
      }
      return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
    }
    return null;
  }
  isColumnOutsideViewport(column) {
    const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
    const { colLeft, colRight } = this.getColumnBounds(column);
    const isRtl = this.enableRtl;
    const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
    const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
    return { columnBeforeStart, columnAfterEnd };
  }
  getColumnBounds(column) {
    const isRtl = this.enableRtl;
    const bodyWidth = this.visibleCols.bodyWidth;
    const colWidth = column.getActualWidth();
    const colLeft = column.getLeft();
    const multiplier = isRtl ? -1 : 1;
    const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
    const colRightPixel = colLeftPixel + colWidth * multiplier;
    const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;
    return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };
  }
  getViewportBounds() {
    const viewportWidth = this.centerRowsCtrl.getCenterWidth();
    const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
    const viewportStartPixel = scrollPosition;
    const viewportEndPixel = viewportWidth + scrollPosition;
    return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };
  }
};

// packages/ag-grid-community/src/gridBodyComp/centerWidthFeature.ts
var CenterWidthFeature = class extends BeanStub {
  constructor(callback, addSpacer = false) {
    super();
    this.callback = callback;
    this.addSpacer = addSpacer;
  }
  postConstruct() {
    const listener = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", listener);
    this.addManagedEventListeners({
      columnContainerWidthChanged: listener,
      displayedColumnsChanged: listener,
      leftPinnedWidthChanged: listener
    });
    if (this.addSpacer) {
      this.addManagedEventListeners({
        rightPinnedWidthChanged: listener,
        scrollVisibilityChanged: listener,
        scrollbarWidthChanged: listener
      });
    }
    this.setWidth();
  }
  setWidth() {
    const printLayout = _isDomLayout(this.gos, "print");
    const { visibleCols, scrollVisibleSvc } = this.beans;
    const centerWidth = visibleCols.bodyWidth;
    const leftWidth = visibleCols.getColsLeftWidth();
    const rightWidth = visibleCols.getDisplayedColumnsRightWidth();
    let totalWidth;
    if (printLayout) {
      totalWidth = centerWidth + leftWidth + rightWidth;
    } else {
      totalWidth = centerWidth;
      if (this.addSpacer) {
        const relevantWidth = this.gos.get("enableRtl") ? leftWidth : rightWidth;
        if (relevantWidth === 0 && scrollVisibleSvc.verticalScrollShowing) {
          totalWidth += scrollVisibleSvc.getScrollbarWidth();
        }
      }
    }
    this.callback(totalWidth);
  }
};

// packages/ag-grid-community/src/gridBodyComp/viewportSizeFeature.ts
var ViewportSizeFeature = class extends BeanStub {
  constructor(centerContainerCtrl) {
    super();
    this.centerContainerCtrl = centerContainerCtrl;
  }
  wireBeans(beans) {
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
      this.listenForResize();
    });
    this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) });
    this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const { beans, centerContainerCtrl, gridBodyCtrl } = this;
    const listener = () => {
      _requestAnimationFrame(beans, () => {
        this.onCenterViewportResized();
      });
    };
    centerContainerCtrl.registerViewportResizeListener(listener);
    gridBodyCtrl.registerBodyViewportResizeListener(listener);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    this.scrollVisibleSvc.updateScrollGap();
    if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
      const { pinnedCols, colFlex } = this.beans;
      pinnedCols?.keepPinnedColumnsNarrowerThanViewport();
      this.checkViewportAndScrolls();
      const newWidth = this.centerContainerCtrl.getCenterWidth();
      if (newWidth !== this.centerWidth) {
        this.centerWidth = newWidth;
        colFlex?.refreshFlexedColumns({
          viewportWidth: this.centerWidth,
          updateBodyWidths: true,
          fireResizedEvent: true
        });
      }
    } else {
      this.bodyHeight = 0;
    }
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService();
    this.checkBodyHeight();
    this.onHorizontalViewportChanged();
    this.gridBodyCtrl.scrollFeature.checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
    const bodyHeight = _getInnerHeight(eBodyViewport);
    if (this.bodyHeight !== bodyHeight) {
      this.bodyHeight = bodyHeight;
      this.eventSvc.dispatchEvent({
        type: "bodyHeightChanged"
      });
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl();
    setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const params = {
      horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleSvc.setScrollsVisible(params);
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const scrollWidth = this.centerContainerCtrl.getCenterWidth();
    const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition);
  }
};

// packages/ag-grid-community/src/styling/stylingUtils.ts
function processClassRules(expressionSvc, previousClassRules, classRules, params, onApplicableClass, onNotApplicableClass) {
  if (classRules == null && previousClassRules == null) {
    return;
  }
  const classesToApply = {};
  const classesToRemove = {};
  const forEachSingleClass = (className, callback) => {
    className.split(" ").forEach((singleClass) => {
      if (singleClass.trim() == "")
        return;
      callback(singleClass);
    });
  };
  if (classRules) {
    const classNames = Object.keys(classRules);
    for (let i = 0; i < classNames.length; i++) {
      const className = classNames[i];
      const rule = classRules[className];
      let resultOfRule;
      if (typeof rule === "string") {
        resultOfRule = expressionSvc ? expressionSvc.evaluate(rule, params) : true;
      } else if (typeof rule === "function") {
        resultOfRule = rule(params);
      }
      forEachSingleClass(className, (singleClass) => {
        resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;
      });
    }
  }
  if (previousClassRules && onNotApplicableClass) {
    Object.keys(previousClassRules).forEach(
      (className) => forEachSingleClass(className, (singleClass) => {
        if (!classesToApply[singleClass]) {
          classesToRemove[singleClass] = true;
        }
      })
    );
  }
  if (onNotApplicableClass) {
    Object.keys(classesToRemove).forEach(onNotApplicableClass);
  }
  Object.keys(classesToApply).forEach(onApplicableClass);
}

// packages/ag-grid-community/src/styling/rowStyleService.ts
function calculateRowLevel(rowNode) {
  if (rowNode.group) {
    return rowNode.level;
  }
  const parent = rowNode.parent;
  return parent ? parent.level + 1 : 0;
}
var RowStyleService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowStyleSvc";
  }
  processClassesFromGridOptions(classes, rowNode) {
    const gos = this.gos;
    const process = (rowCls) => {
      if (typeof rowCls === "string") {
        classes.push(rowCls);
      } else if (Array.isArray(rowCls)) {
        rowCls.forEach((e) => classes.push(e));
      }
    };
    const rowClass = gos.get("rowClass");
    if (rowClass) {
      process(rowClass);
    }
    const rowClassFunc = gos.getCallback("getRowClass");
    if (rowClassFunc) {
      const params = {
        data: rowNode.data,
        node: rowNode,
        rowIndex: rowNode.rowIndex
      };
      const rowClassFuncResult = rowClassFunc(params);
      process(rowClassFuncResult);
    }
  }
  preProcessRowClassRules(classes, rowNode) {
    this.processRowClassRules(
      rowNode,
      (className) => {
        classes.push(className);
      },
      () => {
      }
    );
  }
  processRowClassRules(rowNode, onApplicableClass, onNotApplicableClass) {
    const { gos, expressionSvc } = this.beans;
    const rowClassParams = gos.addGridCommonParams({
      data: rowNode.data,
      node: rowNode,
      rowIndex: rowNode.rowIndex
    });
    processClassRules(
      expressionSvc,
      void 0,
      gos.get("rowClassRules"),
      rowClassParams,
      onApplicableClass,
      onNotApplicableClass
    );
  }
  processStylesFromGridOptions(rowNode) {
    const gos = this.gos;
    const rowStyle = gos.get("rowStyle");
    const rowStyleFunc = gos.getCallback("getRowStyle");
    let rowStyleFuncResult;
    if (rowStyleFunc) {
      const params = {
        data: rowNode.data,
        node: rowNode,
        rowIndex: rowNode.rowIndex
      };
      rowStyleFuncResult = rowStyleFunc(params);
    }
    if (rowStyleFuncResult || rowStyle) {
      return Object.assign({}, rowStyle, rowStyleFuncResult);
    }
    return void 0;
  }
};

// packages/ag-grid-community/src/rendering/row/rowCtrl.ts
var instanceIdSequence3 = 0;
var DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var RowCtrl = class extends BeanStub {
  constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
    super();
    this.rowNode = rowNode;
    this.useAnimationFrameForCreate = useAnimationFrameForCreate;
    this.printLayout = printLayout;
    this.allRowGuis = [];
    this.active = true;
    this.centerCellCtrls = { list: [], map: {} };
    this.leftCellCtrls = { list: [], map: {} };
    this.rightCellCtrls = { list: [], map: {} };
    this.slideInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.fadeInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.rowDragComps = [];
    this.lastMouseDownOnDragger = false;
    this.emptyStyle = {};
    this.updateColumnListsPending = false;
    this.rowId = null;
    /** sanitised */
    this.businessKey = null;
    this.beans = beans;
    this.gos = beans.gos;
    this.paginationPage = beans.pagination?.getCurrentPage() ?? 0;
    this.suppressRowTransform = this.gos.get("suppressRowTransform");
    this.instanceId = rowNode.id + "-" + instanceIdSequence3++;
    this.rowId = _escapeString(rowNode.id);
    this.initRowBusinessKey();
    this.rowFocused = beans.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    this.rowLevel = calculateRowLevel(this.rowNode);
    this.setRowType();
    this.setAnimateFlags(animateIn);
    this.rowStyles = this.processStylesFromGridOptions();
    this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode");
    this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc !== "function") {
      return;
    }
    const businessKey = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKey = _escapeString(businessKey);
  }
  updateGui(containerType, gui) {
    if (containerType === "left") {
      this.leftGui = gui;
    } else if (containerType === "right") {
      this.rightGui = gui;
    } else if (containerType === "fullWidth") {
      this.fullWidthGui = gui;
    } else {
      this.centerGui = gui;
    }
  }
  setComp(rowComp, element, containerType, compBean) {
    compBean = setupCompBean(this, this.beans.context, compBean);
    const gui = { rowComp, element, containerType, compBean };
    this.allRowGuis.push(gui);
    this.updateGui(containerType, gui);
    this.initialiseRowComp(gui);
    if (this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned) {
      this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    }
  }
  unsetComp(containerType) {
    this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
    this.updateGui(containerType, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(cached) {
    const displayValue = cached ? "none" : "";
    this.allRowGuis.forEach((rg) => rg.element.style.display = displayValue);
  }
  initialiseRowComp(gui) {
    const gos = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
    this.listenOnDomOrder(gui);
    this.beans.rowAutoHeight?.checkAutoHeights(this.rowNode);
    this.onRowHeightChanged(gui);
    this.updateRowIndexes(gui);
    this.setFocusedClasses(gui);
    this.setStylesFromGridOptions(false, gui);
    if (_isRowSelection(gos) && this.rowNode.selectable) {
      this.onRowSelected(gui);
    }
    this.updateColumnLists(!this.useAnimationFrameForCreate);
    const comp = gui.rowComp;
    const initialRowClasses = this.getInitialRowClasses(gui.containerType);
    initialRowClasses.forEach((name) => comp.addOrRemoveCssClass(name, true));
    this.executeSlideAndFadeAnimations(gui);
    if (this.rowNode.group) {
      _setAriaExpanded(gui.element, this.rowNode.expanded == true);
    }
    this.setRowCompRowId(comp);
    this.setRowCompRowBusinessKey(comp);
    _setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, this);
    gui.compBean.addDestroyFunc(() => _setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, null));
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameSvc.createTask(
        this.addHoverFunctionality.bind(this, gui),
        this.rowNode.rowIndex,
        "createTasksP2"
      );
    } else {
      this.addHoverFunctionality(gui);
    }
    if (this.isFullWidth()) {
      this.setupFullWidth(gui);
    }
    if (gos.get("rowDragEntireRow")) {
      this.addRowDraggerToRow(gui);
    }
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameSvc.addDestroyTask(() => {
        if (!this.isAlive()) {
          return;
        }
        gui.rowComp.addOrRemoveCssClass("ag-after-created", true);
      });
    }
    this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(comp) {
    if (this.businessKey == null) {
      return;
    }
    comp.setRowBusinessKey(this.businessKey);
  }
  setRowCompRowId(comp) {
    const rowId = _escapeString(this.rowNode.id);
    this.rowId = rowId;
    if (rowId == null) {
      return;
    }
    comp.setRowId(rowId);
  }
  executeSlideAndFadeAnimations(gui) {
    const { containerType } = gui;
    const shouldSlide = this.slideInAnimation[containerType];
    if (shouldSlide) {
      _executeNextVMTurn(() => {
        this.onTopChanged();
      });
      this.slideInAnimation[containerType] = false;
    }
    const shouldFade = this.fadeInAnimation[containerType];
    if (shouldFade) {
      _executeNextVMTurn(() => {
        gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", false);
      });
      this.fadeInAnimation[containerType] = false;
    }
  }
  addRowDraggerToRow(gui) {
    const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForRow(this.rowNode, gui.element);
    if (!rowDragComp) {
      return;
    }
    const rowDragBean = this.createBean(rowDragComp, this.beans.context);
    this.rowDragComps.push(rowDragBean);
    gui.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((r) => r !== rowDragBean);
      this.destroyBean(rowDragBean, this.beans.context);
    });
  }
  setupFullWidth(gui) {
    const pinned = this.getPinnedForContainer(gui.containerType);
    const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
    gui.rowComp.showFullWidth(compDetails);
  }
  getFullWidthCellRenderers() {
    if (this.gos.get("embedFullWidthRows")) {
      return this.allRowGuis.map((gui) => gui?.rowComp?.getFullWidthCellRenderer());
    }
    return [this.fullWidthGui?.rowComp?.getFullWidthCellRenderer()];
  }
  executeProcessRowPostCreateFunc() {
    const func = this.gos.getCallback("processRowPostCreate");
    if (!func || !this.areAllContainersReady()) {
      return;
    }
    const params = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    func(params);
  }
  areAllContainersReady() {
    const {
      leftGui,
      centerGui,
      rightGui,
      beans: { visibleCols }
    } = this;
    const isLeftReady = !!leftGui || !visibleCols.isPinningLeft();
    const isCenterReady = !!centerGui;
    const isRightReady = !!rightGui || !visibleCols.isPinningRight();
    return isLeftReady && isCenterReady && isRightReady;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail) {
      return true;
    }
    const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
    return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this.rowNode }) : false;
  }
  setRowType() {
    const isStub = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents");
    const isFullWidthCell = this.isNodeFullWidthCell();
    const isDetailCell = this.gos.get("masterDetail") && this.rowNode.detail;
    const pivotMode = this.beans.colModel.isPivotMode();
    const isGroupRow = !!this.rowNode.group && !this.rowNode.footer;
    const isFullWidthGroup = isGroupRow && _isGroupUseEntireRow(this.gos, pivotMode);
    if (isStub) {
      this.rowType = "FullWidthLoading";
    } else if (isDetailCell) {
      this.rowType = "FullWidthDetail";
    } else if (isFullWidthCell) {
      this.rowType = "FullWidth";
    } else if (isFullWidthGroup) {
      this.rowType = "FullWidthGroup";
    } else {
      this.rowType = "Normal";
    }
  }
  updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
    if (this.isFullWidth()) {
      return;
    }
    const { animationFrameSvc } = this.beans;
    const noAnimation = !animationFrameSvc || suppressAnimationFrame || this.gos.get("suppressAnimationFrame") || this.printLayout;
    if (noAnimation) {
      this.updateColumnListsImpl(useFlushSync);
      return;
    }
    if (this.updateColumnListsPending) {
      return;
    }
    animationFrameSvc.createTask(
      () => {
        if (!this.active) {
          return;
        }
        this.updateColumnListsImpl(true);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    );
    this.updateColumnListsPending = true;
  }
  createCellCtrls(prev, cols, pinned = null) {
    const res = {
      list: [],
      map: {}
    };
    const addCell = (colInstanceId, cellCtrl) => {
      res.list.push(cellCtrl);
      res.map[colInstanceId] = cellCtrl;
    };
    cols.forEach((col) => {
      const colInstanceId = col.getInstanceId();
      let cellCtrl = prev.map[colInstanceId];
      if (!cellCtrl) {
        cellCtrl = new CellCtrl(col, this.rowNode, this.beans, this);
      }
      addCell(colInstanceId, cellCtrl);
    });
    prev.list.forEach((prevCellCtrl) => {
      const colInstanceId = prevCellCtrl.column.getInstanceId();
      const cellInResult = res.map[colInstanceId] != null;
      if (cellInResult) {
        return;
      }
      const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
      if (keepCell) {
        addCell(colInstanceId, prevCellCtrl);
        return;
      }
      prevCellCtrl.destroy();
    });
    return res;
  }
  updateColumnListsImpl(useFlushSync) {
    this.updateColumnListsPending = false;
    this.createAllCellCtrls();
    this.setCellCtrls(useFlushSync);
  }
  setCellCtrls(useFlushSync) {
    this.allRowGuis.forEach((item) => {
      const cellControls = this.getCellCtrlsForContainer(item.containerType);
      item.rowComp.setCellCtrls(cellControls, useFlushSync);
    });
  }
  getCellCtrlsForContainer(containerType) {
    switch (containerType) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const colViewport = this.beans.colViewport;
    const presentedColsService = this.beans.visibleCols;
    if (this.printLayout) {
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, presentedColsService.allCols);
      this.leftCellCtrls = { list: [], map: {} };
      this.rightCellCtrls = { list: [], map: {} };
    } else {
      const centerCols = colViewport.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
      const leftCols = presentedColsService.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
      const rightCols = presentedColsService.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
    }
  }
  isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
    const REMOVE_CELL = true;
    const KEEP_CELL = false;
    const { column } = cellCtrl;
    if (column.getPinned() != nextContainerPinned) {
      return REMOVE_CELL;
    }
    const { editing, cellPosition } = cellCtrl;
    const { focusSvc, visibleCols } = this.beans;
    const focused = focusSvc.isCellFocused(cellPosition);
    const mightWantToKeepCell = editing || focused;
    if (mightWantToKeepCell) {
      const displayedColumns = visibleCols.allCols;
      const cellStillDisplayed = displayedColumns.indexOf(column) >= 0;
      return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
    }
    return REMOVE_CELL;
  }
  getDomOrder() {
    const isEnsureDomOrder = this.gos.get("ensureDomOrder");
    return isEnsureDomOrder || _isDomLayout(this.gos, "print");
  }
  listenOnDomOrder(gui) {
    const listener = () => {
      gui.rowComp.setDomOrder(this.getDomOrder());
    };
    gui.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], listener);
  }
  setAnimateFlags(animateIn) {
    if (this.rowNode.sticky || !animateIn) {
      return;
    }
    const oldRowTopExists = _exists(this.rowNode.oldRowTop);
    const { visibleCols } = this.beans;
    const pinningLeft = visibleCols.isPinningLeft();
    const pinningRight = visibleCols.isPinningRight();
    if (oldRowTopExists) {
      const { slideInAnimation } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        slideInAnimation.fullWidth = true;
        return;
      }
      slideInAnimation.center = true;
      slideInAnimation.left = pinningLeft;
      slideInAnimation.right = pinningRight;
    } else {
      const { fadeInAnimation } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        fadeInAnimation.fullWidth = true;
        return;
      }
      fadeInAnimation.center = true;
      fadeInAnimation.left = pinningLeft;
      fadeInAnimation.right = pinningRight;
    }
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const tryRefresh = (gui, pinned) => {
      if (!gui) {
        return true;
      }
      return gui.rowComp.refreshFullWidth(() => {
        const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
        return compDetails.params;
      });
    };
    const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
    const centerSuccess = tryRefresh(this.centerGui, null);
    const leftSuccess = tryRefresh(this.leftGui, "left");
    const rightSuccess = tryRefresh(this.rightGui, "right");
    const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
    return allFullWidthRowsRefreshed;
  }
  addListeners() {
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      ...this.beans.expansionSvc?.getRowExpandedListeners(this) ?? {}
    });
    if (this.rowNode.detail) {
      this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) });
    }
    this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this)
    });
    this.addManagedListeners(this.beans.eventSvc, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    });
    this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
      this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context);
    });
    this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    );
    this.addManagedPropertyListener("rowDragEntireRow", () => {
      const useRowDragEntireRow = this.gos.get("rowDragEntireRow");
      if (useRowDragEntireRow) {
        this.allRowGuis.forEach((gui) => {
          this.addRowDraggerToRow(gui);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    });
    this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged());
      },
      cellChanged: (event) => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event));
      }
    });
  }
  onRowNodeDataChanged(event) {
    const fullWidthChanged = this.isFullWidth() !== !!this.isNodeFullWidthCell();
    if (fullWidthChanged) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      const refresh = this.refreshFullWidth();
      if (!refresh) {
        this.beans.rowRenderer.redrawRow(this.rowNode);
      }
      return;
    }
    this.getAllCellCtrls().forEach(
      (cellCtrl) => cellCtrl.refreshCell({
        suppressFlash: !event.update,
        newData: !event.update
      })
    );
    this.allRowGuis.forEach((gui) => {
      this.setRowCompRowId(gui.rowComp);
      this.updateRowBusinessKey();
      this.setRowCompRowBusinessKey(gui.rowComp);
    });
    this.onRowSelected();
    this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(true);
    this.postProcessClassesFromGridOptions();
    this.postProcessRowClassRules();
    this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const highlighted = this.rowNode.highlighted;
    this.allRowGuis.forEach((gui) => {
      const aboveOn = highlighted === "Above";
      const belowOn = highlighted === "Below";
      gui.rowComp.addOrRemoveCssClass("ag-row-highlight-above", aboveOn);
      gui.rowComp.addOrRemoveCssClass("ag-row-highlight-below", belowOn);
    });
  }
  postProcessRowDragging() {
    const dragging = this.rowNode.dragging;
    this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-dragging", dragging));
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(true);
    this.beans.rowAutoHeight?.checkAutoHeights(this.rowNode);
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(false, true);
  }
  getRowPosition() {
    return {
      rowPinned: _makeNull(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  findFullWidthRowGui(target) {
    return this.allRowGuis.find((c) => c.element.contains(target));
  }
  onKeyboardNavigate(keyboardEvent) {
    const currentFullWidthComp = this.findFullWidthRowGui(keyboardEvent.target);
    const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    if (!isFullWidthContainerFocused) {
      return;
    }
    const node = this.rowNode;
    const { focusSvc, navigation } = this.beans;
    const lastFocusedCell = focusSvc.getFocusedCell();
    const cellPosition = {
      rowIndex: node.rowIndex,
      rowPinned: node.rowPinned,
      column: lastFocusedCell?.column ?? this.getColumnForFullWidth(currentFullWidthComp)
    };
    navigation?.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
    keyboardEvent.preventDefault();
  }
  onTabKeyDown(keyboardEvent) {
    if (keyboardEvent.defaultPrevented || _isStopPropagationForAgGrid(keyboardEvent)) {
      return;
    }
    const currentFullWidthComp = this.allRowGuis.find(
      (c) => c.element.contains(keyboardEvent.target)
    );
    const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    const activeEl = _getActiveDomElement(this.beans);
    let isDetailGridCellFocused = false;
    if (currentFullWidthContainer && activeEl) {
      isDetailGridCellFocused = currentFullWidthContainer.contains(activeEl) && activeEl.classList.contains("ag-cell");
    }
    let nextEl = null;
    if (!isFullWidthContainerFocused && !isDetailGridCellFocused) {
      nextEl = _findNextFocusableElement(this.beans, currentFullWidthContainer, false, keyboardEvent.shiftKey);
    }
    if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) {
      this.beans.navigation?.onTabKeyDown(this, keyboardEvent);
    }
  }
  getFullWidthElement() {
    if (this.fullWidthGui) {
      return this.fullWidthGui.element;
    }
    return null;
  }
  getRowYPosition() {
    const displayedEl = this.allRowGuis.find((el) => _isVisible(el.element))?.element;
    if (displayedEl) {
      return displayedEl.getBoundingClientRect().top;
    }
    return 0;
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    const tabIndex = this.isFullWidth() && suppressCellFocus ? void 0 : -1;
    this.allRowGuis.forEach((gui) => {
      _addOrRemoveAttribute(gui.element, "tabindex", tabIndex);
    });
  }
  onFullWidthRowFocused(event) {
    const node = this.rowNode;
    const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
    const element = this.fullWidthGui ? this.fullWidthGui.element : this.centerGui?.element;
    if (!element) {
      return;
    }
    element.classList.toggle("ag-full-width-focus", isFocused);
    if (isFocused && event?.forceBrowserFocus) {
      element.focus({ preventScroll: true });
    }
  }
  recreateCell(cellCtrl) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
    this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
    this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
    cellCtrl.destroy();
    this.updateColumnLists();
  }
  removeCellCtrl(prev, cellCtrlToRemove) {
    const res = {
      list: [],
      map: {}
    };
    prev.list.forEach((cellCtrl) => {
      if (cellCtrl === cellCtrlToRemove) {
        return;
      }
      res.list.push(cellCtrl);
      res.map[cellCtrl.column.getInstanceId()] = cellCtrl;
    });
    return res;
  }
  onMouseEvent(eventName, mouseEvent) {
    switch (eventName) {
      case "dblclick":
        this.onRowDblClick(mouseEvent);
        break;
      case "click":
        this.onRowClick(mouseEvent);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(mouseEvent);
        break;
    }
  }
  createRowEvent(type, domEvent) {
    const { rowNode } = this;
    return this.gos.addGridCommonParams({
      type,
      node: rowNode,
      data: rowNode.data,
      rowIndex: rowNode.rowIndex,
      rowPinned: rowNode.rowPinned,
      event: domEvent
    });
  }
  createRowEventWithSource(type, domEvent) {
    const event = this.createRowEvent(type, domEvent);
    event.source = this;
    return event;
  }
  onRowDblClick(mouseEvent) {
    if (_isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    this.beans.eventSvc.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", mouseEvent));
  }
  getColumnForFullWidth(fullWidthRowGui) {
    const { visibleCols } = this.beans;
    switch (fullWidthRowGui?.containerType) {
      case "center":
        return visibleCols.centerCols[0];
      case "left":
        return visibleCols.leftCols[0];
      case "right":
        return visibleCols.rightCols[0];
      default:
        return visibleCols.allCols[0];
    }
  }
  onRowMouseDown(mouseEvent) {
    this.lastMouseDownOnDragger = _isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
    if (!this.isFullWidth()) {
      return;
    }
    const node = this.rowNode;
    const { rangeSvc, focusSvc } = this.beans;
    rangeSvc?.removeAllCellRanges();
    const fullWidthRowGui = this.findFullWidthRowGui(mouseEvent.target);
    const element = fullWidthRowGui?.element;
    const target = mouseEvent.target;
    let forceBrowserFocus = true;
    if (element && element.contains(target) && _isFocusableFormField(target)) {
      forceBrowserFocus = false;
    }
    focusSvc.setFocusedCell({
      rowIndex: node.rowIndex,
      column: this.getColumnForFullWidth(fullWidthRowGui),
      rowPinned: node.rowPinned,
      forceBrowserFocus
    });
  }
  onRowClick(mouseEvent) {
    const stop = _isStopPropagationForAgGrid(mouseEvent) || this.lastMouseDownOnDragger;
    if (stop) {
      return;
    }
    const { eventSvc, selectionSvc } = this.beans;
    eventSvc.dispatchEvent(this.createRowEventWithSource("rowClicked", mouseEvent));
    selectionSvc?.handleSelectionEvent(mouseEvent, this.rowNode, "rowClicked");
  }
  setupDetailRowAutoHeight(eDetailGui) {
    if (this.rowType !== "FullWidthDetail") {
      return;
    }
    this.beans.masterDetailSvc?.setupDetailRowAutoHeight(this, eDetailGui);
  }
  createFullWidthCompDetails(eRow, pinned) {
    const { gos, rowNode } = this;
    const params = gos.addGridCommonParams({
      fullWidth: true,
      data: rowNode.data,
      node: rowNode,
      value: rowNode.key,
      valueFormatted: rowNode.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: eRow,
      eParentOfValue: eRow,
      pinned,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange),
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.refreshRowTooltip(value, shouldDisplayTooltip);
      }
    });
    const compFactory = this.beans.userCompFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return _getFullWidthDetailCellRendererDetails(compFactory, params);
      case "FullWidthGroup":
        return _getFullWidthGroupCellRendererDetails(compFactory, params);
      case "FullWidthLoading":
        return _getFullWidthLoadingCellRendererDetails(compFactory, params);
      default:
        return _getFullWidthCellRendererDetails(compFactory, params);
    }
  }
  refreshRowTooltip(value, shouldDisplayTooltip) {
    if (!this.fullWidthGui) {
      return;
    }
    this.tooltipFeature = this.beans.tooltipSvc?.refreshRowTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", suppressVisibilityChange) {
    const { rowDragSvc, context } = this.beans;
    if (!rowDragSvc || !this.isFullWidth()) {
      return;
    }
    const rowDragComp = rowDragSvc.createRowDragComp(
      () => value,
      this.rowNode,
      void 0,
      rowDraggerElement,
      dragStartPixels,
      suppressVisibilityChange
    );
    this.createBean(rowDragComp, context);
    this.addDestroyFunc(() => {
      this.destroyBean(rowDragComp, context);
    });
  }
  onUiLevelChanged() {
    const newLevel = calculateRowLevel(this.rowNode);
    if (this.rowLevel != newLevel) {
      const classToAdd = "ag-row-level-" + newLevel;
      const classToRemove = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((gui) => {
        gui.rowComp.addOrRemoveCssClass(classToAdd, true);
        gui.rowComp.addOrRemoveCssClass(classToRemove, false);
      });
    }
    this.rowLevel = newLevel;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const newFirst = this.isFirstRowOnPage();
    const newLast = this.isLastRowOnPage();
    if (this.firstRowOnPage !== newFirst) {
      this.firstRowOnPage = newFirst;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-first", newFirst));
    }
    if (this.lastRowOnPage !== newLast) {
      this.lastRowOnPage = newLast;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-last", newLast));
    }
  }
  getAllCellCtrls() {
    if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) {
      return this.centerCellCtrls.list;
    }
    const res = [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
    return res;
  }
  postProcessClassesFromGridOptions() {
    const cssClasses = [];
    this.beans.rowStyleSvc?.processClassesFromGridOptions(cssClasses, this.rowNode);
    if (!cssClasses.length) {
      return;
    }
    cssClasses.forEach((classStr) => {
      this.allRowGuis.forEach((c) => c.rowComp.addOrRemoveCssClass(classStr, true));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowStyleSvc?.processRowClassRules(
      this.rowNode,
      (className) => {
        this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, true));
      },
      (className) => {
        this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, false));
      }
    );
  }
  setStylesFromGridOptions(updateStyles, gui) {
    if (updateStyles) {
      this.rowStyles = this.processStylesFromGridOptions();
    }
    this.forEachGui(gui, (gui2) => gui2.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(rowContainerType) {
    if (rowContainerType === "left" || rowContainerType === "right") {
      return rowContainerType;
    }
    return null;
  }
  getInitialRowClasses(rowContainerType) {
    const pinned = this.getPinnedForContainer(rowContainerType);
    const fullWidthRow = this.isFullWidth();
    const { rowNode, beans } = this;
    const classes = [];
    classes.push("ag-row");
    classes.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
    if (this.fadeInAnimation[rowContainerType]) {
      classes.push("ag-opacity-zero");
    }
    classes.push(rowNode.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd");
    if (rowNode.isRowPinned()) {
      classes.push("ag-row-pinned");
    }
    if (rowNode.isSelected()) {
      classes.push("ag-row-selected");
    }
    if (rowNode.footer) {
      classes.push("ag-row-footer");
    }
    classes.push("ag-row-level-" + this.rowLevel);
    if (rowNode.stub) {
      classes.push("ag-row-loading");
    }
    if (fullWidthRow) {
      classes.push("ag-full-width-row");
    }
    beans.expansionSvc?.addExpandedCss(classes, rowNode);
    if (rowNode.dragging) {
      classes.push("ag-row-dragging");
    }
    const { rowStyleSvc } = beans;
    if (rowStyleSvc) {
      rowStyleSvc.processClassesFromGridOptions(classes, rowNode);
      rowStyleSvc.preProcessRowClassRules(classes, rowNode);
    }
    classes.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
    if (this.isFirstRowOnPage()) {
      classes.push("ag-row-first");
    }
    if (this.isLastRowOnPage()) {
      classes.push("ag-row-last");
    }
    if (fullWidthRow) {
      if (pinned === "left") {
        classes.push("ag-cell-last-left-pinned");
      }
      if (pinned === "right") {
        classes.push("ag-cell-first-right-pinned");
      }
    }
    return classes;
  }
  processStylesFromGridOptions() {
    return this.beans.rowStyleSvc?.processStylesFromGridOptions(this.rowNode) ?? this.emptyStyle;
  }
  onRowSelected(gui) {
    this.beans.selectionSvc?.onRowCtrlSelected(
      this,
      (gui2) => {
        if (gui2 === this.centerGui || gui2 === this.fullWidthGui) {
          this.announceDescription();
        }
      },
      gui
    );
  }
  announceDescription() {
    this.beans.selectionSvc?.announceAriaRowSelection(this.rowNode);
  }
  addHoverFunctionality(eGui) {
    if (!this.active) {
      return;
    }
    const { element, compBean } = eGui;
    const { rowNode, beans, gos } = this;
    compBean.addManagedListeners(element, {
      mouseenter: () => rowNode.dispatchRowEvent("mouseEnter"),
      mouseleave: () => rowNode.dispatchRowEvent("mouseLeave")
    });
    compBean.addManagedListeners(rowNode, {
      mouseEnter: () => {
        if (!beans.dragSvc?.dragging && !gos.get("suppressRowHoverHighlight")) {
          element.classList.add("ag-row-hover");
          rowNode.setHovered(true);
        }
      },
      mouseLeave: () => {
        element.classList.remove("ag-row-hover");
        rowNode.setHovered(false);
      }
    });
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(rowTop) {
    const range = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition();
    const minPixel = this.applyPaginationOffset(range.top, true) - 100;
    const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
    return Math.min(Math.max(minPixel, rowTop), maxPixel);
  }
  forEachGui(gui, callback) {
    if (gui) {
      callback(gui);
    } else {
      this.allRowGuis.forEach(callback);
    }
  }
  onRowHeightChanged(gui) {
    if (this.rowNode.rowHeight == null) {
      return;
    }
    const rowHeight = this.rowNode.rowHeight;
    const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
    const isHeightFromFunc = _isGetRowHeightFunction(this.gos);
    const heightFromFunc = isHeightFromFunc ? _getRowHeightForNode(this.beans, this.rowNode).height : void 0;
    const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
    this.forEachGui(gui, (gui2) => {
      gui2.element.style.height = `${rowHeight}px`;
      if (lineHeight) {
        gui2.element.style.setProperty("--ag-line-height", lineHeight);
      }
    });
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(suppressAnimation = false) {
    this.active = false;
    const { rowNode } = this;
    if (!suppressAnimation && _isAnimateRows(this.gos) && !rowNode.sticky) {
      const rowStillVisibleJustNotInViewport = rowNode.rowTop != null;
      if (rowStillVisibleJustNotInViewport) {
        const rowTop = this.roundRowTopToBounds(rowNode.rowTop);
        this.setRowTop(rowTop);
      } else {
        this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", true));
      }
    }
    rowNode.setHovered(false);
    const event = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(event);
    this.beans.eventSvc.dispatchEvent(event);
    super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0;
    this.beans.editSvc?.stopRowEditing(this);
    const destroyCellCtrls = (ctrls) => {
      ctrls.list.forEach((c) => c.destroy());
      return { list: [], map: {} };
    };
    this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
    this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
    this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
  }
  setFocusedClasses(gui) {
    this.forEachGui(gui, (gui2) => {
      gui2.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused);
      gui2.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const { focusSvc, editSvc } = this.beans;
    const rowFocused = focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    if (rowFocused !== this.rowFocused) {
      this.rowFocused = rowFocused;
      this.setFocusedClasses();
    }
    if (!rowFocused && this.editing) {
      editSvc?.stopRowEditing(this, false);
    }
  }
  onPaginationChanged() {
    const currentPage = this.beans.pagination?.getCurrentPage() ?? 0;
    if (this.paginationPage !== currentPage) {
      this.paginationPage = currentPage;
      this.onTopChanged();
    }
    this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(topPx, reverse = false) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky) {
      return topPx;
    }
    const pixelOffset = this.beans.pageBounds.getPixelOffset();
    const multiplier = reverse ? 1 : -1;
    return topPx + pixelOffset * multiplier;
  }
  setRowTop(pixels) {
    if (this.printLayout) {
      return;
    }
    if (_exists(pixels)) {
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      const skipScaling = this.rowNode.isRowPinned() || this.rowNode.sticky;
      const afterScalingPixels = skipScaling ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
      const topPx = `${afterScalingPixels}px`;
      this.setRowTopStyle(topPx);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(rowContainerType) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
  }
  getInitialTransform(rowContainerType) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
  }
  getInitialRowTopShared(rowContainerType) {
    if (this.printLayout) {
      return "";
    }
    const rowNode = this.rowNode;
    let rowTop;
    if (rowNode.sticky) {
      rowTop = rowNode.stickyRowTop;
    } else {
      const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(rowNode.oldRowTop) : rowNode.rowTop;
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      rowTop = rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
    }
    return rowTop + "px";
  }
  setRowTopStyle(topPx) {
    this.allRowGuis.forEach(
      (gui) => this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`)
    );
  }
  getCellCtrl(column, skipColSpanSearch = false) {
    let res = null;
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.column == column) {
        res = cellCtrl;
      }
    });
    if (res != null || skipColSpanSearch) {
      return res;
    }
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.getColSpanningList().indexOf(column) >= 0) {
        res = cellCtrl;
      }
    });
    return res;
  }
  onRowIndexChanged() {
    if (this.rowNode.rowIndex != null) {
      this.onCellFocusChanged();
      this.updateRowIndexes();
      this.postProcessCss();
    }
  }
  updateRowIndexes(gui) {
    const rowIndexStr = this.rowNode.getRowIndexString();
    if (rowIndexStr === null) {
      return;
    }
    const headerRowCount = (this.beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) + (this.beans.filterManager?.getHeaderRowCount() ?? 0);
    const rowIsEven = this.rowNode.rowIndex % 2 === 0;
    const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
    this.forEachGui(gui, (c) => {
      c.rowComp.setRowIndex(rowIndexStr);
      c.rowComp.addOrRemoveCssClass("ag-row-even", rowIsEven);
      c.rowComp.addOrRemoveCssClass("ag-row-odd", !rowIsEven);
      _setAriaRowIndex(c.element, ariaRowIndex);
    });
  }
};

// packages/ag-grid-community/src/utils/keyboard.ts
function _isEventFromPrintableCharacter(event) {
  if (event.altKey || event.ctrlKey || event.metaKey) {
    return false;
  }
  const printableCharacter = event.key?.length === 1;
  return printableCharacter;
}
function _isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
  const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
  if (!colDefFunc) {
    return false;
  }
  const params = gos.addGridCommonParams({
    event: keyboardEvent,
    editing,
    column,
    node: rowNode,
    data: rowNode.data,
    colDef: column.getColDef()
  });
  if (colDefFunc) {
    const colDefFuncResult = colDefFunc(params);
    if (colDefFuncResult) {
      return true;
    }
  }
  return false;
}

// packages/ag-grid-community/src/gridBodyComp/rowContainer/rowContainerEventsFeature.ts
var A_KEYCODE = 65;
var C_KEYCODE = 67;
var V_KEYCODE = 86;
var D_KEYCODE = 68;
var Z_KEYCODE = 90;
var Y_KEYCODE = 89;
function _normaliseQwertyAzerty(keyboardEvent) {
  const { keyCode } = keyboardEvent;
  let code;
  switch (keyCode) {
    case A_KEYCODE:
      code = KeyCode.A;
      break;
    case C_KEYCODE:
      code = KeyCode.C;
      break;
    case V_KEYCODE:
      code = KeyCode.V;
      break;
    case D_KEYCODE:
      code = KeyCode.D;
      break;
    case Z_KEYCODE:
      code = KeyCode.Z;
      break;
    case Y_KEYCODE:
      code = KeyCode.Y;
      break;
    default:
      code = keyboardEvent.code;
  }
  return code;
}
var RowContainerEventsFeature = class extends BeanStub {
  constructor(element) {
    super();
    this.element = element;
  }
  postConstruct() {
    this.addKeyboardListeners();
    this.addMouseListeners();
    this.beans.touchSvc?.mockRowContextMenu(this);
  }
  addKeyboardListeners() {
    const eventName = "keydown";
    const listener = this.processKeyboardEvent.bind(this, eventName);
    this.addManagedElementListeners(this.element, { [eventName]: listener });
  }
  addMouseListeners() {
    const mouseDownEvent = _isEventSupported("touchstart") ? "touchstart" : "mousedown";
    const eventNames = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", mouseDownEvent];
    eventNames.forEach((eventName) => {
      const listener = this.processMouseEvent.bind(this, eventName);
      this.addManagedElementListeners(this.element, { [eventName]: listener });
    });
  }
  processMouseEvent(eventName, mouseEvent) {
    if (!_isEventFromThisGrid(this.gos, mouseEvent) || _isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(mouseEvent.target);
    if (eventName === "contextmenu") {
      if (cellCtrl?.column) {
        cellCtrl.dispatchCellContextMenuEvent(mouseEvent);
      }
      this.beans.contextMenuSvc?.handleContextMenuMouseEvent(mouseEvent, void 0, rowCtrl, cellCtrl);
    } else {
      if (cellCtrl) {
        cellCtrl.onMouseEvent(eventName, mouseEvent);
      }
      if (rowCtrl) {
        rowCtrl.onMouseEvent(eventName, mouseEvent);
      }
    }
  }
  getControlsForEventTarget(target) {
    const { gos } = this;
    return {
      cellCtrl: _getCellCtrlForEventTarget(gos, target),
      rowCtrl: _getCtrlForEventTarget(gos, target, DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(eventName, keyboardEvent) {
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
    if (keyboardEvent.defaultPrevented) {
      return;
    }
    if (cellCtrl) {
      this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
    } else if (rowCtrl && rowCtrl.isFullWidth()) {
      this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
    }
  }
  processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
    const { rowNode, column, editing } = cellCtrl;
    const gridProcessingAllowed = !_isUserSuppressingKeyboardEvent(
      this.gos,
      keyboardEvent,
      rowNode,
      column,
      editing
    );
    if (gridProcessingAllowed) {
      if (eventName === "keydown") {
        const wasScrollKey = !editing && this.beans.navigation?.handlePageScrollingKey(keyboardEvent);
        if (!wasScrollKey) {
          cellCtrl.onKeyDown(keyboardEvent);
        }
        this.doGridOperations(keyboardEvent, cellCtrl.editing);
        if (_isEventFromPrintableCharacter(keyboardEvent)) {
          cellCtrl.processCharacter(keyboardEvent);
        }
      }
    }
    if (eventName === "keydown") {
      this.eventSvc.dispatchEvent(cellCtrl.createEvent(keyboardEvent, "cellKeyDown"));
    }
  }
  processFullWidthRowKeyboardEvent(rowComp, eventName, keyboardEvent) {
    const { rowNode } = rowComp;
    const { focusSvc, navigation } = this.beans;
    const focusedCell = focusSvc.getFocusedCell();
    const column = focusedCell && focusedCell.column;
    const gridProcessingAllowed = !_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, false);
    if (gridProcessingAllowed) {
      const key = keyboardEvent.key;
      if (eventName === "keydown") {
        switch (key) {
          case KeyCode.PAGE_HOME:
          case KeyCode.PAGE_END:
          case KeyCode.PAGE_UP:
          case KeyCode.PAGE_DOWN:
            navigation?.handlePageScrollingKey(keyboardEvent, true);
            break;
          case KeyCode.UP:
          case KeyCode.DOWN:
            rowComp.onKeyboardNavigate(keyboardEvent);
            break;
          case KeyCode.TAB:
            rowComp.onTabKeyDown(keyboardEvent);
            break;
          default:
        }
      }
    }
    if (eventName === "keydown") {
      this.eventSvc.dispatchEvent(rowComp.createRowEvent("cellKeyDown", keyboardEvent));
    }
  }
  doGridOperations(keyboardEvent, editing) {
    if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {
      return;
    }
    if (editing) {
      return;
    }
    if (!_isEventFromThisGrid(this.gos, keyboardEvent)) {
      return;
    }
    const keyCode = _normaliseQwertyAzerty(keyboardEvent);
    const { clipboardSvc, undoRedo } = this.beans;
    if (keyCode === KeyCode.A) {
      return this.onCtrlAndA(keyboardEvent);
    }
    if (keyCode === KeyCode.C) {
      return this.onCtrlAndC(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.D) {
      return this.onCtrlAndD(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.V) {
      return this.onCtrlAndV(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.X) {
      return this.onCtrlAndX(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.Y) {
      return this.onCtrlAndY(undoRedo);
    }
    if (keyCode === KeyCode.Z) {
      return this.onCtrlAndZ(undoRedo, keyboardEvent);
    }
  }
  onCtrlAndA(event) {
    const {
      beans: { pinnedRowModel, rowModel, visibleCols, rangeSvc, selectionSvc },
      gos
    } = this;
    if (rangeSvc && _isCellSelectionEnabled(gos) && rowModel.isRowsToRender()) {
      const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
        pinnedRowModel?.isEmpty("top") ?? true,
        pinnedRowModel?.isEmpty("bottom") ?? true
      ];
      const floatingStart = isEmptyPinnedTop ? null : "top";
      let floatingEnd;
      let rowEnd;
      if (isEmptyPinnedBottom) {
        floatingEnd = null;
        rowEnd = rowModel.getRowCount() - 1;
      } else {
        floatingEnd = "bottom";
        rowEnd = pinnedRowModel?.getPinnedBottomRowCount() ?? 0 - 1;
      }
      const allDisplayedColumns = visibleCols.allCols;
      if (!allDisplayedColumns?.length) {
        return;
      }
      rangeSvc.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: floatingStart,
        rowEndIndex: rowEnd,
        rowEndPinned: floatingEnd,
        columnStart: allDisplayedColumns[0],
        columnEnd: _last(allDisplayedColumns)
      });
    } else if (selectionSvc) {
      selectionSvc?.selectAllRowNodes({ source: "keyboardSelectAll", selectAll: _getSelectAll(gos) });
    }
    event.preventDefault();
  }
  onCtrlAndC(clipboardSvc, event) {
    if (!clipboardSvc || this.gos.get("enableCellTextSelection")) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if (cellCtrl?.editing || rowCtrl?.editing) {
      return;
    }
    event.preventDefault();
    clipboardSvc.copyToClipboard();
  }
  onCtrlAndX(clipboardSvc, event) {
    if (!clipboardSvc || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if (cellCtrl?.editing || rowCtrl?.editing) {
      return;
    }
    event.preventDefault();
    clipboardSvc.cutToClipboard(void 0, "ui");
  }
  onCtrlAndV(clipboardSvc, event) {
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
    if (cellCtrl?.editing || rowCtrl?.editing) {
      return;
    }
    if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) {
      clipboardSvc.pasteFromClipboard();
    }
  }
  onCtrlAndD(clipboardSvc, event) {
    if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) {
      clipboardSvc.copyRangeDown();
    }
    event.preventDefault();
  }
  onCtrlAndZ(undoRedo, event) {
    if (!this.gos.get("undoRedoCellEditing") || !undoRedo) {
      return;
    }
    event.preventDefault();
    if (event.shiftKey) {
      undoRedo.redo("ui");
    } else {
      undoRedo.undo("ui");
    }
  }
  onCtrlAndY(undoRedo) {
    undoRedo?.redo("ui");
  }
};

// packages/ag-grid-community/src/gridBodyComp/rowContainer/setHeightFeature.ts
var SetHeightFeature = class extends BeanStub {
  constructor(eContainer, eViewport) {
    super();
    this.eContainer = eContainer;
    this.eViewport = eViewport;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight)
    });
  }
  onHeightChanged(maxDivHeightScaler) {
    const height = maxDivHeightScaler.uiContainerHeight;
    const heightString = height != null ? `${height}px` : ``;
    this.eContainer.style.height = heightString;
    if (this.eViewport) {
      this.eViewport.style.height = heightString;
    }
  }
};

// packages/ag-grid-community/src/gridBodyComp/rowContainer/rowContainerCtrl.ts
var getTopRowCtrls = (r) => r.topRowCtrls;
var getStickyTopRowCtrls = (r) => r.getStickyTopRowCtrls();
var getStickyBottomRowCtrls = (r) => r.getStickyBottomRowCtrls();
var getBottomRowCtrls = (r) => r.bottomRowCtrls;
var getCentreRowCtrls = (r) => r.allRowCtrls;
var ContainerCssClasses = {
  center: {
    type: "center",
    container: "ag-center-cols-container",
    viewport: "ag-center-cols-viewport",
    getRowCtrls: getCentreRowCtrls
  },
  left: {
    type: "left",
    container: "ag-pinned-left-cols-container",
    pinnedType: "left",
    getRowCtrls: getCentreRowCtrls
  },
  right: {
    type: "right",
    container: "ag-pinned-right-cols-container",
    pinnedType: "right",
    getRowCtrls: getCentreRowCtrls
  },
  fullWidth: {
    type: "fullWidth",
    container: "ag-full-width-container",
    fullWidth: true,
    getRowCtrls: getCentreRowCtrls
  },
  topCenter: {
    type: "center",
    container: "ag-floating-top-container",
    viewport: "ag-floating-top-viewport",
    getRowCtrls: getTopRowCtrls
  },
  topLeft: {
    type: "left",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: getTopRowCtrls
  },
  topRight: {
    type: "right",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: getTopRowCtrls
  },
  topFullWidth: {
    type: "fullWidth",
    container: "ag-floating-top-full-width-container",
    fullWidth: true,
    getRowCtrls: getTopRowCtrls
  },
  stickyTopCenter: {
    type: "center",
    container: "ag-sticky-top-container",
    viewport: "ag-sticky-top-viewport",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopRight: {
    type: "right",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-top-full-width-container",
    fullWidth: true,
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyBottomCenter: {
    type: "center",
    container: "ag-sticky-bottom-container",
    viewport: "ag-sticky-bottom-viewport",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomRight: {
    type: "right",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-bottom-full-width-container",
    fullWidth: true,
    getRowCtrls: getStickyBottomRowCtrls
  },
  bottomCenter: {
    type: "center",
    container: "ag-floating-bottom-container",
    viewport: "ag-floating-bottom-viewport",
    getRowCtrls: getBottomRowCtrls
  },
  bottomLeft: {
    type: "left",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: getBottomRowCtrls
  },
  bottomRight: {
    type: "right",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: getBottomRowCtrls
  },
  bottomFullWidth: {
    type: "fullWidth",
    container: "ag-floating-bottom-full-width-container",
    fullWidth: true,
    getRowCtrls: getBottomRowCtrls
  }
};
function _getRowContainerOptions(name) {
  return ContainerCssClasses[name];
}
var allTopNoFW = ["topCenter", "topLeft", "topRight"];
var allBottomNoFW = ["bottomCenter", "bottomLeft", "bottomRight"];
var allMiddleNoFW = ["center", "left", "right"];
var allMiddle = ["center", "left", "right", "fullWidth"];
var allCenter = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"];
var allLeft = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"];
var allRight = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"];
var allStickyTopNoFW = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"];
var allStickyBottomNoFW = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"];
var allStickyContainers = [
  ...allStickyTopNoFW,
  "stickyTopFullWidth",
  ...allStickyBottomNoFW,
  "stickyBottomFullWidth"
];
var allNoFW = [
  ...allTopNoFW,
  ...allBottomNoFW,
  ...allMiddleNoFW,
  ...allStickyTopNoFW,
  ...allStickyBottomNoFW
];
var RowContainerCtrl = class extends BeanStub {
  constructor(name) {
    super();
    this.name = name;
    this.visible = true;
    // Maintaining a constant reference enables optimization in React.
    this.EMPTY_CTRLS = [];
    this.options = _getRowContainerOptions(name);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new ViewportSizeFeature(this));
      this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(event) {
    this.comp.setOffsetTop(`${event.offset}px`);
  }
  registerWithCtrlsService() {
    if (this.options.fullWidth)
      return;
    this.beans.ctrlsSvc.register(this.name, this);
  }
  forContainers(names, callback) {
    if (names.indexOf(this.name) >= 0) {
      callback();
    }
  }
  setComp(view, eContainer, eViewport) {
    this.comp = view;
    this.eContainer = eContainer;
    this.eViewport = eViewport;
    this.createManagedBean(new RowContainerEventsFeature(this.eContainer));
    this.addPreventScrollWhileDragging();
    this.listenOnDomOrder();
    const { pinnedCols, rangeSvc } = this.beans;
    const pinnedWidthChanged = () => this.onPinnedWidthChanged();
    this.forContainers(allLeft, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        pinnedCols?.createPinnedWidthFeature(this.eContainer, true)
      );
      this.addManagedEventListeners({ leftPinnedWidthChanged: pinnedWidthChanged });
    });
    this.forContainers(allRight, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        pinnedCols?.createPinnedWidthFeature(this.eContainer, false)
      );
      this.addManagedEventListeners({ rightPinnedWidthChanged: pinnedWidthChanged });
    });
    this.forContainers(
      allMiddle,
      () => this.createManagedBean(
        new SetHeightFeature(this.eContainer, this.name === "center" ? eViewport : void 0)
      )
    );
    if (rangeSvc) {
      this.forContainers(
        allNoFW,
        () => this.createManagedBean(rangeSvc.createDragListenerFeature(this.eContainer))
      );
    }
    this.forContainers(
      allCenter,
      () => this.createManagedBean(new CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`)))
    );
    this.visible = this.isContainerVisible();
    this.addListeners();
    this.registerWithCtrlsService();
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
  addListeners() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedRowsChanged: (params) => this.onDisplayedRowsChanged(params.afterScroll)
    });
    this.onDisplayedColumnsChanged();
    this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    const isStickContainer = allStickyContainers.indexOf(this.name) >= 0;
    if (isStickContainer) {
      this.comp.setDomOrder(true);
      return;
    }
    const listener = () => {
      const isEnsureDomOrder = this.gos.get("ensureDomOrder");
      const isPrintLayout = _isDomLayout(this.gos, "print");
      this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
    };
    this.addManagedPropertyListener("domLayout", listener);
    listener();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const { dragSvc } = this.beans;
    if (!dragSvc) {
      return;
    }
    const preventScroll = (e) => {
      if (dragSvc.dragging) {
        if (e.cancelable) {
          e.preventDefault();
        }
      }
    };
    this.eContainer.addEventListener("touchmove", preventScroll, { passive: false });
    this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", preventScroll));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(afterScroll = false) {
    const scrollWidth = this.getCenterWidth();
    const scrollPosition = this.getCenterViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition, afterScroll);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return _getInnerWidth(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(listener) {
    const unsubscribeFromResize = _observeResize(this.beans, this.eViewport, listener);
    this.addDestroyFunc(() => unsubscribeFromResize());
  }
  isViewportInTheDOMTree() {
    return _isInDOM(this.eViewport);
  }
  getViewportScrollLeft() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    const isAlwaysShowHorizontalScroll = this.gos.get("alwaysShowHorizontalScroll");
    return isAlwaysShowHorizontalScroll || _isHorizontalScrollShowing(this.eViewport);
  }
  setHorizontalScroll(offset) {
    this.comp.setHorizontalScroll(offset);
  }
  getHScrollPosition() {
    const res = {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
    return res;
  }
  setCenterViewportScrollLeft(value) {
    _setScrollLeft(this.eViewport, value, this.enableRtl);
  }
  isContainerVisible() {
    const pinned = this.options.pinnedType != null;
    return !pinned || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const visible = this.isContainerVisible();
    if (this.visible != visible) {
      this.visible = visible;
      this.onDisplayedRowsChanged();
    }
  }
  onDisplayedRowsChanged(afterScroll = false) {
    const rows = this.options.getRowCtrls(this.beans.rowRenderer);
    if (!this.visible || rows.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const printLayout = _isDomLayout(this.gos, "print");
    const embedFullWidthRows = this.gos.get("embedFullWidthRows");
    const embedFW = embedFullWidthRows || printLayout;
    const rowsThisContainer = rows.filter((rowCtrl) => {
      const fullWidthRow = rowCtrl.isFullWidth();
      const match = this.options.fullWidth ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
      return match;
    });
    this.comp.setRowCtrls({ rowCtrls: rowsThisContainer, useFlushSync: afterScroll });
  }
};

// packages/ag-grid-community/src/gridBodyComp/gridBodyCtrl.ts
var CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
var CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
var CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
var GridBodyCtrl = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.stickyTopHeight = 0;
    this.stickyBottomHeight = 0;
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.colModel = beans.colModel;
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
    this.pinnedRowModel = beans.pinnedRowModel;
    this.filterManager = beans.filterManager;
    this.rowGroupColsSvc = beans.rowGroupColsSvc;
  }
  setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
    this.comp = comp;
    this.eGridBody = eGridBody;
    this.eBodyViewport = eBodyViewport;
    this.eTop = eTop;
    this.eBottom = eBottom;
    this.eStickyTop = eStickyTop;
    this.eStickyBottom = eStickyBottom;
    this.eCenterColsViewport = eBodyViewport.querySelector(
      `.${_getRowContainerOptions("center").viewport}`
    );
    this.eFullWidthContainer = eBodyViewport.querySelector(
      `.${_getRowContainerOptions("fullWidth").container}`
    );
    this.eStickyTopFullWidthContainer = eStickyTop.querySelector(
      `.${_getRowContainerOptions("stickyTopFullWidth").container}`
    );
    this.eStickyBottomFullWidthContainer = eStickyBottom.querySelector(
      `.${_getRowContainerOptions("stickyBottomFullWidth").container}`
    );
    this.setCellTextSelection(this.gos.get("enableCellTextSelection"));
    this.addManagedPropertyListener(
      "enableCellTextSelection",
      (props) => this.setCellTextSelection(props.currentValue)
    );
    this.createManagedBean(new LayoutFeature(this.comp));
    this.scrollFeature = this.createManagedBean(new GridBodyScrollFeature(this.eBodyViewport));
    this.beans.rowDragSvc?.setupRowDrag(this.eBodyViewport, this);
    this.setupRowAnimationCssClass();
    this.addEventListeners();
    this.addFocusListeners([eTop, eBodyViewport, eBottom, eStickyTop, eStickyBottom]);
    this.setGridRootRole();
    this.onGridColumnsChanged();
    this.addBodyViewportListener();
    this.setFloatingHeights();
    this.disableBrowserDragging();
    this.addStopEditingWhenGridLosesFocus();
    this.updateScrollingClasses();
    this.filterManager?.setupAdvFilterHeaderComp(eTop);
    this.ctrlsSvc.register("gridBodyCtrl", this);
  }
  addEventListeners() {
    const setFloatingHeights = this.setFloatingHeights.bind(this);
    const setGridRootRole = this.setGridRootRole.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.updateScrollingClasses.bind(this),
      pinnedRowDataChanged: setFloatingHeights,
      pinnedHeightChanged: setFloatingHeights,
      headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
      columnRowGroupChanged: setGridRootRole,
      columnPivotChanged: setGridRootRole
    });
    this.addManagedPropertyListener("treeData", setGridRootRole);
  }
  onGridColumnsChanged() {
    const columns = this.beans.colModel.getCols();
    this.comp.setColumnCount(columns.length);
  }
  onScrollVisibilityChanged() {
    const { scrollVisibleSvc } = this;
    const visible = scrollVisibleSvc.verticalScrollShowing;
    this.setVerticalScrollPaddingVisible(visible);
    this.setStickyWidth(visible);
    this.setStickyBottomOffsetBottom();
    const scrollbarWidth = visible ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const pad = _isInvisibleScrollbar() ? 16 : 0;
    const width = `calc(100% + ${scrollbarWidth + pad}px)`;
    _requestAnimationFrame(this.beans, () => this.comp.setBodyViewportWidth(width));
    this.updateScrollingClasses();
  }
  setGridRootRole() {
    const { rowGroupColsSvc, colModel } = this;
    let isTreeGrid = this.gos.get("treeData");
    if (!isTreeGrid) {
      const isPivotActive = colModel.isPivotMode();
      const rowGroupColumnLen = !rowGroupColsSvc ? 0 : rowGroupColsSvc.columns.length;
      const columnsNeededForGrouping = isPivotActive ? 2 : 1;
      isTreeGrid = rowGroupColumnLen >= columnsNeededForGrouping;
    }
    this.comp.setGridRootRole(isTreeGrid ? "treegrid" : "grid");
  }
  addFocusListeners(elements) {
    elements.forEach((element) => {
      this.addManagedElementListeners(element, {
        focusin: (e) => {
          const { target } = e;
          const isFocusedElementNested = _isElementChildOfClass(target, "ag-root", element);
          element.classList.toggle("ag-has-focus", !isFocusedElementNested);
        },
        focusout: (e) => {
          const { target, relatedTarget } = e;
          const gridContainRelatedTarget = element.contains(relatedTarget);
          const isNestedRelatedTarget = _isElementChildOfClass(
            relatedTarget,
            "ag-root",
            element
          );
          const isNestedTarget = _isElementChildOfClass(target, "ag-root", element);
          if (isNestedTarget) {
            return;
          }
          if (!gridContainRelatedTarget || isNestedRelatedTarget) {
            element.classList.remove("ag-has-focus");
          }
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(moving) {
    this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
  }
  setCellTextSelection(selectable = false) {
    this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
  }
  updateScrollingClasses() {
    const {
      eGridBody: { classList },
      scrollVisibleSvc
    } = this;
    classList.toggle("ag-body-vertical-content-no-gap", !scrollVisibleSvc.verticalScrollGap);
    classList.toggle("ag-body-horizontal-content-no-gap", !scrollVisibleSvc.horizontalScrollGap);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (event) => {
        if (event.target instanceof HTMLImageElement) {
          event.preventDefault();
          return false;
        }
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    this.beans.editSvc?.addStopEditingWhenGridLosesFocus([
      this.eBodyViewport,
      this.eBottom,
      this.eTop,
      this.eStickyTop,
      this.eStickyBottom
    ]);
  }
  updateRowCount() {
    const headerCount = (this.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) + (this.filterManager?.getHeaderRowCount() ?? 0);
    const { rowModel } = this.beans;
    const rowCount = rowModel.isLastRowIndexKnown() ? rowModel.getRowCount() : -1;
    const total = rowCount === -1 ? -1 : headerCount + rowCount;
    this.comp.setRowCount(total);
  }
  registerBodyViewportResizeListener(listener) {
    this.comp.registerBodyViewportResizeListener(listener);
  }
  setVerticalScrollPaddingVisible(visible) {
    const overflowY = visible ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(overflowY);
  }
  isVerticalScrollShowing() {
    const show = this.gos.get("alwaysShowVerticalScroll");
    const cssClass = show ? CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
    const allowVerticalScroll = _isDomLayout(this.gos, "normal");
    this.comp.setAlwaysVerticalScrollClass(cssClass, show);
    return show || allowVerticalScroll && _isVerticalScrollShowing(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const { rowContainerHeight, environment } = this.beans;
    let initialSizeMeasurementComplete = environment.sizesMeasured;
    const updateAnimationClass = () => {
      const animateRows = initialSizeMeasurementComplete && _isAnimateRows(this.gos) && !rowContainerHeight.stretching;
      const animateRowsCssClass = animateRows ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
    };
    updateAnimationClass();
    this.addManagedEventListeners({ heightScaleChanged: updateAnimationClass });
    this.addManagedPropertyListener("animateRows", updateAnimationClass);
    this.addManagedEventListeners({
      gridStylesChanged: () => {
        if (!initialSizeMeasurementComplete && environment.sizesMeasured) {
          initialSizeMeasurementComplete = true;
          updateAnimationClass();
        }
      }
    });
  }
  addBodyViewportListener() {
    const { popupSvc, touchSvc } = this.beans;
    const listener = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: listener });
    touchSvc?.mockBodyContextMenu(this, listener);
    this.addManagedElementListeners(this.eBodyViewport, {
      wheel: this.onBodyViewportWheel.bind(this, popupSvc)
    });
    this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) });
    this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) });
    this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX, deltaY, shiftKey } = e;
    const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
    if (isHorizontalScroll && _isEventFromThisGrid(this.gos, e)) {
      this.scrollGridBodyToMatchEvent(e);
    }
  }
  onStickyWheel(e) {
    const { deltaX, deltaY, shiftKey } = e;
    const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
    const target = e.target;
    if (!isHorizontalScroll) {
      e.preventDefault();
      this.scrollVertically(deltaY);
    } else if (this.eStickyTopFullWidthContainer.contains(target) || this.eStickyBottomFullWidthContainer.contains(target)) {
      this.scrollGridBodyToMatchEvent(e);
    }
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX, deltaY } = e;
    e.preventDefault();
    this.eCenterColsViewport.scrollBy({ left: deltaX || deltaY });
  }
  onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
    if (!mouseEvent && !touchEvent) {
      return;
    }
    if (this.gos.get("preventDefaultOnContextMenu")) {
      const event = mouseEvent || touchEvent;
      event.preventDefault();
    }
    const { target } = mouseEvent || touch;
    if (target === this.eBodyViewport || target === this.ctrlsSvc.get("center").eViewport) {
      this.beans.contextMenuSvc?.showContextMenu({
        mouseEvent,
        touchEvent,
        value: null,
        anchorToElement: this.eGridBody
      });
    }
  }
  onBodyViewportWheel(popupSvc, e) {
    if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) {
      return;
    }
    if (popupSvc?.hasAnchoredPopup()) {
      e.preventDefault();
    }
  }
  // called by rowDragFeature
  scrollVertically(pixels) {
    const oldScrollPosition = this.eBodyViewport.scrollTop;
    this.scrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
    return this.eBodyViewport.scrollTop - oldScrollPosition;
  }
  setFloatingHeights() {
    const { pinnedRowModel } = this;
    const floatingTopHeight = pinnedRowModel?.getPinnedTopTotalHeight() ?? 0;
    const floatingBottomHeight = pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
    this.comp.setTopHeight(floatingTopHeight);
    this.comp.setBottomHeight(floatingBottomHeight);
    this.comp.setTopDisplay(floatingTopHeight ? "inherit" : "none");
    this.comp.setBottomDisplay(floatingBottomHeight ? "inherit" : "none");
    this.setStickyTopOffsetTop();
    this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(height = 0) {
    this.comp.setStickyTopHeight(`${height}px`);
    this.stickyTopHeight = height;
  }
  setStickyBottomHeight(height = 0) {
    this.comp.setStickyBottomHeight(`${height}px`);
    this.stickyBottomHeight = height;
  }
  setStickyWidth(vScrollVisible) {
    if (!vScrollVisible) {
      this.comp.setStickyTopWidth("100%");
      this.comp.setStickyBottomWidth("100%");
    } else {
      const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
      this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
    }
  }
  setStickyTopOffsetTop() {
    const headerCtrl = this.ctrlsSvc.get("gridHeaderCtrl");
    const headerHeight = headerCtrl.headerHeight + (this.filterManager?.getHeaderHeight() ?? 0);
    const pinnedTopHeight = this.pinnedRowModel?.getPinnedTopTotalHeight() ?? 0;
    let height = 0;
    if (headerHeight > 0) {
      height += headerHeight;
    }
    if (pinnedTopHeight > 0) {
      height += pinnedTopHeight;
    }
    if (height > 0) {
      height += 1;
    }
    this.comp.setStickyTopTop(`${height}px`);
  }
  setStickyBottomOffsetBottom() {
    const { pinnedRowModel, scrollVisibleSvc, comp } = this;
    const pinnedBottomHeight = pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
    const hScrollShowing = scrollVisibleSvc.horizontalScrollShowing;
    const scrollbarWidth = hScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const height = pinnedBottomHeight + scrollbarWidth;
    comp.setStickyBottomBottom(`${height}px`);
  }
};

// packages/ag-grid-community/src/gridBodyComp/abstractFakeScrollComp.ts
var AbstractFakeScrollComp = class extends Component {
  constructor(template, direction) {
    super();
    this.direction = direction;
    this.eViewport = RefPlaceholder;
    this.eContainer = RefPlaceholder;
    this.hideTimeout = 0;
    this.setTemplate(template);
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    });
    this.onScrollVisibilityChanged();
    this.addOrRemoveCssClass("ag-apple-scrollbar", _isMacOsUserAgent() || _isIOSUserAgent());
  }
  destroy() {
    super.destroy();
    window.clearTimeout(this.hideTimeout);
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.invisibleScrollbar = _isInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.hideAndShowInvisibleScrollAsNeeded();
      this.addActiveListenerToggles();
    }
  }
  addActiveListenerToggles() {
    const eGui = this.getGui();
    const onActivate = () => this.addOrRemoveCssClass("ag-scrollbar-active", true);
    const onDeactivate = () => this.addOrRemoveCssClass("ag-scrollbar-active", false);
    this.addManagedListeners(eGui, {
      mouseenter: onActivate,
      mousedown: onActivate,
      touchstart: onActivate,
      mouseleave: onDeactivate,
      touchend: onDeactivate
    });
  }
  onScrollVisibilityChanged() {
    if (this.invisibleScrollbar === void 0) {
      this.initialiseInvisibleScrollbar();
    }
    _requestAnimationFrame(this.beans, () => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (params) => {
        if (params.direction === this.direction) {
          if (this.hideTimeout) {
            window.clearTimeout(this.hideTimeout);
            this.hideTimeout = 0;
          }
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", true);
        }
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", false);
          this.hideTimeout = 0;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(value) {
    const viewport = this.eViewport;
    _waitUntil(
      () => _isVisible(viewport),
      () => this.setScrollPosition(value),
      100
    );
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
};

// packages/ag-grid-community/src/gridBodyComp/fakeHScrollComp.ts
var FakeHScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
      "horizontal"
    );
    this.eLeftSpacer = RefPlaceholder;
    this.eRightSpacer = RefPlaceholder;
    this.setScrollVisibleDebounce = 0;
  }
  wireBeans(beans) {
    this.visibleCols = beans.visibleCols;
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
  }
  postConstruct() {
    super.postConstruct();
    const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: spacerWidthsListener,
      displayedColumnsWidthChanged: spacerWidthsListener,
      pinnedRowDataChanged: this.refreshCompBottom.bind(this)
    });
    this.addManagedPropertyListener("domLayout", spacerWidthsListener);
    this.beans.ctrlsSvc.register("fakeHScrollComp", this);
    this.createManagedBean(new CenterWidthFeature((width) => this.eContainer.style.width = `${width}px`));
    this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  destroy() {
    window.clearTimeout(this.setScrollVisibleDebounce);
    super.destroy();
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.enableRtl = this.gos.get("enableRtl");
    super.initialiseInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.refreshCompBottom();
    }
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar) {
      return;
    }
    const bottomPinnedHeight = this.beans.pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
    this.getGui().style.bottom = `${bottomPinnedHeight}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged();
    this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const vScrollShowing = this.scrollVisibleSvc.verticalScrollShowing;
    let rightSpacing = this.visibleCols.getDisplayedColumnsRightWidth();
    const scrollOnRight = !this.enableRtl && vScrollShowing;
    const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
    if (scrollOnRight) {
      rightSpacing += scrollbarWidth;
    }
    _setFixedWidth(this.eRightSpacer, rightSpacing);
    this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
    let leftSpacing = this.visibleCols.getColsLeftWidth();
    const scrollOnLeft = this.enableRtl && vScrollShowing;
    if (scrollOnLeft) {
      leftSpacing += scrollbarWidth;
    }
    _setFixedWidth(this.eLeftSpacer, leftSpacing);
    this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
  }
  setScrollVisible() {
    const hScrollShowing = this.scrollVisibleSvc.horizontalScrollShowing;
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const isSuppressHorizontalScroll = this.gos.get("suppressHorizontalScroll");
    const scrollbarWidth = hScrollShowing ? this.scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
    const apply = () => {
      this.setScrollVisibleDebounce = 0;
      this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
      _setFixedHeight(this.getGui(), scrollContainerSize);
      _setFixedHeight(this.eViewport, scrollContainerSize);
      _setFixedHeight(this.eContainer, scrollContainerSize);
      this.setDisplayed(hScrollShowing, { skipAriaHidden: true });
    };
    window.clearTimeout(this.setScrollVisibleDebounce);
    if (!hScrollShowing) {
      apply();
    } else {
      this.setScrollVisibleDebounce = window.setTimeout(apply, 100);
    }
  }
  getScrollPosition() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  setScrollPosition(value) {
    if (!_isVisible(this.eViewport)) {
      this.attemptSettingScrollPosition(value);
    }
    _setScrollLeft(this.eViewport, value, this.enableRtl);
  }
};
var FakeHScrollSelector = {
  selector: "AG-FAKE-HORIZONTAL-SCROLL",
  component: FakeHScrollComp
};

// packages/ag-grid-community/src/gridBodyComp/fakeVScrollComp.ts
var FakeVScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
      "vertical"
    );
  }
  postConstruct() {
    super.postConstruct();
    this.createManagedBean(new SetHeightFeature(this.eContainer));
    const { ctrlsSvc } = this.beans;
    ctrlsSvc.register("fakeVScrollComp", this);
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, ctrlsSvc)
    });
  }
  setScrollVisible() {
    const { scrollVisibleSvc } = this.beans;
    const vScrollShowing = scrollVisibleSvc.verticalScrollShowing;
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const scrollbarWidth = vScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
    _setFixedWidth(this.getGui(), adjustedScrollbarWidth);
    _setFixedWidth(this.eViewport, adjustedScrollbarWidth);
    _setFixedWidth(this.eContainer, adjustedScrollbarWidth);
    this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
  }
  onRowContainerHeightChanged(ctrlsSvc) {
    const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
    const gridBodyViewportEl = gridBodyCtrl.eBodyViewport;
    const eViewportScrollTop = this.getScrollPosition();
    const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
    if (eViewportScrollTop != gridBodyViewportScrollTop) {
      this.setScrollPosition(gridBodyViewportScrollTop, true);
    }
  }
  getScrollPosition() {
    return this.eViewport.scrollTop;
  }
  setScrollPosition(value, force) {
    if (!force && !_isVisible(this.eViewport)) {
      this.attemptSettingScrollPosition(value);
    }
    this.eViewport.scrollTop = value;
  }
};
var FakeVScrollSelector = {
  selector: "AG-FAKE-VERTICAL-SCROLL",
  component: FakeVScrollComp
};

// packages/ag-grid-community/src/headerRendering/headerUtils.ts
function getHeaderRowCount(colModel) {
  return colModel.cols ? colModel.cols.treeDepth + 1 : -1;
}
function getFocusHeaderRowCount(beans) {
  return beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0;
}
function getGroupRowsHeight(beans) {
  const heights = [];
  const headerRowContainerCtrls = beans.ctrlsSvc.getHeaderRowContainerCtrls();
  for (const headerRowContainerCtrl of headerRowContainerCtrls) {
    if (!headerRowContainerCtrl) {
      continue;
    }
    const groupRowCount = headerRowContainerCtrl.getGroupRowCount() || 0;
    for (let i = 0; i < groupRowCount; i++) {
      const headerRowCtrl = headerRowContainerCtrl.getGroupRowCtrlAtIndex(i);
      const currentHeightAtPos = heights[i];
      if (headerRowCtrl) {
        const newHeight = getColumnGroupHeaderRowHeight(beans, headerRowCtrl);
        if (currentHeightAtPos == null || newHeight > currentHeightAtPos) {
          heights[i] = newHeight;
        }
      }
    }
  }
  return heights;
}
function getColumnGroupHeaderRowHeight(beans, headerRowCtrl) {
  const defaultHeight = beans.colModel.isPivotMode() ? getPivotGroupHeaderHeight(beans) : getGroupHeaderHeight(beans);
  let displayedHeights = 0;
  const headerRowCellCtrls = headerRowCtrl.getHeaderCtrls();
  for (const headerCellCtrl of headerRowCellCtrls) {
    const { column } = headerCellCtrl;
    if (column.isAutoHeaderHeight()) {
      const height = column.getAutoHeaderHeight();
      if (height != null && height > displayedHeights) {
        displayedHeights = height;
      }
    }
  }
  return Math.max(defaultHeight, displayedHeights);
}
function getColumnHeaderRowHeight(beans) {
  const defaultHeight = beans.colModel.isPivotMode() ? getPivotHeaderHeight(beans) : getHeaderHeight(beans);
  const allDisplayedCols = beans.visibleCols.allCols;
  const displayedHeights = allDisplayedCols.filter((col) => col.isAutoHeaderHeight()).map((col) => col.getAutoHeaderHeight() || 0);
  return Math.max(defaultHeight, ...displayedHeights);
}
function getHeaderHeight(beans) {
  return beans.gos.get("headerHeight") ?? beans.environment.getDefaultHeaderHeight();
}
function getFloatingFiltersHeight(beans) {
  return beans.gos.get("floatingFiltersHeight") ?? getHeaderHeight(beans);
}
function getGroupHeaderHeight(beans) {
  return beans.gos.get("groupHeaderHeight") ?? getHeaderHeight(beans);
}
function getPivotHeaderHeight(beans) {
  return beans.gos.get("pivotHeaderHeight") ?? getHeaderHeight(beans);
}
function getPivotGroupHeaderHeight(beans) {
  return beans.gos.get("pivotGroupHeaderHeight") ?? getGroupHeaderHeight(beans);
}

// packages/ag-grid-community/src/headerRendering/gridHeaderCtrl.ts
var GridHeaderCtrl = class extends BeanStub {
  setComp(comp, eGui, eFocusableElement) {
    this.comp = comp;
    this.eGui = eGui;
    const { beans } = this;
    const { headerNavigation, touchSvc, ctrlsSvc } = beans;
    if (headerNavigation) {
      this.createManagedBean(
        new ManagedFocusFeature(eFocusableElement, {
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusOut: this.onFocusOut.bind(this)
        })
      );
    }
    this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this, beans),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, beans)
    });
    this.onPivotModeChanged(beans);
    this.setupHeaderHeight();
    const listener = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: listener });
    touchSvc?.mockHeaderContextMenu(this, listener);
    ctrlsSvc.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const listener = this.setHeaderHeight.bind(this);
    listener();
    this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      listener
    );
    this.addManagedEventListeners({
      displayedColumnsChanged: listener,
      columnHeaderHeightChanged: listener,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => _requestAnimationFrame(this.beans, () => listener()),
      gridStylesChanged: listener,
      advancedFilterEnabledChanged: listener
    });
  }
  setHeaderHeight() {
    const { beans } = this;
    let totalHeaderHeight = 0;
    const groupHeight = getGroupRowsHeight(beans).reduce((prev, curr) => prev + curr, 0);
    const headerHeight = getColumnHeaderRowHeight(beans);
    if (beans.filterManager?.hasFloatingFilters()) {
      totalHeaderHeight += getFloatingFiltersHeight(beans);
    }
    totalHeaderHeight += groupHeight;
    totalHeaderHeight += headerHeight;
    if (this.headerHeight === totalHeaderHeight) {
      return;
    }
    this.headerHeight = totalHeaderHeight;
    const px = `${totalHeaderHeight + 1}px`;
    this.comp.setHeightAndMinHeight(px);
    this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged(beans) {
    const pivotMode = beans.colModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", pivotMode);
    this.comp.addOrRemoveCssClass("ag-pivot-off", !pivotMode);
  }
  onDisplayedColumnsChanged(beans) {
    const columns = beans.visibleCols.allCols;
    const shouldAllowOverflow = columns.some((col) => col.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", shouldAllowOverflow);
  }
  onTabKeyDown(e) {
    const isRtl = this.gos.get("enableRtl");
    const backwards = e.shiftKey;
    const direction = backwards !== isRtl ? "LEFT" : "RIGHT";
    const { beans } = this;
    const { headerNavigation, focusSvc } = beans;
    if (headerNavigation.navigateHorizontally(direction, true, e) || !backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards, true)) {
      e.preventDefault();
    }
  }
  handleKeyDown(e) {
    let direction = null;
    const { headerNavigation } = this.beans;
    switch (e.key) {
      case KeyCode.LEFT:
        direction = "LEFT";
      case KeyCode.RIGHT: {
        if (!_exists(direction)) {
          direction = "RIGHT";
        }
        if (headerNavigation.navigateHorizontally(direction, false, e)) {
          e.preventDefault();
        }
        break;
      }
      case KeyCode.UP:
        direction = "UP";
      case KeyCode.DOWN: {
        if (!_exists(direction)) {
          direction = "DOWN";
        }
        if (headerNavigation.navigateVertically(direction, null, e)) {
          e.preventDefault();
        }
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget } = e;
    const { eGui, beans } = this;
    if (!relatedTarget && eGui.contains(_getActiveDomElement(beans))) {
      return;
    }
    if (!eGui.contains(relatedTarget)) {
      beans.focusSvc.focusedHeader = null;
    }
  }
  onHeaderContextMenu(mouseEvent, touch, touchEvent) {
    const { menuSvc, ctrlsSvc } = this.beans;
    if (!mouseEvent && !touchEvent || !menuSvc?.isHeaderContextMenuEnabled()) {
      return;
    }
    const { target } = mouseEvent ?? touch;
    if (target === this.eGui || target === ctrlsSvc.getHeaderRowContainerCtrl()?.eViewport) {
      menuSvc.showHeaderContextMenu(void 0, mouseEvent, touchEvent);
    }
  }
};

// packages/ag-grid-community/src/headerRendering/cells/abstractCell/abstractHeaderCellComp.ts
var AbstractHeaderCellComp = class extends Component {
  constructor(template, ctrl) {
    super(template);
    this.ctrl = ctrl;
  }
  getCtrl() {
    return this.ctrl;
  }
};

// packages/ag-grid-community/src/headerRendering/cells/column/headerCellComp.ts
var HeaderCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(
      /* html */
      `<div class="ag-header-cell" role="columnheader">
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div data-ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`,
      ctrl
    );
    this.eResize = RefPlaceholder;
    this.eHeaderCompWrapper = RefPlaceholder;
    this.headerCompVersion = 0;
  }
  postConstruct() {
    const eGui = this.getGui();
    const setAttribute = (name, value) => {
      if (value != null && value != "") {
        eGui.setAttribute(name, value);
      } else {
        eGui.removeAttribute(name);
      }
    };
    setAttribute("col-id", this.ctrl.column.getColId());
    const compProxy = {
      setWidth: (width) => eGui.style.width = width,
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setAriaSort: (sort) => sort ? _setAriaSort(eGui, sort) : _removeAriaSort(eGui),
      setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0);
    const selectAllGui = this.ctrl.getSelectAllGui();
    if (selectAllGui) {
      this.eResize.insertAdjacentElement("afterend", selectAllGui);
    }
  }
  destroy() {
    this.destroyHeaderComp();
    super.destroy();
  }
  destroyHeaderComp() {
    if (this.headerComp) {
      this.eHeaderCompWrapper.removeChild(this.headerCompGui);
      this.headerComp = this.destroyBean(this.headerComp);
      this.headerCompGui = void 0;
    }
  }
  setUserCompDetails(compDetails) {
    this.headerCompVersion++;
    const versionCopy = this.headerCompVersion;
    compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
  }
  afterCompCreated(version, headerComp) {
    if (version != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(headerComp);
      return;
    }
    this.destroyHeaderComp();
    this.headerComp = headerComp;
    this.headerCompGui = headerComp.getGui();
    this.eHeaderCompWrapper.appendChild(this.headerCompGui);
    this.ctrl.setDragSource(this.getGui());
  }
};

// packages/ag-grid-community/src/headerRendering/cells/columnGroup/headerGroupCellComp.ts
var HeaderGroupCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(
      /* html */
      `<div class="ag-header-group-cell" role="columnheader">
            <div data-ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`,
      ctrl
    );
    this.eResize = RefPlaceholder;
    this.eHeaderCompWrapper = RefPlaceholder;
  }
  postConstruct() {
    const eGui = this.getGui();
    const setAttribute = (key, value) => value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
    eGui.setAttribute("col-id", this.ctrl.column.getUniqueId());
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setHeaderWrapperHidden: (hidden) => {
        if (hidden) {
          this.eHeaderCompWrapper.style.setProperty("display", "none");
        } else {
          this.eHeaderCompWrapper.style.removeProperty("display");
        }
      },
      setHeaderWrapperMaxHeight: (value) => {
        if (value != null) {
          this.eHeaderCompWrapper.style.setProperty("max-height", `${value}px`);
        } else {
          this.eHeaderCompWrapper.style.removeProperty("max-height");
        }
        this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", value != null);
      },
      setResizableDisplayed: (displayed) => _setDisplayed(this.eResize, displayed),
      setWidth: (width) => eGui.style.width = width,
      setAriaExpanded: (expanded) => setAttribute("aria-expanded", expanded),
      setUserCompDetails: (details) => this.setUserCompDetails(details),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(compProxy, eGui, this.eResize, this.eHeaderCompWrapper, void 0);
  }
  setUserCompDetails(details) {
    details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
  }
  afterHeaderCompCreated(headerGroupComp) {
    const destroyFunc = () => this.destroyBean(headerGroupComp);
    if (!this.isAlive()) {
      destroyFunc();
      return;
    }
    const eGui = this.getGui();
    const eHeaderGroupGui = headerGroupComp.getGui();
    this.eHeaderCompWrapper.appendChild(eHeaderGroupGui);
    this.addDestroyFunc(destroyFunc);
    this.headerGroupComp = headerGroupComp;
    this.ctrl.setDragSource(eGui);
  }
  addOrRemoveHeaderWrapperStyle(style, value) {
    const { eHeaderCompWrapper } = this;
    if (value) {
      eHeaderCompWrapper.style.setProperty(style, value);
    } else {
      eHeaderCompWrapper.style.removeProperty(style);
    }
  }
};

// packages/ag-grid-community/src/headerRendering/cells/floatingFilter/headerFilterCellComp.ts
var HeaderFilterCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(
      /* html */
      `<div class="ag-header-cell ag-floating-filter" role="gridcell">
            <div data-ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" data-ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" data-ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`,
      ctrl
    );
    this.eFloatingFilterBody = RefPlaceholder;
    this.eButtonWrapper = RefPlaceholder;
    this.eButtonShowMainFilter = RefPlaceholder;
  }
  postConstruct() {
    const eGui = this.getGui();
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
      setButtonWrapperDisplayed: (displayed) => _setDisplayed(this.eButtonWrapper, displayed),
      setCompDetails: (compDetails) => this.setCompDetails(compDetails),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (width) => eGui.style.width = width,
      setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon)
    };
    this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
  }
  setCompDetails(compDetails) {
    if (!compDetails) {
      this.destroyFloatingFilterComp();
      this.compPromise = null;
      return;
    }
    this.compPromise = compDetails.newAgStackInstance();
    this.compPromise.then((comp) => this.afterCompCreated(comp));
  }
  destroy() {
    this.destroyFloatingFilterComp();
    super.destroy();
  }
  destroyFloatingFilterComp() {
    if (this.floatingFilterComp) {
      this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
      this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
    }
  }
  afterCompCreated(comp) {
    if (!comp) {
      return;
    }
    if (!this.isAlive()) {
      this.destroyBean(comp);
      return;
    }
    this.destroyFloatingFilterComp();
    this.floatingFilterComp = comp;
    this.eFloatingFilterBody.appendChild(comp.getGui());
    if (comp.afterGuiAttached) {
      comp.afterGuiAttached();
    }
  }
};

// packages/ag-grid-community/src/headerRendering/row/headerRowComp.ts
var HeaderRowComp = class extends Component {
  constructor(ctrl) {
    super();
    this.headerComps = {};
    this.ctrl = ctrl;
    this.setTemplate(
      /* html */
      `<div class="${this.ctrl.headerRowClass}" role="row"></div>`
    );
  }
  postConstruct() {
    _setAriaRowIndex(this.getGui(), this.ctrl.getAriaRowIndex());
    const compProxy = {
      setHeight: (height) => this.getGui().style.height = height,
      setTop: (top) => this.getGui().style.top = top,
      setHeaderCtrls: (ctrls, forceOrder) => this.setHeaderCtrls(ctrls, forceOrder),
      setWidth: (width) => this.getGui().style.width = width
    };
    this.ctrl.setComp(compProxy, void 0);
  }
  destroy() {
    this.setHeaderCtrls([], false);
    super.destroy();
  }
  setHeaderCtrls(ctrls, forceOrder) {
    if (!this.isAlive()) {
      return;
    }
    const oldComps = this.headerComps;
    this.headerComps = {};
    ctrls.forEach((ctrl) => {
      const id = ctrl.instanceId;
      let comp = oldComps[id];
      delete oldComps[id];
      if (comp == null) {
        comp = this.createHeaderComp(ctrl);
        this.getGui().appendChild(comp.getGui());
      }
      this.headerComps[id] = comp;
    });
    Object.values(oldComps).forEach((comp) => {
      this.getGui().removeChild(comp.getGui());
      this.destroyBean(comp);
    });
    if (forceOrder) {
      const comps = Object.values(this.headerComps);
      comps.sort(
        (a, b) => {
          const leftA = a.getCtrl().column.getLeft();
          const leftB = b.getCtrl().column.getLeft();
          return leftA - leftB;
        }
      );
      const elementsInOrder = comps.map((c) => c.getGui());
      _setDomChildOrder(this.getGui(), elementsInOrder);
    }
  }
  createHeaderComp(headerCtrl) {
    let result;
    switch (this.ctrl.type) {
      case "group":
        result = new HeaderGroupCellComp(headerCtrl);
        break;
      case "filter":
        result = new HeaderFilterCellComp(headerCtrl);
        break;
      default:
        result = new HeaderCellComp(headerCtrl);
        break;
    }
    this.createBean(result);
    result.setParentComponent(this);
    return result;
  }
};

// packages/ag-grid-community/src/rendering/features/setLeftFeature.ts
var SetLeftFeature = class extends BeanStub {
  constructor(columnOrGroup, eCell, beans, colsSpanning) {
    super();
    this.columnOrGroup = columnOrGroup;
    this.eCell = eCell;
    this.colsSpanning = colsSpanning;
    this.columnOrGroup = columnOrGroup;
    this.ariaEl = eCell.querySelector("[role=columnheader]") || eCell;
    this.beans = beans;
  }
  setColsSpanning(colsSpanning) {
    this.colsSpanning = colsSpanning;
    this.onLeftChanged();
  }
  getColumnOrGroup() {
    const { beans, colsSpanning } = this;
    if (beans.gos.get("enableRtl") && colsSpanning) {
      return _last(colsSpanning);
    }
    return this.columnOrGroup;
  }
  postConstruct() {
    const onLeftChanged = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: onLeftChanged });
    this.setLeftFirstTime();
    this.addManagedEventListeners({ displayedColumnsWidthChanged: onLeftChanged });
    this.addManagedPropertyListener("domLayout", onLeftChanged);
  }
  setLeftFirstTime() {
    const { gos, colAnimation } = this.beans;
    const suppressMoveAnimation = gos.get("suppressColumnMoveAnimation");
    const oldLeftExists = _exists(this.columnOrGroup.getOldLeft());
    const animateColumnMove = colAnimation?.isActive() && oldLeftExists && !suppressMoveAnimation;
    if (animateColumnMove) {
      this.animateInLeft();
    } else {
      this.onLeftChanged();
    }
  }
  animateInLeft() {
    const colOrGroup = this.getColumnOrGroup();
    const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getOldLeft());
    const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getLeft());
    this.setLeft(oldActualLeft);
    this.actualLeft = actualLeft;
    this.beans.colAnimation.executeNextVMTurn(() => {
      if (this.actualLeft === actualLeft) {
        this.setLeft(actualLeft);
      }
    });
  }
  onLeftChanged() {
    const colOrGroup = this.getColumnOrGroup();
    const left = colOrGroup.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
    this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(colOrGroup, leftPosition) {
    const { gos, visibleCols } = this.beans;
    const printLayout = _isDomLayout(gos, "print");
    if (!printLayout) {
      return leftPosition;
    }
    if (colOrGroup.getPinned() === "left") {
      return leftPosition;
    }
    const leftWidth = visibleCols.getColsLeftWidth();
    if (colOrGroup.getPinned() === "right") {
      const bodyWidth = visibleCols.bodyWidth;
      return leftWidth + bodyWidth + leftPosition;
    }
    return leftWidth + leftPosition;
  }
  setLeft(value) {
    if (_exists(value)) {
      this.eCell.style.left = `${value}px`;
    }
    if (isColumnGroup2(this.columnOrGroup)) {
      const children = this.columnOrGroup.getLeafColumns();
      if (!children.length) {
        return;
      }
      if (children.length > 1) {
        _setAriaColSpan(this.ariaEl, children.length);
      }
    }
  }
};

// packages/ag-grid-community/src/headerRendering/cells/abstractCell/abstractHeaderCellCtrl.ts
var instanceIdSequence4 = 0;
var DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var AbstractHeaderCellCtrl = class extends BeanStub {
  constructor(column, rowCtrl) {
    super();
    this.column = column;
    this.rowCtrl = rowCtrl;
    this.resizeToggleTimeout = 0;
    this.resizeMultiplier = 1;
    this.resizeFeature = null;
    this.lastFocusEvent = null;
    this.dragSource = null;
    this.instanceId = column.getUniqueId() + "-" + instanceIdSequence4++;
  }
  postConstruct() {
    const refreshTabIndex = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], refreshTabIndex);
    this.addManagedEventListeners({
      overlayExclusiveChanged: refreshTabIndex
    });
  }
  shouldStopEventPropagation(event) {
    const { headerRowIndex, column } = this.beans.focusSvc.focusedHeader;
    const colDef = column.getDefinition();
    const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
    if (!_exists(colDefFunc)) {
      return false;
    }
    const params = this.gos.addGridCommonParams({
      colDef,
      column,
      headerRowIndex,
      event
    });
    return !!colDefFunc(params);
  }
  getWrapperHasFocus() {
    const activeEl = _getActiveDomElement(this.beans);
    return activeEl === this.eGui;
  }
  setGui(eGui, compBean) {
    this.eGui = eGui;
    this.addDomData(compBean);
    compBean.addManagedListeners(this.beans.eventSvc, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    });
    compBean.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    });
    this.onDisplayedColumnsChanged();
    this.refreshTabIndex();
  }
  onGuiFocus() {
    this.eventSvc.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(params) {
    const { wrapperElement, checkMeasuringCallback, compBean } = params;
    const { beans } = this;
    const measureHeight = (timesCalled) => {
      if (!this.isAlive() || !compBean.isAlive()) {
        return;
      }
      const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = _getElementSize(this.eGui);
      const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
      const wrapperHeight = wrapperElement.offsetHeight;
      const autoHeight = wrapperHeight + extraHeight;
      if (timesCalled < 5) {
        const doc = _getDocument(beans);
        const notYetInDom = !doc || !doc.contains(wrapperElement);
        const possiblyNoContentYet = autoHeight == 0;
        if (notYetInDom || possiblyNoContentYet) {
          _requestAnimationFrame(beans, () => measureHeight(timesCalled + 1));
          return;
        }
      }
      this.setColHeaderHeight(this.column, autoHeight);
    };
    let isMeasuring = false;
    let stopResizeObserver;
    const checkMeasuring = () => {
      const newValue = this.column.isAutoHeaderHeight();
      if (newValue && !isMeasuring) {
        startMeasuring();
      }
      if (!newValue && isMeasuring) {
        stopMeasuring();
      }
    };
    const startMeasuring = () => {
      isMeasuring = true;
      measureHeight(0);
      this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", true);
      stopResizeObserver = _observeResize(this.beans, wrapperElement, () => measureHeight(0));
    };
    const stopMeasuring = () => {
      isMeasuring = false;
      if (stopResizeObserver) {
        stopResizeObserver();
      }
      this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", false);
      stopResizeObserver = void 0;
    };
    checkMeasuring();
    compBean.addDestroyFunc(() => stopMeasuring());
    compBean.addManagedListeners(this.column, { widthChanged: () => isMeasuring && measureHeight(0) });
    compBean.addManagedEventListeners({
      sortChanged: () => {
        if (isMeasuring) {
          window.setTimeout(() => measureHeight(0));
        }
      }
    });
    if (checkMeasuringCallback) {
      checkMeasuringCallback(checkMeasuring);
    }
  }
  onDisplayedColumnsChanged() {
    const { comp, column, beans, eGui } = this;
    if (!comp || !column || !eGui) {
      return;
    }
    refreshFirstAndLastStyles(comp, column, beans.visibleCols);
    _setAriaColIndex(eGui, beans.visibleCols.getAriaColIndex(column));
  }
  addResizeAndMoveKeyboardListeners(compBean) {
    compBean.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const suppressHeaderFocus = _isHeaderFocusSuppressed(this.beans);
    if (this.eGui) {
      _addOrRemoveAttribute(this.eGui, "tabindex", suppressHeaderFocus ? null : "-1");
    }
  }
  onGuiKeyDown(e) {
    const activeEl = _getActiveDomElement(this.beans);
    const isLeftOrRight = e.key === KeyCode.LEFT || e.key === KeyCode.RIGHT;
    if (this.isResizing) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    if (
      // if elements within the header are focused, we don't process the event
      activeEl !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
      !e.shiftKey && !e.altKey
    ) {
      return;
    }
    if (this.isResizing || isLeftOrRight) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    if (!isLeftOrRight) {
      return;
    }
    const isLeft = e.key === KeyCode.LEFT !== this.gos.get("enableRtl");
    const direction = isLeft ? "left" : "right";
    if (e.altKey) {
      this.isResizing = true;
      this.resizeMultiplier += 1;
      const diff = this.getViewportAdjustedResizeDiff(e);
      this.resizeHeader(diff, e.shiftKey);
      this.resizeFeature?.toggleColumnResizing(true);
    } else {
      this.moveHeader(direction);
    }
  }
  moveHeader(hDirection) {
    this.beans.colMoves?.moveHeader(hDirection, this.eGui, this.column, this.rowCtrl.pinned, this);
  }
  getViewportAdjustedResizeDiff(e) {
    const diff = this.getResizeDiff(e);
    const { pinnedCols } = this.beans;
    return pinnedCols ? pinnedCols.getHeaderResizeDiff(diff, this.column) : diff;
  }
  getResizeDiff(e) {
    const { gos, column } = this;
    let isLeft = e.key === KeyCode.LEFT !== gos.get("enableRtl");
    const pinned = column.getPinned();
    const isRtl = gos.get("enableRtl");
    if (pinned) {
      if (isRtl !== (pinned === "right")) {
        isLeft = !isLeft;
      }
    }
    return (isLeft ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    if (!this.isResizing) {
      return;
    }
    if (this.resizeToggleTimeout) {
      window.clearTimeout(this.resizeToggleTimeout);
      this.resizeToggleTimeout = 0;
    }
    this.isResizing = false;
    this.resizeMultiplier = 1;
    this.resizeToggleTimeout = window.setTimeout(() => {
      this.resizeFeature?.toggleColumnResizing(false);
    }, 150);
  }
  handleKeyDown(e) {
    const wrapperHasFocus = this.getWrapperHasFocus();
    switch (e.key) {
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (wrapperHasFocus) {
          e.preventDefault();
        }
    }
  }
  addDomData(compBean) {
    const key = DOM_DATA_KEY_HEADER_CTRL;
    const { eGui, gos } = this;
    _setDomData(gos, eGui, key, this);
    compBean.addDestroyFunc(() => _setDomData(gos, eGui, key, null));
  }
  focus(event) {
    const { eGui } = this;
    if (!eGui) {
      return false;
    }
    this.lastFocusEvent = event || null;
    eGui.focus();
    return true;
  }
  focusThis() {
    this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
  }
  removeDragSource() {
    if (this.dragSource) {
      this.beans.dragAndDrop?.removeDragSource(this.dragSource);
      this.dragSource = null;
    }
  }
  handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
    const event = mouseEvent ?? touchEvent;
    const { menuSvc, gos } = this.beans;
    if (gos.get("preventDefaultOnContextMenu")) {
      event.preventDefault();
    }
    if (menuSvc?.isHeaderContextMenuEnabled(column)) {
      menuSvc.showHeaderContextMenu(column, mouseEvent, touchEvent);
    }
    this.dispatchColumnMouseEvent("columnHeaderContextMenu", column);
  }
  dispatchColumnMouseEvent(eventType, column) {
    this.eventSvc.dispatchEvent({
      type: eventType,
      column
    });
  }
  setColHeaderHeight(col, height) {
    if (!col.setAutoHeaderHeight(height)) {
      return;
    }
    const { eventSvc } = this;
    if (col.isColumn) {
      eventSvc.dispatchEvent({
        type: "columnHeaderHeightChanged",
        column: col,
        columns: [col],
        source: "autosizeColumnHeaderHeight"
      });
    } else {
      eventSvc.dispatchEvent({
        type: "columnGroupHeaderHeightChanged",
        columnGroup: col,
        source: "autosizeColumnGroupHeaderHeight"
      });
    }
  }
  clearComponent() {
    this.removeDragSource();
    this.resizeFeature = null;
    this.comp = null;
    this.eGui = null;
  }
  destroy() {
    super.destroy();
    this.column = null;
    this.lastFocusEvent = null;
    this.rowCtrl = null;
  }
};

// packages/ag-grid-community/src/headerRendering/cells/column/headerCellCtrl.ts
var HeaderCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor() {
    super(...arguments);
    this.refreshFunctions = {};
    this.userHeaderClasses = /* @__PURE__ */ new Set();
    this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
  }
  setComp(comp, eGui, eResize, eHeaderCompWrapper, compBeanInput) {
    this.comp = comp;
    const { colResize, context, colHover } = this.beans;
    const compBean = setupCompBean(this, context, compBeanInput);
    this.setGui(eGui, compBean);
    this.updateState();
    this.setupWidth(compBean);
    this.setupMovingCss(compBean);
    this.setupMenuClass(compBean);
    this.setupSortableClass(compBean);
    this.setupWrapTextClass();
    this.refreshSpanHeaderHeight();
    this.setupAutoHeight({
      wrapperElement: eHeaderCompWrapper,
      checkMeasuringCallback: (checkMeasuring) => this.setRefreshFunction("measuring", checkMeasuring),
      compBean
    });
    this.addColumnHoverListener(compBean);
    this.setupFilterClass(compBean);
    this.setupClassesFromColDef();
    this.setupTooltip();
    this.addActiveHeaderMouseListeners(compBean);
    this.setupSelectAll(compBean);
    this.setupUserComp();
    this.refreshAria();
    if (colResize) {
      this.resizeFeature = compBean.createManagedBean(
        colResize.createResizeFeature(this.rowCtrl.pinned, this.column, eResize, comp, this)
      );
    } else {
      _setDisplayed(eResize, false);
    }
    colHover?.createHoverFeature(compBean, [this.column], eGui);
    compBean.createManagedBean(new SetLeftFeature(this.column, eGui, this.beans));
    compBean.createManagedBean(
      new ManagedFocusFeature(eGui, {
        shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    );
    this.addResizeAndMoveKeyboardListeners(compBean);
    compBean.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"],
      () => this.refresh()
    );
    compBean.addManagedListeners(this.column, { colDefChanged: () => this.refresh() });
    compBean.addManagedListeners(this.column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const listener = () => this.checkDisplayName();
    compBean.addManagedEventListeners({
      columnValueChanged: listener,
      columnRowGroupChanged: listener,
      columnPivotChanged: listener,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
    compBean.addDestroyFunc(() => {
      this.refreshFunctions = {};
      this.selectAllFeature = null;
      this.dragSourceElement = void 0;
      this.userCompDetails = null;
      this.userHeaderClasses.clear();
      this.ariaDescriptionProperties.clear();
      this.clearComponent();
    });
  }
  resizeHeader(delta, shiftKey) {
    this.beans.colResize?.resizeHeader(this.column, delta, shiftKey);
  }
  setupUserComp() {
    const compDetails = this.lookupUserCompDetails();
    if (compDetails) {
      this.setCompDetails(compDetails);
    }
  }
  setCompDetails(compDetails) {
    this.userCompDetails = compDetails;
    this.comp.setUserCompDetails(compDetails);
  }
  lookupUserCompDetails() {
    const params = this.createParams();
    const colDef = this.column.getColDef();
    return _getHeaderCompDetails(this.beans.userCompFactory, colDef, params);
  }
  createParams() {
    const { menuSvc, sortSvc, colFilter, gos } = this.beans;
    const params = gos.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && !!menuSvc?.isHeaderFilterButtonEnabled(this.column),
      enableFilterIcon: !!colFilter && (!this.openFilterEnabled || _isLegacyMenuEnabled(this.gos)),
      showColumnMenu: (buttonElement) => {
        menuSvc?.showColumnMenu({
          column: this.column,
          buttonElement,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (mouseEvent) => {
        menuSvc?.showColumnMenu({
          column: this.column,
          mouseEvent,
          positionBy: "mouse"
        });
      },
      showFilter: (buttonElement) => {
        menuSvc?.showFilterMenu({
          column: this.column,
          buttonElement,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (multiSort) => {
        sortSvc?.progressSort(this.column, !!multiSort, "uiColumnSorted");
      },
      setSort: (sort, multiSort) => {
        sortSvc?.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
      },
      eGridHeader: this.eGui,
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.setupTooltip(value, shouldDisplayTooltip);
      }
    });
    return params;
  }
  setupSelectAll(compBean) {
    const { selectionSvc } = this.beans;
    if (!selectionSvc) {
      return;
    }
    this.selectAllFeature = compBean.createManagedBean(selectionSvc.createSelectAllFeature(this.column));
    this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature?.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    if (e.key === KeyCode.SPACE) {
      this.selectAllFeature?.onSpaceKeyDown(e);
    }
    if (e.key === KeyCode.ENTER) {
      this.onEnterKeyDown(e);
    }
    if (e.key === KeyCode.DOWN && e.altKey) {
      this.showMenuOnKeyPress(e, false);
    }
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey) {
      this.showMenuOnKeyPress(e, true);
    } else if (this.sortable) {
      this.beans.sortSvc?.progressSort(this.column, e.shiftKey, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, isFilterShortcut) {
    const headerComp = this.comp.getUserCompInstance();
    if (!isHeaderComp(headerComp)) {
      return;
    }
    if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) {
      e.preventDefault();
    }
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      this.focusThis();
      this.announceAriaDescription();
    }
    if (_isKeyboardMode()) {
      this.setActiveHeader(true);
    }
  }
  onFocusOut(e) {
    if (this.eGui.contains(e.relatedTarget)) {
      return;
    }
    this.setActiveHeader(false);
  }
  setupTooltip(value, shouldDisplayTooltip) {
    this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  setupClassesFromColDef() {
    const refreshHeaderClasses = () => {
      const colDef = this.column.getColDef();
      const classes = _getHeaderClassesFromColDef(colDef, this.gos, this.column, null);
      const oldClasses = this.userHeaderClasses;
      this.userHeaderClasses = new Set(classes);
      classes.forEach((c) => {
        if (oldClasses.has(c)) {
          oldClasses.delete(c);
        } else {
          this.comp.addOrRemoveCssClass(c, true);
        }
      });
      oldClasses.forEach((c) => this.comp.addOrRemoveCssClass(c, false));
    };
    this.setRefreshFunction("headerClasses", refreshHeaderClasses);
    refreshHeaderClasses();
  }
  setDragSource(eSource) {
    this.dragSourceElement = eSource;
    this.removeDragSource();
    if (!eSource || !this.draggable) {
      return;
    }
    this.dragSource = this.beans.colMoves?.setDragSourceForHeader(eSource, this.column, this.displayName) ?? null;
  }
  updateState() {
    const { menuSvc } = this.beans;
    this.menuEnabled = !!menuSvc?.isColumnMenuInHeaderEnabled(this.column);
    this.openFilterEnabled = !!menuSvc?.isFilterMenuInHeaderEnabled(this.column);
    this.sortable = this.column.isSortable();
    this.displayName = this.calculateDisplayName();
    this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(name, func) {
    this.refreshFunctions[name] = func;
  }
  refresh() {
    this.updateState();
    this.refreshHeaderComp();
    this.refreshAria();
    Object.values(this.refreshFunctions).forEach((f) => f());
  }
  refreshHeaderComp() {
    const newCompDetails = this.lookupUserCompDetails();
    if (!newCompDetails) {
      return;
    }
    const compInstance = this.comp.getUserCompInstance();
    const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
    const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
    if (headerCompRefreshed) {
      this.setDragSource(this.dragSourceElement);
    } else {
      this.setCompDetails(newCompDetails);
    }
  }
  attemptHeaderCompRefresh(params) {
    const headerComp = this.comp.getUserCompInstance();
    if (!headerComp) {
      return false;
    }
    if (!headerComp.refresh) {
      return false;
    }
    const res = headerComp.refresh(params);
    return res;
  }
  calculateDisplayName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "header", true);
  }
  checkDisplayName() {
    if (this.displayName !== this.calculateDisplayName()) {
      this.refresh();
    }
  }
  workOutDraggable() {
    const colDef = this.column.getColDef();
    const isSuppressMovableColumns = this.gos.get("suppressMovableColumns");
    const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
    return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
  }
  setupWidth(compBean) {
    const listener = () => {
      const columnWidth = this.column.getActualWidth();
      this.comp.setWidth(`${columnWidth}px`);
    };
    compBean.addManagedListeners(this.column, { widthChanged: listener });
    listener();
  }
  setupMovingCss(compBean) {
    const listener = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    compBean.addManagedListeners(this.column, { movingChanged: listener });
    listener();
  }
  setupMenuClass(compBean) {
    const listener = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    compBean.addManagedListeners(this.column, { menuVisibleChanged: listener });
    listener();
  }
  setupSortableClass(compBean) {
    const updateSortableCssClass = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    updateSortableCssClass();
    this.setRefreshFunction("updateSortable", updateSortableCssClass);
    compBean.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(compBean) {
    const listener = () => {
      const isFilterActive = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", isFilterActive);
      this.refreshAria();
    };
    compBean.addManagedListeners(this.column, { filterActiveChanged: listener });
    listener();
  }
  setupWrapTextClass() {
    const listener = () => {
      const wrapText = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", wrapText);
    };
    listener();
    this.setRefreshFunction("wrapText", listener);
  }
  onHeaderHighlightChanged() {
    const highlighted = this.column.getHighlighted();
    const beforeOn = highlighted === 0 /* Before */;
    const afterOn = highlighted === 1 /* After */;
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", beforeOn);
    this.comp.addOrRemoveCssClass("ag-header-highlight-after", afterOn);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged();
    if (!this.isAlive()) {
      return;
    }
    this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui, column, comp, beans } = this;
    const groupHeaderHeight = getGroupRowsHeight(this.beans);
    const isZeroGroupHeight = groupHeaderHeight.reduce((total, next) => total += next, 0) === 0;
    comp.addOrRemoveCssClass("ag-header-parent-hidden", isZeroGroupHeight);
    if (!column.isSpanHeaderHeight()) {
      eGui.style.removeProperty("top");
      eGui.style.removeProperty("height");
      comp.addOrRemoveCssClass("ag-header-span-height", false);
      comp.addOrRemoveCssClass("ag-header-span-total", false);
      return;
    }
    const { numberOfParents, isSpanningTotal } = this.column.getColumnGroupPaddingInfo();
    comp.addOrRemoveCssClass("ag-header-span-height", numberOfParents > 0);
    const headerHeight = getColumnHeaderRowHeight(beans);
    if (numberOfParents === 0) {
      comp.addOrRemoveCssClass("ag-header-span-total", false);
      eGui.style.setProperty("top", `0px`);
      eGui.style.setProperty("height", `${headerHeight}px`);
      return;
    }
    comp.addOrRemoveCssClass("ag-header-span-total", isSpanningTotal);
    let extraHeight = 0;
    for (let i = 0; i < numberOfParents; i++) {
      extraHeight += groupHeaderHeight[groupHeaderHeight.length - 1 - i];
    }
    eGui.style.setProperty("top", `${-extraHeight}px`);
    eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const translate = this.getLocaleTextFunc();
      const sort = this.beans.sortSvc?.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(_getAriaSortState(sort));
      this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort"));
    } else {
      this.comp.setAriaSort();
      this.setAriaDescriptionProperty("sort", null);
    }
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const translate = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else {
      this.setAriaDescriptionProperty("menu", null);
    }
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !_isLegacyMenuEnabled(this.gos)) {
      const translate = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        translate("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else {
      this.setAriaDescriptionProperty("filterButton", null);
    }
  }
  refreshAriaFiltered() {
    const translate = this.getLocaleTextFunc();
    const isFilterActive = this.column.isFilterActive();
    if (isFilterActive) {
      this.setAriaDescriptionProperty("filter", translate("ariaColumnFiltered", "Column Filtered"));
    } else {
      this.setAriaDescriptionProperty("filter", null);
    }
  }
  setAriaDescriptionProperty(property, value) {
    if (value != null) {
      this.ariaDescriptionProperties.set(property, value);
    } else {
      this.ariaDescriptionProperties.delete(property);
    }
  }
  announceAriaDescription() {
    if (!this.eGui.contains(_getActiveDomElement(this.beans))) {
      return;
    }
    const ariaDescription = Array.from(this.ariaDescriptionProperties.keys()).sort((a, b) => a === "filter" ? -1 : b.charCodeAt(0) - a.charCodeAt(0)).map((key) => this.ariaDescriptionProperties.get(key)).join(". ");
    this.beans.ariaAnnounce?.announceValue(ariaDescription, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort();
    this.refreshAriaMenu();
    this.refreshAriaFilterButton();
    this.refreshAriaFiltered();
  }
  addColumnHoverListener(compBean) {
    this.beans.colHover?.addHeaderColumnHoverListener(compBean, this.comp, this.column);
  }
  addActiveHeaderMouseListeners(compBean) {
    const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
    const clickListener = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
    const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column);
    compBean.addManagedListeners(this.eGui, {
      mouseenter: listener,
      mouseleave: listener,
      click: clickListener,
      contextmenu: contextMenuListener
    });
  }
  handleMouseOverChange(isMouseOver) {
    this.setActiveHeader(isMouseOver);
    this.eventSvc.dispatchEvent({
      type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(active) {
    this.comp.addOrRemoveCssClass("ag-header-active", active);
  }
  getAnchorElementForMenu(isFilter) {
    const headerComp = this.comp.getUserCompInstance();
    if (isHeaderComp(headerComp)) {
      return headerComp.getAnchorElementForMenu(isFilter);
    }
    return this.eGui;
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    super.destroy();
  }
};
function isHeaderComp(headerComp) {
  return typeof headerComp.getAnchorElementForMenu === "function" && typeof headerComp.onMenuKeyboardShortcut === "function";
}

// packages/ag-grid-community/src/headerRendering/row/headerRowCtrl.ts
var instanceIdSequence5 = 0;
var HeaderRowCtrl = class extends BeanStub {
  constructor(rowIndex, pinned, type) {
    super();
    this.rowIndex = rowIndex;
    this.pinned = pinned;
    this.type = type;
    this.instanceId = instanceIdSequence5++;
    const typeClass = type == "group" ? `ag-header-row-column-group` : type == "filter" ? `ag-header-row-column-filter` : `ag-header-row-column`;
    this.headerRowClass = `ag-header-row ${typeClass}`;
  }
  postConstruct() {
    this.isPrintLayout = _isDomLayout(this.gos, "print");
    this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    if (!this.comp) {
      return false;
    }
    return this.getHeaderCellCtrls().every((ctrl) => ctrl.eGui != null);
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(comp, compBean, initCompState = true) {
    this.comp = comp;
    compBean = setupCompBean(this, this.beans.context, compBean);
    if (initCompState) {
      this.onRowHeightChanged();
      this.onVirtualColumnsChanged();
    }
    this.setWidth();
    this.addEventListeners(compBean);
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(compBean) {
    const onHeightChanged = this.onRowHeightChanged.bind(this);
    compBean.addManagedEventListeners({
      columnResized: this.setWidth.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: (params) => this.onVirtualColumnsChanged(params.afterScroll),
      columnGroupHeaderHeightChanged: onHeightChanged,
      columnHeaderHeightChanged: onHeightChanged,
      gridStylesChanged: onHeightChanged,
      advancedFilterEnabledChanged: onHeightChanged
    });
    compBean.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this));
    compBean.addManagedPropertyListener("ensureDomOrder", (e) => this.isEnsureDomOrder = e.currentValue);
    compBean.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      onHeightChanged
    );
  }
  getHeaderCellCtrl(column) {
    if (!this.headerCellCtrls) {
      return;
    }
    for (const cellCtrl of this.headerCellCtrls.values()) {
      if (cellCtrl.column === column) {
        return cellCtrl;
      }
    }
    return void 0;
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = _isDomLayout(this.gos, "print");
    this.onVirtualColumnsChanged();
    this.setWidth();
    this.onRowHeightChanged();
  }
  setWidth() {
    const width = this.getWidthForRow();
    this.comp.setWidth(`${width}px`);
  }
  getWidthForRow() {
    const { visibleCols: presentedColsService } = this.beans;
    if (this.isPrintLayout) {
      const pinned = this.pinned != null;
      if (pinned) {
        return 0;
      }
      return presentedColsService.getContainerWidth("right") + presentedColsService.getContainerWidth("left") + presentedColsService.getContainerWidth(null);
    }
    return presentedColsService.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset, rowHeight } = this.getTopAndHeight();
    this.comp.setTop(topOffset + "px");
    this.comp.setHeight(rowHeight + "px");
  }
  getTopAndHeight() {
    const { filterManager } = this.beans;
    const sizes = [];
    const groupHeadersHeight = getGroupRowsHeight(this.beans);
    const headerHeight = getColumnHeaderRowHeight(this.beans);
    sizes.push(...groupHeadersHeight);
    sizes.push(headerHeight);
    if (filterManager?.hasFloatingFilters()) {
      sizes.push(getFloatingFiltersHeight(this.beans));
    }
    let topOffset = 0;
    for (let i = 0; i < this.rowIndex; i++) {
      topOffset += sizes[i];
    }
    const rowHeight = sizes[this.rowIndex];
    return { topOffset, rowHeight };
  }
  onVirtualColumnsChanged(afterScroll = false) {
    const ctrlsToDisplay = this.getHeaderCtrls();
    const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
  }
  getHeaderCtrls() {
    const oldCtrls = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const columns = this.getColumnsInViewport();
    for (const child of columns) {
      this.recycleAndCreateHeaderCtrls(child, oldCtrls);
    }
    const isFocusedAndDisplayed = (ctrl) => {
      const { focusSvc, visibleCols } = this.beans;
      const isFocused = focusSvc.isHeaderWrapperFocused(ctrl);
      if (!isFocused) {
        return false;
      }
      const isDisplayed = visibleCols.isVisible(ctrl.column);
      return isDisplayed;
    };
    if (oldCtrls) {
      for (const [id, oldCtrl] of oldCtrls) {
        const keepCtrl = isFocusedAndDisplayed(oldCtrl);
        if (keepCtrl) {
          this.headerCellCtrls.set(id, oldCtrl);
        } else {
          this.destroyBean(oldCtrl);
        }
      }
    }
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    return Array.from(this.headerCellCtrls?.values() ?? []);
  }
  recycleAndCreateHeaderCtrls(headerColumn, oldCtrls) {
    if (!this.headerCellCtrls) {
      return;
    }
    if (headerColumn.isEmptyGroup()) {
      return;
    }
    const idOfChild = headerColumn.getUniqueId();
    let headerCtrl;
    if (oldCtrls) {
      headerCtrl = oldCtrls.get(idOfChild);
      oldCtrls.delete(idOfChild);
    }
    const forOldColumn = headerCtrl && headerCtrl.column != headerColumn;
    if (forOldColumn) {
      this.destroyBean(headerCtrl);
      headerCtrl = void 0;
    }
    if (headerCtrl == null) {
      switch (this.type) {
        case "filter": {
          headerCtrl = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerFilterCellCtrl",
              true,
              headerColumn,
              this
            )
          );
          break;
        }
        case "group":
          headerCtrl = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerGroupCellCtrl",
              true,
              headerColumn,
              this
            )
          );
          break;
        default:
          headerCtrl = this.createBean(new HeaderCellCtrl(headerColumn, this));
          break;
      }
    }
    this.headerCellCtrls.set(idOfChild, headerCtrl);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null) {
      return [];
    }
    let viewportColumns = [];
    const actualDepth = this.getActualDepth();
    const { colViewport } = this.beans;
    ["left", null, "right"].forEach((pinned) => {
      const items = colViewport.getHeadersToRender(pinned, actualDepth);
      viewportColumns = viewportColumns.concat(items);
    });
    return viewportColumns;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.colViewport.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(column) {
    if (!this.headerCellCtrls) {
      return;
    }
    const allCtrls = this.getHeaderCellCtrls();
    let ctrl;
    if (typeof column === "function") {
      ctrl = allCtrls.find(column);
    } else {
      ctrl = allCtrls.find((ctrl2) => ctrl2.column == column);
    }
    return ctrl;
  }
  focusHeader(column, event) {
    const ctrl = this.findHeaderCellCtrl(column);
    if (!ctrl) {
      return false;
    }
    const focused = ctrl.focus(event);
    return focused;
  }
  destroy() {
    this.headerCellCtrls?.forEach((ctrl) => {
      this.destroyBean(ctrl);
    });
    this.headerCellCtrls = void 0;
    super.destroy();
  }
};

// packages/ag-grid-community/src/headerRendering/rowContainer/headerRowContainerCtrl.ts
var HeaderRowContainerCtrl = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.hidden = false;
    this.includeFloatingFilter = false;
    this.groupsRowCtrls = [];
  }
  setComp(comp, eGui) {
    this.comp = comp;
    this.eViewport = eGui;
    const { pinnedCols, ctrlsSvc, colModel, colMoves, filterManager } = this.beans;
    this.setupCenterWidth();
    pinnedCols?.setupHeaderPinnedWidth(this);
    this.setupDragAndDrop(colMoves, this.eViewport);
    const onDisplayedColsChanged = this.onDisplayedColumnsChanged.bind(this, filterManager);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: onDisplayedColsChanged,
      advancedFilterEnabledChanged: onDisplayedColsChanged
    });
    const headerType = `${typeof this.pinned === "string" ? this.pinned : "center"}Header`;
    ctrlsSvc.register(headerType, this);
    if (colModel.ready) {
      this.refresh();
    }
  }
  getAllCtrls() {
    const res = [...this.groupsRowCtrls];
    if (this.columnsRowCtrl) {
      res.push(this.columnsRowCtrl);
    }
    if (this.filtersRowCtrl) {
      res.push(this.filtersRowCtrl);
    }
    return res;
  }
  refresh(keepColumns = false) {
    const { focusSvc, colModel, filterManager } = this.beans;
    let sequence = 0;
    const focusedHeaderPosition = focusSvc.getFocusHeaderToUseAfterRefresh();
    const refreshColumnGroups = () => {
      const groupRowCount = getHeaderRowCount(colModel) - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let i = 0; i < groupRowCount; i++) {
        const ctrl = this.createBean(new HeaderRowCtrl(sequence++, this.pinned, "group"));
        this.groupsRowCtrls.push(ctrl);
      }
    };
    const refreshColumns = () => {
      const rowIndex = sequence++;
      const needNewInstance = !this.hidden && (this.columnsRowCtrl == null || !keepColumns || this.columnsRowCtrl.rowIndex !== rowIndex);
      const shouldDestroyInstance = needNewInstance || this.hidden;
      if (shouldDestroyInstance) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
      }
      if (needNewInstance) {
        this.columnsRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "column"));
      }
    };
    const refreshFilters = () => {
      this.includeFloatingFilter = !!filterManager?.hasFloatingFilters() && !this.hidden;
      const destroyPreviousComp = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        destroyPreviousComp();
        return;
      }
      const rowIndex = sequence++;
      if (this.filtersRowCtrl) {
        const rowIndexMismatch = this.filtersRowCtrl.rowIndex !== rowIndex;
        if (!keepColumns || rowIndexMismatch) {
          destroyPreviousComp();
        }
      }
      if (!this.filtersRowCtrl) {
        this.filtersRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "filter"));
      }
    };
    refreshColumnGroups();
    refreshColumns();
    refreshFilters();
    const allCtrls = this.getAllCtrls();
    this.comp.setCtrls(allCtrls);
    this.restoreFocusOnHeader(focusSvc, focusedHeaderPosition);
  }
  getHeaderCtrlForColumn(column) {
    if (isColumn(column)) {
      return this.columnsRowCtrl?.getHeaderCellCtrl(column);
    }
    if (this.groupsRowCtrls.length === 0) {
      return;
    }
    for (let i = 0; i < this.groupsRowCtrls.length; i++) {
      const ctrl = this.groupsRowCtrls[i].getHeaderCellCtrl(column);
      if (ctrl) {
        return ctrl;
      }
    }
  }
  getHtmlElementForColumnHeader(column) {
    return this.getHeaderCtrlForColumn(column)?.eGui ?? null;
  }
  getRowType(rowIndex) {
    return this.getAllCtrls()[rowIndex]?.type;
  }
  focusHeader(rowIndex, column, event) {
    const allCtrls = this.getAllCtrls();
    const ctrl = allCtrls[rowIndex];
    if (!ctrl) {
      return false;
    }
    return ctrl.focusHeader(column, event);
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(index) {
    return this.groupsRowCtrls[index];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(offset) {
    this.comp.setViewportScrollLeft(offset);
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
  destroy() {
    this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
    this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
    this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
    super.destroy();
  }
  setupDragAndDrop(colMoves, dropContainer) {
    const bodyDropTarget = colMoves?.createBodyDropTarget(this.pinned, dropContainer);
    if (bodyDropTarget) {
      this.createManagedBean(bodyDropTarget);
    }
  }
  restoreFocusOnHeader(focusSvc, position) {
    if (!position) {
      return;
    }
    const { column } = position;
    if (column.getPinned() != this.pinned) {
      return;
    }
    focusSvc.focusHeaderPosition({ headerPosition: position });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(true);
  }
  onDisplayedColumnsChanged(filterManager) {
    const includeFloatingFilter = !!filterManager?.hasFloatingFilters() && !this.hidden;
    if (this.includeFloatingFilter !== includeFloatingFilter) {
      this.refresh(true);
    }
  }
  setupCenterWidth() {
    if (this.pinned != null) {
      return;
    }
    this.createManagedBean(new CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
  }
};

// packages/ag-grid-community/src/misc/menu/menuService.ts
var MenuService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "menuSvc";
  }
  postConstruct() {
    const { enterpriseMenuFactory, filterMenuFactory } = this.beans;
    this.activeMenuFactory = enterpriseMenuFactory ?? filterMenuFactory;
  }
  showColumnMenu(params) {
    this.showColumnMenuCommon(this.activeMenuFactory, params, "columnMenu");
  }
  showFilterMenu(params) {
    const { enterpriseMenuFactory, filterMenuFactory } = this.beans;
    const menuFactory = enterpriseMenuFactory && _isLegacyMenuEnabled(this.gos) ? enterpriseMenuFactory : filterMenuFactory;
    this.showColumnMenuCommon(menuFactory, params, params.containerType, true);
  }
  showHeaderContextMenu(column, mouseEvent, touchEvent) {
    this.activeMenuFactory?.showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent);
  }
  hidePopupMenu() {
    this.beans.contextMenuSvc?.hideActiveMenu();
    this.activeMenuFactory?.hideActiveMenu();
  }
  isColumnMenuInHeaderEnabled(column) {
    const { suppressHeaderMenuButton } = column.getColDef();
    return !suppressHeaderMenuButton && !!this.activeMenuFactory?.isMenuEnabled(column) && (_isLegacyMenuEnabled(this.gos) || !!this.beans.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(column) {
    return !column.getColDef().suppressHeaderFilterButton && !!this.beans.filterManager?.isFilterAllowed(column);
  }
  isHeaderContextMenuEnabled(column) {
    const colDef = column && isColumn(column) ? column.getColDef() : column?.getColGroupDef();
    return !colDef?.suppressHeaderContextMenu && this.gos.get("columnMenu") === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const menuHides = !this.isSuppressMenuHide();
    const onIpadAndMenuHides = _isIOSUserAgent() && menuHides;
    return !onIpadAndMenuHides;
  }
  isHeaderFilterButtonEnabled(column) {
    return this.isFilterMenuInHeaderEnabled(column) && !_isLegacyMenuEnabled(this.gos) && !this.isFloatingFilterButtonDisplayed(column);
  }
  isFilterMenuItemEnabled(column) {
    return !!this.beans.filterManager?.isFilterAllowed(column) && !_isLegacyMenuEnabled(this.gos) && !this.isFilterMenuInHeaderEnabled(column) && !this.isFloatingFilterButtonDisplayed(column);
  }
  isFloatingFilterButtonEnabled(column) {
    return !column.getColDef().suppressFloatingFilterButton;
  }
  isFloatingFilterButtonDisplayed(column) {
    return !!column.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(column);
  }
  isSuppressMenuHide() {
    const gos = this.gos;
    const suppressMenuHide = gos.get("suppressMenuHide");
    if (_isLegacyMenuEnabled(gos)) {
      return gos.exists("suppressMenuHide") ? suppressMenuHide : false;
    }
    return suppressMenuHide;
  }
  showColumnMenuCommon(menuFactory, params, containerType, filtersOnly) {
    const { positionBy } = params;
    const column = params.column;
    if (positionBy === "button") {
      const { buttonElement } = params;
      menuFactory?.showMenuAfterButtonClick(column, buttonElement, containerType, filtersOnly);
    } else if (positionBy === "mouse") {
      const { mouseEvent } = params;
      menuFactory?.showMenuAfterMouseEvent(column, mouseEvent, containerType, filtersOnly);
    } else if (column) {
      const beans = this.beans;
      const ctrlsSvc = beans.ctrlsSvc;
      ctrlsSvc.getScrollFeature().ensureColumnVisible(column, "auto");
      _requestAnimationFrame(beans, () => {
        const headerCellCtrl = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned())?.getHeaderCtrlForColumn(column);
        if (headerCellCtrl) {
          menuFactory?.showMenuAfterButtonClick(
            column,
            headerCellCtrl.getAnchorElementForMenu(filtersOnly),
            containerType,
            true
          );
        }
      });
    }
  }
};
function _setColMenuVisible(column, visible, source) {
  if (column.menuVisible !== visible) {
    column.menuVisible = visible;
    column.dispatchColEvent("menuVisibleChanged", source);
  }
}

// packages/ag-grid-community/src/rendering/overlays/overlayComponent.ts
var OverlayComponent = class extends Component {
  constructor() {
    super();
  }
};

// packages/ag-grid-community/src/rendering/overlays/loadingOverlayComponent.ts
var LoadingOverlayComponent2 = class extends OverlayComponent {
  init() {
    const customTemplate = _makeNull(this.gos.get("overlayLoadingTemplate")?.trim());
    this.setTemplate(
      customTemplate ?? /* html */
      `<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>`
    );
    if (!customTemplate) {
      const localeTextFunc = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = localeTextFunc("loadingOoo", "Loading...");
      });
    }
  }
};

// packages/ag-grid-community/src/rendering/overlays/noRowsOverlayComponent.ts
var NoRowsOverlayComponent2 = class extends OverlayComponent {
  init() {
    const customTemplate = _makeNull(this.gos.get("overlayNoRowsTemplate")?.trim());
    this.setTemplate(customTemplate ?? /* html */
    `<span class="ag-overlay-no-rows-center"></span>`);
    if (!customTemplate) {
      const localeTextFunc = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = localeTextFunc("noRowsToShow", "No Rows To Show");
      });
    }
  }
};

// packages/ag-grid-community/src/utils/icon.ts
function _createIcon(iconName, beans, column) {
  const iconContents = _createIconNoSpan(iconName, beans, column);
  if (iconContents) {
    const { className } = iconContents;
    if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) {
      return iconContents;
    }
  }
  const eResult = document.createElement("span");
  eResult.appendChild(iconContents);
  return eResult;
}
function _createIconNoSpan(iconName, beans, column) {
  let userProvidedIcon = null;
  if (iconName === "smallDown") {
    _warn(262);
  } else if (iconName === "smallLeft") {
    _warn(263);
  } else if (iconName === "smallRight") {
    _warn(264);
  }
  const icons = column && column.getColDef().icons;
  if (icons) {
    userProvidedIcon = icons[iconName];
  }
  if (beans.gos && !userProvidedIcon) {
    const optionsIcons = beans.gos.get("icons");
    if (optionsIcons) {
      userProvidedIcon = optionsIcons[iconName];
    }
  }
  if (userProvidedIcon) {
    let rendererResult;
    if (typeof userProvidedIcon === "function") {
      rendererResult = userProvidedIcon();
    } else if (typeof userProvidedIcon === "string") {
      rendererResult = userProvidedIcon;
    } else {
      _warn(38, { iconName });
      return void 0;
    }
    if (typeof rendererResult === "string") {
      return _loadTemplate(rendererResult);
    }
    if (_isNodeOrElement(rendererResult)) {
      return rendererResult;
    }
    _warn(133, { iconName });
    return void 0;
  } else {
    const span = document.createElement("span");
    const iconValue = beans.registry.getIcon(iconName);
    if (!iconValue) {
      beans.validation?.validateIcon(iconName);
    }
    const cssClass = iconValue ?? iconName;
    span.setAttribute("class", `ag-icon ag-icon-${cssClass}`);
    span.setAttribute("unselectable", "on");
    _setAriaRole(span, "presentation");
    return span;
  }
}

// packages/ag-grid-community/src/dragAndDrop/dragAndDropImageComponent.css-GENERATED.ts
var dragAndDropImageComponentCSS = (
  /*css*/
  `.ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}`
);

// packages/ag-grid-community/src/dragAndDrop/dragAndDropImageComponent.ts
var DragAndDropImageComponent2 = class extends Component {
  constructor() {
    super();
    this.dragSource = null;
    this.eIcon = RefPlaceholder;
    this.eLabel = RefPlaceholder;
    this.registerCSS(dragAndDropImageComponentCSS);
  }
  postConstruct() {
    const create = (iconName) => _createIcon(iconName, this.beans, null);
    this.dropIconMap = {
      pinned: create("columnMovePin"),
      hide: create("columnMoveHide"),
      move: create("columnMoveMove"),
      left: create("columnMoveLeft"),
      right: create("columnMoveRight"),
      group: create("columnMoveGroup"),
      aggregate: create("columnMoveValue"),
      pivot: create("columnMovePivot"),
      notAllowed: create("dropNotAllowed")
    };
  }
  init(params) {
    this.dragSource = params.dragSource;
    this.setTemplate(
      /* html */
      `<div class="ag-dnd-ghost ag-unselectable">
                <span data-ref="eIcon" class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
                <div data-ref="eLabel" class="ag-dnd-ghost-label"></div>
            </div>`
    );
  }
  destroy() {
    this.dragSource = null;
    super.destroy();
  }
  setIcon(iconName, shake) {
    const { eIcon, dragSource, dropIconMap, gos } = this;
    _clearElement(eIcon);
    let eIconChild = null;
    if (!iconName) {
      iconName = dragSource?.getDefaultIconName ? dragSource.getDefaultIconName() : "notAllowed";
    }
    eIconChild = dropIconMap[iconName];
    eIcon.classList.toggle("ag-shake-left-to-right", shake);
    if (eIconChild === dropIconMap["hide"] && gos.get("suppressDragLeaveHidesColumns")) {
      return;
    }
    if (eIconChild) {
      eIcon.appendChild(eIconChild);
    }
  }
  setLabel(label) {
    this.eLabel.textContent = _escapeString(label);
  }
};

// packages/ag-grid-community/src/widgets/agAbstractLabel.css-GENERATED.ts
var agAbstractLabelCSS = (
  /*css*/
  `.ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}`
);

// packages/ag-grid-community/src/widgets/agAbstractLabel.ts
var AgAbstractLabel = class extends Component {
  constructor(config, template, components) {
    super(template, components);
    this.labelSeparator = "";
    this.labelAlignment = "left";
    this.disabled = false;
    this.label = "";
    this.config = config || {};
    this.registerCSS(agAbstractLabelCSS);
  }
  postConstruct() {
    this.addCssClass("ag-labeled");
    this.eLabel.classList.add("ag-label");
    const { labelSeparator, label, labelWidth, labelAlignment, disabled } = this.config;
    if (disabled != null) {
      this.setDisabled(disabled);
    }
    if (labelSeparator != null) {
      this.setLabelSeparator(labelSeparator);
    }
    if (label != null) {
      this.setLabel(label);
    }
    if (labelWidth != null) {
      this.setLabelWidth(labelWidth);
    }
    this.setLabelAlignment(labelAlignment || this.labelAlignment);
    this.refreshLabel();
  }
  refreshLabel() {
    const { label, eLabel } = this;
    _clearElement(eLabel);
    if (typeof label === "string") {
      eLabel.innerText = label + this.labelSeparator;
    } else if (label) {
      eLabel.appendChild(label);
    }
    if (label === "") {
      _setDisplayed(eLabel, false);
      _setAriaRole(eLabel, "presentation");
    } else {
      _setDisplayed(eLabel, true);
      _setAriaRole(eLabel, null);
    }
  }
  setLabelSeparator(labelSeparator) {
    if (this.labelSeparator === labelSeparator) {
      return this;
    }
    this.labelSeparator = labelSeparator;
    if (this.label != null) {
      this.refreshLabel();
    }
    return this;
  }
  getLabelId() {
    const eLabel = this.eLabel;
    eLabel.id = eLabel.id || `ag-${this.getCompId()}-label`;
    return eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    if (this.label === label) {
      return this;
    }
    this.label = label;
    this.refreshLabel();
    return this;
  }
  setLabelAlignment(alignment) {
    const eGui = this.getGui();
    const eGuiClassList = eGui.classList;
    eGuiClassList.toggle("ag-label-align-left", alignment === "left");
    eGuiClassList.toggle("ag-label-align-right", alignment === "right");
    eGuiClassList.toggle("ag-label-align-top", alignment === "top");
    return this;
  }
  setLabelEllipsis(hasEllipsis) {
    this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
    return this;
  }
  setLabelWidth(width) {
    if (this.label == null) {
      return this;
    }
    _setElementWidth(this.eLabel, width);
    return this;
  }
  setDisabled(disabled) {
    disabled = !!disabled;
    const element = this.getGui();
    _setDisabled(element, disabled);
    element.classList.toggle("ag-disabled", disabled);
    this.disabled = disabled;
    return this;
  }
  isDisabled() {
    return !!this.disabled;
  }
};

// packages/ag-grid-community/src/widgets/agAbstractField.ts
var AgAbstractField = class extends AgAbstractLabel {
  constructor(config, template, components, className) {
    super(config, template, components);
    this.className = className;
  }
  postConstruct() {
    super.postConstruct();
    const { width, value, onValueChange } = this.config;
    if (width != null) {
      this.setWidth(width);
    }
    if (value != null) {
      this.setValue(value);
    }
    if (onValueChange != null) {
      this.onValueChange(onValueChange);
    }
    if (this.className) {
      this.addCssClass(this.className);
    }
    this.refreshAriaLabelledBy();
  }
  setLabel(label) {
    super.setLabel(label);
    this.refreshAriaLabelledBy();
    return this;
  }
  refreshAriaLabelledBy() {
    const ariaEl = this.getAriaElement();
    const labelId = this.getLabelId();
    const label = this.getLabel();
    if (label == null || label == "" || _getAriaLabel(ariaEl) !== null) {
      _setAriaLabelledBy(ariaEl, "");
    } else {
      _setAriaLabelledBy(ariaEl, labelId ?? "");
    }
  }
  setAriaLabel(label) {
    _setAriaLabel(this.getAriaElement(), label);
    this.refreshAriaLabelledBy();
    return this;
  }
  onValueChange(callbackFn) {
    this.addManagedListeners(this, { fieldValueChanged: () => callbackFn(this.getValue()) });
    return this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(width) {
    _setFixedWidth(this.getGui(), width);
    return this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(value, silent) {
    if (this.value === value) {
      return this;
    }
    this.previousValue = this.value;
    this.value = value;
    if (!silent) {
      this.dispatchLocalEvent({ type: "fieldValueChanged" });
    }
    return this;
  }
};

// packages/ag-grid-community/src/widgets/agAbstractInputField.ts
var AgAbstractInputField = class extends AgAbstractField {
  constructor(config, className, inputType = "text", displayFieldTag = "input") {
    super(
      config,
      config?.template ?? /* html */
      `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${displayFieldTag} data-ref="eInput" class="ag-input-field-input"></${displayFieldTag}>
                </div>
            </div>`,
      [],
      className
    );
    this.inputType = inputType;
    this.displayFieldTag = displayFieldTag;
    this.eLabel = RefPlaceholder;
    this.eWrapper = RefPlaceholder;
    this.eInput = RefPlaceholder;
  }
  postConstruct() {
    super.postConstruct();
    this.setInputType();
    const { eLabel, eWrapper, eInput, className } = this;
    eLabel.classList.add(`${className}-label`);
    eWrapper.classList.add(`${className}-input-wrapper`);
    eInput.classList.add(`${className}-input`);
    this.addCssClass("ag-input-field");
    eInput.id = eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName, inputWidth } = this.config;
    if (inputName != null) {
      this.setInputName(inputName);
    }
    if (inputWidth != null) {
      this.setInputWidth(inputWidth);
    }
    this.addInputListeners();
    this.activateTabIndex([eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    if (this.displayFieldTag === "input") {
      this.eInput.setAttribute("type", this.inputType);
    }
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(width) {
    _setElementWidth(this.eWrapper, width);
    return this;
  }
  setInputName(name) {
    this.getInputElement().setAttribute("name", name);
    return this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(length) {
    const eInput = this.eInput;
    eInput.maxLength = length;
    return this;
  }
  setInputPlaceholder(placeholder) {
    _addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
    return this;
  }
  setInputAriaLabel(label) {
    _setAriaLabel(this.eInput, label);
    this.refreshAriaLabelledBy();
    return this;
  }
  setDisabled(disabled) {
    _setDisabled(this.eInput, disabled);
    return super.setDisabled(disabled);
  }
  setAutoComplete(value) {
    if (value === true) {
      _addOrRemoveAttribute(this.eInput, "autocomplete", null);
    } else {
      const autoCompleteValue = typeof value === "string" ? value : "off";
      _addOrRemoveAttribute(this.eInput, "autocomplete", autoCompleteValue);
    }
    return this;
  }
};

// packages/ag-grid-community/src/widgets/agCheckbox.ts
var AgCheckbox = class extends AgAbstractInputField {
  constructor(config, className = "ag-checkbox", inputType = "checkbox") {
    super(config, className, inputType);
    this.labelAlignment = "right";
    this.selected = false;
    this.readOnly = false;
    this.passive = false;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly, passive } = this.config;
    if (typeof readOnly === "boolean")
      this.setReadOnly(readOnly);
    if (typeof passive === "boolean")
      this.setPassive(passive);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) });
    this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? true : !this.selected;
  }
  setPassive(passive) {
    this.passive = passive;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(readOnly) {
    this.eWrapper.classList.toggle("ag-disabled", readOnly);
    this.eInput.disabled = readOnly;
    this.readOnly = readOnly;
  }
  setDisabled(disabled) {
    this.eWrapper.classList.toggle("ag-disabled", disabled);
    return super.setDisabled(disabled);
  }
  toggle() {
    if (this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const nextValue = this.getNextValue();
    if (this.passive) {
      this.dispatchChange(nextValue, previousValue);
    } else {
      this.setValue(nextValue);
    }
  }
  getValue() {
    return this.isSelected();
  }
  setValue(value, silent) {
    this.refreshSelectedClass(value);
    this.setSelected(value, silent);
    return this;
  }
  setName(name) {
    const input = this.getInputElement();
    input.name = name;
    return this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected, silent) {
    if (this.isSelected() === selected) {
      return;
    }
    this.previousValue = this.isSelected();
    selected = this.selected = typeof selected === "boolean" ? selected : void 0;
    const eInput = this.eInput;
    eInput.checked = selected;
    eInput.indeterminate = selected === void 0;
    if (!silent) {
      this.dispatchChange(this.selected, this.previousValue);
    }
  }
  dispatchChange(selected, previousValue, event) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected, previousValue, event });
    const input = this.getInputElement();
    this.eventSvc.dispatchEvent({
      type: "checkboxChanged",
      id: input.id,
      name: input.name,
      selected,
      previousValue
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const selected = this.selected = e.target.checked;
    this.refreshSelectedClass(selected);
    this.dispatchChange(selected, previousValue, e);
  }
  refreshSelectedClass(value) {
    const classList = this.eWrapper.classList;
    classList.toggle("ag-checked", value === true);
    classList.toggle("ag-indeterminate", value == null);
  }
};
var AgCheckboxSelector = {
  selector: "AG-CHECKBOX",
  component: AgCheckbox
};

// packages/ag-grid-community/src/rendering/cellRenderers/checkboxCellRenderer.css-GENERATED.ts
var checkboxCellRendererCSS = (
  /*css*/
  `.ag-checkbox-cell{height:100%}`
);

// packages/ag-grid-community/src/rendering/cellRenderers/checkboxCellRenderer.ts
var CheckboxCellRenderer = class extends Component {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [AgCheckboxSelector]
    );
    this.eCheckbox = RefPlaceholder;
    this.registerCSS(checkboxCellRendererCSS);
  }
  init(params) {
    this.refresh(params);
    const { eCheckbox, beans } = this;
    const inputEl = eCheckbox.getInputElement();
    inputEl.setAttribute("tabindex", "-1");
    _setAriaLive(inputEl, "polite");
    this.addManagedListeners(inputEl, {
      click: (event) => {
        _stopPropagationForAgGrid(event);
        if (eCheckbox.isDisabled()) {
          return;
        }
        const isSelected = eCheckbox.getValue();
        this.onCheckboxChanged(isSelected);
      },
      dblclick: (event) => {
        _stopPropagationForAgGrid(event);
      }
    });
    this.addManagedElementListeners(params.eGridCell, {
      keydown: (event) => {
        if (event.key === KeyCode.SPACE && !eCheckbox.isDisabled()) {
          if (params.eGridCell === _getActiveDomElement(beans)) {
            eCheckbox.toggle();
          }
          const isSelected = eCheckbox.getValue();
          this.onCheckboxChanged(isSelected);
          event.preventDefault();
        }
      }
    });
  }
  refresh(params) {
    this.params = params;
    this.updateCheckbox(params);
    return true;
  }
  updateCheckbox(params) {
    let isSelected;
    let displayed = true;
    const { value, column, node } = params;
    if (node.group && column) {
      if (typeof value === "boolean") {
        isSelected = value;
      } else {
        const colId = column.getColId();
        if (colId.startsWith(GROUP_AUTO_COLUMN_ID)) {
          isSelected = value == null || value === "" ? void 0 : value === "true";
        } else if (node.aggData && node.aggData[colId] !== void 0) {
          isSelected = value ?? void 0;
        } else {
          displayed = false;
        }
      }
    } else {
      isSelected = value ?? void 0;
    }
    const { eCheckbox } = this;
    if (!displayed) {
      eCheckbox.setDisplayed(false);
      return;
    }
    eCheckbox.setValue(isSelected);
    const disabled = params.disabled ?? !column?.isCellEditable(node);
    eCheckbox.setDisabled(disabled);
    const translate = this.getLocaleTextFunc();
    const stateName = _getAriaCheckboxStateName(translate, isSelected);
    const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
    eCheckbox.setInputAriaLabel(ariaLabel);
  }
  onCheckboxChanged(isSelected) {
    const { eventSvc, params } = this;
    const { column, node, value } = params;
    const sharedEventParams = {
      column,
      colDef: column.getColDef(),
      data: node.data,
      node,
      rowIndex: node.rowIndex,
      rowPinned: node.rowPinned,
      value
    };
    eventSvc.dispatchEvent({
      type: "cellEditingStarted",
      ...sharedEventParams
    });
    const valueChanged = node.setDataValue(column, isSelected, "edit");
    eventSvc.dispatchEvent({
      type: "cellEditingStopped",
      ...sharedEventParams,
      oldValue: value,
      newValue: isSelected,
      valueChanged
    });
    if (!valueChanged) {
      this.updateCheckbox(params);
    }
  }
};

// packages/ag-grid-community/src/clientSideRowModel/abstractClientSideNodeManager.ts
var ROOT_NODE_ID = "ROOT_NODE_ID";
var AbstractClientSideNodeManager = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.nextId = 0;
    this.allNodesMap = {};
    this.rootNode = null;
  }
  get treeData() {
    return false;
  }
  getRowNode(id) {
    return this.allNodesMap[id];
  }
  extractRowData() {
    return this.rootNode?.allLeafChildren?.map((node) => node.data);
  }
  activate(rootNode) {
    this.rootNode = rootNode;
    rootNode.group = true;
    rootNode.level = -1;
    rootNode.id = ROOT_NODE_ID;
    rootNode.allLeafChildren = [];
    rootNode.childrenAfterGroup = [];
    rootNode.childrenAfterSort = [];
    rootNode.childrenAfterAggFilter = [];
    rootNode.childrenAfterFilter = [];
    this.updateRootSiblingArrays(rootNode);
  }
  deactivate() {
    if (this.rootNode) {
      this.allNodesMap = {};
      this.rootNode = null;
    }
  }
  destroy() {
    super.destroy();
    this.allNodesMap = {};
    this.rootNode = null;
  }
  setNewRowData(rowData) {
    const rootNode = this.rootNode;
    if (!rootNode) {
      return;
    }
    this.dispatchRowDataUpdateStartedEvent(rowData);
    rootNode.childrenAfterFilter = null;
    rootNode.childrenAfterGroup = null;
    rootNode.childrenAfterAggFilter = null;
    rootNode.childrenAfterSort = null;
    rootNode.childrenMapped = null;
    rootNode.updateHasChildren();
    this.allNodesMap = {};
    this.nextId = 0;
    this.loadNewRowData(rowData);
    this.updateRootSiblingArrays(rootNode);
  }
  updateRootSiblingArrays(rootNode) {
    const sibling = rootNode.sibling;
    if (sibling) {
      sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
      sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
      sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
      sibling.childrenAfterSort = rootNode.childrenAfterSort;
      sibling.childrenMapped = rootNode.childrenMapped;
      sibling.allLeafChildren = rootNode.allLeafChildren;
    }
  }
  loadNewRowData(rowData) {
    this.rootNode.allLeafChildren = rowData?.map((dataItem, index) => this.createRowNode(dataItem, index)) ?? [];
  }
  setImmutableRowData(params, rowData) {
    const rowDataTransaction = this.createTransactionForRowData(rowData);
    const result = this.updateRowData(rowDataTransaction, params.changedRowNodes);
    let rowsOrderChanged = false;
    if (!this.gos.get("suppressMaintainUnsortedOrder")) {
      rowsOrderChanged = this.updateRowOrderFromRowData(rowData);
    }
    const { rowNodeTransaction, rowsInserted } = result;
    const { add, remove, update } = rowNodeTransaction;
    if (rowsInserted || rowsOrderChanged || add.length || remove.length || update.length) {
      params.step = "group";
      params.rowDataUpdated = true;
      params.rowNodeTransactions = [rowNodeTransaction];
      params.rowNodesOrderChanged = rowsInserted || rowsOrderChanged;
    }
  }
  updateRowData(rowDataTran, changedRowNodes) {
    this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);
    const updateRowDataResult = {
      changedRowNodes,
      rowNodeTransaction: { remove: [], update: [], add: [] },
      rowsInserted: false
    };
    const nodesToUnselect = [];
    const getRowIdFunc = _getRowIdCallback(this.gos);
    this.executeRemove(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
    this.executeUpdate(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
    this.executeAdd(rowDataTran, updateRowDataResult);
    this.deselectNodes(nodesToUnselect);
    return updateRowDataResult;
  }
  /** Converts the setRowData() command to a transaction */
  createTransactionForRowData(rowData) {
    const getRowIdFunc = _getRowIdCallback(this.gos);
    const existingNodesMap = { ...this.allNodesMap };
    const remove = [];
    const update = [];
    const add = [];
    if (_exists(rowData)) {
      rowData.forEach((data) => {
        const id = getRowIdFunc({ data, level: 0 });
        const existingNode = existingNodesMap[id];
        if (existingNode) {
          const dataHasChanged = existingNode.data !== data;
          if (dataHasChanged) {
            update.push(data);
          }
          existingNodesMap[id] = void 0;
        } else {
          add.push(data);
        }
      });
    }
    for (const rowNode of Object.values(existingNodesMap)) {
      if (rowNode) {
        remove.push(rowNode.data);
      }
    }
    return { remove, update, add };
  }
  /**
   * Used by setImmutableRowData, after updateRowData, after updating with a generated transaction to
   * apply the order as specified by the the new data. We use sourceRowIndex to determine the order of the rows.
   * Time complexity is O(n) where n is the number of rows/rowData
   * @returns true if the order changed, otherwise false
   */
  updateRowOrderFromRowData(rowData) {
    const rows = this.rootNode?.allLeafChildren;
    const rowsLength = rows?.length ?? 0;
    const rowsOutOfOrder = /* @__PURE__ */ new Map();
    let firstIndexOutOfOrder = -1;
    let lastIndexOutOfOrder = -1;
    for (let i = 0; i < rowsLength; ++i) {
      const row = rows[i];
      const data = row.data;
      if (data !== rowData[i]) {
        if (lastIndexOutOfOrder < 0) {
          firstIndexOutOfOrder = i;
        }
        lastIndexOutOfOrder = i;
        rowsOutOfOrder.set(data, row);
      }
    }
    if (firstIndexOutOfOrder < 0) {
      return false;
    }
    for (let i = firstIndexOutOfOrder; i <= lastIndexOutOfOrder; ++i) {
      const row = rowsOutOfOrder.get(rowData[i]);
      if (row !== void 0) {
        rows[i] = row;
        row.sourceRowIndex = i;
      }
    }
    return true;
  }
  executeAdd(rowDataTran, result) {
    const add = rowDataTran.add;
    if (!add?.length) {
      return;
    }
    let allLeafChildren = this.rootNode.allLeafChildren;
    let addIndex = allLeafChildren.length;
    if (typeof rowDataTran.addIndex === "number") {
      addIndex = this.sanitizeAddIndex(rowDataTran.addIndex);
      if (addIndex > 0) {
        const getDataPath = this.gos.get("treeData") && this.gos.get("getDataPath");
        if (getDataPath) {
          for (let i = 0; i < allLeafChildren.length; i++) {
            const node = allLeafChildren[i];
            if (node?.rowIndex == addIndex - 1) {
              addIndex = i + 1;
              break;
            }
          }
        }
      }
    }
    const addLength = add.length;
    const changedRowNodes = result.changedRowNodes;
    const newNodes = new Array(addLength);
    for (let i = 0; i < addLength; i++) {
      const newNode = this.createRowNode(add[i], addIndex + i);
      changedRowNodes.add(newNode);
      newNodes[i] = newNode;
    }
    const rootNode = this.rootNode;
    if (addIndex < allLeafChildren.length) {
      const nodesBeforeIndex = allLeafChildren.slice(0, addIndex);
      const nodesAfterIndex = allLeafChildren.slice(addIndex, allLeafChildren.length);
      const nodesAfterIndexFirstIndex = nodesBeforeIndex.length + newNodes.length;
      for (let index = 0, length = nodesAfterIndex.length; index < length; ++index) {
        nodesAfterIndex[index].sourceRowIndex = nodesAfterIndexFirstIndex + index;
      }
      allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];
      result.rowsInserted = true;
    } else {
      allLeafChildren = allLeafChildren.concat(newNodes);
    }
    rootNode.allLeafChildren = allLeafChildren;
    const sibling = rootNode.sibling;
    if (sibling) {
      sibling.allLeafChildren = allLeafChildren;
    }
    result.rowNodeTransaction.add = newNodes;
  }
  executeRemove(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
    const { remove } = rowDataTran;
    if (!remove?.length) {
      return;
    }
    const rowIdsRemoved = {};
    remove.forEach((item) => {
      const rowNode = this.lookupRowNode(getRowIdFunc, item);
      if (!rowNode) {
        return;
      }
      if (rowNode.isSelected()) {
        nodesToUnselect.push(rowNode);
      }
      rowNode.clearRowTopAndRowIndex();
      rowIdsRemoved[rowNode.id] = true;
      delete this.allNodesMap[rowNode.id];
      rowNodeTransaction.remove.push(rowNode);
      changedRowNodes.remove(rowNode);
    });
    const rootNode = this.rootNode;
    rootNode.allLeafChildren = rootNode.allLeafChildren?.filter((rowNode) => !rowIdsRemoved[rowNode.id]) ?? null;
    rootNode.allLeafChildren?.forEach((node, idx) => {
      node.sourceRowIndex = idx;
    });
    const sibling = rootNode.sibling;
    if (sibling) {
      sibling.allLeafChildren = rootNode.allLeafChildren;
    }
  }
  executeUpdate(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
    const { update } = rowDataTran;
    if (!update?.length) {
      return;
    }
    update.forEach((item) => {
      const rowNode = this.lookupRowNode(getRowIdFunc, item);
      if (!rowNode) {
        return;
      }
      rowNode.updateData(item);
      if (!rowNode.selectable && rowNode.isSelected()) {
        nodesToUnselect.push(rowNode);
      }
      rowNodeTransaction.update.push(rowNode);
      changedRowNodes.update(rowNode);
    });
  }
  dispatchRowDataUpdateStartedEvent(rowData) {
    this.eventSvc.dispatchEvent({
      type: "rowDataUpdateStarted",
      firstRowData: rowData?.length ? rowData[0] : null
    });
  }
  deselectNodes(nodesToUnselect) {
    const source = "rowDataChanged";
    const selectionSvc = this.beans.selectionSvc;
    const selectionChanged = nodesToUnselect.length > 0;
    if (selectionChanged) {
      selectionSvc?.setNodesSelected({
        newValue: false,
        nodes: nodesToUnselect,
        suppressFinishActions: true,
        source
      });
    }
    selectionSvc?.updateGroupsFromChildrenSelections?.(source);
    if (selectionChanged) {
      this.eventSvc.dispatchEvent({
        type: "selectionChanged",
        source
      });
    }
  }
  sanitizeAddIndex(addIndex) {
    const allChildrenCount = this.rootNode.allLeafChildren?.length ?? 0;
    if (addIndex < 0 || addIndex >= allChildrenCount || Number.isNaN(addIndex)) {
      return allChildrenCount;
    }
    return Math.ceil(addIndex);
  }
  createRowNode(data, sourceRowIndex) {
    const node = new RowNode(this.beans);
    node.parent = this.rootNode;
    node.level = 0;
    node.group = false;
    node.expanded = false;
    node.sourceRowIndex = sourceRowIndex;
    node.setDataAndId(data, String(this.nextId));
    if (this.allNodesMap[node.id]) {
      _warn(2, { nodeId: node.id });
    }
    this.allNodesMap[node.id] = node;
    this.nextId++;
    return node;
  }
  lookupRowNode(getRowIdFunc, data) {
    let rowNode;
    if (getRowIdFunc) {
      const id = getRowIdFunc({ data, level: 0 });
      rowNode = this.allNodesMap[id];
      if (!rowNode) {
        _error(4, { id });
        return null;
      }
    } else {
      rowNode = this.rootNode?.allLeafChildren?.find((node) => node.data === data);
      if (!rowNode) {
        _error(5, { data });
        return null;
      }
    }
    return rowNode || null;
  }
};

// packages/ag-grid-community/src/interfaces/serverSideTransaction.ts
var ServerSideTransactionResultStatus = /* @__PURE__ */ ((ServerSideTransactionResultStatus2) => {
  ServerSideTransactionResultStatus2["Applied"] = "Applied";
  ServerSideTransactionResultStatus2["StoreNotFound"] = "StoreNotFound";
  ServerSideTransactionResultStatus2["StoreLoading"] = "StoreLoading";
  ServerSideTransactionResultStatus2["StoreWaitingToLoad"] = "StoreWaitingToLoad";
  ServerSideTransactionResultStatus2["StoreLoadingFailed"] = "StoreLoadingFailed";
  ServerSideTransactionResultStatus2["StoreWrongType"] = "StoreWrongType";
  ServerSideTransactionResultStatus2["Cancelled"] = "Cancelled";
  ServerSideTransactionResultStatus2["StoreNotStarted"] = "StoreNotStarted";
  return ServerSideTransactionResultStatus2;
})(ServerSideTransactionResultStatus || {});

// packages/ag-grid-community/src/selection/checkboxSelectionComponent.ts
var CheckboxSelectionComponent = class extends Component {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [AgCheckboxSelector]
    );
    this.eCheckbox = RefPlaceholder;
  }
  postConstruct() {
    this.eCheckbox.setPassive(true);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const translate = this.getLocaleTextFunc();
    const { rowNode, eCheckbox } = this;
    const state = rowNode.isSelected();
    const stateName = _getAriaCheckboxStateName(translate, state);
    const [ariaKey, ariaLabel] = rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"];
    const translatedLabel = translate(ariaKey, ariaLabel);
    eCheckbox.setValue(state, true);
    eCheckbox.setInputAriaLabel(`${translatedLabel} (${stateName})`);
  }
  init(params) {
    this.rowNode = params.rowNode;
    this.column = params.column;
    this.overrides = params.overrides;
    this.onSelectionChanged();
    this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: _stopPropagationForAgGrid,
      click: (event) => {
        _stopPropagationForAgGrid(event);
        this.beans.selectionSvc?.handleSelectionEvent(event, this.rowNode, "checkboxSelected");
      }
    });
    this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    });
    this.addManagedPropertyListener("rowSelection", ({ currentValue, previousValue }) => {
      const curr = typeof currentValue === "object" ? _getHideDisabledCheckboxes(currentValue) : void 0;
      const prev = typeof previousValue === "object" ? _getHideDisabledCheckboxes(previousValue) : void 0;
      if (curr !== prev) {
        this.onSelectableChanged();
      }
    });
    const isRowSelectableFunc = _getIsRowSelectable(this.gos);
    const checkboxVisibleIsDynamic = isRowSelectableFunc || typeof this.getIsVisible() === "function";
    if (checkboxVisibleIsDynamic) {
      const showOrHideSelectListener = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: showOrHideSelectListener });
      this.addManagedListeners(this.rowNode, {
        dataChanged: showOrHideSelectListener,
        cellChanged: showOrHideSelectListener
      });
      this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  showOrHideSelect() {
    const { column, rowNode, overrides, gos } = this;
    let selectable = rowNode.selectable;
    const isVisible = this.getIsVisible();
    if (selectable) {
      if (typeof isVisible === "function") {
        const extraParams = overrides?.callbackParams;
        if (!column) {
          selectable = isVisible({ ...extraParams, node: rowNode, data: rowNode.data });
        } else {
          const params = column.createColumnFunctionCallbackParams(rowNode);
          selectable = isVisible({ ...extraParams, ...params });
        }
      } else {
        selectable = isVisible ?? false;
      }
    }
    const so = gos.get("rowSelection");
    const disableInsteadOfHide = so && typeof so !== "string" ? !_getHideDisabledCheckboxes(so) : column?.getColDef().showDisabledCheckboxes;
    if (disableInsteadOfHide) {
      this.eCheckbox.setDisabled(!selectable);
      this.setVisible(true);
      this.setDisplayed(true);
      return;
    }
    if (overrides?.removeHidden) {
      this.setDisplayed(selectable);
      return;
    }
    this.setVisible(selectable);
  }
  getIsVisible() {
    const overrides = this.overrides;
    if (overrides) {
      return overrides.isVisible;
    }
    const so = this.gos.get("rowSelection");
    if (so && typeof so !== "string") {
      return _getCheckboxes(so);
    }
    return this.column?.getColDef()?.checkboxSelection;
  }
};

// packages/ag-grid-community/src/selection/rowRangeSelectionContext.ts
var RowRangeSelectionContext = class {
  constructor(rowModel) {
    this.rootId = null;
    /**
     * Note that the "end" `RowNode` may come before or after the "root" `RowNode` in the
     * actual grid.
     */
    this.endId = null;
    this.cachedRange = [];
    this.rowModel = rowModel;
  }
  reset() {
    this.rootId = null;
    this.endId = null;
    this.cachedRange.length = 0;
  }
  setRoot(node) {
    this.rootId = node.id;
    this.endId = null;
    this.cachedRange.length = 0;
  }
  setEndRange(end) {
    this.endId = end.id;
    this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const root = this.getRoot();
      const end = this.getEnd();
      if (root == null || end == null) {
        return this.cachedRange;
      }
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(root, end) ?? [];
    }
    return this.cachedRange;
  }
  isInRange(node) {
    if (this.rootId === null) {
      return false;
    }
    return this.getRange().some((nodeInRange) => nodeInRange.id === node.id);
  }
  getRoot() {
    if (this.rootId) {
      return this.rowModel.getRowNode(this.rootId) ?? null;
    }
    return null;
  }
  getEnd() {
    if (this.endId) {
      return this.rowModel.getRowNode(this.endId) ?? null;
    }
    return null;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(node) {
    const range = this.getRange();
    if (range.length === 0) {
      return { keep: [], discard: [] };
    }
    const discardAfter = range[0].id === this.rootId;
    const idx = range.findIndex((rowNode) => rowNode.id === node.id);
    if (idx > -1) {
      const above = range.slice(0, idx);
      const below = range.slice(idx + 1);
      this.setEndRange(node);
      return discardAfter ? { keep: above, discard: below } : { keep: below, discard: above };
    } else {
      return { keep: range, discard: [] };
    }
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(node, groupSelectsChildren = false) {
    const root = this.getRoot();
    if (root == null) {
      const keep = this.getRange().slice();
      if (groupSelectsChildren) {
        node.depthFirstSearch((node2) => !node2.group && keep.push(node2));
      }
      keep.push(node);
      this.setRoot(node);
      return { keep, discard: [] };
    }
    const newRange = this.rowModel.getNodesInRangeForSelection(root, node);
    if (!newRange) {
      this.setRoot(node);
      return { keep: [node], discard: [] };
    }
    if (newRange.find((newRangeNode) => newRangeNode.id === this.endId)) {
      this.setEndRange(node);
      return { keep: this.getRange(), discard: [] };
    } else {
      const discard = this.getRange().slice();
      this.setEndRange(node);
      return { keep: this.getRange(), discard };
    }
  }
};

// packages/ag-grid-community/src/selection/selectAllFeature.ts
var SelectAllFeature = class extends BeanStub {
  constructor(column) {
    super();
    this.column = column;
    this.cbSelectAllVisible = false;
    this.processingEventFromCheckbox = false;
  }
  onSpaceKeyDown(e) {
    const checkbox = this.cbSelectAll;
    if (checkbox.isDisplayed() && !checkbox.getGui().contains(_getActiveDomElement(this.beans))) {
      e.preventDefault();
      checkbox.setValue(!checkbox.getValue());
    }
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(ctrl) {
    this.headerCellCtrl = ctrl;
    const cbSelectAll = this.createManagedBean(new AgCheckbox());
    this.cbSelectAll = cbSelectAll;
    cbSelectAll.addCssClass("ag-header-select-all");
    _setAriaRole(cbSelectAll.getGui(), "presentation");
    this.showOrHideSelectAll();
    this.addManagedEventListeners({
      newColumnsLoaded: this.showOrHideSelectAll.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: this.onSelectionChanged.bind(this),
      paginationChanged: this.onSelectionChanged.bind(this),
      modelUpdated: this.onModelChanged.bind(this)
    });
    this.addManagedListeners(cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) });
    cbSelectAll.getInputElement().setAttribute("tabindex", "-1");
    this.refreshSelectAllLabel();
  }
  onDisplayedColumnsChanged() {
    if (!this.isAlive()) {
      return;
    }
    this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    const cbSelectAllVisible = this.isCheckboxSelection();
    this.cbSelectAllVisible = cbSelectAllVisible;
    this.cbSelectAll.setDisplayed(cbSelectAllVisible);
    if (cbSelectAllVisible) {
      this.checkRightRowModelType("selectAllCheckbox");
      this.checkSelectionType("selectAllCheckbox");
      this.updateStateOfCheckbox();
    }
    this.refreshSelectAllLabel();
  }
  onModelChanged() {
    if (!this.cbSelectAllVisible) {
      return;
    }
    this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    if (!this.cbSelectAllVisible) {
      return;
    }
    this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox) {
      return;
    }
    this.processingEventFromCheckbox = true;
    const selectAllMode = this.getSelectAllMode();
    const selectionSvc = this.beans.selectionSvc;
    const cbSelectAll = this.cbSelectAll;
    const allSelected = selectionSvc.getSelectAllState(selectAllMode);
    cbSelectAll.setValue(allSelected);
    const hasNodesToSelect = selectionSvc.hasNodesToSelect(selectAllMode);
    cbSelectAll.setDisabled(!hasNodesToSelect);
    this.refreshSelectAllLabel();
    this.processingEventFromCheckbox = false;
  }
  refreshSelectAllLabel() {
    const translate = this.getLocaleTextFunc();
    const { headerCellCtrl, cbSelectAll, cbSelectAllVisible } = this;
    const checked = cbSelectAll.getValue();
    const ariaStatus = checked ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
    const ariaLabel = translate("ariaRowSelectAll", "Press Space to toggle all rows selection");
    headerCellCtrl.setAriaDescriptionProperty(
      "selectAll",
      cbSelectAllVisible ? `${ariaLabel} (${ariaStatus})` : null
    );
    cbSelectAll.setInputAriaLabel(translate("ariaHeaderSelection", "Column with Header Selection"));
    headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(feature) {
    const isMultiSelect = _isMultiRowSelection(this.gos);
    if (!isMultiSelect) {
      _warn(128, { feature });
      return false;
    }
    return true;
  }
  checkRightRowModelType(feature) {
    const { gos, rowModel } = this.beans;
    const rowModelMatches = _isClientSideRowModel(gos) || _isServerSideRowModel(gos);
    if (!rowModelMatches) {
      _warn(129, { feature, rowModel: rowModel.getType() });
      return false;
    }
    return true;
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox) {
      return;
    }
    if (!this.cbSelectAllVisible) {
      return;
    }
    const value = this.cbSelectAll.getValue();
    const selectAll2 = this.getSelectAllMode();
    let source = "uiSelectAll";
    if (selectAll2 === "currentPage") {
      source = "uiSelectAllCurrentPage";
    } else if (selectAll2 === "filtered") {
      source = "uiSelectAllFiltered";
    }
    const params = { source, selectAll: selectAll2 };
    const selectionSvc = this.beans.selectionSvc;
    if (value) {
      selectionSvc.selectAllRowNodes(params);
    } else {
      selectionSvc.deselectAllRowNodes(params);
    }
  }
  /**
   * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
   * or `headerCheckboxSelection` is enabled in the legacy API.
   */
  isCheckboxSelection() {
    const { column, gos, beans } = this;
    const rowSelection = gos.get("rowSelection");
    const colDef = column.getColDef();
    const { headerCheckboxSelection } = colDef;
    let result = false;
    const newHeaderCheckbox = typeof rowSelection === "object";
    if (newHeaderCheckbox) {
      const isSelectionCol = isColumnSelectionCol(column);
      const isAutoCol = isColumnGroupAutoCol(column);
      const location = _getCheckboxLocation(rowSelection);
      if (location === "autoGroupColumn" && isAutoCol || isSelectionCol && beans.selectionColSvc?.isSelectionColumnEnabled()) {
        result = _getHeaderCheckbox(rowSelection);
      }
    } else {
      if (typeof headerCheckboxSelection === "function") {
        result = headerCheckboxSelection(gos.addGridCommonParams({ column, colDef }));
      } else {
        result = !!headerCheckboxSelection;
      }
    }
    const featureName = newHeaderCheckbox ? "headerCheckbox" : "headerCheckboxSelection";
    return result && this.checkRightRowModelType(featureName) && this.checkSelectionType(featureName);
  }
  getSelectAllMode() {
    const selectAll2 = _getSelectAll(this.gos, false);
    if (selectAll2) {
      return selectAll2;
    }
    const { headerCheckboxSelectionCurrentPageOnly, headerCheckboxSelectionFilteredOnly } = this.column.getColDef();
    if (headerCheckboxSelectionCurrentPageOnly) {
      return "currentPage";
    }
    if (headerCheckboxSelectionFilteredOnly) {
      return "filtered";
    }
    return "all";
  }
};

// packages/ag-grid-community/src/selection/baseSelectionService.ts
var BaseSelectionService = class extends BeanStub {
  postConstruct() {
    const { gos, beans } = this;
    this.selectionCtx = new RowRangeSelectionContext(beans.rowModel);
    this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => {
      const callback = _getIsRowSelectable(gos);
      if (callback !== this.isRowSelectable) {
        this.isRowSelectable = callback;
        this.updateSelectable();
      }
    });
    this.isRowSelectable = _getIsRowSelectable(gos);
  }
  destroy() {
    super.destroy();
    this.selectionCtx.reset();
  }
  createCheckboxSelectionComponent() {
    return new CheckboxSelectionComponent();
  }
  createSelectAllFeature(column) {
    return new SelectAllFeature(column);
  }
  isMultiSelect() {
    return _isMultiRowSelection(this.gos);
  }
  onRowCtrlSelected(rowCtrl, hasFocusFunc, gui) {
    const selected = !!rowCtrl.rowNode.isSelected();
    rowCtrl.forEachGui(gui, (gui2) => {
      gui2.rowComp.addOrRemoveCssClass("ag-row-selected", selected);
      const element = gui2.element;
      _setAriaSelected(element, selected);
      const hasFocus = element.contains(_getActiveDomElement(this.beans));
      if (hasFocus) {
        hasFocusFunc(gui2);
      }
    });
  }
  announceAriaRowSelection(rowNode) {
    if (this.isRowSelectionBlocked(rowNode)) {
      return;
    }
    const selected = rowNode.isSelected();
    if (selected && !_getEnableDeselection(this.gos)) {
      return;
    }
    const translate = this.getLocaleTextFunc();
    const label = translate(
      selected ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${selected ? "deselect" : "select"} this row`
    );
    this.beans.ariaAnnounce?.announceValue(label, "rowSelection");
  }
  dispatchSelectionChanged(source) {
    this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source
    });
  }
  isRowSelectionBlocked(rowNode) {
    return !rowNode.selectable || !!rowNode.rowPinned || !_isRowSelection(this.gos);
  }
  updateRowSelectable(rowNode, suppressSelectionUpdate) {
    const selectable = this.isRowSelectable?.(rowNode) ?? true;
    this.setRowSelectable(rowNode, selectable, suppressSelectionUpdate);
    return selectable;
  }
  setRowSelectable(rowNode, newVal, suppressSelectionUpdate) {
    if (rowNode.selectable !== newVal) {
      rowNode.selectable = newVal;
      rowNode.dispatchRowEvent("selectableChanged");
      if (suppressSelectionUpdate) {
        return;
      }
      const isGroupSelectsChildren = _getGroupSelectsDescendants(this.gos);
      if (isGroupSelectsChildren) {
        const selected = this.calculateSelectedFromChildren(rowNode);
        this.setNodesSelected({ nodes: [rowNode], newValue: selected ?? false, source: "selectableChanged" });
        return;
      }
      if (rowNode.isSelected() && !rowNode.selectable) {
        this.setNodesSelected({ nodes: [rowNode], newValue: false, source: "selectableChanged" });
      }
    }
  }
  calculateSelectedFromChildren(rowNode) {
    let atLeastOneSelected = false;
    let atLeastOneDeSelected = false;
    if (!rowNode.childrenAfterGroup?.length) {
      return rowNode.selectable ? rowNode.__selected : null;
    }
    for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
      const child = rowNode.childrenAfterGroup[i];
      let childState = child.isSelected();
      if (!child.selectable) {
        const selectable = this.calculateSelectedFromChildren(child);
        if (selectable === null) {
          continue;
        }
        childState = selectable;
      }
      switch (childState) {
        case true:
          atLeastOneSelected = true;
          break;
        case false:
          atLeastOneDeSelected = true;
          break;
        default:
          return void 0;
      }
    }
    if (atLeastOneSelected && atLeastOneDeSelected) {
      return void 0;
    }
    if (atLeastOneSelected) {
      return true;
    }
    if (atLeastOneDeSelected) {
      return false;
    }
    if (!rowNode.selectable) {
      return null;
    }
    return rowNode.__selected;
  }
  selectRowNode(rowNode, newValue, e, source = "api") {
    const selectionNotAllowed = !rowNode.selectable && newValue;
    const selectionNotChanged = rowNode.__selected === newValue;
    if (selectionNotAllowed || selectionNotChanged) {
      return false;
    }
    rowNode.__selected = newValue;
    rowNode.dispatchRowEvent("rowSelected");
    const sibling = rowNode.sibling;
    if (sibling && sibling.footer && sibling.__localEventService) {
      sibling.dispatchRowEvent("rowSelected");
    }
    this.eventSvc.dispatchEvent({
      ..._createGlobalRowEvent(rowNode, this.gos, "rowSelected"),
      event: e || null,
      source
    });
    return true;
  }
  isCellCheckboxSelection(column, rowNode) {
    const so = this.gos.get("rowSelection");
    if (so && typeof so !== "string") {
      const checkbox = isColumnSelectionCol(column) && _getCheckboxes(so);
      return column.isColumnFunc(rowNode, checkbox);
    } else {
      return column.isColumnFunc(rowNode, column.colDef.checkboxSelection);
    }
  }
  inferNodeSelections(node, shiftKey, metaKey, source) {
    const { gos, selectionCtx } = this;
    const currentSelection = node.isSelected();
    const groupSelectsDescendants = _getGroupSelectsDescendants(gos);
    const enableClickSelection = _getEnableSelection(gos);
    const enableDeselection = _getEnableDeselection(gos);
    const isRowClicked = source === "rowClicked";
    if (isRowClicked && groupSelectsDescendants && node.group)
      return null;
    if (isRowClicked && !(enableClickSelection || enableDeselection))
      return null;
    if (shiftKey && metaKey && this.isMultiSelect()) {
      const root = selectionCtx.getRoot();
      if (!root) {
        return null;
      } else if (!root.isSelected()) {
        const partition = selectionCtx.extend(node, groupSelectsDescendants);
        return {
          select: [],
          deselect: partition.keep,
          reset: false
        };
      } else {
        const partition = selectionCtx.isInRange(node) ? selectionCtx.truncate(node) : selectionCtx.extend(node, groupSelectsDescendants);
        return {
          deselect: partition.discard,
          select: partition.keep,
          reset: false
        };
      }
    } else if (shiftKey && this.isMultiSelect()) {
      const root = selectionCtx.getRoot();
      const partition = selectionCtx.isInRange(node) ? selectionCtx.truncate(node) : selectionCtx.extend(node, groupSelectsDescendants);
      return {
        select: partition.keep,
        deselect: partition.discard,
        reset: !!(root && !root.isSelected())
      };
    } else if (metaKey) {
      selectionCtx.setRoot(node);
      if (isRowClicked && currentSelection && !enableDeselection) {
        return null;
      }
      return {
        node,
        newValue: currentSelection ? false : true,
        clearSelection: !this.isMultiSelect()
      };
    } else {
      selectionCtx.setRoot(node);
      const enableSelectionWithoutKeys = _getEnableSelectionWithoutKeys(gos);
      const groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
      const shouldClear = isRowClicked && (!enableSelectionWithoutKeys || !enableClickSelection);
      if (groupSelectsFiltered && currentSelection === void 0 && _isClientSideRowModel(gos)) {
        return {
          node,
          newValue: false,
          clearSelection: !this.isMultiSelect() || shouldClear
        };
      }
      if (isRowClicked) {
        const newValue = currentSelection ? !enableSelectionWithoutKeys : enableClickSelection;
        if (newValue === currentSelection)
          return null;
        return {
          node,
          newValue,
          clearSelection: !this.isMultiSelect() || shouldClear
        };
      }
      return {
        node,
        newValue: !currentSelection,
        clearSelection: !this.isMultiSelect() || shouldClear
      };
    }
  }
};

// packages/ag-grid-community/src/widgets/agRadioButton.ts
var AgRadioButton = class extends AgCheckbox {
  constructor(config) {
    super(config, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    if (this.eInput.disabled) {
      return;
    }
    if (!this.isSelected()) {
      this.setValue(true);
    }
  }
  addInputListeners() {
    super.addInputListeners();
    this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(event) {
    const eInput = this.eInput;
    if (event.selected && event.name && eInput.name && eInput.name === event.name && event.id && eInput.id !== event.id) {
      this.setValue(false, true);
    }
  }
};

// packages/ag-grid-community/src/widgets/agToggleButton.css-GENERATED.ts
var agToggleButtonCSS = (
  /*css*/
  `.ag-toggle-button{flex:none;min-width:unset;width:unset}.ag-toggle-button-input-wrapper{background-color:var(--ag-toggle-button-off-background-color);border-radius:calc(var(--ag-toggle-button-height)*.5);flex:none;height:var(--ag-toggle-button-height);max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);position:relative;transition:background-color .1s;:where(.ag-toggle-button-input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-toggle-button-height);margin:0;max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);opacity:0}&:before{background-color:var(--ag-toggle-button-switch-background-color);border-radius:100%;content:"";display:block;height:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2);left:var(--ag-toggle-button-switch-inset);pointer-events:none;position:absolute;top:var(--ag-toggle-button-switch-inset);transition:left .1s;width:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2)}&.ag-checked{background-color:var(--ag-toggle-button-on-background-color);&:before{left:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-switch-inset))}}&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{opacity:.5}}`
);

// packages/ag-grid-community/src/widgets/agToggleButton.ts
var AgToggleButton = class extends AgCheckbox {
  constructor(config) {
    super(config, "ag-toggle-button");
    this.registerCSS(agToggleButtonCSS);
  }
  setValue(value, silent) {
    super.setValue(value, silent);
    this.addOrRemoveCssClass("ag-selected", this.getValue());
    return this;
  }
};
var AgToggleButtonSelector = {
  selector: "AG-TOGGLE-BUTTON",
  component: AgToggleButton
};

// packages/ag-grid-community/src/widgets/agInputTextField.ts
var AgInputTextField = class extends AgAbstractInputField {
  constructor(config, className = "ag-text-field", inputType = "text") {
    super(config, className, inputType);
  }
  postConstruct() {
    super.postConstruct();
    if (this.config.allowedCharPattern) {
      this.preventDisallowedCharacters();
    }
  }
  setValue(value, silent) {
    const eInput = this.eInput;
    if (eInput.value !== value) {
      eInput.value = _exists(value) ? value : "";
    }
    return super.setValue(value, silent);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(value) {
    this.setValue(value, true);
  }
  preventDisallowedCharacters() {
    const pattern = new RegExp(`[${this.config.allowedCharPattern}]`);
    const preventCharacters = (event) => {
      if (!_isEventFromPrintableCharacter(event)) {
        return;
      }
      if (event.key && !pattern.test(event.key)) {
        event.preventDefault();
      }
    };
    this.addManagedListeners(this.eInput, {
      keydown: preventCharacters,
      paste: (e) => {
        const text = e.clipboardData?.getData("text");
        if (text && text.split("").some((c) => !pattern.test(c))) {
          e.preventDefault();
        }
      }
    });
  }
};
var AgInputTextFieldSelector = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: AgInputTextField
};

// packages/ag-grid-community/src/widgets/agInputTextArea.ts
var AgInputTextArea = class extends AgAbstractInputField {
  constructor(config) {
    super(config, "ag-text-area", null, "textarea");
  }
  setValue(value, silent) {
    const ret = super.setValue(value, silent);
    this.eInput.value = value;
    return ret;
  }
  setCols(cols) {
    this.eInput.cols = cols;
    return this;
  }
  setRows(rows) {
    this.eInput.rows = rows;
    return this;
  }
};
var AgInputTextAreaSelector = {
  selector: "AG-INPUT-TEXT-AREA",
  component: AgInputTextArea
};

// packages/ag-grid-community/src/widgets/agInputNumberField.ts
var AgInputNumberField = class extends AgInputTextField {
  constructor(config) {
    super(config, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct();
    const eInput = this.eInput;
    this.addManagedListeners(eInput, {
      blur: () => {
        const floatedValue = parseFloat(eInput.value);
        const value = isNaN(floatedValue) ? "" : this.normalizeValue(floatedValue.toString());
        if (this.value !== value) {
          this.setValue(value);
        }
      },
      wheel: this.onWheel.bind(this)
    });
    eInput.step = "any";
    const { precision, min, max, step } = this.config;
    if (typeof precision === "number")
      this.setPrecision(precision);
    if (typeof min === "number")
      this.setMin(min);
    if (typeof max === "number")
      this.setMax(max);
    if (typeof step === "number")
      this.setStep(step);
  }
  onWheel(e) {
    if (_getActiveDomElement(this.beans) === this.eInput) {
      e.preventDefault();
    }
  }
  normalizeValue(value) {
    if (value === "") {
      return "";
    }
    if (this.precision != null) {
      value = this.adjustPrecision(value);
    }
    const val = parseFloat(value);
    const { min, max } = this;
    if (min != null && val < min) {
      value = min.toString();
    } else if (max != null && val > max) {
      value = max.toString();
    }
    return value;
  }
  adjustPrecision(value, isScientificNotation) {
    const precision = this.precision;
    if (precision == null) {
      return value;
    }
    if (isScientificNotation) {
      const floatString = parseFloat(value).toFixed(precision);
      return parseFloat(floatString).toString();
    }
    const parts = String(value).split(".");
    if (parts.length > 1) {
      if (parts[1].length <= precision) {
        return value;
      } else if (precision > 0) {
        return `${parts[0]}.${parts[1].slice(0, precision)}`;
      }
    }
    return parts[0];
  }
  setMin(min) {
    if (this.min === min) {
      return this;
    }
    this.min = min;
    _addOrRemoveAttribute(this.eInput, "min", min);
    return this;
  }
  setMax(max) {
    if (this.max === max) {
      return this;
    }
    this.max = max;
    _addOrRemoveAttribute(this.eInput, "max", max);
    return this;
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  setStep(step) {
    if (this.step === step) {
      return this;
    }
    this.step = step;
    _addOrRemoveAttribute(this.eInput, "step", step);
    return this;
  }
  setValue(value, silent) {
    return this.setValueOrInputValue(
      (v) => super.setValue(v, silent),
      () => this,
      value
    );
  }
  setStartValue(value) {
    return this.setValueOrInputValue(
      (v) => super.setValue(v, true),
      (v) => {
        this.eInput.value = v;
      },
      value
    );
  }
  setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
    if (_exists(value)) {
      let setInputValueOnly = this.isScientificNotation(value);
      if (setInputValueOnly && this.eInput.validity.valid) {
        return setValueFunc(value);
      }
      if (!setInputValueOnly) {
        value = this.adjustPrecision(value);
        const normalizedValue = this.normalizeValue(value);
        setInputValueOnly = value != normalizedValue;
      }
      if (setInputValueOnly) {
        return setInputValueOnlyFunc(value);
      }
    }
    return setValueFunc(value);
  }
  getValue() {
    const eInput = this.eInput;
    if (!eInput.validity.valid) {
      return void 0;
    }
    const inputValue = eInput.value;
    if (this.isScientificNotation(inputValue)) {
      return this.adjustPrecision(inputValue, true);
    }
    return super.getValue();
  }
  isScientificNotation(value) {
    return typeof value === "string" && value.includes("e");
  }
};
var AgInputNumberFieldSelector = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: AgInputNumberField
};

// packages/ag-grid-community/src/utils/date.ts
function _padStartWidthZeros(value, totalStringSize) {
  return value.toString().padStart(totalStringSize, "0");
}
function _serialiseDate(date, includeTime = true, separator = "-") {
  if (!date) {
    return null;
  }
  let serialised = [date.getFullYear(), date.getMonth() + 1, date.getDate()].map((part) => _padStartWidthZeros(part, 2)).join(separator);
  if (includeTime) {
    serialised += " " + [date.getHours(), date.getMinutes(), date.getSeconds()].map((part) => _padStartWidthZeros(part, 2)).join(":");
  }
  return serialised;
}
var calculateOrdinal = (value) => {
  if (value > 3 && value < 21) {
    return "th";
  }
  const remainder = value % 10;
  switch (remainder) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function _dateToFormattedString(date, format = "YYYY-MM-DD") {
  const fullYear = _padStartWidthZeros(date.getFullYear(), 4);
  const months = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const replace = {
    YYYY: () => fullYear.slice(fullYear.length - 4, fullYear.length),
    YY: () => fullYear.slice(fullYear.length - 2, fullYear.length),
    Y: () => `${date.getFullYear()}`,
    MMMM: () => months[date.getMonth()],
    MMM: () => months[date.getMonth()].slice(0, 3),
    MM: () => _padStartWidthZeros(date.getMonth() + 1, 2),
    Mo: () => `${date.getMonth() + 1}${calculateOrdinal(date.getMonth() + 1)}`,
    M: () => `${date.getMonth() + 1}`,
    Do: () => `${date.getDate()}${calculateOrdinal(date.getDate())}`,
    DD: () => _padStartWidthZeros(date.getDate(), 2),
    D: () => `${date.getDate()}`,
    dddd: () => days[date.getDay()],
    ddd: () => days[date.getDay()].slice(0, 3),
    dd: () => days[date.getDay()].slice(0, 2),
    do: () => `${date.getDay()}${calculateOrdinal(date.getDay())}`,
    d: () => `${date.getDay()}`
  };
  const regexp = new RegExp(Object.keys(replace).join("|"), "g");
  return format.replace(regexp, (match) => {
    if (match in replace) {
      return replace[match]();
    }
    return match;
  });
}
function _parseDateTimeFromString(value) {
  if (!value) {
    return null;
  }
  const [dateStr, timeStr] = value.split(" ");
  if (!dateStr) {
    return null;
  }
  const fields = dateStr.split("-").map((f) => parseInt(f, 10));
  if (fields.filter((f) => !isNaN(f)).length !== 3) {
    return null;
  }
  const [year, month, day] = fields;
  const date = new Date(year, month - 1, day);
  if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
    return null;
  }
  if (!timeStr || timeStr === "00:00:00") {
    return date;
  }
  const [hours, minutes, seconds] = timeStr.split(":").map((part) => parseInt(part, 10));
  if (hours >= 0 && hours < 24) {
    date.setHours(hours);
  }
  if (minutes >= 0 && minutes < 60) {
    date.setMinutes(minutes);
  }
  if (seconds >= 0 && seconds < 60) {
    date.setSeconds(seconds);
  }
  return date;
}

// packages/ag-grid-community/src/widgets/agInputDateField.ts
var AgInputDateField = class extends AgInputTextField {
  constructor(config) {
    super(config, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const usingSafari = _isBrowserSafari();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        if (this.isDisabled() || usingSafari) {
          return;
        }
        this.eInput.focus();
      }
    });
    this.eInput.step = "any";
  }
  onWheel(e) {
    if (_getActiveDomElement(this.beans) === this.eInput) {
      e.preventDefault();
    }
  }
  setMin(minDate) {
    const min = minDate instanceof Date ? _serialiseDate(minDate ?? null, false) ?? void 0 : minDate;
    if (this.min === min) {
      return this;
    }
    this.min = min;
    _addOrRemoveAttribute(this.eInput, "min", min);
    return this;
  }
  setMax(maxDate) {
    const max = maxDate instanceof Date ? _serialiseDate(maxDate ?? null, false) ?? void 0 : maxDate;
    if (this.max === max) {
      return this;
    }
    this.max = max;
    _addOrRemoveAttribute(this.eInput, "max", max);
    return this;
  }
  setStep(step) {
    if (this.step === step) {
      return this;
    }
    this.step = step;
    _addOrRemoveAttribute(this.eInput, "step", step);
    return this;
  }
  getDate() {
    if (!this.eInput.validity.valid) {
      return void 0;
    }
    return _parseDateTimeFromString(this.getValue()) ?? void 0;
  }
  setDate(date, silent) {
    this.setValue(_serialiseDate(date ?? null, false), silent);
  }
};
var AgInputDateFieldSelector = {
  selector: "AG-INPUT-DATE-FIELD",
  component: AgInputDateField
};

// packages/ag-grid-community/src/tooltip/tooltipStateManager.ts
var SHOW_QUICK_TOOLTIP_DIFF = 1e3;
var FADE_OUT_TOOLTIP_TIMEOUT = 1e3;
var INTERACTIVE_HIDE_DELAY = 100;
var lastTooltipHideTime;
var isLocked = false;
var TooltipStateManager = class extends BeanStub {
  constructor(tooltipCtrl, getTooltipValue) {
    super();
    this.tooltipCtrl = tooltipCtrl;
    this.getTooltipValue = getTooltipValue;
    this.interactionEnabled = false;
    this.isInteractingWithTooltip = false;
    this.state = 0 /* NOTHING */;
    // when showing the tooltip, we need to make sure it's the most recent instance we request, as due to
    // async we could request two tooltips before the first instance returns, in which case we should
    // disregard the second instance.
    this.tooltipInstanceCount = 0;
    this.tooltipMouseTrack = false;
  }
  wireBeans(beans) {
    this.popupSvc = beans.popupSvc;
    this.userCompFactory = beans.userCompFactory;
  }
  postConstruct() {
    if (this.gos.get("tooltipInteraction")) {
      this.interactionEnabled = true;
    }
    this.tooltipTrigger = this.getTooltipTrigger();
    this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const el = this.tooltipCtrl.getGui();
    if (this.tooltipTrigger === 0 /* HOVER */) {
      this.addManagedListeners(el, {
        mouseenter: this.onMouseEnter.bind(this),
        mouseleave: this.onMouseLeave.bind(this)
      });
    }
    if (this.tooltipTrigger === 1 /* FOCUS */) {
      this.addManagedListeners(el, {
        focusin: this.onFocusIn.bind(this),
        focusout: this.onFocusOut.bind(this)
      });
    }
    this.addManagedListeners(el, { mousemove: this.onMouseMove.bind(this) });
    if (!this.interactionEnabled) {
      this.addManagedListeners(el, {
        mousedown: this.onMouseDown.bind(this),
        keydown: this.onKeyDown.bind(this)
      });
    }
  }
  getGridOptionsTooltipDelay(delayOption) {
    const delay = this.gos.get(delayOption);
    return Math.max(200, delay);
  }
  getTooltipDelay(type) {
    if (type === "show") {
      return this.tooltipCtrl.getTooltipShowDelayOverride?.() ?? this.getGridOptionsTooltipDelay("tooltipShowDelay");
    }
    return this.tooltipCtrl.getTooltipHideDelayOverride?.() ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing();
    super.destroy();
  }
  getTooltipTrigger() {
    const trigger = this.gos.get("tooltipTrigger");
    if (!trigger || trigger === "hover") {
      return 0 /* HOVER */;
    }
    return 1 /* FOCUS */;
  }
  onMouseEnter(e) {
    if (this.interactionEnabled && this.interactiveTooltipTimeoutId) {
      this.unlockService();
      this.startHideTimeout();
    }
    if (_isIOSUserAgent()) {
      return;
    }
    if (isLocked) {
      this.showTooltipTimeoutId = window.setTimeout(() => {
        this.prepareToShowTooltip(e);
      }, INTERACTIVE_HIDE_DELAY);
    } else {
      this.prepareToShowTooltip(e);
    }
  }
  onMouseMove(e) {
    if (this.lastMouseEvent) {
      this.lastMouseEvent = e;
    }
    if (this.tooltipMouseTrack && this.state === 2 /* SHOWING */ && this.tooltipComp) {
      this.positionTooltip();
    }
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    if (this.interactionEnabled) {
      this.lockService();
    } else {
      this.setToDoNothing();
    }
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(e) {
    const relatedTarget = e.relatedTarget;
    const parentCompGui = this.tooltipCtrl.getGui();
    const tooltipGui = this.tooltipComp?.getGui();
    if (this.isInteractingWithTooltip || parentCompGui.contains(relatedTarget) || this.interactionEnabled && tooltipGui?.contains(relatedTarget)) {
      return;
    }
    this.setToDoNothing();
  }
  onKeyDown() {
    if (this.isInteractingWithTooltip) {
      this.isInteractingWithTooltip = false;
    }
    this.setToDoNothing();
  }
  prepareToShowTooltip(mouseEvent) {
    if (this.state != 0 /* NOTHING */ || isLocked) {
      return;
    }
    let delay = 0;
    if (mouseEvent) {
      delay = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show");
    }
    this.lastMouseEvent = mouseEvent || null;
    this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
    this.state = 1 /* WAITING_TO_SHOW */;
  }
  isLastTooltipHiddenRecently() {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const then = lastTooltipHideTime;
    return now - then < SHOW_QUICK_TOOLTIP_DIFF;
  }
  setToDoNothing(fromHideTooltip) {
    if (!fromHideTooltip && this.state === 2 /* SHOWING */) {
      this.hideTooltip();
    }
    if (this.onBodyScrollEventCallback) {
      this.onBodyScrollEventCallback();
      this.onBodyScrollEventCallback = void 0;
    }
    if (this.onColumnMovedEventCallback) {
      this.onColumnMovedEventCallback();
      this.onColumnMovedEventCallback = void 0;
    }
    if (this.onDocumentKeyDownCallback) {
      this.onDocumentKeyDownCallback();
      this.onDocumentKeyDownCallback = void 0;
    }
    this.clearTimeouts();
    this.state = 0 /* NOTHING */;
    this.lastMouseEvent = null;
  }
  showTooltip() {
    const value = this.getTooltipValue();
    const ctrl = this.tooltipCtrl;
    if (!_exists(value) || ctrl.shouldDisplayTooltip && !ctrl.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    const rowNode = ctrl.getRowNode?.();
    const params = {
      location: ctrl.getLocation?.() ?? "UNKNOWN",
      //'cell',
      colDef: ctrl.getColDef?.(),
      column: ctrl.getColumn?.(),
      rowIndex: ctrl.getRowIndex?.(),
      node: rowNode,
      data: rowNode?.data,
      value,
      valueFormatted: ctrl.getValueFormatted?.(),
      hideTooltipCallback: () => this.hideTooltip(true),
      ...ctrl.getAdditionalParams?.() ?? {}
    };
    this.state = 2 /* SHOWING */;
    this.tooltipInstanceCount++;
    const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    const userDetails = _getTooltipCompDetails(this.userCompFactory, params);
    userDetails?.newAgStackInstance().then(callback);
  }
  hideTooltip(forceHide) {
    if (!forceHide && this.isInteractingWithTooltip) {
      return;
    }
    if (this.tooltipComp) {
      this.destroyTooltipComp();
      lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime();
    }
    this.eventSvc.dispatchEvent({
      type: "tooltipHide",
      parentGui: this.tooltipCtrl.getGui()
    });
    if (forceHide) {
      this.isInteractingWithTooltip = false;
    }
    this.setToDoNothing(true);
  }
  newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
    const compNoLongerNeeded = this.state !== 2 /* SHOWING */ || this.tooltipInstanceCount !== tooltipInstanceCopy;
    if (compNoLongerNeeded) {
      this.destroyBean(tooltipComp);
      return;
    }
    const eGui = tooltipComp.getGui();
    this.tooltipComp = tooltipComp;
    if (!eGui.classList.contains("ag-tooltip")) {
      eGui.classList.add("ag-tooltip-custom");
    }
    if (this.tooltipTrigger === 0 /* HOVER */) {
      eGui.classList.add("ag-tooltip-animate");
    }
    if (this.interactionEnabled) {
      eGui.classList.add("ag-tooltip-interactive");
    }
    const translate = this.getLocaleTextFunc();
    const addPopupRes = this.popupSvc?.addPopup({
      eChild: eGui,
      ariaLabel: translate("ariaLabelTooltip", "Tooltip")
    });
    if (addPopupRes) {
      this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
    }
    this.positionTooltip();
    if (this.tooltipTrigger === 1 /* FOCUS */) {
      const listener = () => this.setToDoNothing();
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
        bodyScroll: listener,
        columnMoved: listener
      });
    }
    if (this.interactionEnabled) {
      [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(eGui, {
        mouseenter: this.onTooltipMouseEnter.bind(this),
        mouseleave: this.onTooltipMouseLeave.bind(this)
      });
      [this.onDocumentKeyDownCallback] = this.addManagedElementListeners(_getDocument(this.beans), {
        keydown: (e) => {
          if (!eGui.contains(e?.target)) {
            this.onKeyDown();
          }
        }
      });
      if (this.tooltipTrigger === 1 /* FOCUS */) {
        [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(eGui, {
          focusin: this.onTooltipFocusIn.bind(this),
          focusout: this.onTooltipFocusOut.bind(this)
        });
      }
    }
    this.eventSvc.dispatchEvent({
      type: "tooltipShow",
      tooltipGui: eGui,
      parentGui: this.tooltipCtrl.getGui()
    });
    this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = true;
    this.unlockService();
  }
  onTooltipMouseLeave() {
    if (this.isTooltipFocused()) {
      return;
    }
    this.isInteractingWithTooltip = false;
    this.lockService();
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = true;
  }
  isTooltipFocused() {
    const tooltipGui = this.tooltipComp?.getGui();
    const activeEl = _getActiveDomElement(this.beans);
    return !!tooltipGui && tooltipGui.contains(activeEl);
  }
  onTooltipFocusOut(e) {
    const parentGui = this.tooltipCtrl.getGui();
    if (this.isTooltipFocused()) {
      return;
    }
    this.isInteractingWithTooltip = false;
    if (parentGui.contains(e.relatedTarget)) {
      this.startHideTimeout();
    } else {
      this.hideTooltip();
    }
  }
  positionTooltip() {
    const params = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    if (this.lastMouseEvent) {
      this.popupSvc?.positionPopupUnderMouseEvent({
        ...params,
        mouseEvent: this.lastMouseEvent
      });
    } else {
      this.popupSvc?.positionPopupByComponent({
        ...params,
        eventSource: this.tooltipCtrl.getGui(),
        position: "under",
        keepWithinBounds: true,
        nudgeY: 5
      });
    }
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
    const tooltipComp = this.tooltipComp;
    const delay = this.tooltipTrigger === 0 /* HOVER */ ? FADE_OUT_TOOLTIP_TIMEOUT : 0;
    window.setTimeout(() => {
      tooltipPopupDestroyFunc();
      this.destroyBean(tooltipComp);
    }, delay);
    this.clearTooltipListeners();
    this.tooltipPopupDestroyFunc = void 0;
    this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((listener) => {
      if (listener) {
        listener();
      }
    });
    this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    isLocked = true;
    this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService();
      this.setToDoNothing();
    }, INTERACTIVE_HIDE_DELAY);
  }
  unlockService() {
    isLocked = false;
    this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout();
    this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    if (!this.showTooltipTimeoutId) {
      return;
    }
    window.clearTimeout(this.showTooltipTimeoutId);
    this.showTooltipTimeoutId = void 0;
  }
  clearHideTimeout() {
    if (!this.hideTooltipTimeoutId) {
      return;
    }
    window.clearTimeout(this.hideTooltipTimeoutId);
    this.hideTooltipTimeoutId = void 0;
  }
  clearInteractiveTimeout() {
    if (!this.interactiveTooltipTimeoutId) {
      return;
    }
    window.clearTimeout(this.interactiveTooltipTimeoutId);
    this.interactiveTooltipTimeoutId = void 0;
  }
  clearTimeouts() {
    this.clearShowTimeout();
    this.clearHideTimeout();
    this.clearInteractiveTimeout();
  }
};

// packages/ag-grid-community/src/tooltip/tooltipFeature.ts
function _isShowTooltipWhenTruncated(gos) {
  return gos.get("tooltipShowMode") === "whenTruncated";
}
function _getShouldDisplayTooltip(gos, getElement) {
  return _isShowTooltipWhenTruncated(gos) ? _shouldDisplayTooltip(getElement) : void 0;
}
function _shouldDisplayTooltip(getElement) {
  return () => {
    const element = getElement();
    if (!element) {
      return true;
    }
    return element.scrollWidth > element.clientWidth;
  };
}
var TooltipFeature = class extends BeanStub {
  constructor(ctrl, beans) {
    super();
    this.ctrl = ctrl;
    if (beans) {
      this.beans = beans;
    }
  }
  postConstruct() {
    this.refreshTooltip();
  }
  setBrowserTooltip(tooltip) {
    const name = "title";
    const eGui = this.ctrl.getGui();
    if (!eGui) {
      return;
    }
    if (tooltip != null && tooltip != "") {
      eGui.setAttribute(name, tooltip);
    } else {
      eGui.removeAttribute(name);
    }
  }
  updateTooltipText() {
    const { getTooltipValue } = this.ctrl;
    if (getTooltipValue) {
      this.tooltip = getTooltipValue();
    }
  }
  createTooltipFeatureIfNeeded() {
    if (this.tooltipManager == null) {
      this.tooltipManager = this.createBean(
        new TooltipStateManager(this.ctrl, () => this.tooltip),
        this.beans.context
      );
    }
  }
  setTooltipAndRefresh(tooltip) {
    this.tooltip = tooltip;
    this.refreshTooltip();
  }
  refreshTooltip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips");
    this.updateTooltipText();
    if (this.browserTooltips) {
      this.setBrowserTooltip(this.tooltip);
      this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
    } else {
      this.setBrowserTooltip(null);
      this.createTooltipFeatureIfNeeded();
    }
  }
  destroy() {
    this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
    super.destroy();
  }
};

// packages/ag-grid-community/src/widgets/agList.ts
var AgList = class extends Component {
  constructor(cssIdentifier = "default", unFocusable = false) {
    super(
      /* html */
      `<div class="ag-list ag-${cssIdentifier}-list" role="listbox"></div>`
    );
    this.cssIdentifier = cssIdentifier;
    this.unFocusable = unFocusable;
    this.activeClass = "ag-active-item";
    this.options = [];
    this.itemEls = [];
  }
  postConstruct() {
    const eGui = this.getGui();
    this.addManagedElementListeners(eGui, { mouseleave: () => this.clearHighlighted() });
    if (this.unFocusable) {
      return;
    }
    this.addManagedElementListeners(eGui, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const key = e.key;
    switch (key) {
      case KeyCode.ENTER:
        if (!this.highlightedEl) {
          this.setValue(this.getValue());
        } else {
          const pos = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(pos);
        }
        break;
      case KeyCode.DOWN:
      case KeyCode.UP:
        e.preventDefault();
        this.navigate(key);
        break;
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        e.preventDefault();
        this.navigateToPage(key);
        break;
    }
  }
  navigate(key) {
    const isDown = key === KeyCode.DOWN;
    let itemToHighlight;
    const { itemEls, highlightedEl } = this;
    if (!highlightedEl) {
      itemToHighlight = itemEls[isDown ? 0 : itemEls.length - 1];
    } else {
      const currentIdx = itemEls.indexOf(highlightedEl);
      let nextPos = currentIdx + (isDown ? 1 : -1);
      nextPos = Math.min(Math.max(nextPos, 0), itemEls.length - 1);
      itemToHighlight = itemEls[nextPos];
    }
    this.highlightItem(itemToHighlight);
  }
  navigateToPage(key) {
    const { itemEls, highlightedEl } = this;
    if (!highlightedEl || itemEls.length === 0) {
      return;
    }
    const currentIdx = itemEls.indexOf(highlightedEl);
    const rowCount = this.options.length - 1;
    const itemHeight = itemEls[0].clientHeight;
    const pageSize = Math.floor(this.getGui().clientHeight / itemHeight);
    let newIndex = -1;
    if (key === KeyCode.PAGE_HOME) {
      newIndex = 0;
    } else if (key === KeyCode.PAGE_END) {
      newIndex = rowCount;
    } else if (key === KeyCode.PAGE_DOWN) {
      newIndex = Math.min(currentIdx + pageSize, rowCount);
    } else if (key === KeyCode.PAGE_UP) {
      newIndex = Math.max(currentIdx - pageSize, 0);
    }
    if (newIndex === -1) {
      return;
    }
    this.highlightItem(itemEls[newIndex]);
  }
  addOptions(listOptions) {
    listOptions.forEach((listOption) => this.addOption(listOption));
    return this;
  }
  addOption(listOption) {
    const { value, text } = listOption;
    const valueToRender = text || value;
    this.options.push({ value, text: valueToRender });
    this.renderOption(value, valueToRender);
    this.updateIndices();
    return this;
  }
  clearOptions() {
    this.options = [];
    this.reset(true);
    this.itemEls.forEach((itemEl) => {
      _removeFromParent(itemEl);
    });
    this.itemEls = [];
  }
  updateIndices() {
    const options = this.getGui().querySelectorAll(".ag-list-item");
    options.forEach((option, idx) => {
      _setAriaPosInSet(option, idx + 1);
      _setAriaSetSize(option, options.length);
    });
  }
  renderOption(value, text) {
    const eDocument = _getDocument(this.beans);
    const itemEl = eDocument.createElement("div");
    _setAriaRole(itemEl, "option");
    itemEl.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const span = eDocument.createElement("span");
    itemEl.appendChild(span);
    span.textContent = text;
    if (!this.unFocusable) {
      itemEl.tabIndex = -1;
    }
    this.itemEls.push(itemEl);
    this.addManagedListeners(itemEl, {
      mouseover: () => this.highlightItem(itemEl),
      mousedown: (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.setValue(value);
      }
    });
    this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", false, {
        getTooltipValue: () => text,
        getGui: () => itemEl,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => span.scrollWidth > span.clientWidth
      })
    );
    this.getGui().appendChild(itemEl);
  }
  setValue(value, silent) {
    if (this.value === value) {
      this.fireItemSelected();
      return this;
    }
    if (value == null) {
      this.reset(silent);
      return this;
    }
    const idx = this.options.findIndex((option) => option.value === value);
    if (idx !== -1) {
      const option = this.options[idx];
      this.value = option.value;
      this.displayValue = option.text;
      this.highlightItem(this.itemEls[idx]);
      if (!silent) {
        this.fireChangeEvent();
      }
    }
    return this;
  }
  setValueByIndex(idx) {
    return this.setValue(this.options[idx].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const idx = this.options.findIndex((option) => option.value === this.value);
    if (idx !== -1) {
      this.highlightItem(this.itemEls[idx]);
    }
  }
  reset(silent) {
    this.value = null;
    this.displayValue = null;
    this.clearHighlighted();
    if (!silent) {
      this.fireChangeEvent();
    }
  }
  highlightItem(el) {
    if (!_isVisible(el)) {
      return;
    }
    this.clearHighlighted();
    this.highlightedEl = el;
    el.classList.add(this.activeClass);
    _setAriaSelected(el, true);
    const eGui = this.getGui();
    const { scrollTop, clientHeight } = eGui;
    const { offsetTop, offsetHeight } = el;
    if (offsetTop + offsetHeight > scrollTop + clientHeight || offsetTop < scrollTop) {
      el.scrollIntoView({ block: "nearest" });
    }
    if (!this.unFocusable) {
      el.focus();
    }
  }
  clearHighlighted() {
    const highlightedEl = this.highlightedEl;
    if (!highlightedEl || !_isVisible(highlightedEl)) {
      return;
    }
    highlightedEl.classList.remove(this.activeClass);
    _setAriaSelected(highlightedEl, false);
    this.highlightedEl = null;
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" });
    this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
};

// packages/ag-grid-community/src/widgets/agPickerField.css-GENERATED.ts
var agPickerFieldCSS = (
  /*css*/
  `.ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:disabled{opacity:.5}&.ag-picker-has-focus,&:focus-within{border:var(--ag-input-focus-border);box-shadow:var(--ag-focus-shadow)}}.ag-picker-field-button{background-color:var(--ag-background-color)}`
);

// packages/ag-grid-community/src/widgets/agPickerField.ts
var AgPickerField = class extends AgAbstractField {
  constructor(config) {
    super(
      config,
      config?.template || /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      config?.agComponents || [],
      config?.className
    );
    this.isPickerDisplayed = false;
    this.skipClick = false;
    this.pickerGap = 4;
    this.hideCurrentPicker = null;
    this.eLabel = RefPlaceholder;
    this.eWrapper = RefPlaceholder;
    this.eDisplayField = RefPlaceholder;
    this.eIcon = RefPlaceholder;
    this.registerCSS(agPickerFieldCSS);
    this.ariaRole = config?.ariaRole;
    this.onPickerFocusIn = this.onPickerFocusIn.bind(this);
    this.onPickerFocusOut = this.onPickerFocusOut.bind(this);
    if (!config) {
      return;
    }
    const { pickerGap, maxPickerHeight, variableWidth, minPickerWidth, maxPickerWidth } = config;
    if (pickerGap != null) {
      this.pickerGap = pickerGap;
    }
    this.variableWidth = !!variableWidth;
    if (maxPickerHeight != null) {
      this.setPickerMaxHeight(maxPickerHeight);
    }
    if (minPickerWidth != null) {
      this.setPickerMinWidth(minPickerWidth);
    }
    if (maxPickerWidth != null) {
      this.setPickerMaxWidth(maxPickerWidth);
    }
  }
  postConstruct() {
    super.postConstruct();
    this.setupAria();
    const displayId = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", displayId);
    const ariaEl = this.getAriaElement();
    this.addManagedElementListeners(ariaEl, { keydown: this.onKeyDown.bind(this) });
    this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon, inputWidth } = this.config;
    if (pickerIcon) {
      const icon = _createIconNoSpan(pickerIcon, this.beans);
      if (icon) {
        this.eIcon.appendChild(icon);
      }
    }
    if (inputWidth != null) {
      this.setInputWidth(inputWidth);
    }
  }
  setupAria() {
    const ariaEl = this.getAriaElement();
    ariaEl.setAttribute("tabindex", this.gos.get("tabIndex").toString());
    _setAriaExpanded(ariaEl, false);
    if (this.ariaRole) {
      _setAriaRole(ariaEl, this.ariaRole);
    }
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const focusableEl = this.getFocusableElement();
      if (focusableEl !== this.eWrapper && e?.target === focusableEl) {
        return;
      }
      e.preventDefault();
      this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = false;
      return;
    }
    if (this.isDisabled()) {
      return;
    }
    if (this.isPickerDisplayed) {
      this.hidePicker();
    } else {
      this.showPicker();
    }
  }
  onKeyDown(e) {
    switch (e.key) {
      case KeyCode.UP:
      case KeyCode.DOWN:
      case KeyCode.ENTER:
      case KeyCode.SPACE:
        e.preventDefault();
        this.onLabelOrWrapperMouseDown();
        break;
      case KeyCode.ESCAPE:
        if (this.isPickerDisplayed) {
          e.preventDefault();
          e.stopPropagation();
          if (this.hideCurrentPicker) {
            this.hideCurrentPicker();
          }
        }
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = true;
    if (!this.pickerComponent) {
      this.pickerComponent = this.createPickerComponent();
    }
    const pickerGui = this.pickerComponent.getGui();
    pickerGui.addEventListener("focusin", this.onPickerFocusIn);
    pickerGui.addEventListener("focusout", this.onPickerFocusOut);
    this.hideCurrentPicker = this.renderAndPositionPicker();
    this.toggleExpandedStyles(true);
  }
  renderAndPositionPicker() {
    const ePicker = this.pickerComponent.getGui();
    if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) {
      [this.destroyMouseWheelFunc] = this.addManagedEventListeners({
        bodyScroll: () => {
          this.hidePicker();
        }
      });
    }
    const translate = this.getLocaleTextFunc();
    const {
      config: { pickerAriaLabelKey, pickerAriaLabelValue, modalPicker = true },
      maxPickerHeight,
      minPickerWidth,
      maxPickerWidth,
      variableWidth,
      beans,
      eWrapper
    } = this;
    const popupParams = {
      modal: modalPicker,
      eChild: ePicker,
      closeOnEsc: true,
      closedCallback: () => {
        const shouldRestoreFocus = _isNothingFocused(beans);
        this.beforeHidePicker();
        if (shouldRestoreFocus && this.isAlive()) {
          this.getFocusableElement().focus();
        }
      },
      ariaLabel: translate(pickerAriaLabelKey, pickerAriaLabelValue),
      anchorToElement: eWrapper
    };
    ePicker.style.position = "absolute";
    const popupSvc = beans.popupSvc;
    const addPopupRes = popupSvc.addPopup(popupParams);
    if (variableWidth) {
      if (minPickerWidth) {
        ePicker.style.minWidth = minPickerWidth;
      }
      ePicker.style.width = _formatSize(_getAbsoluteWidth(eWrapper));
      if (maxPickerWidth) {
        ePicker.style.maxWidth = maxPickerWidth;
      }
    } else {
      _setElementWidth(ePicker, maxPickerWidth ?? _getAbsoluteWidth(eWrapper));
    }
    const maxHeight = maxPickerHeight ?? `${_getInnerHeight(popupSvc.getPopupParent())}px`;
    ePicker.style.setProperty("max-height", maxHeight);
    this.alignPickerToComponent();
    return addPopupRes.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent) {
      return;
    }
    const {
      pickerGap,
      config: { pickerType },
      beans: { popupSvc, gos },
      eWrapper,
      pickerComponent
    } = this;
    const alignSide = gos.get("enableRtl") ? "right" : "left";
    popupSvc.positionPopupByComponent({
      type: pickerType,
      eventSource: eWrapper,
      ePopup: pickerComponent.getGui(),
      position: "under",
      alignSide,
      keepWithinBounds: true,
      nudgeY: pickerGap
    });
  }
  beforeHidePicker() {
    if (this.destroyMouseWheelFunc) {
      this.destroyMouseWheelFunc();
      this.destroyMouseWheelFunc = void 0;
    }
    this.toggleExpandedStyles(false);
    const pickerGui = this.pickerComponent.getGui();
    pickerGui.removeEventListener("focusin", this.onPickerFocusIn);
    pickerGui.removeEventListener("focusout", this.onPickerFocusOut);
    this.isPickerDisplayed = false;
    this.pickerComponent = void 0;
    this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(expanded) {
    if (!this.isAlive()) {
      return;
    }
    const ariaEl = this.getAriaElement();
    _setAriaExpanded(ariaEl, expanded);
    const classList = this.eWrapper.classList;
    classList.toggle("ag-picker-expanded", expanded);
    classList.toggle("ag-picker-collapsed", !expanded);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(true);
  }
  onPickerFocusOut(e) {
    if (!this.pickerComponent?.getGui().contains(e.relatedTarget)) {
      this.togglePickerHasFocus(false);
    }
  }
  togglePickerHasFocus(focused) {
    if (!this.pickerComponent) {
      return;
    }
    this.eWrapper.classList.toggle("ag-picker-has-focus", focused);
  }
  hidePicker() {
    this.hideCurrentPicker?.();
  }
  setInputWidth(width) {
    _setElementWidth(this.eWrapper, width);
    return this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(gap) {
    this.pickerGap = gap;
    return this;
  }
  setPickerMinWidth(width) {
    if (typeof width === "number") {
      width = `${width}px`;
    }
    this.minPickerWidth = width == null ? void 0 : width;
    return this;
  }
  setPickerMaxWidth(width) {
    if (typeof width === "number") {
      width = `${width}px`;
    }
    this.maxPickerWidth = width == null ? void 0 : width;
    return this;
  }
  setPickerMaxHeight(height) {
    if (typeof height === "number") {
      height = `${height}px`;
    }
    this.maxPickerHeight = height == null ? void 0 : height;
    return this;
  }
  destroy() {
    this.hidePicker();
    super.destroy();
  }
};

// packages/ag-grid-community/src/widgets/agSelect.css-GENERATED.ts
var agSelectCSS = (
  /*css*/
  `.ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}`
);

// packages/ag-grid-community/src/widgets/agSelect.ts
var AgSelect = class extends AgPickerField {
  constructor(config) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "selectOpen",
      ariaRole: "combobox",
      ...config
    });
    this.registerCSS(agSelectCSS);
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", false, {
        shouldDisplayTooltip: _shouldDisplayTooltip(() => this.eDisplayField),
        getGui: () => this.getGui()
      })
    );
    super.postConstruct();
    this.createListComponent();
    this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options, value, placeholder } = this.config;
    if (options != null) {
      this.addOptions(options);
    }
    if (value != null) {
      this.setValue(value, true);
    }
    if (placeholder && value == null) {
      this.eDisplayField.textContent = placeholder;
    }
    this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    if (!this.eWrapper.contains(e.relatedTarget)) {
      this.hidePicker();
    }
  }
  createListComponent() {
    const listComponent = this.createBean(new AgList("select", true));
    this.listComponent = listComponent;
    listComponent.setParentComponent(this);
    const eListAriaEl = listComponent.getAriaElement();
    const listId = `ag-select-list-${listComponent.getCompId()}`;
    eListAriaEl.setAttribute("id", listId);
    _setAriaControls(this.getAriaElement(), eListAriaEl);
    listComponent.addManagedListeners(listComponent, {
      selectedItem: () => {
        this.hidePicker();
        this.dispatchLocalEvent({ type: "selectedItem" });
      }
    });
    listComponent.addManagedListeners(listComponent, {
      fieldValueChanged: () => {
        if (!this.listComponent) {
          return;
        }
        this.setValue(this.listComponent.getValue(), false, true);
        this.hidePicker();
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    const { key } = e;
    if (key === KeyCode.TAB) {
      this.hidePicker();
    }
    switch (key) {
      case KeyCode.ENTER:
      case KeyCode.UP:
      case KeyCode.DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        e.preventDefault();
        if (this.isPickerDisplayed) {
          this.listComponent?.handleKeyDown(e);
        } else {
          super.onKeyDown(e);
        }
        break;
      case KeyCode.ESCAPE:
        super.onKeyDown(e);
        break;
      case KeyCode.SPACE:
        if (this.isPickerDisplayed) {
          e.preventDefault();
        } else {
          super.onKeyDown(e);
        }
        break;
    }
  }
  showPicker() {
    const listComponent = this.listComponent;
    if (!listComponent) {
      return;
    }
    super.showPicker();
    listComponent.refreshHighlighted();
  }
  addOptions(options) {
    options.forEach((option) => this.addOption(option));
    return this;
  }
  addOption(option) {
    this.listComponent.addOption(option);
    return this;
  }
  clearOptions() {
    this.listComponent?.clearOptions();
    return this;
  }
  setValue(value, silent, fromPicker) {
    const {
      listComponent,
      config: { placeholder },
      eDisplayField,
      tooltipFeature
    } = this;
    if (this.value === value || !listComponent) {
      return this;
    }
    if (!fromPicker) {
      listComponent.setValue(value, true);
    }
    const newValue = listComponent.getValue();
    if (newValue === this.getValue()) {
      return this;
    }
    let displayValue = listComponent.getDisplayValue();
    if (displayValue == null && placeholder) {
      displayValue = placeholder;
    }
    eDisplayField.textContent = displayValue;
    tooltipFeature?.setTooltipAndRefresh(displayValue ?? null);
    return super.setValue(value, silent);
  }
  destroy() {
    this.listComponent = this.destroyBean(this.listComponent);
    super.destroy();
  }
};
var AgSelectSelector = {
  selector: "AG-SELECT",
  component: AgSelect
};

// packages/ag-grid-community/src/widgets/tabGuardCtrl.ts
var TabGuardClassNames = {
  TAB_GUARD: "ag-tab-guard",
  TAB_GUARD_TOP: "ag-tab-guard-top",
  TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
};
var TabGuardCtrl = class extends BeanStub {
  constructor(params) {
    super();
    this.skipTabGuardFocus = false;
    this.forcingFocusOut = false;
    // Used when `isFocusableContainer` enabled
    this.allowFocus = false;
    const {
      comp,
      eTopGuard,
      eBottomGuard,
      focusTrapActive,
      forceFocusOutWhenTabGuardsAreEmpty,
      isFocusableContainer,
      focusInnerElement,
      onFocusIn,
      onFocusOut,
      shouldStopEventPropagation,
      onTabKeyDown,
      handleKeyDown,
      eFocusableElement
    } = params;
    this.comp = comp;
    this.eTopGuard = eTopGuard;
    this.eBottomGuard = eBottomGuard;
    this.providedFocusInnerElement = focusInnerElement;
    this.eFocusableElement = eFocusableElement;
    this.focusTrapActive = !!focusTrapActive;
    this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
    this.isFocusableContainer = !!isFocusableContainer;
    this.providedFocusIn = onFocusIn;
    this.providedFocusOut = onFocusOut;
    this.providedShouldStopEventPropagation = shouldStopEventPropagation;
    this.providedOnTabKeyDown = onTabKeyDown;
    this.providedHandleKeyDown = handleKeyDown;
  }
  postConstruct() {
    this.createManagedBean(
      new ManagedFocusFeature(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    );
    this.activateTabGuards();
    [this.eTopGuard, this.eBottomGuard].forEach(
      (guard) => this.addManagedElementListeners(guard, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    if (this.providedHandleKeyDown) {
      this.providedHandleKeyDown(e);
    }
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    if (this.providedShouldStopEventPropagation) {
      return this.providedShouldStopEventPropagation();
    }
    return false;
  }
  activateTabGuards() {
    if (this.forcingFocusOut) {
      return;
    }
    const tabIndex = this.gos.get("tabIndex");
    this.comp.setTabIndex(tabIndex.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget)) {
      if (!this.allowFocus) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
        return;
      }
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = false;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty) {
      const isEmpty = _findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0;
      if (isEmpty) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
        return;
      }
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) {
      return;
    }
    const fromBottom = e.target === this.eBottomGuard;
    if (this.providedFocusInnerElement) {
      this.providedFocusInnerElement(fromBottom);
    } else {
      this.focusInnerElement(fromBottom);
    }
  }
  findNextElementOutsideAndFocus(up) {
    const eDocument = _getDocument(this.beans);
    const focusableEls = _findFocusableElements(eDocument.body, null, true);
    const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
    if (index === -1) {
      return;
    }
    let start;
    let end;
    if (up) {
      start = 0;
      end = index;
    } else {
      start = index + 1;
      end = focusableEls.length;
    }
    const focusableRange = focusableEls.slice(start, end);
    const targetTabIndex = this.gos.get("tabIndex");
    focusableRange.sort((a, b) => {
      const indexA = parseInt(a.getAttribute("tabindex") || "0");
      const indexB = parseInt(b.getAttribute("tabindex") || "0");
      if (indexB === targetTabIndex) {
        return 1;
      }
      if (indexA === targetTabIndex) {
        return -1;
      }
      if (indexA === 0) {
        return 1;
      }
      if (indexB === 0) {
        return -1;
      }
      return indexA - indexB;
    });
    focusableRange[up ? focusableRange.length - 1 : 0]?.focus();
  }
  onFocusIn(e) {
    if (this.focusTrapActive || this.forcingFocusOut) {
      return;
    }
    if (this.providedFocusIn) {
      this.providedFocusIn(e);
    }
    if (!this.isFocusableContainer) {
      this.deactivateTabGuards();
    }
  }
  onFocusOut(e) {
    if (this.focusTrapActive) {
      return;
    }
    if (this.providedFocusOut) {
      this.providedFocusOut(e);
    }
    if (!this.eFocusableElement.contains(e.relatedTarget)) {
      this.activateTabGuards();
    }
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive) {
      return;
    }
    if (e.defaultPrevented) {
      return;
    }
    const tabGuardsAreActive = this.tabGuardsAreActive();
    if (tabGuardsAreActive) {
      this.deactivateTabGuards();
    }
    const nextRoot = this.getNextFocusableElement(e.shiftKey);
    if (tabGuardsAreActive) {
      setTimeout(() => this.activateTabGuards(), 0);
    }
    if (!nextRoot) {
      return;
    }
    nextRoot.focus();
    e.preventDefault();
  }
  focusInnerElement(fromBottom = false) {
    const focusable = _findFocusableElements(this.eFocusableElement);
    if (this.tabGuardsAreActive()) {
      focusable.splice(0, 1);
      focusable.splice(focusable.length - 1, 1);
    }
    if (!focusable.length) {
      return;
    }
    focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
  }
  getNextFocusableElement(backwards) {
    return _findNextFocusableElement(this.beans, this.eFocusableElement, false, backwards);
  }
  forceFocusOutOfContainer(up = false) {
    if (this.forcingFocusOut) {
      return;
    }
    const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards();
    this.skipTabGuardFocus = true;
    this.forcingFocusOut = true;
    tabGuardToFocus.focus();
    window.setTimeout(() => {
      this.forcingFocusOut = false;
      this.activateTabGuards();
    });
  }
  isTabGuard(element, bottom) {
    return element === this.eTopGuard && !bottom || element === this.eBottomGuard && (bottom ?? true);
  }
  setAllowFocus(allowFocus) {
    this.allowFocus = allowFocus;
  }
};

// packages/ag-grid-community/src/widgets/tabGuardFeature.ts
var TabGuardFeature = class extends BeanStub {
  constructor(comp) {
    super();
    this.comp = comp;
  }
  initialiseTabGuard(params) {
    this.eTopGuard = this.createTabGuard("top");
    this.eBottomGuard = this.createTabGuard("bottom");
    this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard, eBottomGuard, eFocusableElement } = this;
    const tabGuards = [eTopGuard, eBottomGuard];
    const compProxy = {
      setTabIndex: (tabIndex) => {
        tabGuards.forEach(
          (tabGuard) => tabIndex != null ? tabGuard.setAttribute("tabindex", tabIndex) : tabGuard.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(eTopGuard, eBottomGuard);
    const {
      focusTrapActive = false,
      onFocusIn,
      onFocusOut,
      focusInnerElement,
      handleKeyDown,
      onTabKeyDown,
      shouldStopEventPropagation,
      forceFocusOutWhenTabGuardsAreEmpty,
      isFocusableContainer
    } = params;
    this.tabGuardCtrl = this.createManagedBean(
      new TabGuardCtrl({
        comp: compProxy,
        focusTrapActive,
        eTopGuard,
        eBottomGuard,
        eFocusableElement,
        onFocusIn,
        onFocusOut,
        focusInnerElement,
        handleKeyDown,
        onTabKeyDown,
        shouldStopEventPropagation,
        forceFocusOutWhenTabGuardsAreEmpty,
        isFocusableContainer
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(side) {
    const tabGuard = _getDocument(this.beans).createElement("div");
    const cls = side === "top" ? TabGuardClassNames.TAB_GUARD_TOP : TabGuardClassNames.TAB_GUARD_BOTTOM;
    tabGuard.classList.add(TabGuardClassNames.TAB_GUARD, cls);
    _setAriaRole(tabGuard, "presentation");
    return tabGuard;
  }
  addTabGuards(topTabGuard, bottomTabGuard) {
    const eFocusableElement = this.eFocusableElement;
    eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
    eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
  }
  removeAllChildrenExceptTabGuards() {
    const tabGuards = [this.eTopGuard, this.eBottomGuard];
    _clearElement(this.comp.getFocusableElement());
    this.addTabGuards(...tabGuards);
  }
  forceFocusOutOfContainer(up = false) {
    this.tabGuardCtrl.forceFocusOutOfContainer(up);
  }
  appendChild(appendChild, newChild, container) {
    if (!_isNodeOrElement(newChild)) {
      newChild = newChild.getGui();
    }
    const { eBottomGuard: bottomTabGuard } = this;
    if (bottomTabGuard) {
      bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
    } else {
      appendChild(newChild, container);
    }
  }
};

// packages/ag-grid-community/src/widgets/tabGuardComp.ts
var TabGuardComp = class extends Component {
  initialiseTabGuard(params) {
    this.tabGuardFeature = this.createManagedBean(new TabGuardFeature(this));
    this.tabGuardFeature.initialiseTabGuard(params);
  }
  forceFocusOutOfContainer(up = false) {
    this.tabGuardFeature.forceFocusOutOfContainer(up);
  }
  appendChild(newChild, container) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), newChild, container);
  }
};

// packages/ag-grid-community/src/widgets/popupComponent.ts
var PopupComponent = class extends Component {
  isPopup() {
    return true;
  }
  setParentComponent(container) {
    container.addCssClass("ag-has-popup");
    super.setParentComponent(container);
  }
  destroy() {
    const parentComp = this.parentComponent;
    const hasParent = parentComp && parentComp.isAlive();
    if (hasParent) {
      parentComp.getGui().classList.remove("ag-has-popup");
    }
    super.destroy();
  }
};

// packages/ag-grid-community/src/widgets/touchListener.ts
var TouchListener = class {
  constructor(eElement, preventMouseClick = false) {
    this.DOUBLE_TAP_MILLIS = 500;
    this.destroyFuncs = [];
    this.touching = false;
    this.localEventService = new LocalEventService();
    this.preventMouseClick = preventMouseClick;
    const startListener = this.onTouchStart.bind(this);
    const moveListener = this.onTouchMove.bind(this);
    const endListener = this.onTouchEnd.bind(this);
    eElement.addEventListener("touchstart", startListener, { passive: true });
    eElement.addEventListener("touchmove", moveListener, { passive: true });
    eElement.addEventListener("touchend", endListener, { passive: false });
    this.destroyFuncs.push(() => {
      eElement.removeEventListener("touchstart", startListener, { passive: true });
      eElement.removeEventListener("touchmove", moveListener, { passive: true });
      eElement.removeEventListener("touchend", endListener, { passive: false });
    });
  }
  getActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      const matches = touchList[i].identifier === this.touchStart.identifier;
      if (matches) {
        return touchList[i];
      }
    }
    return null;
  }
  addEventListener(eventType, listener) {
    this.localEventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.localEventService.removeEventListener(eventType, listener);
  }
  onTouchStart(touchEvent) {
    if (this.touching) {
      return;
    }
    this.touchStart = touchEvent.touches[0];
    this.touching = true;
    this.moved = false;
    const touchStartCopy = this.touchStart;
    window.setTimeout(() => {
      const touchesMatch = this.touchStart === touchStartCopy;
      if (this.touching && touchesMatch && !this.moved) {
        this.moved = true;
        const event = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent
        };
        this.localEventService.dispatchEvent(event);
      }
    }, 500);
  }
  onTouchMove(touchEvent) {
    if (!this.touching) {
      return;
    }
    const touch = this.getActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    const eventIsFarAway = !_areEventsNear(touch, this.touchStart, 4);
    if (eventIsFarAway) {
      this.moved = true;
    }
  }
  onTouchEnd(touchEvent) {
    if (!this.touching) {
      return;
    }
    if (!this.moved) {
      const event = {
        type: "tap",
        touchStart: this.touchStart
      };
      this.localEventService.dispatchEvent(event);
      this.checkForDoubleTap();
    }
    if (this.preventMouseClick && touchEvent.cancelable) {
      touchEvent.preventDefault();
    }
    this.touching = false;
  }
  checkForDoubleTap() {
    const now = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0) {
      const interval = now - this.lastTapTime;
      if (interval > this.DOUBLE_TAP_MILLIS) {
        const event = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(event);
        this.lastTapTime = null;
      } else {
        this.lastTapTime = now;
      }
    } else {
      this.lastTapTime = now;
    }
  }
  destroy() {
    this.destroyFuncs.forEach((func) => func());
  }
};

// packages/ag-grid-community/src/interfaces/IRangeService.ts
var CellRangeType = /* @__PURE__ */ ((CellRangeType2) => {
  CellRangeType2[CellRangeType2["VALUE"] = 0] = "VALUE";
  CellRangeType2[CellRangeType2["DIMENSION"] = 1] = "DIMENSION";
  return CellRangeType2;
})(CellRangeType || {});

// packages/ag-grid-community/src/vanillaFrameworkOverrides.ts
var VanillaFrameworkOverrides = class {
  constructor(frameworkName = "javascript") {
    this.frameworkName = frameworkName;
    this.renderingEngine = "vanilla";
    this.wrapIncoming = (callback) => callback();
    this.wrapOutgoing = (callback) => callback();
    this.baseDocLink = `${BASE_URL}/${this.frameworkName}-data-grid`;
    setValidationDocLink(this.baseDocLink);
  }
  setInterval(action, timeout) {
    return new AgPromise((resolve) => {
      resolve(window.setInterval(action, timeout));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(element, type, listener, options) {
    let eventListenerOptions = {};
    if (typeof options === "object") {
      eventListenerOptions = options;
    } else if (typeof options === "boolean") {
      eventListenerOptions = { capture: options };
    }
    if (eventListenerOptions.passive == null) {
      const passive = getPassiveStateForEvent(type);
      if (passive != null) {
        eventListenerOptions.passive = passive;
      }
    }
    element.addEventListener(type, listener, eventListenerOptions);
  }
  frameworkComponent(_) {
    return null;
  }
  isFrameworkComponent(_) {
    return false;
  }
  getDocLink(path) {
    return `${this.baseDocLink}${path ? `/${path}` : ""}`;
  }
};

// packages/ag-grid-community/src/api/apiUtils.ts
function createGridApi(context) {
  return {
    beanName: "gridApi",
    bean: context.getBean("apiFunctionSvc").api
  };
}

// packages/ag-grid-community/src/context/gridBeanComparator.ts
var orderedCoreBeans = [
  // Validate license first
  "licenseManager",
  // core beans only
  "environment",
  "eventSvc",
  "gos",
  "paginationAutoPageSizeSvc",
  "apiFunctionSvc",
  "gridApi",
  "registry",
  "agCompUtils",
  "userCompFactory",
  "rowContainerHeight",
  "horizontalResizeSvc",
  "localeSvc",
  "pinnedRowModel",
  "dragSvc",
  "colGroupSvc",
  "visibleCols",
  "popupSvc",
  "selectionSvc",
  "colFilter",
  "quickFilter",
  "filterManager",
  "colModel",
  "headerNavigation",
  "pageBounds",
  "pagination",
  "pageBoundsListener",
  "stickyRowSvc",
  "rowRenderer",
  "expressionSvc",
  "alignedGridsSvc",
  "navigation",
  "valueCache",
  "valueSvc",
  "autoWidthCalc",
  "filterMenuFactory",
  "dragAndDrop",
  "focusSvc",
  "cellNavigation",
  "cellStyles",
  "scrollVisibleSvc",
  "sortSvc",
  "colHover",
  "colAnimation",
  "autoColSvc",
  "selectionColSvc",
  "changeDetectionSvc",
  "animationFrameSvc",
  "undoRedo",
  "colDefFactory",
  "rowStyleSvc",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsSvc",
  "pinnedCols",
  "dataTypeSvc",
  "syncSvc",
  "overlays",
  "stateSvc",
  "expansionSvc",
  "apiEventSvc",
  "ariaAnnounce",
  "menuSvc",
  "colMoves",
  "colAutosize",
  "colFlex",
  "colResize",
  "pivotColsSvc",
  "valueColsSvc",
  "rowGroupColsSvc",
  "funcColsSvc",
  "colNames",
  "colViewport",
  "pivotResultCols",
  "showRowGroupCols",
  "validation"
  // Have validations run last
];
var beanNamePosition = Object.fromEntries(
  orderedCoreBeans.map((beanName, index) => [beanName, index])
);
function gridBeanInitComparator(bean1, bean2) {
  const index1 = (bean1.beanName ? beanNamePosition[bean1.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  const index2 = (bean2.beanName ? beanNamePosition[bean2.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return index1 - index2;
}
function gridBeanDestroyComparator(bean1, bean2) {
  return bean1?.beanName === "gridDestroySvc" ? -1 : 0;
}

// packages/ag-grid-community/src/headerRendering/rowContainer/headerRowContainerComp.ts
var PINNED_LEFT_TEMPLATE = (
  /* html */
  `<div class="ag-pinned-left-header" role="rowgroup"></div>`
);
var PINNED_RIGHT_TEMPLATE = (
  /* html */
  `<div class="ag-pinned-right-header" role="rowgroup"></div>`
);
var CENTER_TEMPLATE = (
  /* html */
  `<div class="ag-header-viewport" role="presentation">
        <div class="ag-header-container" data-ref="eCenterContainer" role="rowgroup"></div>
    </div>`
);
var HeaderRowContainerComp = class extends Component {
  constructor(pinned) {
    super();
    this.eCenterContainer = RefPlaceholder;
    this.headerRowComps = {};
    this.rowCompsList = [];
    this.pinned = pinned;
  }
  postConstruct() {
    this.selectAndSetTemplate();
    const compProxy = {
      setDisplayed: (displayed) => this.setDisplayed(displayed),
      setCtrls: (ctrls) => this.setCtrls(ctrls),
      // only gets called for center section
      setCenterWidth: (width) => this.eCenterContainer.style.width = width,
      setViewportScrollLeft: (left) => this.getGui().scrollLeft = left,
      // only gets called for pinned sections
      setPinnedContainerWidth: (width) => {
        const eGui = this.getGui();
        eGui.style.width = width;
        eGui.style.maxWidth = width;
        eGui.style.minWidth = width;
      }
    };
    const ctrl = this.createManagedBean(new HeaderRowContainerCtrl(this.pinned));
    ctrl.setComp(compProxy, this.getGui());
  }
  selectAndSetTemplate() {
    const pinnedLeft = this.pinned == "left";
    const pinnedRight = this.pinned == "right";
    const template = pinnedLeft ? PINNED_LEFT_TEMPLATE : pinnedRight ? PINNED_RIGHT_TEMPLATE : CENTER_TEMPLATE;
    this.setTemplate(template);
    this.eRowContainer = this.eCenterContainer !== RefPlaceholder ? this.eCenterContainer : this.getGui();
  }
  destroy() {
    this.setCtrls([]);
    super.destroy();
  }
  destroyRowComp(rowComp) {
    this.destroyBean(rowComp);
    this.eRowContainer.removeChild(rowComp.getGui());
  }
  setCtrls(ctrls) {
    const oldRowComps = this.headerRowComps;
    this.headerRowComps = {};
    this.rowCompsList = [];
    let prevGui;
    const appendEnsuringDomOrder = (rowComp) => {
      const eGui = rowComp.getGui();
      const notAlreadyIn = eGui.parentElement != this.eRowContainer;
      if (notAlreadyIn) {
        this.eRowContainer.appendChild(eGui);
      }
      if (prevGui) {
        _ensureDomOrder(this.eRowContainer, eGui, prevGui);
      }
      prevGui = eGui;
    };
    ctrls.forEach((ctrl) => {
      const ctrlId = ctrl.instanceId;
      const existingComp = oldRowComps[ctrlId];
      delete oldRowComps[ctrlId];
      const rowComp = existingComp ? existingComp : this.createBean(new HeaderRowComp(ctrl));
      this.headerRowComps[ctrlId] = rowComp;
      this.rowCompsList.push(rowComp);
      appendEnsuringDomOrder(rowComp);
    });
    Object.values(oldRowComps).forEach((c) => this.destroyRowComp(c));
  }
};

// packages/ag-grid-community/src/headerRendering/gridHeaderComp.ts
var GridHeaderComp = class extends Component {
  constructor() {
    super(
      /* html */
      `<div class="ag-header" role="presentation"/>`
    );
  }
  postConstruct() {
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setHeightAndMinHeight: (height) => {
        this.getGui().style.height = height;
        this.getGui().style.minHeight = height;
      }
    };
    const ctrl = this.createManagedBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
    const addContainer = (container) => {
      this.createManagedBean(container);
      this.appendChild(container);
    };
    addContainer(new HeaderRowContainerComp("left"));
    addContainer(new HeaderRowContainerComp(null));
    addContainer(new HeaderRowContainerComp("right"));
  }
};
var GridHeaderSelector = {
  selector: "AG-HEADER-ROOT",
  component: GridHeaderComp
};

// packages/ag-grid-community/src/rendering/cell/cellComp.ts
var CellComp = class extends Component {
  constructor(beans, cellCtrl, printLayout, eRow, editingRow) {
    super();
    this.cellCtrl = cellCtrl;
    // every time we go into edit mode, or back again, this gets incremented.
    // it's the components way of dealing with the async nature of framework components,
    // so if a framework component takes a while to be created, we know if the object
    // is still relevant when creating is finished. eg we could click edit / un-edit 20
    // times before the first React edit component comes back - we should discard
    // the first 19.
    this.rendererVersion = 0;
    this.editorVersion = 0;
    this.beans = beans;
    this.column = cellCtrl.column;
    this.rowNode = cellCtrl.rowNode;
    this.eRow = eRow;
    const cellDiv = document.createElement("div");
    cellDiv.setAttribute("comp-id", `${this.getCompId()}`);
    this.setTemplateFromElement(cellDiv);
    const eGui = this.getGui();
    this.forceWrapper = cellCtrl.isForceWrapper();
    this.refreshWrapper(false);
    _setAriaRole(eGui, cellCtrl.getCellAriaRole());
    eGui.setAttribute("col-id", cellCtrl.colIdSanitised);
    const compProxy = {
      addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
      setUserStyles: (styles) => _addStylesToElement(eGui, styles),
      getFocusableElement: () => this.getFocusableElement(),
      setIncludeSelection: (include) => this.includeSelection = include,
      setIncludeRowDrag: (include) => this.includeRowDrag = include,
      setIncludeDndSource: (include) => this.includeDndSource = include,
      setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
      setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    cellCtrl.setComp(compProxy, this.getGui(), this.eCellWrapper, printLayout, editingRow, void 0);
  }
  getParentOfValue() {
    if (this.eCellValue) {
      return this.eCellValue;
    }
    if (this.eCellWrapper) {
      return this.eCellWrapper;
    }
    return this.getGui();
  }
  setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
    const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
    if (isInlineEditing) {
      return;
    }
    this.firstRender = this.firstRender == null;
    const controlWrapperChanged = this.refreshWrapper(false);
    this.refreshEditStyles(false);
    if (compDetails) {
      const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
      const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
      if (!cellRendererRefreshSuccessful) {
        this.destroyRenderer();
        this.createCellRendererInstance(compDetails);
      }
    } else {
      this.destroyRenderer();
      this.insertValueWithoutCellRenderer(valueToDisplay);
    }
  }
  setEditDetails(compDetails, popup, position) {
    if (compDetails) {
      this.createCellEditorInstance(compDetails, popup, position);
    } else {
      this.destroyEditor();
    }
  }
  removeControls() {
    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);
    this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);
    this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(editing) {
    const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
    const usingWrapper = providingControls || this.forceWrapper;
    const putWrapperIn = usingWrapper && this.eCellWrapper == null;
    if (putWrapperIn) {
      const wrapperDiv = document.createElement("div");
      wrapperDiv.setAttribute("role", "presentation");
      wrapperDiv.setAttribute("class", "ag-cell-wrapper");
      this.eCellWrapper = wrapperDiv;
      this.getGui().appendChild(this.eCellWrapper);
    }
    const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
    if (takeWrapperOut) {
      _removeFromParent(this.eCellWrapper);
      this.eCellWrapper = void 0;
    }
    this.addOrRemoveCssClass("ag-cell-value", !usingWrapper);
    const usingCellValue = !editing && usingWrapper;
    const putCellValueIn = usingCellValue && this.eCellValue == null;
    if (putCellValueIn) {
      const cellSpan = document.createElement("span");
      cellSpan.setAttribute("role", "presentation");
      cellSpan.setAttribute("class", "ag-cell-value");
      this.eCellValue = cellSpan;
      this.eCellWrapper.appendChild(this.eCellValue);
    }
    const takeCellValueOut = !usingCellValue && this.eCellValue != null;
    if (takeCellValueOut) {
      _removeFromParent(this.eCellValue);
      this.eCellValue = void 0;
    }
    const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
    if (templateChanged) {
      this.removeControls();
    }
    if (!editing) {
      if (providingControls) {
        this.addControls();
      }
    }
    return templateChanged;
  }
  addControls() {
    if (this.includeRowDrag) {
      if (this.rowDraggingComp == null) {
        this.rowDraggingComp = this.cellCtrl.createRowDragComp();
        if (this.rowDraggingComp) {
          this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);
        }
      }
    }
    if (this.includeDndSource) {
      if (this.dndSourceComp == null) {
        this.dndSourceComp = this.cellCtrl.createDndSource();
        if (this.dndSourceComp) {
          this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);
        }
      }
    }
    if (this.includeSelection) {
      if (this.checkboxSelectionComp == null) {
        this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();
        if (this.checkboxSelectionComp) {
          this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);
        }
      }
    }
  }
  createCellEditorInstance(compDetails, popup, position) {
    const versionCopy = this.editorVersion;
    const cellEditorPromise = compDetails.newAgStackInstance();
    const { params } = compDetails;
    cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
    const cellEditorAsync = _missing(this.cellEditor);
    if (cellEditorAsync && params.cellStartedEdit) {
      this.cellCtrl.focusCell(true);
    }
  }
  insertValueWithoutCellRenderer(valueToDisplay) {
    const eParent = this.getParentOfValue();
    _clearElement(eParent);
    const escapedValue = valueToDisplay != null ? _escapeString(valueToDisplay, true) : null;
    if (escapedValue != null) {
      eParent.textContent = escapedValue;
    }
  }
  destroyEditorAndRenderer() {
    this.destroyRenderer();
    this.destroyEditor();
  }
  destroyRenderer() {
    const { context } = this.beans;
    this.cellRenderer = context.destroyBean(this.cellRenderer);
    _removeFromParent(this.cellRendererGui);
    this.cellRendererGui = null;
    this.rendererVersion++;
  }
  destroyEditor() {
    const { context } = this.beans;
    if (this.hideEditorPopup) {
      this.hideEditorPopup();
    }
    this.hideEditorPopup = void 0;
    this.cellEditor = context.destroyBean(this.cellEditor);
    this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
    _removeFromParent(this.cellEditorGui);
    this.cellEditorGui = null;
    this.editorVersion++;
  }
  refreshCellRenderer(compClassAndParams) {
    if (this.cellRenderer == null || this.cellRenderer.refresh == null) {
      return false;
    }
    if (this.cellRendererClass !== compClassAndParams.componentClass) {
      return false;
    }
    const result = this.cellRenderer.refresh(compClassAndParams.params);
    return result === true || result === void 0;
  }
  createCellRendererInstance(compDetails) {
    const suppressAnimationFrame = this.beans.gos.get("suppressAnimationFrame");
    const useTaskService = !suppressAnimationFrame && this.beans.animationFrameSvc;
    const displayComponentVersionCopy = this.rendererVersion;
    const { componentClass } = compDetails;
    const createCellRendererFunc = () => {
      const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
      if (staleTask) {
        return;
      }
      const componentPromise = compDetails.newAgStackInstance();
      const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, componentClass);
      if (componentPromise) {
        componentPromise.then(callback);
      }
    };
    if (useTaskService && this.firstRender) {
      this.beans.animationFrameSvc.createTask(createCellRendererFunc, this.rowNode.rowIndex, "createTasksP2");
    } else {
      createCellRendererFunc();
    }
  }
  afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
    const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
    if (staleTask) {
      this.beans.context.destroyBean(cellRenderer);
      return;
    }
    this.cellRenderer = cellRenderer;
    this.cellRendererClass = cellRendererClass;
    this.cellRendererGui = this.cellRenderer.getGui();
    if (this.cellRendererGui != null) {
      const eParent = this.getParentOfValue();
      _clearElement(eParent);
      eParent.appendChild(this.cellRendererGui);
    }
  }
  afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
    const staleComp = requestVersion !== this.editorVersion;
    if (staleComp) {
      this.beans.context.destroyBean(cellEditor);
      return;
    }
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      this.beans.context.destroyBean(cellEditor);
      this.cellCtrl.stopEditing(true);
      return;
    }
    if (!cellEditor.getGui) {
      _warn(97, { colId: this.column.getId() });
      this.beans.context.destroyBean(cellEditor);
      return;
    }
    this.cellEditor = cellEditor;
    this.cellEditorGui = cellEditor.getGui();
    const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
    if (cellEditorInPopup) {
      this.addPopupCellEditor(params, position);
    } else {
      this.addInCellEditor();
    }
    this.refreshEditStyles(true, cellEditorInPopup);
    if (cellEditor.afterGuiAttached) {
      cellEditor.afterGuiAttached();
    }
    this.cellCtrl.cellEditorAttached();
  }
  refreshEditStyles(editing, isPopup) {
    this.addOrRemoveCssClass("ag-cell-inline-editing", editing && !isPopup);
    this.addOrRemoveCssClass("ag-cell-popup-editing", editing && !!isPopup);
    this.addOrRemoveCssClass("ag-cell-not-inline-editing", !editing || !!isPopup);
    this.cellCtrl.setInlineEditingCss();
  }
  addInCellEditor() {
    const eGui = this.getGui();
    if (eGui.contains(_getActiveDomElement(this.beans))) {
      eGui.focus();
    }
    this.destroyRenderer();
    this.refreshWrapper(true);
    this.clearParentOfValue();
    if (this.cellEditorGui) {
      const eParent = this.getParentOfValue();
      eParent.appendChild(this.cellEditorGui);
    }
  }
  addPopupCellEditor(params, position) {
    if (this.beans.gos.get("editType") === "fullRow") {
      _warn(98);
    }
    const cellEditor = this.cellEditor;
    this.cellEditorPopupWrapper = this.beans.context.createBean(
      this.beans.editSvc.createPopupEditorWrapper(params)
    );
    const ePopupGui = this.cellEditorPopupWrapper.getGui();
    if (this.cellEditorGui) {
      ePopupGui.appendChild(this.cellEditorGui);
    }
    const popupSvc = this.beans.popupSvc;
    const useModelPopup = this.beans.gos.get("stopEditingWhenCellsLoseFocus");
    const positionToUse = position != null ? position : cellEditor.getPopupPosition?.() ?? "over";
    const isRtl = this.beans.gos.get("enableRtl");
    const positionParams = {
      ePopup: ePopupGui,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.getGui(),
      position: positionToUse,
      alignSide: isRtl ? "right" : "left",
      keepWithinBounds: true
    };
    const positionCallback = popupSvc.positionPopupByComponent.bind(popupSvc, positionParams);
    const translate = _getLocaleTextFunc(this.beans.localeSvc);
    const addPopupRes = popupSvc.addPopup({
      modal: useModelPopup,
      eChild: ePopupGui,
      closeOnEsc: true,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.getGui(),
      positionCallback,
      ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
    });
    if (addPopupRes) {
      this.hideEditorPopup = addPopupRes.hideFunc;
    }
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.cellCtrl.stopEditing();
    this.destroyEditorAndRenderer();
    this.removeControls();
    super.destroy();
  }
  clearParentOfValue() {
    const eGui = this.getGui();
    if (eGui.contains(_getActiveDomElement(this.beans))) {
      eGui.focus({ preventScroll: true });
    }
    _clearElement(this.getParentOfValue());
  }
};

// packages/ag-grid-community/src/rendering/row/rowComp.ts
var RowComp = class extends Component {
  constructor(ctrl, beans, containerType) {
    super();
    this.cellComps = {};
    this.beans = beans;
    this.rowCtrl = ctrl;
    const rowDiv = document.createElement("div");
    rowDiv.setAttribute("comp-id", `${this.getCompId()}`);
    rowDiv.setAttribute("style", this.getInitialStyle(containerType));
    this.setTemplateFromElement(rowDiv);
    const eGui = this.getGui();
    const style = eGui.style;
    this.domOrder = this.rowCtrl.getDomOrder();
    _setAriaRole(eGui, "row");
    const compProxy = {
      setDomOrder: (domOrder) => this.domOrder = domOrder,
      setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
      showFullWidth: (compDetails) => this.showFullWidth(compDetails),
      getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
      addOrRemoveCssClass: (name, on) => this.addOrRemoveCssClass(name, on),
      setUserStyles: (styles) => _addStylesToElement(eGui, styles),
      setTop: (top) => style.top = top,
      setTransform: (transform) => style.transform = transform,
      setRowIndex: (rowIndex) => eGui.setAttribute("row-index", rowIndex),
      setRowId: (rowId) => eGui.setAttribute("row-id", rowId),
      setRowBusinessKey: (businessKey) => eGui.setAttribute("row-business-key", businessKey),
      refreshFullWidth: (getUpdatedParams) => this.fullWidthCellRenderer?.refresh?.(getUpdatedParams()) ?? false
    };
    ctrl.setComp(compProxy, this.getGui(), containerType, void 0);
    this.addDestroyFunc(() => {
      ctrl.unsetComp(containerType);
    });
  }
  getInitialStyle(containerType) {
    const transform = this.rowCtrl.getInitialTransform(containerType);
    return transform ? `transform: ${transform}` : `top: ${this.rowCtrl.getInitialRowTop(containerType)}`;
  }
  showFullWidth(compDetails) {
    const callback = (cellRenderer) => {
      if (this.isAlive()) {
        const eGui = cellRenderer.getGui();
        this.getGui().appendChild(eGui);
        this.rowCtrl.setupDetailRowAutoHeight(eGui);
        this.setFullWidthRowComp(cellRenderer);
      } else {
        this.beans.context.destroyBean(cellRenderer);
      }
    };
    const res = compDetails.newAgStackInstance();
    res.then(callback);
  }
  setCellCtrls(cellCtrls) {
    const cellsToRemove = Object.assign({}, this.cellComps);
    cellCtrls.forEach((cellCtrl) => {
      const key = cellCtrl.instanceId;
      const existingCellComp = this.cellComps[key];
      if (existingCellComp == null) {
        this.newCellComp(cellCtrl);
      } else {
        cellsToRemove[key] = null;
      }
    });
    const cellCompsToRemove = Object.values(cellsToRemove).filter((cellComp) => cellComp != null);
    this.destroyCells(cellCompsToRemove);
    this.ensureDomOrder(cellCtrls);
  }
  ensureDomOrder(cellCtrls) {
    if (!this.domOrder) {
      return;
    }
    const elementsInOrder = [];
    cellCtrls.forEach((cellCtrl) => {
      const cellComp = this.cellComps[cellCtrl.instanceId];
      if (cellComp) {
        elementsInOrder.push(cellComp.getGui());
      }
    });
    _setDomChildOrder(this.getGui(), elementsInOrder);
  }
  newCellComp(cellCtrl) {
    const cellComp = new CellComp(
      this.beans,
      cellCtrl,
      this.rowCtrl.printLayout,
      this.getGui(),
      this.rowCtrl.editing
    );
    this.cellComps[cellCtrl.instanceId] = cellComp;
    this.getGui().appendChild(cellComp.getGui());
  }
  destroy() {
    super.destroy();
    this.destroyAllCells();
  }
  destroyAllCells() {
    const cellsToDestroy = Object.values(this.cellComps).filter((cp) => cp != null);
    this.destroyCells(cellsToDestroy);
  }
  setFullWidthRowComp(fullWidthRowComponent) {
    this.fullWidthCellRenderer = fullWidthRowComponent;
    this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  destroyCells(cellComps) {
    cellComps.forEach((cellComp) => {
      if (!cellComp) {
        return;
      }
      const instanceId = cellComp.cellCtrl.instanceId;
      if (this.cellComps[instanceId] !== cellComp) {
        return;
      }
      cellComp.detach();
      cellComp.destroy();
      this.cellComps[instanceId] = null;
    });
  }
};

// packages/ag-grid-community/src/gridBodyComp/rowContainer/rowContainerComp.ts
function templateFactory(options) {
  let res;
  if (options.type === "center") {
    res = /* html */
    `<div class="${options.viewport}" data-ref="eViewport" role="presentation">
                <div class="${options.container}" data-ref="eContainer"></div>
            </div>`;
  } else {
    res = /* html */
    `<div class="${options.container}" data-ref="eContainer"></div>`;
  }
  return res;
}
var RowContainerComp = class extends Component {
  constructor(params) {
    super();
    this.eViewport = RefPlaceholder;
    this.eContainer = RefPlaceholder;
    this.rowComps = {};
    this.name = params?.name;
    this.options = _getRowContainerOptions(this.name);
    this.setTemplate(templateFactory(this.options));
  }
  postConstruct() {
    const compProxy = {
      setHorizontalScroll: (offset) => this.eViewport.scrollLeft = offset,
      setViewportHeight: (height) => this.eViewport.style.height = height,
      setRowCtrls: ({ rowCtrls }) => this.setRowCtrls(rowCtrls),
      setDomOrder: (domOrder) => {
        this.domOrder = domOrder;
      },
      setContainerWidth: (width) => this.eContainer.style.width = width,
      setOffsetTop: (offset) => this.eContainer.style.transform = `translateY(${offset})`
    };
    const ctrl = this.createManagedBean(new RowContainerCtrl(this.name));
    ctrl.setComp(compProxy, this.eContainer, this.eViewport);
  }
  destroy() {
    this.setRowCtrls([]);
    super.destroy();
  }
  setRowCtrls(rowCtrls) {
    const oldRows = { ...this.rowComps };
    this.rowComps = {};
    this.lastPlacedElement = null;
    const processRow = (rowCon) => {
      const instanceId = rowCon.instanceId;
      const existingRowComp = oldRows[instanceId];
      if (existingRowComp) {
        this.rowComps[instanceId] = existingRowComp;
        delete oldRows[instanceId];
        this.ensureDomOrder(existingRowComp.getGui());
      } else {
        if (!rowCon.rowNode.displayed) {
          return;
        }
        const rowComp = new RowComp(rowCon, this.beans, this.options.type);
        this.rowComps[instanceId] = rowComp;
        this.appendRow(rowComp.getGui());
      }
    };
    rowCtrls.forEach(processRow);
    Object.values(oldRows).forEach((oldRowComp) => {
      this.eContainer.removeChild(oldRowComp.getGui());
      oldRowComp.destroy();
    });
    _setAriaRole(this.eContainer, "rowgroup");
  }
  appendRow(element) {
    if (this.domOrder) {
      _insertWithDomOrder(this.eContainer, element, this.lastPlacedElement);
    } else {
      this.eContainer.appendChild(element);
    }
    this.lastPlacedElement = element;
  }
  ensureDomOrder(eRow) {
    if (this.domOrder) {
      _ensureDomOrder(this.eContainer, eRow, this.lastPlacedElement);
      this.lastPlacedElement = eRow;
    }
  }
};
var RowContainerSelector = {
  selector: "AG-ROW-CONTAINER",
  component: RowContainerComp
};

// packages/ag-grid-community/src/gridBodyComp/gridBodyComp.ts
function makeRowContainers(paramsMap, names) {
  return names.map((name) => {
    const refName = `e${name[0].toUpperCase() + name.substring(1)}RowContainer`;
    paramsMap[refName] = { name };
    return (
      /* html */
      `<ag-row-container name="${name}" data-ref="${refName}"></ag-row-container>`
    );
  }).join("");
}
function getGridBodyTemplate(includeOverlay) {
  const paramsMap = {};
  const template = (
    /* html */
    `<div class="ag-root ag-unselectable" data-ref="eGridRoot">
        <ag-header-root></ag-header-root>
        <div class="ag-floating-top" data-ref="eTop" role="presentation">
            ${makeRowContainers(paramsMap, ["topLeft", "topCenter", "topRight", "topFullWidth"])}
        </div>
        <div class="ag-body" data-ref="eBody" role="presentation">
            <div class="ag-body-viewport" data-ref="eBodyViewport" role="presentation">
            ${makeRowContainers(paramsMap, ["left", "center", "right", "fullWidth"])}
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" data-ref="eStickyTop" role="presentation">
            ${makeRowContainers(paramsMap, ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}
        </div>
        <div class="ag-sticky-bottom" data-ref="eStickyBottom" role="presentation">
            ${makeRowContainers(paramsMap, ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}
        </div>
        <div class="ag-floating-bottom" data-ref="eBottom" role="presentation">
            ${makeRowContainers(paramsMap, ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        ${includeOverlay ? (
      /* html */
      `<ag-overlay-wrapper></ag-overlay-wrapper>`
    ) : ""}
    </div>`
  );
  return { paramsMap, template };
}
var GridBodyComp = class extends Component {
  constructor() {
    super(...arguments);
    this.eGridRoot = RefPlaceholder;
    this.eBodyViewport = RefPlaceholder;
    this.eStickyTop = RefPlaceholder;
    this.eStickyBottom = RefPlaceholder;
    this.eTop = RefPlaceholder;
    this.eBottom = RefPlaceholder;
    this.eBody = RefPlaceholder;
  }
  postConstruct() {
    const { overlays, rangeSvc } = this.beans;
    const overlaySelector = overlays?.getOverlayWrapperSelector();
    const { paramsMap, template } = getGridBodyTemplate(!!overlaySelector);
    this.setTemplate(
      template,
      [
        ...overlaySelector ? [overlaySelector] : [],
        FakeHScrollSelector,
        FakeVScrollSelector,
        GridHeaderSelector,
        RowContainerSelector
      ],
      paramsMap
    );
    const setHeight = (height, element) => {
      const heightString = `${height}px`;
      element.style.minHeight = heightString;
      element.style.height = heightString;
    };
    const compProxy = {
      setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
      setColumnCount: (count) => _setAriaColCount(this.getGui(), count),
      setRowCount: (count) => _setAriaRowCount(this.getGui(), count),
      setTopHeight: (height) => setHeight(height, this.eTop),
      setBottomHeight: (height) => setHeight(height, this.eBottom),
      setTopDisplay: (display) => this.eTop.style.display = display,
      setBottomDisplay: (display) => this.eBottom.style.display = display,
      setStickyTopHeight: (height) => this.eStickyTop.style.height = height,
      setStickyTopTop: (top) => this.eStickyTop.style.top = top,
      setStickyTopWidth: (width) => this.eStickyTop.style.width = width,
      setStickyBottomHeight: (height) => {
        this.eStickyBottom.style.height = height;
        this.eStickyBottom.classList.toggle("ag-hidden", height === "0px");
      },
      setStickyBottomBottom: (bottom) => this.eStickyBottom.style.bottom = bottom,
      setStickyBottomWidth: (width) => this.eStickyBottom.style.width = width,
      setColumnMovingCss: (cssClass, flag) => this.addOrRemoveCssClass(cssClass, flag),
      updateLayoutClasses: (cssClass, params) => {
        const classLists = [this.eBodyViewport.classList, this.eBody.classList];
        classLists.forEach((classList) => {
          classList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
          classList.toggle(LayoutCssClasses.NORMAL, params.normal);
          classList.toggle(LayoutCssClasses.PRINT, params.print);
        });
        this.addOrRemoveCssClass(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
        this.addOrRemoveCssClass(LayoutCssClasses.NORMAL, params.normal);
        this.addOrRemoveCssClass(LayoutCssClasses.PRINT, params.print);
      },
      setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = _observeResize(this.beans, this.eBodyViewport, listener);
        this.addDestroyFunc(() => unsubscribeFromResize());
      },
      setPinnedTopBottomOverflowY: (overflow) => this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
      setCellSelectableCss: (cssClass, selectable) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach(
          (ct) => ct.classList.toggle(cssClass, selectable)
        );
      },
      setBodyViewportWidth: (width) => this.eBodyViewport.style.width = width,
      setGridRootRole: (role) => _setAriaRole(this.eGridRoot, role)
    };
    this.ctrl = this.createManagedBean(new GridBodyCtrl());
    this.ctrl.setComp(
      compProxy,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    );
    if (rangeSvc && _isCellSelectionEnabled(this.gos) || _isMultiRowSelection(this.gos)) {
      _setAriaMultiSelectable(this.getGui(), true);
    }
  }
  setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
    const bodyViewportClassList = this.eBodyViewport.classList;
    bodyViewportClassList.toggle("ag-row-animation", animateRows);
    bodyViewportClassList.toggle("ag-row-no-animation", !animateRows);
  }
};
var GridBodySelector = {
  selector: "AG-GRID-BODY",
  component: GridBodyComp
};

// packages/ag-grid-community/src/gridComp/gridCtrl.ts
var GridCtrl = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  setComp(view, eGridDiv, eGui) {
    this.view = view;
    this.eGridHostDiv = eGridDiv;
    this.eGui = eGui;
    this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
    const { dragAndDrop, ctrlsSvc } = this.beans;
    dragAndDrop?.registerGridDropTarget(() => this.eGui, this);
    _stampTopLevelGridCompWithGridInstance(this.gos, eGridDiv);
    this.createManagedBean(new LayoutFeature(this.view));
    this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
    const unsubscribeFromResize = _observeResize(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => unsubscribeFromResize());
    ctrlsSvc.register("gridCtrl", this);
  }
  isDetailGrid() {
    const el = _findTabbableParent(this.getGui());
    return el?.getAttribute("row-id")?.startsWith("detail") || false;
  }
  getOptionalSelectors() {
    const beans = this.beans;
    return {
      paginationSelector: beans.pagination?.getPaginationSelector(),
      gridHeaderDropZonesSelector: beans.registry.getSelector("AG-GRID-HEADER-DROP-ZONES"),
      sideBarSelector: beans.sideBar?.getSelector(),
      statusBarSelector: beans.registry?.getSelector("AG-STATUS-BAR"),
      watermarkSelector: beans.licenseManager?.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventSvc.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(on) {
    this.view.setCursor(on ? "ew-resize" : null);
  }
  disableUserSelect(on) {
    this.view.setUserSelect(on ? "none" : null);
  }
  focusNextInnerContainer(backwards) {
    const focusableContainers = this.getFocusableContainers();
    const { indexWithFocus, nextIndex } = this.getNextFocusableIndex(focusableContainers, backwards);
    if (nextIndex < 0 || nextIndex >= focusableContainers.length) {
      return false;
    }
    if (nextIndex === 0) {
      if (indexWithFocus > 0) {
        const { visibleCols, focusSvc } = this.beans;
        const allColumns = visibleCols.allCols;
        const lastColumn = _last(allColumns);
        if (focusSvc.focusGridView(lastColumn, true)) {
          return true;
        }
      }
      return false;
    }
    return this.focusContainer(focusableContainers[nextIndex], backwards);
  }
  focusInnerElement(fromBottom) {
    const userCallbackFunction = this.gos.getCallback("focusGridInnerElement");
    if (userCallbackFunction && userCallbackFunction({ fromBottom: !!fromBottom })) {
      return true;
    }
    const focusableContainers = this.getFocusableContainers();
    const { focusSvc, visibleCols } = this.beans;
    const allColumns = visibleCols.allCols;
    if (fromBottom) {
      if (focusableContainers.length > 1) {
        return this.focusContainer(_last(focusableContainers), true);
      }
      const lastColumn = _last(allColumns);
      if (focusSvc.focusGridView(lastColumn, true)) {
        return true;
      }
    }
    if (this.gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(this.beans)) {
      if (focusSvc.focusGridView(allColumns[0])) {
        return true;
      }
      for (let i = 1; i < focusableContainers.length; i++) {
        if (_focusInto(focusableContainers[i].getGui())) {
          return true;
        }
      }
      return false;
    }
    return focusSvc.focusFirstHeader();
  }
  forceFocusOutOfContainer(up = false) {
    this.view.forceFocusOutOfContainer(up);
  }
  addFocusableContainer(container) {
    this.additionalFocusableContainers.add(container);
  }
  removeFocusableContainer(container) {
    this.additionalFocusableContainers.delete(container);
  }
  allowFocusForNextCoreContainer(up) {
    const coreContainers = this.view.getFocusableContainers();
    const { nextIndex, indexWithFocus } = this.getNextFocusableIndex(coreContainers, up);
    if (indexWithFocus === -1 || nextIndex < 0 || nextIndex >= coreContainers.length) {
      return;
    }
    const comp = coreContainers[nextIndex];
    comp.setAllowFocus?.(true);
    setTimeout(() => {
      comp.setAllowFocus?.(false);
    });
  }
  getNextFocusableIndex(focusableContainers, backwards) {
    const activeEl = _getActiveDomElement(this.beans);
    const indexWithFocus = focusableContainers.findIndex((container) => container.getGui().contains(activeEl));
    const nextIndex = indexWithFocus + (backwards ? -1 : 1);
    return {
      indexWithFocus,
      nextIndex
    };
  }
  focusContainer(comp, up) {
    comp.setAllowFocus?.(true);
    const result = _focusInto(comp.getGui(), up);
    comp.setAllowFocus?.(false);
    return result;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  destroy() {
    this.additionalFocusableContainers.clear();
    super.destroy();
  }
};

// packages/ag-grid-community/src/gridComp/gridComp.ts
var GridComp = class extends TabGuardComp {
  constructor(eGridDiv) {
    super();
    this.gridBody = RefPlaceholder;
    this.sideBar = RefPlaceholder;
    this.pagination = RefPlaceholder;
    this.rootWrapperBody = RefPlaceholder;
    this.eGridDiv = eGridDiv;
  }
  postConstruct() {
    const compProxy = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (cssClass) => this.addCssClass(cssClass),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (value) => {
        this.getGui().style.userSelect = value != null ? value : "";
        this.getGui().style.webkitUserSelect = value != null ? value : "";
      },
      setCursor: (value) => {
        this.getGui().style.cursor = value != null ? value : "";
      }
    };
    const ctrl = this.createManagedBean(new GridCtrl());
    const comps = ctrl.getOptionalSelectors();
    const template = this.createTemplate(comps);
    const requiredComps = [GridBodySelector, ...Object.values(comps).filter((c) => !!c)];
    this.setTemplate(template, requiredComps);
    ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
    this.insertGridIntoDom();
    this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => void 0,
      focusInnerElement: (fromBottom) => ctrl.focusInnerElement(fromBottom),
      forceFocusOutWhenTabGuardsAreEmpty: true
    });
  }
  insertGridIntoDom() {
    const eGui = this.getGui();
    this.eGridDiv.appendChild(eGui);
    this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(eGui);
      _logIfDebug(this.gos, "Grid removed from DOM");
    });
  }
  updateLayoutClasses(cssClass, params) {
    const eRootWrapperBodyClassList = this.rootWrapperBody.classList;
    const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
    const { autoHeight, normal, print } = params;
    eRootWrapperBodyClassList.toggle(AUTO_HEIGHT, autoHeight);
    eRootWrapperBodyClassList.toggle(NORMAL, normal);
    eRootWrapperBodyClassList.toggle(PRINT, print);
    this.addOrRemoveCssClass(AUTO_HEIGHT, autoHeight);
    this.addOrRemoveCssClass(NORMAL, normal);
    this.addOrRemoveCssClass(PRINT, print);
  }
  createTemplate(params) {
    const dropZones = params.gridHeaderDropZonesSelector ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "";
    const sideBar = params.sideBarSelector ? '<ag-side-bar data-ref="sideBar"></ag-side-bar>' : "";
    const statusBar = params.statusBarSelector ? "<ag-status-bar></ag-status-bar>" : "";
    const watermark = params.watermarkSelector ? "<ag-watermark></ag-watermark>" : "";
    const pagination = params.paginationSelector ? '<ag-pagination data-ref="pagination"></ag-pagination>' : "";
    const template = (
      /* html */
      `<div class="ag-root-wrapper" role="presentation">
                ${dropZones}
                <div class="ag-root-wrapper-body" data-ref="rootWrapperBody" role="presentation">
                    <ag-grid-body data-ref="gridBody"></ag-grid-body>
                    ${sideBar}
                </div>
                ${statusBar}
                ${pagination}
                ${watermark}
            </div>`
    );
    return template;
  }
  getFocusableElement() {
    return this.rootWrapperBody;
  }
  forceFocusOutOfContainer(up = false) {
    if (!up && this.pagination?.isDisplayed()) {
      this.pagination.forceFocusOutOfContainer(up);
      return;
    }
    super.forceFocusOutOfContainer(up);
  }
  getFocusableContainers() {
    const focusableContainers = [this.gridBody];
    [this.sideBar, this.pagination].forEach((comp) => {
      if (comp) {
        focusableContainers.push(comp);
      }
    });
    return focusableContainers.filter((el) => _isVisible(el.getGui()));
  }
};

// packages/ag-grid-community/src/api/gridApiFunctions.ts
var mod = (moduleName, input) => {
  for (const key of Object.keys(input)) {
    input[key] = moduleName;
  }
  return input;
};
var gridApiFunctionsMap = {
  dispatchEvent: "CommunityCore",
  // this is always registered
  ...mod("CommunityCore", {
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0
  }),
  ...mod("GridState", {
    getState: 0
  }),
  ...mod("SharedRowSelection", {
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0
  }),
  ...mod("RowApi", {
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0
  }),
  ...mod("ScrollApi", {
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0
  }),
  ...mod("KeyboardNavigation", {
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0
  }),
  ...mod("EventApi", {
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0
  }),
  ...mod("ValueCache", {
    expireValueCache: 0
  }),
  ...mod("CellApi", {
    getCellValue: 0
  }),
  ...mod("SharedMenu", {
    showColumnMenu: 0,
    hidePopupMenu: 0
  }),
  ...mod("Sort", {
    onSortChanged: 0
  }),
  ...mod("PinnedRow", {
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0
  }),
  ...mod("Overlay", {
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0
  }),
  ...mod("RenderApi", {
    setGridAriaProperty: 0,
    refreshCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0
  }),
  ...mod("HighlightChanges", {
    flashCells: 0
  }),
  ...mod("RowDrag", {
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0
  }),
  ...mod("ColumnApi", {
    getColumnDefs: 0,
    getColumnDef: 0,
    getDisplayNameForColumn: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnsVisible: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0
  }),
  ...mod("ColumnAutoSize", {
    sizeColumnsToFit: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0
  }),
  ...mod("ColumnGroup", {
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumnGroup: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0
  }),
  ...mod("ColumnMove", {
    moveColumnByIndex: 0,
    moveColumns: 0
  }),
  ...mod("ColumnResize", {
    setColumnWidths: 0
  }),
  ...mod("ColumnHover", {
    isColumnHovered: 0
  }),
  ...mod("EditCore", {
    getCellEditorInstances: 0,
    getEditingCells: 0,
    stopEditing: 0,
    startEditingCell: 0
  }),
  ...mod("UndoRedoEdit", {
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0
  }),
  ...mod("FilterCore", {
    isAnyFilterPresent: 0,
    onFilterChanged: 0
  }),
  ...mod("ColumnFilter", {
    isColumnFilterPresent: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0
  }),
  ...mod("QuickFilter", {
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0
  }),
  ...mod("Pagination", {
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0
  }),
  ...mod("CsrmSsrmSharedApi", {
    expandAll: 0,
    collapseAll: 0,
    onRowHeightChanged: 0
  }),
  ...mod("SsrmInfiniteSharedApi", {
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...mod("ClientSideRowModelApi", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    resetRowHeights: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0
  }),
  ...mod("CsvExport", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...mod("InfiniteRowModel", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...mod("AdvancedFilter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...mod("IntegratedCharts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...mod("Clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...mod("ExcelExport", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...mod("SharedMasterDetail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...mod("ContextMenu", {
    showContextMenu: 0
  }),
  ...mod("ColumnMenu", {
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...mod("CellSelection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...mod("SharedRowGrouping", {
    setRowGroupColumns: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0
  }),
  ...mod("SharedAggregation", {
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0
  }),
  ...mod("SharedPivot", {
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumns: 0,
    addValueColumns: 0,
    setPivotColumns: 0,
    removePivotColumns: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...mod("ServerSideRowModelApi", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0
  }),
  ...mod("SideBar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...mod("StatusBar", {
    getStatusPanel: 0
  })
};

// packages/ag-grid-community/src/api/apiFunctionService.ts
var defaultFns = {
  isDestroyed: () => true,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
};
var dispatchEvent = (beans, event) => beans.eventSvc.dispatchEvent(event);
var GridApiClass = class {
};
Reflect.defineProperty(GridApiClass, "name", { value: "GridApi" });
var ApiFunctionService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "apiFunctionSvc";
    this.api = new GridApiClass();
    this.fns = {
      ...defaultFns,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent
    };
    this.preDestroyLink = "";
    const { api } = this;
    for (const key of Object.keys(gridApiFunctionsMap)) {
      api[key] = this.makeApi(key)[key];
    }
  }
  postConstruct() {
    this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(functionName, func) {
    const { fns, beans } = this;
    if (fns !== defaultFns) {
      fns[functionName] = beans?.validation?.validateApiFunction(functionName, func) ?? func;
    }
  }
  makeApi(apiName) {
    return {
      [apiName]: (...args) => {
        const {
          beans,
          fns: { [apiName]: fn }
        } = this;
        return fn ? fn(beans, ...args) : this.apiNotFound(apiName);
      }
    };
  }
  apiNotFound(fnName) {
    const { beans, gos, preDestroyLink } = this;
    if (!beans) {
      _warn(26, { fnName, preDestroyLink });
    } else {
      const module2 = gridApiFunctionsMap[fnName];
      if (gos.assertModuleRegistered(module2, `api.${fnName}`)) {
        _warn(27, { fnName, module: module2 });
      }
    }
  }
  destroy() {
    super.destroy();
    this.fns = defaultFns;
    this.beans = null;
  }
};

// packages/ag-grid-community/src/api/coreApi.ts
function getGridId(beans) {
  return beans.context.getGridId();
}
function destroy(beans) {
  beans.gridDestroySvc.destroy();
}
function isDestroyed(beans) {
  return beans.gridDestroySvc.destroyCalled;
}
function getGridOption(beans, key) {
  return beans.gos.get(key);
}
function setGridOption(beans, key, value) {
  updateGridOptions(beans, { [key]: value });
}
function updateGridOptions(beans, options) {
  beans.gos.updateGridOptions({ options });
}

// packages/ag-grid-community/src/rendering/dndSourceComp.ts
var DndSourceComp = class extends Component {
  constructor(rowNode, column, eCell) {
    super(
      /* html */
      `<div class="ag-drag-handle ag-row-drag" draggable="true"></div>`
    );
    this.rowNode = rowNode;
    this.column = column;
    this.eCell = eCell;
  }
  postConstruct() {
    const eGui = this.getGui();
    eGui.appendChild(_createIconNoSpan("rowDrag", this.beans, null));
    this.addGuiEventListener("mousedown", (e) => {
      e.stopPropagation();
    });
    this.addDragSource();
    this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(dragEvent) {
    const { rowNode, column, eCell, gos } = this;
    const providedOnRowDrag = column.getColDef().dndSourceOnRowDrag;
    const dataTransfer = dragEvent.dataTransfer;
    dataTransfer.setDragImage(eCell, 0, 0);
    if (providedOnRowDrag) {
      const params = gos.addGridCommonParams({
        rowNode,
        dragEvent
      });
      providedOnRowDrag(params);
    } else {
      try {
        const jsonData = JSON.stringify(rowNode.data);
        dataTransfer.setData("application/json", jsonData);
        dataTransfer.setData("text/plain", jsonData);
      } catch (e) {
      }
    }
  }
  checkVisibility() {
    const visible = this.column.isDndSource(this.rowNode);
    this.setDisplayed(visible);
  }
};

// packages/ag-grid-community/src/dragAndDrop/dragApi.ts
function addRowDropZone(beans, params) {
  beans.rowDragSvc?.rowDragFeature?.addRowDropZone(params);
}
function removeRowDropZone(beans, params) {
  const activeDropTarget = beans.dragAndDrop?.findExternalZone(params);
  if (activeDropTarget) {
    beans.dragAndDrop?.removeDropTarget(activeDropTarget);
  }
}
function getRowDropZoneParams(beans, events) {
  return beans.rowDragSvc?.rowDragFeature?.getRowDropZone(events);
}

// packages/ag-grid-community/src/dragAndDrop/horizontalResizeService.ts
var HorizontalResizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "horizontalResizeSvc";
  }
  addResizeBar(params) {
    const dragSource = {
      dragStartPixels: params.dragStartPixels || 0,
      eElement: params.eResizeBar,
      onDragStart: this.onDragStart.bind(this, params),
      onDragStop: this.onDragStop.bind(this, params),
      onDragging: this.onDragging.bind(this, params),
      onDragCancel: this.onDragStop.bind(this, params),
      includeTouch: true,
      stopPropagationForTouch: true
    };
    const { dragSvc } = this.beans;
    dragSvc.addDragSource(dragSource);
    const finishedWithResizeFunc = () => dragSvc.removeDragSource(dragSource);
    return finishedWithResizeFunc;
  }
  onDragStart(params, mouseEvent) {
    this.dragStartX = mouseEvent.clientX;
    this.setResizeIcons();
    const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
    params.onResizeStart(shiftKey);
  }
  setResizeIcons() {
    const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
    ctrl.setResizeCursor(true);
    ctrl.disableUserSelect(true);
  }
  onDragStop(params) {
    params.onResizeEnd(this.resizeAmount);
    this.resetIcons();
  }
  resetIcons() {
    const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
    ctrl.setResizeCursor(false);
    ctrl.disableUserSelect(false);
  }
  onDragging(params, mouseEvent) {
    this.resizeAmount = mouseEvent.clientX - this.dragStartX;
    params.onResizing(this.resizeAmount);
  }
};

// packages/ag-grid-community/src/dragAndDrop/rowDragComp.ts
var RowDragComp = class extends Component {
  constructor(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
    super();
    this.cellValueFn = cellValueFn;
    this.rowNode = rowNode;
    this.column = column;
    this.customGui = customGui;
    this.dragStartPixels = dragStartPixels;
    this.suppressVisibilityChange = suppressVisibilityChange;
    this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    const { beans, rowNode, column, gos } = this;
    if (!this.customGui) {
      this.setTemplate(
        /* html */
        `<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>`
      );
      this.getGui().appendChild(_createIconNoSpan("rowDrag", beans, null));
      this.addDragSource();
    } else {
      this.setDragElement(this.customGui, this.dragStartPixels);
    }
    if (!this.suppressVisibilityChange) {
      const strategy = gos.get("rowDragManaged") ? new ManagedVisibilityStrategy(this, rowNode, column) : new NonManagedVisibilityStrategy(this, rowNode, column);
      this.createManagedBean(strategy, this.beans.context);
    }
  }
  setDragElement(dragElement, dragStartPixels) {
    this.setTemplateFromElement(dragElement, void 0, void 0, true);
    this.addDragSource(dragStartPixels);
  }
  getSelectedNodes() {
    const rowNode = this.rowNode;
    const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
    if (!isRowDragMultiRow) {
      return [rowNode];
    }
    const selection = this.beans.selectionSvc?.getSelectedNodes() ?? [];
    return selection.indexOf(rowNode) !== -1 ? selection : [rowNode];
  }
  getDragItem() {
    const { column, rowNode } = this;
    return {
      rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: column ? [column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(column) {
    if (column) {
      const colDef = column.getColDef();
      if (colDef.rowDragText) {
        return colDef.rowDragText;
      }
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(dragStartPixels = 4) {
    if (this.dragSource) {
      this.removeDragSource();
    }
    const eGui = this.getGui();
    if (this.gos.get("enableCellTextSelection")) {
      this.removeMouseDownListener();
      this.mouseDownListener = this.addManagedElementListeners(eGui, {
        mousedown: (e) => {
          e?.preventDefault();
        }
      })[0];
    }
    const translate = this.getLocaleTextFunc();
    this.dragSource = {
      type: 2 /* RowDrag */,
      eElement: eGui,
      dragItemName: () => {
        const dragItem = this.getDragItem();
        const dragItemCount = dragItem.rowNodes?.length || 1;
        const rowDragText = this.getRowDragText(this.column);
        if (rowDragText) {
          return rowDragText(dragItem, dragItemCount);
        }
        return dragItemCount === 1 ? this.cellValueFn() : `${dragItemCount} ${translate("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    };
    this.beans.dragAndDrop.addDragSource(this.dragSource, true);
  }
  destroy() {
    this.removeDragSource();
    this.removeMouseDownListener();
    super.destroy();
  }
  removeDragSource() {
    if (!this.dragSource) {
      return;
    }
    this.beans.dragAndDrop.removeDragSource(this.dragSource);
    this.dragSource = null;
  }
  removeMouseDownListener() {
    if (!this.mouseDownListener) {
      return;
    }
    this.mouseDownListener();
    this.mouseDownListener = void 0;
  }
};
var VisibilityStrategy = class extends BeanStub {
  constructor(parent, rowNode, column) {
    super();
    this.parent = parent;
    this.rowNode = rowNode;
    this.column = column;
  }
  setDisplayedOrVisible(neverDisplayed) {
    const displayedOptions = { skipAriaHidden: true };
    if (neverDisplayed) {
      this.parent.setDisplayed(false, displayedOptions);
    } else {
      let shown = true;
      let isShownSometimes = false;
      const { column, rowNode, parent } = this;
      if (column) {
        shown = column.isRowDrag(rowNode) || parent.isCustomGui();
        isShownSometimes = typeof column.getColDef().rowDrag === "function";
      }
      if (isShownSometimes) {
        parent.setDisplayed(true, displayedOptions);
        parent.setVisible(shown, displayedOptions);
      } else {
        parent.setDisplayed(shown, displayedOptions);
        parent.setVisible(true, displayedOptions);
      }
    }
  }
};
var NonManagedVisibilityStrategy = class extends VisibilityStrategy {
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const listener = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, {
      dataChanged: listener,
      cellChanged: listener
    });
    this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: listener });
    this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const neverDisplayed = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(neverDisplayed);
  }
};
var ManagedVisibilityStrategy = class extends VisibilityStrategy {
  postConstruct() {
    const listener = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventSvc, {
      sortChanged: listener,
      filterChanged: listener,
      columnRowGroupChanged: listener,
      newColumnsLoaded: listener
    });
    this.addManagedListeners(this.rowNode, {
      dataChanged: listener,
      cellChanged: listener
    });
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const { rowDragSvc, dragAndDrop, gos } = this.beans;
    const rowDragFeature = rowDragSvc.rowDragFeature;
    const shouldPreventRowMove = rowDragFeature && rowDragFeature.shouldPreventRowMove();
    const suppressRowDrag = gos.get("suppressRowDrag");
    const hasExternalDropZones = dragAndDrop.hasExternalDropZones();
    const neverDisplayed = shouldPreventRowMove && !hasExternalDropZones || suppressRowDrag;
    this.setDisplayedOrVisible(neverDisplayed);
  }
};

// packages/ag-grid-community/src/dragAndDrop/rowDragService.ts
var RowDragService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowDragSvc";
  }
  setupRowDrag(element, ctrl) {
    const rowDragFeature = ctrl.createManagedBean(new RowDragFeature(element));
    const dragAndDrop = this.beans.dragAndDrop;
    dragAndDrop.addDropTarget(rowDragFeature);
    ctrl.addDestroyFunc(() => dragAndDrop.removeDropTarget(rowDragFeature));
    this.rowDragFeature = rowDragFeature;
  }
  createRowDragComp(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
    return new RowDragComp(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange);
  }
  createRowDragCompForRow(rowNode, element) {
    if (_isCellSelectionEnabled(this.gos)) {
      return void 0;
    }
    const translate = this.getLocaleTextFunc();
    return this.createRowDragComp(
      () => `1 ${translate("rowDragRow", "row")}`,
      rowNode,
      void 0,
      element,
      void 0,
      true
    );
  }
  createRowDragCompForCell(rowNode, column, cellValueFn, element, dragStartPixels, suppressVisibilityChange) {
    const gos = this.gos;
    if (gos.get("rowDragManaged")) {
      if (!_isClientSideRowModel(gos) || gos.get("pagination")) {
        return void 0;
      }
    }
    const rowDragComp = this.createRowDragComp(
      cellValueFn,
      rowNode,
      column,
      element,
      dragStartPixels,
      suppressVisibilityChange
    );
    return rowDragComp;
  }
};

// packages/ag-grid-community/src/dragAndDrop/dragModule.ts
var DragModule = {
  moduleName: "Drag",
  version: VERSION,
  beans: [DragService]
};
var DragAndDropModule = {
  moduleName: "DragAndDrop",
  version: VERSION,
  dynamicBeans: {
    dndSourceComp: DndSourceComp
  },
  icons: {
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
};
var SharedDragAndDropModule = {
  moduleName: "SharedDragAndDrop",
  version: VERSION,
  beans: [DragAndDropService],
  dependsOn: [DragModule],
  userComponents: {
    agDragAndDropImage: DragAndDropImageComponent2
  },
  icons: {
    // shown on drag and drop image component icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on drag and drop image component icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on drag and drop image component icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on drag and drop image component icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on drag and drop image component icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
    // string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
};
var RowDragModule = {
  moduleName: "RowDrag",
  version: VERSION,
  beans: [RowDragService],
  apiFunctions: {
    addRowDropZone,
    removeRowDropZone,
    getRowDropZoneParams
  },
  dependsOn: [SharedDragAndDropModule]
};
var HorizontalResizeModule = {
  moduleName: "HorizontalResize",
  version: VERSION,
  beans: [HorizontalResizeService],
  dependsOn: [DragModule]
};

// packages/ag-grid-community/src/columnMove/column-moving.css-GENERATED.ts
var columnMovingCSS = (
  /*css*/
  `:where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}`
);

// packages/ag-grid-community/src/columnMove/columnAnimationService.ts
var ColumnAnimationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colAnimation";
    this.executeNextFuncs = [];
    this.executeLaterFuncs = [];
    this.active = false;
    // activeNext starts with active but it is reset earlier after the nextFuncs are cleared
    // to prevent calls made to executeNextVMTurn from queuing functions after executeNextFuncs has already been flushed,
    this.activeNext = false;
    this.suppressAnimation = false;
    this.animationThreadCount = 0;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => this.gridBodyCtrl = p.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(suppress) {
    this.suppressAnimation = suppress;
  }
  start() {
    if (this.active) {
      return;
    }
    const { gos } = this;
    if (gos.get("suppressColumnMoveAnimation")) {
      return;
    }
    if (gos.get("enableRtl")) {
      return;
    }
    this.ensureAnimationCssClassPresent();
    this.active = true;
    this.activeNext = true;
  }
  finish() {
    if (!this.active) {
      return;
    }
    this.flush(
      () => this.activeNext = false,
      () => this.active = false
    );
  }
  executeNextVMTurn(func) {
    if (this.activeNext) {
      this.executeNextFuncs.push(func);
    } else {
      func();
    }
  }
  executeLaterVMTurn(func) {
    if (this.active) {
      this.executeLaterFuncs.push(func);
    } else {
      func();
    }
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const animationThreadCountCopy = this.animationThreadCount;
    const { gridBodyCtrl } = this;
    gridBodyCtrl.setColumnMovingCss(true);
    this.executeLaterFuncs.push(() => {
      if (this.animationThreadCount === animationThreadCountCopy) {
        gridBodyCtrl.setColumnMovingCss(false);
      }
    });
  }
  flush(callbackNext, callbackLater) {
    const { executeNextFuncs, executeLaterFuncs } = this;
    if (executeNextFuncs.length === 0 && executeLaterFuncs.length === 0) {
      callbackNext();
      callbackLater();
      return;
    }
    const runFuncs = (queue) => {
      while (queue.length) {
        const func = queue.pop();
        if (func) {
          func();
        }
      }
    };
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        callbackNext();
        runFuncs(executeNextFuncs);
      }, 0);
      window.setTimeout(() => {
        callbackLater();
        runFuncs(executeLaterFuncs);
      }, 200);
    });
  }
};

// packages/ag-grid-community/src/columnMove/columnMoveApi.ts
function moveColumnByIndex(beans, fromIndex, toIndex) {
  beans.colMoves?.moveColumnByIndex(fromIndex, toIndex, "api");
}
function moveColumns(beans, columnsToMoveKeys, toIndex) {
  beans.colMoves?.moveColumns(columnsToMoveKeys, toIndex, "api");
}

// packages/ag-grid-community/src/columnMove/columnDrag/bodyDropPivotTarget.ts
var BodyDropPivotTarget = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.columnsToAggregate = [];
    this.columnsToGroup = [];
    this.columnsToPivot = [];
  }
  /** Callback for when drag enters */
  onDragEnter(draggingEvent) {
    this.clearColumnsList();
    if (this.gos.get("functionsReadOnly")) {
      return;
    }
    const dragColumns = draggingEvent.dragItem.columns;
    if (!dragColumns) {
      return;
    }
    dragColumns.forEach((column) => {
      if (!column.isPrimary()) {
        return;
      }
      if (column.isAnyFunctionActive()) {
        return;
      }
      if (column.isAllowValue()) {
        this.columnsToAggregate.push(column);
      } else if (column.isAllowRowGroup()) {
        this.columnsToGroup.push(column);
      } else if (column.isAllowPivot()) {
        this.columnsToPivot.push(column);
      }
    });
  }
  getIconName() {
    const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
    if (totalColumns > 0) {
      return this.pinned ? "pinned" : "move";
    }
    return null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(draggingEvent) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0;
    this.columnsToGroup.length = 0;
    this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(draggingEvent) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(draggingEvent) {
    const { valueColsSvc, rowGroupColsSvc, pivotColsSvc } = this.beans;
    if (this.columnsToAggregate.length > 0) {
      valueColsSvc?.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
    }
    if (this.columnsToGroup.length > 0) {
      rowGroupColsSvc?.addColumns(this.columnsToGroup, "toolPanelDragAndDrop");
    }
    if (this.columnsToPivot.length > 0) {
      pivotColsSvc?.addColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};

// packages/ag-grid-community/src/columnMove/internalColumnMoveUtils.ts
function sortColsLikeCols(colsList, cols) {
  if (!cols || cols.length <= 1) {
    return;
  }
  const notAllColsPresent = cols.filter((c) => colsList.indexOf(c) < 0).length > 0;
  if (notAllColsPresent) {
    return;
  }
  cols.sort((a, b) => {
    const indexA = colsList.indexOf(a);
    const indexB = colsList.indexOf(b);
    return indexA - indexB;
  });
}
function getBestColumnMoveIndexFromXPosition(params) {
  const { isFromHeader, fromLeft, xPosition, fromEnter, fakeEvent, pinned, gos, colModel, colMoves, visibleCols } = params;
  let { allMovingColumns } = params;
  if (isFromHeader) {
    const newCols = [];
    allMovingColumns.forEach((col) => {
      let movingGroup = null;
      let parent = col.getParent();
      while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
        movingGroup = parent;
        parent = parent.getParent();
      }
      if (movingGroup != null) {
        const isMarryChildren = !!movingGroup.getColGroupDef()?.marryChildren;
        const columnsToMove = isMarryChildren ? (
          // when marry children is true, we also have to move hidden
          // columns within the group, so grab them from the `providedColumnGroup`
          movingGroup.getProvidedColumnGroup().getLeafColumns()
        ) : movingGroup.getLeafColumns();
        columnsToMove.forEach((newCol) => {
          if (!newCols.includes(newCol)) {
            newCols.push(newCol);
          }
        });
      } else if (!newCols.includes(col)) {
        newCols.push(col);
      }
    });
    allMovingColumns = newCols;
  }
  const allMovingColumnsOrdered = allMovingColumns.slice();
  sortColsLikeCols(colModel.getCols(), allMovingColumnsOrdered);
  const validMoves = calculateValidMoves({
    movingCols: allMovingColumnsOrdered,
    draggingRight: fromLeft,
    xPosition,
    pinned,
    gos,
    colModel,
    visibleCols
  });
  const oldIndex = calculateOldIndex(allMovingColumnsOrdered, colModel);
  if (validMoves.length === 0) {
    return;
  }
  const firstValidMove = validMoves[0];
  let constrainDirection = oldIndex !== null && !fromEnter;
  if (isFromHeader) {
    constrainDirection = oldIndex !== null;
  }
  if (constrainDirection && !fakeEvent) {
    if (!fromLeft && firstValidMove >= oldIndex) {
      return;
    }
    if (fromLeft && firstValidMove <= oldIndex) {
      return;
    }
  }
  const displayedCols = visibleCols.allCols;
  const potentialMoves = [];
  let targetOrder = null;
  for (let i = 0; i < validMoves.length; i++) {
    const move = validMoves[i];
    const order = colMoves.getProposedColumnOrder(allMovingColumnsOrdered, move);
    if (!colMoves.doesOrderPassRules(order)) {
      continue;
    }
    const displayedOrder = order.filter((col) => displayedCols.includes(col));
    if (targetOrder === null) {
      targetOrder = displayedOrder;
    } else if (!_areEqual(displayedOrder, targetOrder)) {
      break;
    }
    const fragCount = groupFragCount(order);
    potentialMoves.push({ move, fragCount });
  }
  if (potentialMoves.length === 0) {
    return;
  }
  potentialMoves.sort((a, b) => a.fragCount - b.fragCount);
  const toIndex = potentialMoves[0].move;
  if (toIndex > colModel.getCols().length - allMovingColumns.length) {
    return;
  }
  return { columns: allMovingColumns, toIndex };
}
function attemptMoveColumns(params) {
  const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(params) || {};
  const { finished, colMoves } = params;
  if (!columns || toIndex == null) {
    return null;
  }
  colMoves.moveColumns(columns, toIndex, "uiColumnMoved", finished);
  return finished ? null : { columns, toIndex };
}
function calculateOldIndex(movingCols, colModel) {
  const gridCols = colModel.getCols();
  const indexes = _sortNumerically(movingCols.map((col) => gridCols.indexOf(col)));
  const firstIndex = indexes[0];
  const lastIndex = _last(indexes);
  const spread = lastIndex - firstIndex;
  const gapsExist = spread !== indexes.length - 1;
  return gapsExist ? null : firstIndex;
}
function groupFragCount(columns) {
  function parents(col) {
    const result = [];
    let parent = col.getOriginalParent();
    while (parent != null) {
      result.push(parent);
      parent = parent.getOriginalParent();
    }
    return result;
  }
  let count = 0;
  for (let i = 0; i < columns.length - 1; i++) {
    let a = parents(columns[i]);
    let b = parents(columns[i + 1]);
    [a, b] = a.length > b.length ? [a, b] : [b, a];
    a.forEach((parent) => {
      if (b.indexOf(parent) === -1) {
        count++;
      }
    });
  }
  return count;
}
function getDisplayedColumns(visibleCols, type) {
  switch (type) {
    case "left":
      return visibleCols.leftCols;
    case "right":
      return visibleCols.rightCols;
    default:
      return visibleCols.centerCols;
  }
}
function calculateValidMoves(params) {
  const { movingCols, draggingRight, xPosition, pinned, gos, colModel, visibleCols } = params;
  const isMoveBlocked = gos.get("suppressMovableColumns") || movingCols.some((col) => col.getColDef().suppressMovable);
  if (isMoveBlocked) {
    return [];
  }
  const allDisplayedCols = getDisplayedColumns(visibleCols, pinned);
  const allGridCols = colModel.getCols();
  const movingDisplayedCols = allDisplayedCols.filter((col) => movingCols.includes(col));
  const otherDisplayedCols = allDisplayedCols.filter((col) => !movingCols.includes(col));
  const otherGridCols = allGridCols.filter((col) => !movingCols.includes(col));
  let displayIndex = 0;
  let availableWidth = xPosition;
  if (draggingRight) {
    let widthOfMovingDisplayedCols = 0;
    movingDisplayedCols.forEach((col) => widthOfMovingDisplayedCols += col.getActualWidth());
    availableWidth -= widthOfMovingDisplayedCols;
  }
  if (availableWidth > 0) {
    for (let i = 0; i < otherDisplayedCols.length; i++) {
      const col = otherDisplayedCols[i];
      availableWidth -= col.getActualWidth();
      if (availableWidth < 0) {
        break;
      }
      displayIndex++;
    }
    if (draggingRight) {
      displayIndex++;
    }
  }
  let firstValidMove;
  if (displayIndex > 0) {
    const leftColumn = otherDisplayedCols[displayIndex - 1];
    firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
  } else {
    firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
    if (firstValidMove === -1) {
      firstValidMove = 0;
    }
  }
  const validMoves = [firstValidMove];
  const numberComparator = (a, b) => a - b;
  if (draggingRight) {
    let pointer = firstValidMove + 1;
    const lastIndex = allGridCols.length - 1;
    while (pointer <= lastIndex) {
      validMoves.push(pointer);
      pointer++;
    }
    validMoves.sort(numberComparator);
  } else {
    let pointer = firstValidMove;
    const lastIndex = allGridCols.length - 1;
    let displacedCol = allGridCols[pointer];
    while (pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0) {
      pointer++;
      validMoves.push(pointer);
      displacedCol = allGridCols[pointer];
    }
    pointer = firstValidMove - 1;
    const firstDisplayIndex = 0;
    while (pointer >= firstDisplayIndex) {
      validMoves.push(pointer);
      pointer--;
    }
    validMoves.sort(numberComparator).reverse();
  }
  return validMoves;
}
function normaliseX(params) {
  const { pinned, fromKeyboard, gos, ctrlsSvc, useHeaderRow, skipScrollPadding } = params;
  let eViewport = ctrlsSvc.getHeaderRowContainerCtrl(pinned)?.eViewport;
  let { x } = params;
  if (!eViewport) {
    return 0;
  }
  if (fromKeyboard) {
    x -= eViewport.getBoundingClientRect().left;
  }
  if (gos.get("enableRtl")) {
    if (useHeaderRow) {
      eViewport = eViewport.querySelector(".ag-header-row");
    }
    x = eViewport.clientWidth - x;
  }
  if (pinned == null && !skipScrollPadding) {
    x += ctrlsSvc.get("center").getCenterViewportScrollLeft();
  }
  return x;
}
function setColumnsMoving(columns, isMoving) {
  for (const column of columns) {
    column.moving = isMoving;
    column.dispatchColEvent("movingChanged", "uiColumnMoved");
  }
}

// packages/ag-grid-community/src/columnMove/columnDrag/moveColumnFeature.ts
var MOVE_FAIL_THRESHOLD = 7;
var SCROLL_MOVE_WIDTH = 100;
var SCROLL_GAP_NEEDED_BEFORE_MOVE = SCROLL_MOVE_WIDTH / 2;
var SCROLL_ACCELERATION_RATE = 5;
var SCROLL_TIME_INTERVAL = 100;
var MoveColumnFeature = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.needToMoveLeft = false;
    this.needToMoveRight = false;
    this.lastMovedInfo = null;
    this.isCenterContainer = !_exists(pinned);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  getIconName() {
    const { pinned, lastDraggingEvent } = this;
    const columns = lastDraggingEvent?.dragItem.columns ?? [];
    for (const col of columns) {
      const colPinned = col.getPinned();
      if (col.getColDef().lockPinned) {
        if (colPinned == pinned) {
          return "move";
        }
        continue;
      }
      if (colPinned === pinned || !pinned) {
        return "move";
      }
      if (!colPinned && pinned) {
        return "pinned";
      }
    }
    return "notAllowed";
  }
  onDragEnter(draggingEvent) {
    const dragItem = draggingEvent.dragItem;
    const columns = dragItem.columns;
    const dragCameFromToolPanel = draggingEvent.dragSource.type === 0 /* ToolPanel */;
    if (dragCameFromToolPanel) {
      this.setColumnsVisible(columns, true, "uiColumnDragged");
    } else {
      const visibleState = dragItem.visibleState;
      const visibleColumns = (columns || []).filter((column) => visibleState[column.getId()]);
      this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
    }
    if (!this.gos.get("suppressMoveWhenColumnDragging")) {
      this.attemptToPinColumns(columns, this.pinned);
    }
    this.onDragging(draggingEvent, true, true);
  }
  onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
    const { gos, ctrlsSvc } = this.beans;
    const isSuppressMoveWhenDragging = gos.get("suppressMoveWhenColumnDragging");
    if (finished && !isSuppressMoveWhenDragging) {
      this.finishColumnMoving();
      return;
    }
    this.lastDraggingEvent = draggingEvent;
    if (!draggingEvent || !finished && _missing(draggingEvent.hDirection)) {
      return;
    }
    const mouseX = normaliseX({
      x: draggingEvent.x,
      pinned: this.pinned,
      gos,
      ctrlsSvc
    });
    if (!fromEnter) {
      this.checkCenterForScrolling(mouseX);
    }
    if (isSuppressMoveWhenDragging) {
      this.handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
    } else {
      this.handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
    }
  }
  onDragLeave() {
    this.ensureIntervalCleared();
    this.clearHighlighted();
    this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, false, true, true);
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted();
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  setColumnsVisible(columns, visible, source) {
    if (!columns) {
      return;
    }
    const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
    this.beans.colModel.setColsVisible(allowedCols, visible, source);
  }
  finishColumnMoving() {
    this.clearHighlighted();
    const lastMovedInfo = this.lastMovedInfo;
    if (!lastMovedInfo) {
      return;
    }
    const { columns, toIndex } = lastMovedInfo;
    this.beans.colMoves.moveColumns(columns, toIndex, "uiColumnMoved", true);
  }
  handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
    const allMovingColumns = this.getAllMovingColumns(draggingEvent, true);
    if (finished) {
      const isAttemptingToPin = this.isAttemptingToPin(allMovingColumns);
      if (isAttemptingToPin) {
        this.attemptToPinColumns(allMovingColumns, void 0, true);
      }
      const { fromLeft, xPosition } = this.getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) || {};
      if (fromLeft == null || xPosition == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns,
        xPosition,
        fromEnter,
        fakeEvent,
        fromLeft
      });
    } else {
      if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
        return;
      }
      this.highlightHoveredColumn(allMovingColumns, mouseX);
    }
  }
  handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
    const allMovingColumns = this.getAllMovingColumns(draggingEvent);
    const fromLeft = this.normaliseDirection(draggingEvent.hDirection) === "right";
    const isFromHeader = draggingEvent.dragSource.type === 1 /* HeaderCell */;
    const params = this.getMoveColumnParams({
      allMovingColumns,
      isFromHeader,
      xPosition: mouseX,
      fromLeft,
      fromEnter,
      fakeEvent
    });
    const lastMovedInfo = attemptMoveColumns({ ...params, finished });
    if (lastMovedInfo) {
      this.lastMovedInfo = lastMovedInfo;
    }
  }
  getAllMovingColumns(draggingEvent, useSplit = false) {
    const dragItem = draggingEvent.dragSource.getDragItem();
    let columns = null;
    if (useSplit) {
      columns = dragItem.columnsInSplit;
      if (!columns) {
        columns = dragItem.columns;
      }
    } else {
      columns = dragItem.columns;
    }
    const conditionCallback = (col) => col.getColDef().lockPinned ? col.getPinned() == this.pinned : true;
    if (!columns) {
      return [];
    }
    return columns.filter(conditionCallback);
  }
  getMoveColumnParams(params) {
    const { allMovingColumns, isFromHeader, xPosition, fromLeft, fromEnter, fakeEvent } = params;
    const { gos, colModel, colMoves, visibleCols } = this.beans;
    return {
      allMovingColumns,
      isFromHeader,
      fromLeft,
      xPosition,
      pinned: this.pinned,
      fromEnter,
      fakeEvent,
      gos,
      colModel,
      colMoves,
      visibleCols
    };
  }
  highlightHoveredColumn(movingColumns, mouseX) {
    const { gos, colModel } = this.beans;
    const isRtl = gos.get("enableRtl");
    const consideredColumns = colModel.getCols().filter((col) => col.isVisible() && col.getPinned() === this.pinned);
    let start = null;
    let width = null;
    let targetColumn = null;
    for (const col of consideredColumns) {
      width = col.getActualWidth();
      start = this.getNormalisedColumnLeft(col, 0, isRtl);
      if (start != null) {
        const end = start + width;
        if (start <= mouseX && end >= mouseX) {
          targetColumn = col;
          break;
        }
      }
      start = null;
      width = null;
    }
    if (!targetColumn) {
      for (let i = consideredColumns.length - 1; i >= 0; i--) {
        const currentColumn = consideredColumns[i];
        const parent = consideredColumns[i].getParent();
        if (!parent) {
          targetColumn = currentColumn;
          break;
        }
        const leafDisplayedCols = parent?.getDisplayedLeafColumns();
        if (leafDisplayedCols.length) {
          targetColumn = _last(leafDisplayedCols);
          break;
        }
      }
      if (!targetColumn) {
        return;
      }
      start = this.getNormalisedColumnLeft(targetColumn, 0, isRtl);
      width = targetColumn.getActualWidth();
    } else if (movingColumns.indexOf(targetColumn) !== -1) {
      targetColumn = null;
    }
    if (this.lastHighlightedColumn?.column !== targetColumn) {
      this.clearHighlighted();
    }
    if (targetColumn == null || start == null || width == null) {
      return;
    }
    let position;
    if (mouseX - start < width / 2 !== isRtl) {
      position = 0 /* Before */;
    } else {
      position = 1 /* After */;
    }
    setColumnHighlighted(targetColumn, position);
    this.lastHighlightedColumn = { column: targetColumn, position };
  }
  getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) {
    const { gos, visibleCols } = this.beans;
    const isRtl = gos.get("enableRtl");
    const { firstMovingCol, column, position } = this.getColumnMoveAndTargetInfo(
      allMovingColumns,
      isAttemptingToPin,
      isRtl
    );
    if (!firstMovingCol || !column || position == null) {
      return;
    }
    const visibleColumns = visibleCols.allCols;
    const movingColIndex = visibleColumns.indexOf(firstMovingCol);
    const targetIndex = visibleColumns.indexOf(column);
    const isBefore = position === 0 /* Before */ !== isRtl;
    const fromLeft = movingColIndex < targetIndex || movingColIndex === targetIndex && !isBefore;
    let diff = 0;
    if (isBefore) {
      if (fromLeft) {
        diff -= 1;
      }
    } else {
      if (!fromLeft) {
        diff += 1;
      }
    }
    if (targetIndex + diff === movingColIndex) {
      return;
    }
    const targetColumn = visibleColumns[targetIndex + diff];
    if (!targetColumn) {
      return;
    }
    const xPosition = this.getNormalisedColumnLeft(targetColumn, 20, isRtl);
    return { fromLeft, xPosition };
  }
  getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl) {
    const lastHighlightedColumn = this.lastHighlightedColumn || {};
    const { firstMovingCol, lastMovingCol } = findFirstAndLastMovingColumns(allMovingColumns);
    if (!firstMovingCol || !lastMovingCol || lastHighlightedColumn.column || !isAttemptingToPin) {
      return {
        firstMovingCol,
        ...lastHighlightedColumn
      };
    }
    const pinned = this.getPinDirection();
    const isLeft = pinned === "left";
    return {
      firstMovingCol,
      position: isLeft ? 1 /* After */ : 0 /* Before */,
      column: isLeft !== isRtl ? firstMovingCol : lastMovingCol
    };
  }
  normaliseDirection(hDirection) {
    if (this.gos.get("enableRtl")) {
      switch (hDirection) {
        case "left":
          return "right";
        case "right":
          return "left";
      }
    }
    return hDirection;
  }
  getNormalisedColumnLeft(col, padding, isRtl) {
    const { gos, ctrlsSvc } = this.beans;
    const left = col.getLeft();
    if (left == null) {
      return null;
    }
    const width = col.getActualWidth();
    return normaliseX({
      x: isRtl ? left + width - padding : left + padding,
      pinned: col.getPinned(),
      useHeaderRow: isRtl,
      skipScrollPadding: true,
      gos,
      ctrlsSvc
    });
  }
  isAttemptingToPin(columns) {
    const isMovingHorizontally = this.needToMoveLeft || this.needToMoveRight;
    const isFailedMoreThanThreshold = this.failedMoveAttempts > MOVE_FAIL_THRESHOLD;
    return isMovingHorizontally && isFailedMoreThanThreshold || columns.some((col) => col.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(params) {
    const { allMovingColumns, xPosition, fromEnter, fakeEvent, fromLeft } = params;
    const columnMoveParams = this.getMoveColumnParams({
      allMovingColumns,
      isFromHeader: true,
      xPosition,
      fromLeft,
      fromEnter,
      fakeEvent
    });
    const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(columnMoveParams) || {};
    if (columns && toIndex != null) {
      this.lastMovedInfo = {
        columns,
        toIndex
      };
    }
    this.finishColumnMoving();
  }
  clearHighlighted() {
    const { lastHighlightedColumn } = this;
    if (!lastHighlightedColumn) {
      return;
    }
    setColumnHighlighted(lastHighlightedColumn.column, null);
    this.lastHighlightedColumn = null;
  }
  checkCenterForScrolling(xAdjustedForScroll) {
    if (!this.isCenterContainer) {
      return;
    }
    const centerCtrl = this.beans.ctrlsSvc.get("center");
    const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
    const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
    let needToMoveRight;
    let needToMoveLeft;
    if (this.gos.get("enableRtl")) {
      needToMoveRight = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
      needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
    } else {
      needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
      needToMoveRight = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
    }
    this.needToMoveRight = needToMoveRight;
    this.needToMoveLeft = needToMoveLeft;
    if (needToMoveLeft || needToMoveRight) {
      this.ensureIntervalStarted();
    } else {
      this.ensureIntervalCleared();
    }
  }
  ensureIntervalStarted() {
    if (this.movingIntervalId) {
      return;
    }
    this.intervalCount = 0;
    this.failedMoveAttempts = 0;
    this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), SCROLL_TIME_INTERVAL);
    this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.needToMoveLeft ? "left" : "right", true);
  }
  ensureIntervalCleared() {
    if (!this.movingIntervalId) {
      return;
    }
    window.clearInterval(this.movingIntervalId);
    this.movingIntervalId = null;
    this.failedMoveAttempts = 0;
    this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.getIconName(), false);
  }
  moveInterval() {
    let pixelsToMove;
    this.intervalCount++;
    pixelsToMove = 10 + this.intervalCount * SCROLL_ACCELERATION_RATE;
    if (pixelsToMove > SCROLL_MOVE_WIDTH) {
      pixelsToMove = SCROLL_MOVE_WIDTH;
    }
    let pixelsMoved = null;
    const scrollFeature = this.gridBodyCon.scrollFeature;
    if (this.needToMoveLeft) {
      pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
    } else if (this.needToMoveRight) {
      pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
    }
    if (pixelsMoved !== 0) {
      this.onDragging(this.lastDraggingEvent);
      this.failedMoveAttempts = 0;
    } else {
      this.failedMoveAttempts++;
      const { pinnedCols, dragAndDrop, gos } = this.beans;
      if (this.failedMoveAttempts <= MOVE_FAIL_THRESHOLD + 1 || !pinnedCols) {
        return;
      }
      dragAndDrop.getDragAndDropImageComponent()?.setIcon("pinned", false);
      if (!gos.get("suppressMoveWhenColumnDragging")) {
        const columns = this.lastDraggingEvent?.dragItem.columns;
        this.attemptToPinColumns(columns, void 0, true);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left") {
      return "left";
    }
    if (this.needToMoveRight || this.pinned === "right") {
      return "right";
    }
  }
  attemptToPinColumns(columns, pinned, fromMoving = false) {
    const allowedCols = (columns || []).filter((c) => !c.getColDef().lockPinned);
    if (!allowedCols.length) {
      return 0;
    }
    if (fromMoving) {
      pinned = this.getPinDirection();
    }
    const { pinnedCols, dragAndDrop } = this.beans;
    pinnedCols?.setColsPinned(allowedCols, pinned, "uiColumnDragged");
    if (fromMoving) {
      dragAndDrop.nudge();
    }
    return allowedCols.length;
  }
  destroy() {
    super.destroy();
    this.lastDraggingEvent = null;
    this.clearHighlighted();
    this.lastMovedInfo = null;
  }
};
function setColumnHighlighted(column, highlighted) {
  if (column.highlighted === highlighted) {
    return;
  }
  column.highlighted = highlighted;
  column.dispatchColEvent("headerHighlightChanged", "uiColumnMoved");
}
function findFirstAndLastMovingColumns(allMovingColumns) {
  const moveLen = allMovingColumns.length;
  let firstMovingCol;
  let lastMovingCol;
  for (let i = 0; i <= moveLen; i++) {
    if (!firstMovingCol) {
      const leftCol = allMovingColumns[i];
      if (leftCol.getLeft() != null) {
        firstMovingCol = leftCol;
      }
    }
    if (!lastMovingCol) {
      const rightCol = allMovingColumns[moveLen - 1 - i];
      if (rightCol.getLeft() != null) {
        lastMovingCol = rightCol;
      }
    }
    if (firstMovingCol && lastMovingCol) {
      break;
    }
  }
  return { firstMovingCol, lastMovingCol };
}

// packages/ag-grid-community/src/columnMove/columnDrag/bodyDropTarget.ts
var BodyDropTarget = class extends BeanStub {
  constructor(pinned, eContainer) {
    super();
    this.pinned = pinned;
    this.eContainer = eContainer;
  }
  postConstruct() {
    const { ctrlsSvc, dragAndDrop } = this.beans;
    const pinned = this.pinned;
    ctrlsSvc.whenReady(this, (p) => {
      let eSecondaryContainers;
      const eBodyViewport = p.gridBodyCtrl.eBodyViewport;
      switch (pinned) {
        case "left":
          eSecondaryContainers = [
            [eBodyViewport, p.left.eContainer],
            [p.bottomLeft.eContainer],
            [p.topLeft.eContainer]
          ];
          break;
        case "right":
          eSecondaryContainers = [
            [eBodyViewport, p.right.eContainer],
            [p.bottomRight.eContainer],
            [p.topRight.eContainer]
          ];
          break;
        default:
          eSecondaryContainers = [
            [eBodyViewport, p.center.eViewport],
            [p.bottomCenter.eViewport],
            [p.topCenter.eViewport]
          ];
          break;
      }
      this.eSecondaryContainers = eSecondaryContainers;
    });
    this.moveColumnFeature = this.createManagedBean(new MoveColumnFeature(pinned));
    this.bodyDropPivotTarget = this.createManagedBean(new BodyDropPivotTarget(pinned));
    dragAndDrop.addDropTarget(this);
    this.addDestroyFunc(() => dragAndDrop.removeDropTarget(this));
  }
  isInterestedIn(type) {
    return type === 1 /* HeaderCell */ || type === 0 /* ToolPanel */ && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(draggingEvent) {
    return this.beans.colModel.isPivotMode() && draggingEvent.dragSource.type === 0 /* ToolPanel */;
  }
  onDragEnter(draggingEvent) {
    this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
    this.currentDropListener.onDragEnter(draggingEvent);
  }
  onDragLeave(params) {
    this.currentDropListener.onDragLeave(params);
  }
  onDragging(params) {
    this.currentDropListener.onDragging(params);
  }
  onDragStop(params) {
    this.currentDropListener.onDragStop(params);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
};

// packages/ag-grid-community/src/columnMove/columnMoveService.ts
var ColumnMoveService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colMoves";
  }
  moveColumnByIndex(fromIndex, toIndex, source) {
    const gridColumns = this.beans.colModel.getCols();
    if (!gridColumns) {
      return;
    }
    const column = gridColumns[fromIndex];
    this.moveColumns([column], toIndex, source);
  }
  moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
    const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
    const gridColumns = colModel.getCols();
    if (!gridColumns) {
      return;
    }
    if (toIndex > gridColumns.length - columnsToMoveKeys.length) {
      _warn(30, { toIndex });
      return;
    }
    colAnimation?.start();
    const movedColumns = colModel.getColsForKeys(columnsToMoveKeys);
    if (this.doesMovePassRules(movedColumns, toIndex)) {
      _moveInArray(colModel.getCols(), movedColumns, toIndex);
      visibleCols.refresh(source);
      eventSvc.dispatchEvent({
        type: "columnMoved",
        columns: movedColumns,
        column: movedColumns.length === 1 ? movedColumns[0] : null,
        toIndex,
        finished,
        source
      });
    }
    colAnimation?.finish();
  }
  doesMovePassRules(columnsToMove, toIndex) {
    const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
    return this.doesOrderPassRules(proposedColumnOrder);
  }
  doesOrderPassRules(gridOrder) {
    const { colModel, gos } = this.beans;
    if (!doesMovePassMarryChildren(gridOrder, colModel.getColTree())) {
      return false;
    }
    const doesMovePassLockedPositions = (proposedColumnOrder) => {
      const lockPositionToPlacement = (position) => {
        if (!position) {
          return 0 /* NONE */;
        }
        return position === "left" || position === true ? -1 /* LEFT */ : 1 /* RIGHT */;
      };
      const isRtl = gos.get("enableRtl");
      let lastPlacement = isRtl ? 1 /* RIGHT */ : -1 /* LEFT */;
      let rulePassed = true;
      proposedColumnOrder.forEach((col) => {
        const placement = lockPositionToPlacement(col.getColDef().lockPosition);
        if (isRtl) {
          if (placement > lastPlacement) {
            rulePassed = false;
          }
        } else {
          if (placement < lastPlacement) {
            rulePassed = false;
          }
        }
        lastPlacement = placement;
      });
      return rulePassed;
    };
    if (!doesMovePassLockedPositions(gridOrder)) {
      return false;
    }
    return true;
  }
  getProposedColumnOrder(columnsToMove, toIndex) {
    const gridColumns = this.beans.colModel.getCols();
    const proposedColumnOrder = gridColumns.slice();
    _moveInArray(proposedColumnOrder, columnsToMove, toIndex);
    return proposedColumnOrder;
  }
  createBodyDropTarget(pinned, dropContainer) {
    return new BodyDropTarget(pinned, dropContainer);
  }
  moveHeader(hDirection, eGui, column, pinned, bean) {
    const { ctrlsSvc, gos, colModel, visibleCols, focusSvc } = this.beans;
    const rect = eGui.getBoundingClientRect();
    const left = rect.left;
    const isGroup = isColumnGroup2(column);
    const width = isGroup ? rect.width : column.getActualWidth();
    const isLeft = hDirection === "left" !== gos.get("enableRtl");
    const xPosition = normaliseX({
      x: isLeft ? left - 20 : left + width + 20,
      pinned,
      fromKeyboard: true,
      gos,
      ctrlsSvc
    });
    const headerPosition = focusSvc.focusedHeader;
    attemptMoveColumns({
      allMovingColumns: isGroup ? column.getLeafColumns() : [column],
      isFromHeader: true,
      fromLeft: hDirection === "right",
      xPosition,
      pinned,
      fromEnter: false,
      fakeEvent: false,
      gos,
      colModel,
      colMoves: this,
      visibleCols,
      finished: true
    });
    let targetColumn;
    if (isGroup) {
      const displayedLeafColumns = column.getDisplayedLeafColumns();
      targetColumn = isLeft ? displayedLeafColumns[0] : _last(displayedLeafColumns);
    } else {
      targetColumn = column;
    }
    ctrlsSvc.getScrollFeature().ensureColumnVisible(targetColumn, "auto");
    if ((!bean.isAlive() || gos.get("ensureDomOrder")) && headerPosition) {
      let restoreFocusColumn;
      if (isGroup) {
        const groupId = column.getGroupId();
        const leafCols = column.getLeafColumns();
        if (!leafCols.length) {
          return;
        }
        const parent = leafCols[0].getParent();
        if (!parent) {
          return;
        }
        restoreFocusColumn = findGroupWidthId(parent, groupId);
      } else {
        restoreFocusColumn = column;
      }
      if (restoreFocusColumn) {
        focusSvc.focusHeaderPosition({
          headerPosition: {
            ...headerPosition,
            column: restoreFocusColumn
          }
        });
      }
    }
  }
  setDragSourceForHeader(eSource, column, displayName) {
    const { gos, colModel, dragAndDrop, visibleCols } = this.beans;
    let hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
    const isGroup = isColumnGroup2(column);
    const columns = isGroup ? column.getProvidedColumnGroup().getLeafColumns() : [column];
    const getDragItem = isGroup ? () => createDragItemForGroup(column, visibleCols.allCols) : () => createDragItem(column);
    const dragSource = {
      type: 1 /* HeaderCell */,
      eElement: eSource,
      getDefaultIconName: () => hideColumnOnExit ? "hide" : "notAllowed",
      getDragItem,
      dragItemName: displayName,
      onDragStarted: () => {
        hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
        setColumnsMoving(columns, true);
      },
      onDragStopped: () => setColumnsMoving(columns, false),
      onDragCancelled: () => setColumnsMoving(columns, false),
      onGridEnter: (dragItem) => {
        if (hideColumnOnExit) {
          const { columns: columns2 = [], visibleState } = dragItem ?? {};
          const hasVisibleState = isGroup ? (col) => !visibleState || visibleState[col.getColId()] : () => true;
          const unlockedColumns = columns2.filter(
            (col) => !col.getColDef().lockVisible && hasVisibleState(col)
          );
          colModel.setColsVisible(unlockedColumns, true, "uiColumnMoved");
        }
      },
      onGridExit: (dragItem) => {
        if (hideColumnOnExit) {
          const unlockedColumns = dragItem?.columns?.filter((col) => !col.getColDef().lockVisible) || [];
          colModel.setColsVisible(unlockedColumns, false, "uiColumnMoved");
        }
      }
    };
    dragAndDrop.addDragSource(dragSource, true);
    return dragSource;
  }
};
function findGroupWidthId(columnGroup, id) {
  while (columnGroup) {
    if (columnGroup.getGroupId() === id) {
      return columnGroup;
    }
    columnGroup = columnGroup.getParent();
  }
  return void 0;
}
function createDragItem(column) {
  const visibleState = {};
  visibleState[column.getId()] = column.isVisible();
  return {
    columns: [column],
    visibleState
  };
}
function createDragItemForGroup(columnGroup, allCols) {
  const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
  const visibleState = {};
  allColumnsOriginalOrder.forEach((column) => visibleState[column.getId()] = column.isVisible());
  const allColumnsCurrentOrder = [];
  allCols.forEach((column) => {
    if (allColumnsOriginalOrder.indexOf(column) >= 0) {
      allColumnsCurrentOrder.push(column);
      _removeFromArray(allColumnsOriginalOrder, column);
    }
  });
  allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
  const columnsInSplit = [];
  const columnGroupColumns = columnGroup.getLeafColumns();
  for (const col of allColumnsCurrentOrder) {
    if (columnGroupColumns.indexOf(col) !== -1) {
      columnsInSplit.push(col);
    }
  }
  return {
    columns: allColumnsCurrentOrder,
    columnsInSplit,
    visibleState
  };
}

// packages/ag-grid-community/src/columnMove/columnMoveModule.ts
var ColumnMoveModule = {
  moduleName: "ColumnMove",
  version: VERSION,
  beans: [ColumnMoveService, ColumnAnimationService],
  apiFunctions: {
    moveColumnByIndex,
    moveColumns
  },
  dependsOn: [SharedDragAndDropModule],
  css: [columnMovingCSS]
};

// packages/ag-grid-community/src/rendering/autoWidthCalculator.ts
var AutoWidthCalculator = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "autoWidthCalc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.centerRowContainerCtrl = p.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(column, skipHeader) {
    const eHeaderCell = this.getHeaderCellForColumn(column);
    if (!eHeaderCell) {
      return -1;
    }
    const elements = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(column);
    if (!skipHeader) {
      elements.push(eHeaderCell);
    }
    return this.addElementsToContainerAndGetWidth(elements);
  }
  getPreferredWidthForColumnGroup(columnGroup) {
    const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
    if (!eHeaderCell) {
      return -1;
    }
    return this.addElementsToContainerAndGetWidth([eHeaderCell]);
  }
  addElementsToContainerAndGetWidth(elements) {
    const eDummyContainer = document.createElement("form");
    eDummyContainer.style.position = "fixed";
    const eBodyContainer = this.centerRowContainerCtrl.eContainer;
    elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
    eBodyContainer.appendChild(eDummyContainer);
    const dummyContainerWidth = eDummyContainer.offsetWidth;
    eBodyContainer.removeChild(eDummyContainer);
    const autoSizePadding = this.gos.get("autoSizePadding");
    return dummyContainerWidth + autoSizePadding;
  }
  getHeaderCellForColumn(column) {
    let element = null;
    this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((container) => {
      const res = container.getHtmlElementForColumnHeader(column);
      if (res != null) {
        element = res;
      }
    });
    return element;
  }
  cloneItemIntoDummy(eCell, eDummyContainer) {
    const eCellClone = eCell.cloneNode(true);
    eCellClone.style.width = "";
    eCellClone.style.position = "static";
    eCellClone.style.left = "";
    const eCloneParent = document.createElement("div");
    const eCloneParentClassList = eCloneParent.classList;
    const isHeader = ["ag-header-cell", "ag-header-group-cell"].some((cls) => eCellClone.classList.contains(cls));
    if (isHeader) {
      eCloneParentClassList.add("ag-header", "ag-header-row");
      eCloneParent.style.position = "static";
    } else {
      eCloneParentClassList.add("ag-row");
    }
    let pointer = eCell.parentElement;
    while (pointer) {
      const isRow = ["ag-header-row", "ag-row"].some((cls) => pointer.classList.contains(cls));
      if (isRow) {
        for (let i = 0; i < pointer.classList.length; i++) {
          const item = pointer.classList[i];
          if (item != "ag-row-position-absolute") {
            eCloneParentClassList.add(item);
          }
        }
        break;
      }
      pointer = pointer.parentElement;
    }
    eCloneParent.appendChild(eCellClone);
    eDummyContainer.appendChild(eCloneParent);
  }
};

// packages/ag-grid-community/src/rendering/autoWidthModule.ts
var AutoWidthModule = {
  moduleName: "AutoWidth",
  version: VERSION,
  beans: [AutoWidthCalculator]
};

// packages/ag-grid-community/src/columnResize/columnResizeApi.ts
function setColumnWidths(beans, columnWidths, finished = true, source = "api") {
  beans.colResize?.setColumnWidths(columnWidths, false, finished, source);
}

// packages/ag-grid-community/src/columnResize/groupResizeFeature.ts
var GroupResizeFeature = class extends BeanStub {
  constructor(comp, eResize, pinned, columnGroup) {
    super();
    this.comp = comp;
    this.eResize = eResize;
    this.pinned = pinned;
    this.columnGroup = columnGroup;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(false);
      return;
    }
    const { horizontalResizeSvc, gos, colAutosize } = this.beans;
    const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, false),
      onResizeEnd: this.onResizing.bind(this, true)
    });
    this.addDestroyFunc(finishedWithResizeFunc);
    if (!gos.get("suppressAutoSize") && colAutosize) {
      this.addDestroyFunc(
        colAutosize.addColumnGroupResize(
          this.eResize,
          this.columnGroup,
          () => this.resizeLeafColumnsToFit("uiColumnResized")
        )
      );
    }
  }
  onResizeStart(shiftKey) {
    const {
      columnsToResize,
      resizeStartWidth,
      resizeRatios,
      groupAfterColumns,
      groupAfterStartWidth,
      groupAfterRatios
    } = this.getInitialValues(shiftKey);
    this.resizeCols = columnsToResize;
    this.resizeStartWidth = resizeStartWidth;
    this.resizeRatios = resizeRatios;
    this.resizeTakeFromCols = groupAfterColumns;
    this.resizeTakeFromStartWidth = groupAfterStartWidth;
    this.resizeTakeFromRatios = groupAfterRatios;
    this.toggleColumnResizing(true);
  }
  onResizing(finished, resizeAmount, source = "uiColumnResized") {
    const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
    const width = this.resizeStartWidth + resizeAmountNormalised;
    this.resizeColumnsFromLocalValues(width, source, finished);
  }
  getInitialValues(shiftKey) {
    const getInitialSizeOfColumns = (columns) => columns.reduce((totalWidth, column) => totalWidth + column.getActualWidth(), 0);
    const getSizeRatiosOfColumns = (columns, initialSizeOfColumns) => columns.map((column) => column.getActualWidth() / initialSizeOfColumns);
    const columnsToResize = this.getColumnsToResize();
    const resizeStartWidth = getInitialSizeOfColumns(columnsToResize);
    const resizeRatios = getSizeRatiosOfColumns(columnsToResize, resizeStartWidth);
    const columnSizeAndRatios = {
      columnsToResize,
      resizeStartWidth,
      resizeRatios
    };
    let groupAfter = null;
    if (shiftKey) {
      groupAfter = this.beans.colGroupSvc?.getGroupAtDirection(this.columnGroup, "After") ?? null;
    }
    if (groupAfter) {
      const takeFromLeafCols = groupAfter.getDisplayedLeafColumns();
      const groupAfterColumns = columnSizeAndRatios.groupAfterColumns = takeFromLeafCols.filter(
        (col) => col.isResizable()
      );
      const groupAfterStartWidth = columnSizeAndRatios.groupAfterStartWidth = getInitialSizeOfColumns(groupAfterColumns);
      columnSizeAndRatios.groupAfterRatios = getSizeRatiosOfColumns(groupAfterColumns, groupAfterStartWidth);
    } else {
      columnSizeAndRatios.groupAfterColumns = void 0;
      columnSizeAndRatios.groupAfterStartWidth = void 0;
      columnSizeAndRatios.groupAfterRatios = void 0;
    }
    return columnSizeAndRatios;
  }
  resizeLeafColumnsToFit(source) {
    const preferredSize = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup);
    const initialValues = this.getInitialValues();
    if (preferredSize > initialValues.resizeStartWidth) {
      this.resizeColumns(initialValues, preferredSize, source, true);
    }
  }
  resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
    if (!this.resizeCols || !this.resizeRatios) {
      return;
    }
    const initialValues = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols,
      groupAfterStartWidth: this.resizeTakeFromStartWidth,
      groupAfterRatios: this.resizeTakeFromRatios
    };
    this.resizeColumns(initialValues, totalWidth, source, finished);
  }
  resizeColumns(initialValues, totalWidth, source, finished = true) {
    const {
      columnsToResize,
      resizeStartWidth,
      resizeRatios,
      groupAfterColumns,
      groupAfterStartWidth,
      groupAfterRatios
    } = initialValues;
    const resizeSets = [];
    resizeSets.push({
      columns: columnsToResize,
      ratios: resizeRatios,
      width: totalWidth
    });
    if (groupAfterColumns) {
      const diff = totalWidth - resizeStartWidth;
      resizeSets.push({
        columns: groupAfterColumns,
        ratios: groupAfterRatios,
        width: groupAfterStartWidth - diff
      });
    }
    this.beans.colResize?.resizeColumnSets({
      resizeSets,
      finished,
      source
    });
    if (finished) {
      this.toggleColumnResizing(false);
    }
  }
  toggleColumnResizing(resizing) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
  }
  getColumnsToResize() {
    const leafCols = this.columnGroup.getDisplayedLeafColumns();
    return leafCols.filter((col) => col.isResizable());
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(dragChange) {
    let result = dragChange;
    if (this.gos.get("enableRtl")) {
      if (this.pinned !== "left") {
        result *= -1;
      }
    } else if (this.pinned === "right") {
      result *= -1;
    }
    return result;
  }
  destroy() {
    super.destroy();
    this.resizeCols = void 0;
    this.resizeRatios = void 0;
    this.resizeTakeFromCols = void 0;
    this.resizeTakeFromRatios = void 0;
  }
};

// packages/ag-grid-community/src/columnResize/resizeFeature.ts
var ResizeFeature = class extends BeanStub {
  constructor(pinned, column, eResize, comp, ctrl) {
    super();
    this.pinned = pinned;
    this.column = column;
    this.eResize = eResize;
    this.comp = comp;
    this.ctrl = ctrl;
  }
  postConstruct() {
    const destroyResizeFuncs = [];
    let canResize;
    let canAutosize;
    const addResize = () => {
      _setDisplayed(this.eResize, canResize);
      if (!canResize) {
        return;
      }
      const { horizontalResizeSvc, colAutosize } = this.beans;
      const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, false),
        onResizeEnd: this.onResizing.bind(this, true)
      });
      destroyResizeFuncs.push(finishedWithResizeFunc);
      if (canAutosize && colAutosize) {
        destroyResizeFuncs.push(colAutosize.addColumnAutosize(this.eResize, this.column));
      }
    };
    const removeResize = () => {
      destroyResizeFuncs.forEach((f) => f());
      destroyResizeFuncs.length = 0;
    };
    const refresh = () => {
      const resize = this.column.isResizable();
      const autoSize = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      const propertyChange = resize !== canResize || autoSize !== canAutosize;
      if (propertyChange) {
        canResize = resize;
        canAutosize = autoSize;
        removeResize();
        addResize();
      }
    };
    refresh();
    this.addDestroyFunc(removeResize);
    this.ctrl.setRefreshFunction("resize", refresh);
  }
  onResizing(finished, resizeAmount) {
    const { column: key, lastResizeAmount, resizeStartWidth, beans } = this;
    const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
    const newWidth = resizeStartWidth + resizeAmountNormalised;
    const columnWidths = [{ key, newWidth }];
    const { pinnedCols, ctrlsSvc, colResize } = beans;
    if (this.column.getPinned()) {
      const leftWidth = pinnedCols?.leftWidth ?? 0;
      const rightWidth = pinnedCols?.rightWidth ?? 0;
      const bodyWidth = _getInnerWidth(ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) {
        return;
      }
    }
    this.lastResizeAmount = resizeAmountNormalised;
    colResize?.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
    if (finished) {
      this.toggleColumnResizing(false);
    }
  }
  onResizeStart(shiftKey) {
    this.resizeStartWidth = this.column.getActualWidth();
    this.lastResizeAmount = 0;
    this.resizeWithShiftKey = shiftKey;
    this.toggleColumnResizing(true);
  }
  toggleColumnResizing(resizing) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(dragChange) {
    let result = dragChange;
    const notPinningLeft = this.pinned !== "left";
    const pinningRight = this.pinned === "right";
    if (this.gos.get("enableRtl")) {
      if (notPinningLeft) {
        result *= -1;
      }
    } else {
      if (pinningRight) {
        result *= -1;
      }
    }
    return result;
  }
};

// packages/ag-grid-community/src/columnResize/columnResizeService.ts
var ColumnResizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colResize";
  }
  setColumnWidths(columnWidths, shiftKey, finished, source) {
    const sets = [];
    const { colModel, gos, visibleCols } = this.beans;
    columnWidths.forEach((columnWidth) => {
      const col = colModel.getColDefCol(columnWidth.key) || colModel.getCol(columnWidth.key);
      if (!col) {
        return;
      }
      sets.push({
        width: columnWidth.newWidth,
        ratios: [1],
        columns: [col]
      });
      const defaultIsShift = gos.get("colResizeDefault") === "shift";
      if (defaultIsShift) {
        shiftKey = !shiftKey;
      }
      if (shiftKey) {
        const otherCol = visibleCols.getColAfter(col);
        if (!otherCol) {
          return;
        }
        const widthDiff = col.getActualWidth() - columnWidth.newWidth;
        const otherColWidth = otherCol.getActualWidth() + widthDiff;
        sets.push({
          width: otherColWidth,
          ratios: [1],
          columns: [otherCol]
        });
      }
    });
    if (sets.length === 0) {
      return;
    }
    this.resizeColumnSets({
      resizeSets: sets,
      finished,
      source
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(params) {
    const { resizeSets, finished, source } = params;
    const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet) => checkMinAndMaxWidthsForSet(columnResizeSet));
    if (!passMinMaxCheck) {
      if (finished) {
        const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
        dispatchColumnResizedEvent(this.eventSvc, columns, finished, source);
      }
      return;
    }
    const changedCols = [];
    const allResizedCols = [];
    resizeSets.forEach((set) => {
      const { width, columns, ratios } = set;
      const newWidths = {};
      const finishedCols = {};
      columns.forEach((col) => allResizedCols.push(col));
      let finishedColsGrew = true;
      let loopCount = 0;
      while (finishedColsGrew) {
        loopCount++;
        if (loopCount > 1e3) {
          _error(31);
          break;
        }
        finishedColsGrew = false;
        const subsetCols = [];
        let subsetRatioTotal = 0;
        let pixelsToDistribute = width;
        columns.forEach((col, index) => {
          const thisColFinished = finishedCols[col.getId()];
          if (thisColFinished) {
            pixelsToDistribute -= newWidths[col.getId()];
          } else {
            subsetCols.push(col);
            const ratioThisCol = ratios[index];
            subsetRatioTotal += ratioThisCol;
          }
        });
        const ratioScale = 1 / subsetRatioTotal;
        subsetCols.forEach((col, index) => {
          const lastCol = index === subsetCols.length - 1;
          let colNewWidth;
          if (lastCol) {
            colNewWidth = pixelsToDistribute;
          } else {
            colNewWidth = Math.round(ratios[index] * width * ratioScale);
            pixelsToDistribute -= colNewWidth;
          }
          const minWidth = col.getMinWidth();
          const maxWidth = col.getMaxWidth();
          if (colNewWidth < minWidth) {
            colNewWidth = minWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          } else if (maxWidth > 0 && colNewWidth > maxWidth) {
            colNewWidth = maxWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          }
          newWidths[col.getId()] = colNewWidth;
        });
      }
      columns.forEach((col) => {
        const newWidth = newWidths[col.getId()];
        const actualWidth = col.getActualWidth();
        if (actualWidth !== newWidth) {
          col.setActualWidth(newWidth, source);
          changedCols.push(col);
        }
      });
    });
    const atLeastOneColChanged = changedCols.length > 0;
    let flexedCols = [];
    if (atLeastOneColChanged) {
      const { colFlex, visibleCols, colViewport } = this.beans;
      flexedCols = colFlex?.refreshFlexedColumns({
        resizingCols: allResizedCols,
        skipSetLeft: true
      }) ?? [];
      visibleCols.setLeftValues(source);
      visibleCols.updateBodyWidths();
      colViewport.checkViewportColumns();
    }
    const colsForEvent = allResizedCols.concat(flexedCols);
    if (atLeastOneColChanged || finished) {
      dispatchColumnResizedEvent(this.eventSvc, colsForEvent, finished, source, flexedCols);
    }
  }
  resizeHeader(column, delta, shiftKey) {
    if (!column.isResizable()) {
      return;
    }
    const actualWidth = column.getActualWidth();
    const minWidth = column.getMinWidth();
    const maxWidth = column.getMaxWidth();
    const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
    this.setColumnWidths([{ key: column, newWidth }], shiftKey, true, "uiColumnResized");
  }
  createResizeFeature(pinned, column, eResize, comp, ctrl) {
    return new ResizeFeature(pinned, column, eResize, comp, ctrl);
  }
  createGroupResizeFeature(comp, eResize, pinned, columnGroup) {
    return new GroupResizeFeature(comp, eResize, pinned, columnGroup);
  }
};
function checkMinAndMaxWidthsForSet(columnResizeSet) {
  const { columns, width } = columnResizeSet;
  let minWidthAccumulated = 0;
  let maxWidthAccumulated = 0;
  let maxWidthActive = true;
  columns.forEach((col) => {
    const minWidth = col.getMinWidth();
    minWidthAccumulated += minWidth || 0;
    const maxWidth = col.getMaxWidth();
    if (maxWidth > 0) {
      maxWidthAccumulated += maxWidth;
    } else {
      maxWidthActive = false;
    }
  });
  const minWidthPasses = width >= minWidthAccumulated;
  const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
  return minWidthPasses && maxWidthPasses;
}

// packages/ag-grid-community/src/columnResize/columnResizeModule.ts
var ColumnResizeModule = {
  moduleName: "ColumnResize",
  version: VERSION,
  beans: [ColumnResizeService],
  apiFunctions: {
    setColumnWidths
  },
  dependsOn: [HorizontalResizeModule, AutoWidthModule]
};

// packages/ag-grid-community/src/headerRendering/cells/columnGroup/groupWidthFeature.ts
var GroupWidthFeature = class extends BeanStub {
  constructor(comp, columnGroup) {
    super();
    // the children can change, we keep destroy functions related to listening to the children here
    this.removeChildListenersFuncs = [];
    this.columnGroup = columnGroup;
    this.comp = comp;
  }
  postConstruct() {
    this.addListenersToChildrenColumns();
    this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    });
    this.onWidthChanged();
    this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const widthChangedListener = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((column) => {
      column.addEventListener("widthChanged", widthChangedListener);
      column.addEventListener("visibleChanged", widthChangedListener);
      this.removeChildListenersFuncs.push(() => {
        column.removeEventListener("widthChanged", widthChangedListener);
        column.removeEventListener("visibleChanged", widthChangedListener);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((func) => func());
    this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns();
    this.onWidthChanged();
  }
  onWidthChanged() {
    const columnWidth = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${columnWidth}px`);
    this.comp.addOrRemoveCssClass("ag-hidden", columnWidth === 0);
  }
};

// packages/ag-grid-community/src/headerRendering/cells/columnGroup/headerGroupCellCtrl.ts
var HeaderGroupCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor() {
    super(...arguments);
    this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving()) {
        this.removeDragSource();
      } else {
        if (!this.dragSource) {
          this.setDragSource(this.eGui);
        }
      }
    };
  }
  setComp(comp, eGui, eResize, eHeaderCompWrapper, compBean) {
    const { column, beans } = this;
    const { context, colNames, colHover, colResize } = beans;
    this.comp = comp;
    compBean = setupCompBean(this, context, compBean);
    this.setGui(eGui, compBean);
    this.displayName = colNames.getDisplayNameForColumnGroup(column, "header");
    this.addClasses();
    this.setupMovingCss(compBean);
    this.setupExpandable(compBean);
    this.setupTooltip();
    this.setupAutoHeight({
      wrapperElement: eHeaderCompWrapper,
      compBean
    });
    this.setupUserComp();
    this.addHeaderMouseListeners(compBean);
    this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this));
    this.refreshMaxHeaderHeight();
    const pinned = this.rowCtrl.pinned;
    const leafCols = column.getProvidedColumnGroup().getLeafColumns();
    colHover?.createHoverFeature(compBean, leafCols, eGui);
    compBean.createManagedBean(new SetLeftFeature(column, eGui, beans));
    compBean.createManagedBean(new GroupWidthFeature(comp, column));
    if (colResize) {
      this.resizeFeature = compBean.createManagedBean(
        colResize.createGroupResizeFeature(comp, eResize, pinned, column)
      );
    } else {
      comp.setResizableDisplayed(false);
    }
    compBean.createManagedBean(
      new ManagedFocusFeature(eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => void 0,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
    this.addHighlightListeners(compBean, leafCols);
    compBean.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange);
    this.addResizeAndMoveKeyboardListeners(compBean);
    compBean.addDestroyFunc(() => this.clearComponent());
  }
  refreshMaxHeaderHeight() {
    const { gos, comp } = this;
    const groupHeaderHeight = gos.get("groupHeaderHeight");
    if (groupHeaderHeight != null) {
      if (groupHeaderHeight === 0) {
        comp.setHeaderWrapperHidden(true);
      } else {
        comp.setHeaderWrapperMaxHeight(groupHeaderHeight);
      }
    } else {
      comp.setHeaderWrapperHidden(false);
      comp.setHeaderWrapperMaxHeight(null);
    }
  }
  addHighlightListeners(compBean, columns) {
    if (!this.beans.gos.get("suppressMoveWhenColumnDragging")) {
      return;
    }
    for (const column of columns) {
      compBean.addManagedListeners(column, {
        headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, column)
      });
    }
  }
  onLeafColumnHighlightChanged(column) {
    const displayedColumns = this.column.getDisplayedLeafColumns();
    const isFirst = displayedColumns[0] === column;
    const isLast = _last(displayedColumns) === column;
    if (!isFirst && !isLast) {
      return;
    }
    const highlighted = column.getHighlighted();
    const isColumnMoveAtThisLevel = !!this.rowCtrl.findHeaderCellCtrl((ctrl) => {
      return ctrl.column.isMoving();
    });
    let beforeOn = false;
    let afterOn = false;
    if (isColumnMoveAtThisLevel) {
      const isRtl = this.beans.gos.get("enableRtl");
      const isHighlightAfter = highlighted === 1 /* After */;
      const isHighlightBefore = highlighted === 0 /* Before */;
      if (isFirst) {
        if (isRtl) {
          afterOn = isHighlightAfter;
        } else {
          beforeOn = isHighlightBefore;
        }
      }
      if (isLast) {
        if (isRtl) {
          beforeOn = isHighlightBefore;
        } else {
          afterOn = isHighlightAfter;
        }
      }
    }
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", beforeOn);
    this.comp.addOrRemoveCssClass("ag-header-highlight-after", afterOn);
  }
  resizeHeader(delta, shiftKey) {
    const { resizeFeature } = this;
    if (!resizeFeature) {
      return;
    }
    const initialValues = resizeFeature.getInitialValues(shiftKey);
    resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, "uiColumnResized", true);
  }
  resizeLeafColumnsToFit(source) {
    this.resizeFeature?.resizeLeafColumnsToFit(source);
  }
  setupUserComp() {
    const { colGroupSvc, userCompFactory, gos } = this.beans;
    const params = gos.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (expanded) => {
        colGroupSvc.setColumnGroupOpened(this.column.getProvidedColumnGroup(), expanded, "gridInitializing");
      },
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.setupTooltip(value, shouldDisplayTooltip);
      }
    });
    const compDetails = _getHeaderGroupCompDetails(userCompFactory, params);
    if (compDetails) {
      this.comp.setUserCompDetails(compDetails);
    }
  }
  addHeaderMouseListeners(compBean) {
    const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
    const clickListener = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup());
    const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column.getProvidedColumnGroup());
    compBean.addManagedListeners(this.eGui, {
      mouseenter: listener,
      mouseleave: listener,
      click: clickListener,
      contextmenu: contextMenuListener
    });
  }
  handleMouseOverChange(isMouseOver) {
    this.eventSvc.dispatchEvent({
      type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(value, shouldDisplayTooltip) {
    this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderGroupTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  setupExpandable(compBean) {
    const providedColGroup = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const listener = this.refreshExpanded.bind(this);
    compBean.addManagedListeners(providedColGroup, {
      expandedChanged: listener,
      expandableChanged: listener
    });
  }
  refreshExpanded() {
    const { column } = this;
    this.expandable = column.isExpandable();
    const expanded = column.isExpanded();
    if (this.expandable) {
      this.comp.setAriaExpanded(expanded ? "true" : "false");
    } else {
      this.comp.setAriaExpanded(void 0);
    }
  }
  addClasses() {
    const { column } = this;
    const colGroupDef = column.getColGroupDef();
    const classes = _getHeaderClassesFromColDef(colGroupDef, this.gos, null, column);
    if (column.isPadding()) {
      classes.push("ag-header-group-cell-no-group");
      const leafCols = column.getLeafColumns();
      if (leafCols.every((col) => col.isSpanHeaderHeight())) {
        classes.push("ag-header-span-height");
      }
    } else {
      classes.push("ag-header-group-cell-with-group");
      if (colGroupDef?.wrapHeaderText) {
        classes.push("ag-header-cell-wrap-text");
      }
    }
    classes.forEach((c) => this.comp.addOrRemoveCssClass(c, true));
  }
  setupMovingCss(compBean) {
    const { column } = this;
    const providedColumnGroup = column.getProvidedColumnGroup();
    const leafColumns = providedColumnGroup.getLeafColumns();
    const listener = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", column.isMoving());
    leafColumns.forEach((col) => {
      compBean.addManagedListeners(col, { movingChanged: listener });
    });
    listener();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      this.focusThis();
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const wrapperHasFocus = this.getWrapperHasFocus();
    if (!this.expandable || !wrapperHasFocus) {
      return;
    }
    if (e.key === KeyCode.ENTER) {
      const column = this.column;
      const newExpandedValue = !column.isExpanded();
      this.beans.colGroupSvc.setColumnGroupOpened(
        column.getProvidedColumnGroup(),
        newExpandedValue,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(eHeaderGroup) {
    if (!this.isAlive() || this.isSuppressMoving()) {
      return;
    }
    this.removeDragSource();
    if (!eHeaderGroup) {
      return;
    }
    this.dragSource = this.beans.colMoves?.setDragSourceForHeader(eHeaderGroup, this.column, this.displayName) ?? null;
  }
  isSuppressMoving() {
    return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((column) => column.getColDef().suppressMovable || column.getColDef().lockPosition);
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    super.destroy();
  }
};

// packages/ag-grid-community/src/columns/columnGroups/columnGroupApi.ts
function setColumnGroupOpened(beans, group, newValue) {
  beans.colGroupSvc?.setColumnGroupOpened(group, newValue, "api");
}
function getColumnGroup(beans, name, instanceId) {
  return beans.colGroupSvc?.getColumnGroup(name, instanceId) ?? null;
}
function getProvidedColumnGroup(beans, name) {
  return beans.colGroupSvc?.getProvidedColGroup(name) ?? null;
}
function getDisplayNameForColumnGroup(beans, columnGroup, location) {
  return beans.colNames.getDisplayNameForColumnGroup(columnGroup, location) || "";
}
function getColumnGroupState(beans) {
  return beans.colGroupSvc?.getColumnGroupState() ?? [];
}
function setColumnGroupState(beans, stateItems) {
  beans.colGroupSvc?.setColumnGroupState(stateItems, "api");
}
function resetColumnGroupState(beans) {
  beans.colGroupSvc?.resetColumnGroupState("api");
}
function getLeftDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeLeft;
}
function getCenterDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeCenter;
}
function getRightDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeRight;
}
function getAllDisplayedColumnGroups(beans) {
  return beans.visibleCols.getAllTrees();
}

// packages/ag-grid-community/src/columns/visibleColsService.ts
function _removeAllFromUnorderedArray(array, toRemove) {
  for (let i = 0; i < toRemove.length; i++) {
    const index = array.indexOf(toRemove[i]);
    if (index >= 0) {
      array[index] = array[array.length - 1];
      array.pop();
    }
  }
}
var VisibleColsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "visibleCols";
    // for fast lookup, to see if a column or group is still visible
    this.colsAndGroupsMap = {};
    // leave level columns of the displayed trees
    this.leftCols = [];
    this.rightCols = [];
    this.centerCols = [];
    // all three lists above combined
    this.allCols = [];
    // used by:
    // + angularGrid -> for setting body width
    // + rowController -> setting main row widths (when inserting and resizing)
    // need to cache this
    this.bodyWidth = 0;
    this.leftWidth = 0;
    this.rightWidth = 0;
    this.isBodyWidthDirty = true;
  }
  refresh(source, skipTreeBuild = false) {
    const { colModel, colGroupSvc, colViewport } = this.beans;
    if (!skipTreeBuild) {
      this.buildTrees(colModel, colGroupSvc);
    }
    colGroupSvc?.updateOpenClosedVisibility();
    const leftCols = pickDisplayedCols(this.treeLeft);
    this.leftCols = leftCols;
    this.centerCols = pickDisplayedCols(this.treeCenter);
    const rightCols = pickDisplayedCols(this.treeRight);
    this.rightCols = rightCols;
    this.joinColsAriaOrder(colModel);
    this.joinCols();
    this.setLeftValues(source);
    this.autoHeightCols = this.allCols.filter((col) => col.isAutoHeight());
    this.beans.colFlex?.refreshFlexedColumns();
    this.updateBodyWidths();
    colViewport.checkViewportColumns(false);
    this.setFirstRightAndLastLeftPinned(colModel, leftCols, rightCols, source);
    this.eventSvc.dispatchEvent({
      type: "displayedColumnsChanged",
      source
    });
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const newBodyWidth = getWidthOfColsInList(this.centerCols);
    const newLeftWidth = getWidthOfColsInList(this.leftCols);
    const newRightWidth = getWidthOfColsInList(this.rightCols);
    this.isBodyWidthDirty = this.bodyWidth !== newBodyWidth;
    const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
    if (atLeastOneChanged) {
      this.bodyWidth = newBodyWidth;
      this.leftWidth = newLeftWidth;
      this.rightWidth = newRightWidth;
      this.eventSvc.dispatchEvent({
        type: "columnContainerWidthChanged"
      });
      this.eventSvc.dispatchEvent({
        type: "displayedColumnsWidthChanged"
      });
    }
  }
  // sets the left pixel position of each column
  setLeftValues(source) {
    this.setLeftValuesOfCols(source);
    this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(colModel, leftCols, rightCols, source) {
    let lastLeft;
    let firstRight;
    if (this.gos.get("enableRtl")) {
      lastLeft = leftCols ? leftCols[0] : null;
      firstRight = rightCols ? _last(rightCols) : null;
    } else {
      lastLeft = leftCols ? _last(leftCols) : null;
      firstRight = rightCols ? rightCols[0] : null;
    }
    colModel.getCols().forEach((col) => {
      col.setLastLeftPinned(col === lastLeft, source);
      col.setFirstRightPinned(col === firstRight, source);
    });
  }
  buildTrees(colModel, columnGroupSvc) {
    const cols = colModel.getColsToShow();
    const leftCols = cols.filter((col) => col.getPinned() == "left");
    const rightCols = cols.filter((col) => col.getPinned() == "right");
    const centerCols = cols.filter((col) => col.getPinned() != "left" && col.getPinned() != "right");
    const idCreator = new GroupInstanceIdCreator();
    const createGroups = (params) => {
      return columnGroupSvc ? columnGroupSvc.createColumnGroups(params) : params.columns;
    };
    this.treeLeft = createGroups({
      columns: leftCols,
      idCreator,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    });
    this.treeRight = createGroups({
      columns: rightCols,
      idCreator,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    });
    this.treeCenter = createGroups({
      columns: centerCols,
      idCreator,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    });
    this.updateColsAndGroupsMap();
  }
  clear() {
    this.leftCols = [];
    this.rightCols = [];
    this.centerCols = [];
    this.allCols = [];
    this.ariaOrderColumns = [];
  }
  joinColsAriaOrder(colModel) {
    const allColumns = colModel.getCols();
    const pinnedLeft = [];
    const center = [];
    const pinnedRight = [];
    for (const col of allColumns) {
      const pinned = col.getPinned();
      if (!pinned) {
        center.push(col);
      } else if (pinned === true || pinned === "left") {
        pinnedLeft.push(col);
      } else {
        pinnedRight.push(col);
      }
    }
    this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
  }
  getAriaColIndex(colOrGroup) {
    let col;
    if (isColumnGroup2(colOrGroup)) {
      col = colOrGroup.getLeafColumns()[0];
    } else {
      col = colOrGroup;
    }
    return this.ariaOrderColumns.indexOf(col) + 1;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((columns) => {
      columns.forEach((column) => {
        if (isColumnGroup2(column)) {
          const columnGroup = column;
          columnGroup.checkLeft();
        }
      });
    });
  }
  setLeftValuesOfCols(source) {
    const { colModel } = this.beans;
    const primaryCols = colModel.getColDefCols();
    if (!primaryCols) {
      return;
    }
    const allColumns = colModel.getCols().slice(0);
    const doingRtl = this.gos.get("enableRtl");
    [this.leftCols, this.rightCols, this.centerCols].forEach((columns) => {
      if (doingRtl) {
        let left = getWidthOfColsInList(columns);
        columns.forEach((column) => {
          left -= column.getActualWidth();
          column.setLeft(left, source);
        });
      } else {
        let left = 0;
        columns.forEach((column) => {
          column.setLeft(left, source);
          left += column.getActualWidth();
        });
      }
      _removeAllFromUnorderedArray(allColumns, columns);
    });
    allColumns.forEach((column) => {
      column.setLeft(null, source);
    });
  }
  joinCols() {
    if (this.gos.get("enableRtl")) {
      this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols);
    } else {
      this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
    }
  }
  getAllTrees() {
    if (this.treeLeft && this.treeRight && this.treeCenter) {
      return this.treeLeft.concat(this.treeCenter).concat(this.treeRight);
    }
    return null;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(column) {
    return this.allCols.indexOf(column) >= 0;
  }
  getLeftColsForRow(rowNode) {
    const {
      leftCols,
      beans: { colModel }
    } = this;
    const colSpanActive = colModel.colSpanActive;
    if (!colSpanActive) {
      return leftCols;
    }
    return this.getColsForRow(rowNode, leftCols);
  }
  getRightColsForRow(rowNode) {
    const {
      rightCols,
      beans: { colModel }
    } = this;
    const colSpanActive = colModel.colSpanActive;
    if (!colSpanActive) {
      return rightCols;
    }
    return this.getColsForRow(rowNode, rightCols);
  }
  getColsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
    const result = [];
    let lastConsideredCol = null;
    for (let i = 0; i < displayedColumns.length; i++) {
      const col = displayedColumns[i];
      const maxAllowedColSpan = displayedColumns.length - i;
      const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
      const columnsToCheckFilter = [col];
      if (colSpan > 1) {
        const colsToRemove = colSpan - 1;
        for (let j = 1; j <= colsToRemove; j++) {
          columnsToCheckFilter.push(displayedColumns[i + j]);
        }
        i += colsToRemove;
      }
      let filterPasses;
      if (filterCallback) {
        filterPasses = false;
        columnsToCheckFilter.forEach((colForFilter) => {
          if (filterCallback(colForFilter)) {
            filterPasses = true;
          }
        });
      } else {
        filterPasses = true;
      }
      if (filterPasses) {
        if (result.length === 0 && lastConsideredCol) {
          const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
          if (gapBeforeColumn) {
            result.push(lastConsideredCol);
          }
        }
        result.push(col);
      }
      lastConsideredCol = col;
    }
    return result;
  }
  getContainerWidth(pinned) {
    switch (pinned) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getColBefore(col) {
    const allDisplayedColumns = this.allCols;
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex > 0) {
      return allDisplayedColumns[oldIndex - 1];
    }
    return null;
  }
  isPinningLeft() {
    return this.leftCols.length > 0;
  }
  isPinningRight() {
    return this.rightCols.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const func = (child) => {
      this.colsAndGroupsMap[child.getUniqueId()] = child;
    };
    depthFirstAllColumnTreeSearch(this.treeCenter, false, func);
    depthFirstAllColumnTreeSearch(this.treeLeft, false, func);
    depthFirstAllColumnTreeSearch(this.treeRight, false, func);
  }
  isVisible(item) {
    const fromMap = this.colsAndGroupsMap[item.getUniqueId()];
    return fromMap === item;
  }
  getFirstColumn() {
    const isRtl = this.gos.get("enableRtl");
    const queryOrder = ["leftCols", "centerCols", "rightCols"];
    if (isRtl) {
      queryOrder.reverse();
    }
    for (let i = 0; i < queryOrder.length; i++) {
      const container = this[queryOrder[i]];
      if (container.length) {
        return isRtl ? _last(container) : container[0];
      }
    }
    return null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(col) {
    const allDisplayedColumns = this.allCols;
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex < allDisplayedColumns.length - 1) {
      return allDisplayedColumns[oldIndex + 1];
    }
    return null;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return getWidthOfColsInList(this.leftCols);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return getWidthOfColsInList(this.rightCols);
  }
  isColAtEdge(col, edge) {
    const allColumns = this.allCols;
    if (!allColumns.length) {
      return false;
    }
    const isFirst = edge === "first";
    let columnToCompare;
    if (isColumnGroup2(col)) {
      const leafColumns = col.getDisplayedLeafColumns();
      if (!leafColumns.length) {
        return false;
      }
      columnToCompare = isFirst ? leafColumns[0] : _last(leafColumns);
    } else {
      columnToCompare = col;
    }
    return (isFirst ? allColumns[0] : _last(allColumns)) === columnToCompare;
  }
};
function depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
  if (!tree) {
    return;
  }
  for (let i = 0; i < tree.length; i++) {
    const child = tree[i];
    if (isColumnGroup2(child)) {
      const childTree = useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren();
      depthFirstAllColumnTreeSearch(childTree, useDisplayedChildren, callback);
    }
    callback(child);
  }
}
function pickDisplayedCols(tree) {
  const res = [];
  depthFirstAllColumnTreeSearch(tree, true, (child) => {
    if (isColumn(child)) {
      res.push(child);
    }
  });
  return res;
}

// packages/ag-grid-community/src/columns/columnGroups/columnGroupService.ts
var ColumnGroupService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colGroupSvc";
  }
  getColumnGroupState() {
    const columnGroupState = [];
    const gridBalancedTree = this.beans.colModel.getColTree();
    depthFirstOriginalTreeSearch(null, gridBalancedTree, (node) => {
      if (isProvidedColumnGroup(node)) {
        columnGroupState.push({
          groupId: node.getGroupId(),
          open: node.isExpanded()
        });
      }
    });
    return columnGroupState;
  }
  resetColumnGroupState(source) {
    const primaryColumnTree = this.beans.colModel.getColDefColTree();
    if (!primaryColumnTree) {
      return;
    }
    const stateItems = [];
    depthFirstOriginalTreeSearch(null, primaryColumnTree, (child) => {
      if (isProvidedColumnGroup(child)) {
        const colGroupDef = child.getColGroupDef();
        const groupState = {
          groupId: child.getGroupId(),
          open: !colGroupDef ? void 0 : colGroupDef.openByDefault
        };
        stateItems.push(groupState);
      }
    });
    this.setColumnGroupState(stateItems, source);
  }
  setColumnGroupState(stateItems, source) {
    const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
    const gridBalancedTree = colModel.getColTree();
    if (!gridBalancedTree) {
      return;
    }
    colAnimation?.start();
    const impactedGroups = [];
    stateItems.forEach((stateItem) => {
      const groupKey = stateItem.groupId;
      const newValue = stateItem.open;
      const providedColumnGroup = this.getProvidedColGroup(groupKey);
      if (!providedColumnGroup) {
        return;
      }
      if (providedColumnGroup.isExpanded() === newValue) {
        return;
      }
      providedColumnGroup.setExpanded(newValue);
      impactedGroups.push(providedColumnGroup);
    });
    visibleCols.refresh(source, true);
    if (impactedGroups.length) {
      eventSvc.dispatchEvent({
        type: "columnGroupOpened",
        columnGroup: impactedGroups.length === 1 ? impactedGroups[0] : void 0,
        columnGroups: impactedGroups
      });
    }
    colAnimation?.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(key, newValue, source) {
    let keyAsString;
    if (isProvidedColumnGroup(key)) {
      keyAsString = key.getId();
    } else {
      keyAsString = key || "";
    }
    this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);
  }
  getProvidedColGroup(key) {
    let res = null;
    depthFirstOriginalTreeSearch(null, this.beans.colModel.getColTree(), (node) => {
      if (isProvidedColumnGroup(node)) {
        if (node.getId() === key) {
          res = node;
        }
      }
    });
    return res;
  }
  getGroupAtDirection(columnGroup, direction) {
    const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
    const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
    const col = direction === "After" ? _last(colGroupLeafColumns) : colGroupLeafColumns[0];
    const getDisplayColMethod = `getCol${direction}`;
    while (true) {
      const column = this.beans.visibleCols[getDisplayColMethod](col);
      if (!column) {
        return null;
      }
      const groupPointer = this.getColGroupAtLevel(column, requiredLevel);
      if (groupPointer !== columnGroup) {
        return groupPointer;
      }
    }
  }
  getColGroupAtLevel(column, level) {
    let groupPointer = column.getParent();
    let originalGroupLevel;
    let groupPointerLevel;
    while (true) {
      const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
      originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
      groupPointerLevel = groupPointer.getPaddingLevel();
      if (originalGroupLevel + groupPointerLevel <= level) {
        break;
      }
      groupPointer = groupPointer.getParent();
    }
    return groupPointer;
  }
  updateOpenClosedVisibility() {
    const allColumnGroups = this.beans.visibleCols.getAllTrees();
    depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
      if (isColumnGroup2(child)) {
        child.calculateDisplayedColumns();
      }
    });
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(colId, partId) {
    if (!colId) {
      return null;
    }
    if (isColumnGroup2(colId)) {
      return colId;
    }
    const allColumnGroups = this.beans.visibleCols.getAllTrees();
    const checkPartId = typeof partId === "number";
    let result = null;
    depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
      if (isColumnGroup2(child)) {
        const columnGroup = child;
        let matched;
        if (checkPartId) {
          matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
        } else {
          matched = colId === columnGroup.getGroupId();
        }
        if (matched) {
          result = columnGroup;
        }
      }
    });
    return result;
  }
  createColumnGroups(params) {
    const { columns, idCreator, pinned, oldDisplayedGroups, isStandaloneStructure } = params;
    const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
    const topLevelResultCols = [];
    let groupsOrColsAtCurrentLevel = columns;
    while (groupsOrColsAtCurrentLevel.length) {
      const currentlyIterating = groupsOrColsAtCurrentLevel;
      groupsOrColsAtCurrentLevel = [];
      let lastGroupedColIdx = 0;
      const createGroupToIndex = (to) => {
        const from = lastGroupedColIdx;
        lastGroupedColIdx = to;
        const previousNode = currentlyIterating[from];
        const previousNodeProvided = isColumnGroup2(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
        const previousNodeParent = previousNodeProvided.getOriginalParent();
        if (previousNodeParent == null) {
          for (let i = from; i < to; i++) {
            topLevelResultCols.push(currentlyIterating[i]);
          }
          return;
        }
        const newGroup = this.createColumnGroup(
          previousNodeParent,
          idCreator,
          oldColumnsMapped,
          pinned,
          isStandaloneStructure
        );
        for (let i = from; i < to; i++) {
          newGroup.addChild(currentlyIterating[i]);
        }
        groupsOrColsAtCurrentLevel.push(newGroup);
      };
      for (let i = 1; i < currentlyIterating.length; i++) {
        const thisNode = currentlyIterating[i];
        const thisNodeProvided = isColumnGroup2(thisNode) ? thisNode.getProvidedColumnGroup() : thisNode;
        const thisNodeParent = thisNodeProvided.getOriginalParent();
        const previousNode = currentlyIterating[lastGroupedColIdx];
        const previousNodeProvided = isColumnGroup2(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
        const previousNodeParent = previousNodeProvided.getOriginalParent();
        if (thisNodeParent !== previousNodeParent) {
          createGroupToIndex(i);
        }
      }
      if (lastGroupedColIdx < currentlyIterating.length) {
        createGroupToIndex(currentlyIterating.length);
      }
    }
    if (!isStandaloneStructure) {
      this.setupParentsIntoCols(topLevelResultCols, null);
    }
    return topLevelResultCols;
  }
  createProvidedColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
    const groupId = columnKeyCreator.getUniqueKey(colGroupDef.groupId || null, null);
    const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef, groupId);
    const providedGroup = new AgProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
    this.createBean(providedGroup);
    const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
    if (existingGroupAndIndex) {
      existingGroups.splice(existingGroupAndIndex.idx, 1);
    }
    const existingGroup = existingGroupAndIndex?.group;
    if (existingGroup) {
      providedGroup.setExpanded(existingGroup.isExpanded());
    }
    const children = _recursivelyCreateColumns(
      this.beans,
      colGroupDefMerged.children,
      level + 1,
      primaryColumns,
      existingColumns,
      columnKeyCreator,
      existingGroups,
      source
    );
    providedGroup.setChildren(children);
    return providedGroup;
  }
  balanceColumnTree(unbalancedTree, currentDept, columnDept, columnKeyCreator) {
    const result = [];
    for (let i = 0; i < unbalancedTree.length; i++) {
      const child = unbalancedTree[i];
      if (isProvidedColumnGroup(child)) {
        const originalGroup = child;
        const newChildren = this.balanceColumnTree(
          originalGroup.getChildren(),
          currentDept + 1,
          columnDept,
          columnKeyCreator
        );
        originalGroup.setChildren(newChildren);
        result.push(originalGroup);
      } else {
        let firstPaddedGroup;
        let currentPaddedGroup;
        for (let j = columnDept - 1; j >= currentDept; j--) {
          const newColId = columnKeyCreator.getUniqueKey(null, null);
          const colGroupDefMerged = this.createMergedColGroupDef(null, newColId);
          const paddedGroup = new AgProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);
          this.createBean(paddedGroup);
          if (currentPaddedGroup) {
            currentPaddedGroup.setChildren([paddedGroup]);
          }
          currentPaddedGroup = paddedGroup;
          if (!firstPaddedGroup) {
            firstPaddedGroup = currentPaddedGroup;
          }
        }
        if (firstPaddedGroup && currentPaddedGroup) {
          result.push(firstPaddedGroup);
          const hasGroups = unbalancedTree.some((leaf) => isProvidedColumnGroup(leaf));
          if (hasGroups) {
            currentPaddedGroup.setChildren([child]);
            continue;
          } else {
            currentPaddedGroup.setChildren(unbalancedTree);
            break;
          }
        }
        result.push(child);
      }
    }
    return result;
  }
  findDepth(balancedColumnTree) {
    let depth = 0;
    let pointer = balancedColumnTree;
    while (pointer && pointer[0] && isProvidedColumnGroup(pointer[0])) {
      depth++;
      pointer = pointer[0].getChildren();
    }
    return depth;
  }
  findMaxDepth(treeChildren, depth) {
    let maxDeptThisLevel = depth;
    for (let i = 0; i < treeChildren.length; i++) {
      const abstractColumn = treeChildren[i];
      if (isProvidedColumnGroup(abstractColumn)) {
        const originalGroup = abstractColumn;
        const newDept = this.findMaxDepth(originalGroup.getChildren(), depth + 1);
        if (maxDeptThisLevel < newDept) {
          maxDeptThisLevel = newDept;
        }
      }
    }
    return maxDeptThisLevel;
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(autoCols, depth) {
    const tree = [];
    autoCols.forEach((col) => {
      let nextChild = col;
      for (let i = depth - 1; i >= 0; i--) {
        const autoGroup = new AgProvidedColumnGroup(null, `FAKE_PATH_${col.getId()}}_${i}`, true, i);
        this.createBean(autoGroup);
        autoGroup.setChildren([nextChild]);
        nextChild.originalParent = autoGroup;
        nextChild = autoGroup;
      }
      if (depth === 0) {
        col.originalParent = null;
      }
      tree.push(nextChild);
    });
    return tree;
  }
  createMergedColGroupDef(colGroupDef, groupId) {
    const colGroupDefMerged = {};
    const { gos, validation: validation2 } = this.beans;
    Object.assign(colGroupDefMerged, gos.get("defaultColGroupDef"));
    Object.assign(colGroupDefMerged, colGroupDef);
    validation2?.validateColDef(colGroupDefMerged, groupId);
    return colGroupDefMerged;
  }
  findExistingGroup(newGroupDef, existingGroups) {
    const newHasId = newGroupDef.groupId != null;
    if (!newHasId) {
      return void 0;
    }
    for (let i = 0; i < existingGroups.length; i++) {
      const existingGroup = existingGroups[i];
      const existingDef = existingGroup.getColGroupDef();
      if (!existingDef) {
        continue;
      }
      if (existingGroup.getId() === newGroupDef.groupId) {
        return { idx: i, group: existingGroup };
      }
    }
    return void 0;
  }
  createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned, isStandaloneStructure) {
    const groupId = providedGroup.getGroupId();
    const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
    const uniqueId = createUniqueColumnGroupId(groupId, instanceId);
    let columnGroup = oldColumnsMapped[uniqueId];
    if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) {
      columnGroup = null;
    }
    if (_exists(columnGroup)) {
      columnGroup.reset();
    } else {
      columnGroup = new AgColumnGroup(providedGroup, groupId, instanceId, pinned);
      if (!isStandaloneStructure) {
        this.createBean(columnGroup);
      }
    }
    return columnGroup;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(displayedGroups) {
    const result = {};
    const recursive = (columnsOrGroups) => {
      columnsOrGroups.forEach((columnOrGroup) => {
        if (isColumnGroup2(columnOrGroup)) {
          const columnGroup = columnOrGroup;
          result[columnOrGroup.getUniqueId()] = columnGroup;
          recursive(columnGroup.getChildren());
        }
      });
    };
    if (displayedGroups) {
      recursive(displayedGroups);
    }
    return result;
  }
  setupParentsIntoCols(columnsOrGroups, parent) {
    columnsOrGroups.forEach((columnsOrGroup) => {
      columnsOrGroup.parent = parent;
      if (isColumnGroup2(columnsOrGroup)) {
        const columnGroup = columnsOrGroup;
        this.setupParentsIntoCols(columnGroup.getChildren(), columnGroup);
      }
    });
  }
};

// packages/ag-grid-community/src/columns/columnGroups/columnGroupModule.ts
var ColumnGroupModule = {
  moduleName: "ColumnGroup",
  version: VERSION,
  dynamicBeans: { headerGroupCellCtrl: HeaderGroupCellCtrl },
  beans: [ColumnGroupService],
  apiFunctions: {
    getAllDisplayedColumnGroups,
    getCenterDisplayedColumnGroups,
    getColumnGroup,
    getColumnGroupState,
    getDisplayNameForColumnGroup,
    getLeftDisplayedColumnGroups,
    getProvidedColumnGroup,
    getRightDisplayedColumnGroups,
    resetColumnGroupState,
    setColumnGroupOpened,
    setColumnGroupState
  }
};

// packages/ag-grid-community/src/rendering/cellRenderers/cellRendererModule.ts
var CheckboxCellRendererModule = {
  moduleName: "CheckboxCellRenderer",
  version: VERSION,
  userComponents: {
    agCheckboxCellRenderer: CheckboxCellRenderer
  }
};

// packages/ag-grid-community/src/columns/columnApi.ts
function getColumnDef(beans, key) {
  const column = beans.colModel.getColDefCol(key);
  if (column) {
    return column.getColDef();
  }
  return null;
}
function getColumnDefs(beans) {
  return beans.colModel.getColumnDefs();
}
function getDisplayNameForColumn(beans, column, location) {
  return beans.colNames.getDisplayNameForColumn(column, location) || "";
}
function getColumn(beans, key) {
  return beans.colModel.getColDefCol(key);
}
function getColumns(beans) {
  return beans.colModel.getColDefCols();
}
function applyColumnState(beans, params) {
  return _applyColumnState(beans, params, "api");
}
function getColumnState(beans) {
  return _getColumnState(beans);
}
function resetColumnState(beans) {
  _resetColumnState(beans, "api");
}
function isPinning(beans) {
  return beans.visibleCols.isPinningLeft() || beans.visibleCols.isPinningRight();
}
function isPinningLeft(beans) {
  return beans.visibleCols.isPinningLeft();
}
function isPinningRight(beans) {
  return beans.visibleCols.isPinningRight();
}
function getDisplayedColAfter(beans, col) {
  return beans.visibleCols.getColAfter(col);
}
function getDisplayedColBefore(beans, col) {
  return beans.visibleCols.getColBefore(col);
}
function setColumnsVisible(beans, keys, visible) {
  beans.colModel.setColsVisible(keys, visible, "api");
}
function setColumnsPinned(beans, keys, pinned) {
  beans.pinnedCols?.setColsPinned(keys, pinned, "api");
}
function getAllGridColumns(beans) {
  return beans.colModel.getCols();
}
function getDisplayedLeftColumns(beans) {
  return beans.visibleCols.leftCols;
}
function getDisplayedCenterColumns(beans) {
  return beans.visibleCols.centerCols;
}
function getDisplayedRightColumns(beans) {
  return beans.visibleCols.rightCols;
}
function getAllDisplayedColumns(beans) {
  return beans.visibleCols.allCols;
}
function getAllDisplayedVirtualColumns(beans) {
  return beans.colViewport.getViewportColumns();
}

// packages/ag-grid-community/src/columns/columnDefFactory.ts
function _deepCloneDefinition(object, keysToSkip) {
  if (!object) {
    return;
  }
  const obj = object;
  const res = {};
  Object.keys(obj).forEach((key) => {
    if (keysToSkip && keysToSkip.indexOf(key) >= 0 || SKIP_JS_BUILTINS.has(key)) {
      return;
    }
    const value = obj[key];
    const sourceIsSimpleObject = typeof value === "object" && value !== null && value.constructor === Object;
    if (sourceIsSimpleObject) {
      res[key] = _deepCloneDefinition(value);
    } else {
      res[key] = value;
    }
  });
  return res;
}
var ColumnDefFactory = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colDefFactory";
  }
  wireBeans(beans) {
    this.rowGroupColsSvc = beans.rowGroupColsSvc;
    this.pivotColsSvc = beans.pivotColsSvc;
  }
  getColumnDefs(colDefColsList, showingPivotResult, lastOrder, colsList) {
    const cols = colDefColsList.slice();
    if (showingPivotResult) {
      cols.sort((a, b) => lastOrder.indexOf(a) - lastOrder.indexOf(b));
    } else if (lastOrder) {
      cols.sort((a, b) => colsList.indexOf(a) - colsList.indexOf(b));
    }
    const rowGroupColumns = this.rowGroupColsSvc?.columns;
    const pivotColumns = this.pivotColsSvc?.columns;
    return this.buildColumnDefs(cols, rowGroupColumns, pivotColumns);
  }
  buildColumnDefs(cols, rowGroupColumns = [], pivotColumns = []) {
    const res = [];
    const colGroupDefs = {};
    cols.forEach((col) => {
      const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
      let addToResult = true;
      let childDef = colDef;
      let pointer = col.getOriginalParent();
      let lastPointer = null;
      while (pointer) {
        let parentDef = null;
        if (pointer.isPadding()) {
          pointer = pointer.getOriginalParent();
          continue;
        }
        const existingParentDef = colGroupDefs[pointer.getGroupId()];
        if (existingParentDef) {
          existingParentDef.children.push(childDef);
          addToResult = false;
          break;
        }
        parentDef = this.createDefFromGroup(pointer);
        if (parentDef) {
          parentDef.children = [childDef];
          colGroupDefs[parentDef.groupId] = parentDef;
          childDef = parentDef;
          pointer = pointer.getOriginalParent();
        }
        if (pointer != null && lastPointer === pointer) {
          addToResult = false;
          break;
        }
        lastPointer = pointer;
      }
      if (addToResult) {
        res.push(childDef);
      }
    });
    return res;
  }
  createDefFromGroup(group) {
    const defCloned = _deepCloneDefinition(group.getColGroupDef(), ["children"]);
    if (defCloned) {
      defCloned.groupId = group.getGroupId();
    }
    return defCloned;
  }
  createDefFromColumn(col, rowGroupColumns, pivotColumns) {
    const colDefCloned = _deepCloneDefinition(col.getColDef());
    colDefCloned.colId = col.getColId();
    colDefCloned.width = col.getActualWidth();
    colDefCloned.rowGroup = col.isRowGroupActive();
    colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
    colDefCloned.pivot = col.isPivotActive();
    colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
    colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
    colDefCloned.hide = col.isVisible() ? void 0 : true;
    colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
    colDefCloned.sort = col.getSort() ? col.getSort() : null;
    colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
    return colDefCloned;
  }
};

// packages/ag-grid-community/src/columns/columnFlexService.ts
var ColumnFlexService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colFlex";
  }
  refreshFlexedColumns(params = {}) {
    const source = params.source ? params.source : "flex";
    if (params.viewportWidth != null) {
      this.flexViewportWidth = params.viewportWidth;
    }
    const totalSpace = this.flexViewportWidth;
    if (!totalSpace) {
      return [];
    }
    const { visibleCols } = this.beans;
    const visibleCenterCols = visibleCols.centerCols;
    let flexAfterDisplayIndex = -1;
    if (params.resizingCols) {
      const allResizingCols = new Set(params.resizingCols);
      for (let i = visibleCenterCols.length - 1; i >= 0; i--) {
        if (allResizingCols.has(visibleCenterCols[i])) {
          flexAfterDisplayIndex = i;
          break;
        }
      }
    }
    let hasFlexItems = false;
    const items = visibleCenterCols.map((col, i) => {
      const flex = col.getFlex();
      const isFlex = flex != null && flex > 0 && i > flexAfterDisplayIndex;
      hasFlexItems || (hasFlexItems = isFlex);
      return {
        col,
        isFlex,
        flex: Math.max(0, flex ?? 0),
        initialSize: col.getActualWidth(),
        min: col.getMinWidth(),
        max: col.getMaxWidth(),
        targetSize: 0
      };
    });
    if (!hasFlexItems) {
      return [];
    }
    let unfrozenItemCount = items.length;
    let unfrozenFlex = items.reduce((acc, item) => acc + item.flex, 0);
    let unfrozenSpace = totalSpace;
    const freeze = (item, width) => {
      item.frozenSize = width;
      item.col.setActualWidth(width, source);
      unfrozenSpace -= width;
      unfrozenFlex -= item.flex;
      unfrozenItemCount -= 1;
    };
    const isFrozen = (item) => item.frozenSize != null;
    for (const item of items) {
      if (!item.isFlex) {
        freeze(item, item.initialSize);
      }
    }
    while (unfrozenItemCount > 0) {
      const spaceToFill = Math.round(unfrozenFlex < 1 ? unfrozenSpace * unfrozenFlex : unfrozenSpace);
      let lastUnfrozenItem;
      let actualLeft = 0;
      let idealRight = 0;
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        lastUnfrozenItem = item;
        idealRight += spaceToFill * (item.flex / unfrozenFlex);
        const idealSize = idealRight - actualLeft;
        const roundedSize = Math.round(idealSize);
        item.targetSize = roundedSize;
        actualLeft += roundedSize;
      }
      if (lastUnfrozenItem) {
        lastUnfrozenItem.targetSize += spaceToFill - actualLeft;
      }
      let totalViolation = 0;
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        const unclampedSize = item.targetSize;
        const clampedSize = Math.min(Math.max(unclampedSize, item.min), item.max);
        totalViolation += clampedSize - unclampedSize;
        item.violationType = clampedSize === unclampedSize ? void 0 : clampedSize < unclampedSize ? "max" : "min";
        item.targetSize = clampedSize;
      }
      const freezeType = totalViolation === 0 ? "all" : totalViolation > 0 ? "min" : "max";
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        if (freezeType === "all" || item.violationType === freezeType) {
          freeze(item, item.targetSize);
        }
      }
    }
    if (!params.skipSetLeft) {
      visibleCols.setLeftValues(source);
    }
    if (params.updateBodyWidths) {
      visibleCols.updateBodyWidths();
    }
    const unconstrainedFlexColumns = items.filter((item) => item.isFlex && !item.violationType).map((item) => item.col);
    if (params.fireResizedEvent) {
      const changedColumns = items.filter((item) => item.initialSize !== item.frozenSize).map((item) => item.col);
      const flexingColumns = items.filter((item) => item.flex).map((item) => item.col);
      dispatchColumnResizedEvent(this.eventSvc, changedColumns, true, source, flexingColumns);
    }
    return unconstrainedFlexColumns;
  }
  initCol(column) {
    const { flex, initialFlex } = column.colDef;
    if (flex !== void 0) {
      column.flex = flex;
    } else if (initialFlex !== void 0) {
      column.flex = initialFlex;
    }
  }
  // this method should only be used by the colModel to
  // change flex when required by the applyColumnState method.
  setColFlex(column, flex) {
    column.flex = flex ?? null;
    column.dispatchStateUpdatedEvent("flex");
  }
};

// packages/ag-grid-community/src/columns/dataTypeService.ts
var DataTypeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dataTypeSvc";
    this.dataTypeDefinitions = {};
    this.isPendingInference = false;
    this.isColumnTypeOverrideInDataTypeDefinitions = false;
    // keep track of any column state updates whilst waiting for data types to be inferred
    this.columnStateUpdatesPendingInference = {};
    this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
  }
  postConstruct() {
    this.processDataTypeDefinitions();
    this.addManagedPropertyListener("dataTypeDefinitions", (event) => {
      this.processDataTypeDefinitions();
      this.colModel.recreateColumnDefs(_convertColumnEventSourceType(event.source));
    });
  }
  processDataTypeDefinitions() {
    const defaultDataTypes = this.getDefaultDataTypes();
    const newDataTypeDefinitions = {};
    this.dataTypeDefinitions = newDataTypeDefinitions;
    const newFormatValueFuncs = {};
    this.formatValueFuncs = newFormatValueFuncs;
    const generateFormatValueFunc = (dataTypeDefinition) => {
      return (params) => {
        const { column, node, value } = params;
        let valueFormatter = column.getColDef().valueFormatter;
        if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) {
          valueFormatter = dataTypeDefinition.valueFormatter;
        }
        return this.beans.valueSvc.formatValue(column, node, value, valueFormatter);
      };
    };
    Object.entries(defaultDataTypes).forEach(([cellDataType, dataTypeDefinition]) => {
      const mergedDataTypeDefinition = {
        ...dataTypeDefinition,
        groupSafeValueFormatter: createGroupSafeValueFormatter(dataTypeDefinition, this.gos)
      };
      newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
      newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
    });
    const dataTypeDefinitions = this.gos.get("dataTypeDefinitions") ?? {};
    const newDataTypeMatchers = {};
    this.dataTypeMatchers = newDataTypeMatchers;
    Object.entries(dataTypeDefinitions).forEach(([cellDataType, dataTypeDefinition]) => {
      const mergedDataTypeDefinition = this.processDataTypeDefinition(
        dataTypeDefinition,
        dataTypeDefinitions,
        [cellDataType],
        defaultDataTypes
      );
      if (mergedDataTypeDefinition) {
        newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
        if (dataTypeDefinition.dataTypeMatcher) {
          newDataTypeMatchers[cellDataType] = dataTypeDefinition.dataTypeMatcher;
        }
        newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
      }
    });
    this.checkObjectValueHandlers(defaultDataTypes);
    ["dateString", "text", "number", "boolean", "date"].forEach((cellDataType) => {
      const overriddenDataTypeMatcher = newDataTypeMatchers[cellDataType];
      if (overriddenDataTypeMatcher) {
        delete newDataTypeMatchers[cellDataType];
      }
      newDataTypeMatchers[cellDataType] = overriddenDataTypeMatcher ?? defaultDataTypes[cellDataType].dataTypeMatcher;
    });
  }
  processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, alreadyProcessedDataTypes, defaultDataTypes) {
    let mergedDataTypeDefinition;
    const extendsCellDataType = dataTypeDefinition.extendsDataType;
    if (dataTypeDefinition.columnTypes) {
      this.isColumnTypeOverrideInDataTypeDefinitions = true;
    }
    if (dataTypeDefinition.extendsDataType === dataTypeDefinition.baseDataType) {
      let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
      const overriddenBaseDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
      if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) {
        baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
      }
      if (!validateDataTypeDefinition(dataTypeDefinition, baseDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      mergedDataTypeDefinition = mergeDataTypeDefinitions(baseDataTypeDefinition, dataTypeDefinition);
    } else {
      if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
        _warn(44);
        return void 0;
      }
      const extendedDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
      if (!validateDataTypeDefinition(dataTypeDefinition, extendedDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(
        extendedDataTypeDefinition,
        dataTypeDefinitions,
        [...alreadyProcessedDataTypes, extendsCellDataType],
        defaultDataTypes
      );
      if (!mergedExtendedDataTypeDefinition) {
        return void 0;
      }
      mergedDataTypeDefinition = mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, dataTypeDefinition);
    }
    return {
      ...mergedDataTypeDefinition,
      groupSafeValueFormatter: createGroupSafeValueFormatter(mergedDataTypeDefinition, this.gos)
    };
  }
  updateColDefAndGetColumnType(colDef, userColDef, colId) {
    let { cellDataType } = userColDef;
    const { field } = userColDef;
    if (cellDataType === void 0) {
      cellDataType = colDef.cellDataType;
    }
    if (cellDataType == null || cellDataType === true) {
      cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
    }
    if (!cellDataType) {
      colDef.cellDataType = false;
      return void 0;
    }
    const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
    if (!dataTypeDefinition) {
      _warn(47, { cellDataType });
      return void 0;
    }
    colDef.cellDataType = cellDataType;
    if (dataTypeDefinition.groupSafeValueFormatter) {
      colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
    }
    if (dataTypeDefinition.valueParser) {
      colDef.valueParser = dataTypeDefinition.valueParser;
    }
    if (!dataTypeDefinition.suppressDefaultProperties) {
      this.setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId);
    }
    return dataTypeDefinition.columnTypes;
  }
  addColumnListeners(column) {
    if (!this.isPendingInference) {
      return;
    }
    const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
    if (!columnStateUpdates) {
      return;
    }
    const columnListener = (event) => {
      columnStateUpdates.add(event.key);
    };
    column.addEventListener("columnStateUpdated", columnListener);
    this.columnStateUpdateListenerDestroyFuncs.push(
      () => column.removeEventListener("columnStateUpdated", columnListener)
    );
  }
  canInferCellDataType(colDef, userColDef) {
    const { gos } = this;
    if (!_isClientSideRowModel(gos)) {
      return false;
    }
    const propsToCheckForInference = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
    if (doColDefPropsPreventInference(userColDef, propsToCheckForInference)) {
      return false;
    }
    const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
    if (columnTypes) {
      const columnTypeDefs = gos.get("columnTypes") ?? {};
      const hasPropsPreventingInference = convertColumnTypes(columnTypes).some((columnType) => {
        const columnTypeDef = columnTypeDefs[columnType.trim()];
        return columnTypeDef && doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
      });
      if (hasPropsPreventingInference) {
        return false;
      }
    }
    return !doColDefPropsPreventInference(colDef, propsToCheckForInference);
  }
  inferCellDataType(field, colId) {
    if (!field) {
      return void 0;
    }
    let value;
    const initialData = this.getInitialData();
    if (initialData) {
      const fieldContainsDots = field.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      value = _getValueUsingField(initialData, field, fieldContainsDots);
    } else {
      this.initWaitForRowData(colId);
    }
    if (value == null) {
      return void 0;
    }
    const [cellDataType] = Object.entries(this.dataTypeMatchers).find(
      ([_cellDataType, dataTypeMatcher]) => dataTypeMatcher(value)
    ) ?? ["object"];
    return cellDataType;
  }
  getInitialData() {
    const rowData = this.gos.get("rowData");
    if (rowData?.length) {
      return rowData[0];
    } else if (this.initialData) {
      return this.initialData;
    } else {
      const rowNodes = this.beans.rowModel.rootNode?.allLeafChildren;
      if (rowNodes?.length) {
        return rowNodes[0].data;
      }
    }
    return null;
  }
  initWaitForRowData(colId) {
    this.columnStateUpdatesPendingInference[colId] = /* @__PURE__ */ new Set();
    if (this.isPendingInference) {
      return;
    }
    this.isPendingInference = true;
    const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
    const { colAutosize, eventSvc } = this.beans;
    if (columnTypeOverridesExist && colAutosize) {
      colAutosize.shouldQueueResizeOperations = true;
    }
    const [destroyFunc] = this.addManagedEventListeners({
      rowDataUpdateStarted: (event) => {
        const { firstRowData } = event;
        if (!firstRowData) {
          return;
        }
        destroyFunc?.();
        this.isPendingInference = false;
        this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
        this.columnStateUpdatesPendingInference = {};
        if (columnTypeOverridesExist) {
          colAutosize?.processResizeOperations();
        }
        eventSvc.dispatchEvent({
          type: "dataTypesInferred"
        });
      }
    });
  }
  processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
    this.initialData = firstRowData;
    const state = [];
    this.destroyColumnStateUpdateListeners();
    const newRowGroupColumnStateWithoutIndex = {};
    const newPivotColumnStateWithoutIndex = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([colId, columnStateUpdates]) => {
      const column = this.colModel.getCol(colId);
      if (!column) {
        return;
      }
      const oldColDef = column.getColDef();
      if (!this.resetColDefIntoCol(column, "cellDataTypeInferred")) {
        return;
      }
      const newColDef = column.getColDef();
      if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
        const updatedColumnState = getUpdatedColumnState(column, columnStateUpdates);
        if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) {
          newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
        }
        if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) {
          newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
        }
        state.push(updatedColumnState);
      }
    });
    if (columnTypeOverridesExist) {
      state.push(
        ...this.generateColumnStateForRowGroupAndPivotIndexes(
          newRowGroupColumnStateWithoutIndex,
          newPivotColumnStateWithoutIndex
        )
      );
    }
    if (state.length) {
      _applyColumnState(this.beans, { state }, "cellDataTypeInferred");
    }
    this.initialData = null;
  }
  generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
    const existingColumnStateUpdates = {};
    const { rowGroupColsSvc, pivotColsSvc } = this.beans;
    rowGroupColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedRowGroupColumnState);
    pivotColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedPivotColumnState);
    return Object.values(existingColumnStateUpdates);
  }
  resetColDefIntoCol(column, source) {
    const userColDef = column.getUserProvidedColDef();
    if (!userColDef) {
      return false;
    }
    const newColDef = _addColumnDefaultAndTypes(this.beans, userColDef, column.getColId());
    column.setColDef(newColDef, userColDef, source);
    return true;
  }
  checkObjectValueHandlers(defaultDataTypes) {
    const resolvedObjectDataTypeDefinition = this.dataTypeDefinitions.object;
    const defaultObjectDataTypeDefinition = defaultDataTypes.object;
    this.hasObjectValueParser = resolvedObjectDataTypeDefinition.valueParser !== defaultObjectDataTypeDefinition.valueParser;
    this.hasObjectValueFormatter = resolvedObjectDataTypeDefinition.valueFormatter !== defaultObjectDataTypeDefinition.valueFormatter;
  }
  getDateStringTypeDefinition(column) {
    const { dateString } = this.dataTypeDefinitions;
    if (!column) {
      return dateString;
    }
    return this.getDataTypeDefinition(column) ?? dateString;
  }
  getDateParserFunction(column) {
    return this.getDateStringTypeDefinition(column).dateParser;
  }
  getDateFormatterFunction(column) {
    return this.getDateStringTypeDefinition(column).dateFormatter;
  }
  getDataTypeDefinition(column) {
    const colDef = column.getColDef();
    if (!colDef.cellDataType) {
      return void 0;
    }
    return this.dataTypeDefinitions[colDef.cellDataType];
  }
  getBaseDataType(column) {
    return this.getDataTypeDefinition(column)?.baseDataType;
  }
  checkType(column, value) {
    if (value == null) {
      return true;
    }
    const dataTypeMatcher = this.getDataTypeDefinition(column)?.dataTypeMatcher;
    if (!dataTypeMatcher) {
      return true;
    }
    return dataTypeMatcher(value);
  }
  validateColDef(colDef) {
    const warning = (property) => _warn(48, { property });
    if (colDef.cellDataType === "object") {
      const { object } = this.dataTypeDefinitions;
      if (colDef.valueFormatter === object.groupSafeValueFormatter && !this.hasObjectValueFormatter) {
        warning("Formatter");
      }
      if (colDef.editable && colDef.valueParser === object.valueParser && !this.hasObjectValueParser) {
        warning("Parser");
      }
    }
  }
  getFormatValue(cellDataType) {
    return this.formatValueFuncs[cellDataType];
  }
  isColPendingInference(colId) {
    return this.isPendingInference && !!this.columnStateUpdatesPendingInference[colId];
  }
  setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId) {
    const formatValue = this.formatValueFuncs[cellDataType];
    switch (dataTypeDefinition.baseDataType) {
      case "number": {
        colDef.cellEditor = "agNumberCellEditor";
        break;
      }
      case "boolean": {
        colDef.cellEditor = "agCheckboxCellEditor";
        colDef.cellRenderer = "agCheckboxCellRenderer";
        colDef.suppressKeyboardEvent = (params) => !!params.colDef.editable && params.event.key === KeyCode.SPACE;
        break;
      }
      case "date": {
        colDef.cellEditor = "agDateCellEditor";
        colDef.keyCreator = formatValue;
        break;
      }
      case "dateString": {
        colDef.cellEditor = "agDateStringCellEditor";
        colDef.keyCreator = formatValue;
        break;
      }
      case "object": {
        colDef.cellEditorParams = {
          useFormatter: true
        };
        colDef.comparator = (a, b) => {
          const column = this.colModel.getColDefCol(colId);
          const colDef2 = column?.getColDef();
          if (!column || !colDef2) {
            return 0;
          }
          const valA = a == null ? "" : formatValue({ column, node: null, value: a });
          const valB = b == null ? "" : formatValue({ column, node: null, value: b });
          if (valA === valB)
            return 0;
          return valA > valB ? 1 : -1;
        };
        colDef.keyCreator = formatValue;
        break;
      }
    }
    this.beans.filterManager?.setColDefPropertiesForDataType(colDef, dataTypeDefinition, formatValue);
  }
  getDefaultDataTypes() {
    const defaultDateFormatMatcher = (value) => !!value.match("^\\d{4}-\\d{2}-\\d{2}$");
    const translate = this.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (params) => params.newValue?.trim?.() === "" ? null : Number(params.newValue),
        valueFormatter: (params) => {
          if (params.value == null) {
            return "";
          }
          if (typeof params.value !== "number" || isNaN(params.value)) {
            return translate("invalidNumber", "Invalid Number");
          }
          return String(params.value);
        },
        dataTypeMatcher: (value) => typeof value === "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (params) => params.newValue === "" ? null : _toStringOrNull(params.newValue),
        dataTypeMatcher: (value) => typeof value === "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (params) => {
          if (params.newValue == null) {
            return params.newValue;
          }
          return params.newValue?.trim?.() === "" ? null : String(params.newValue).toLowerCase() === "true";
        },
        valueFormatter: (params) => params.value == null ? "" : String(params.value),
        dataTypeMatcher: (value) => typeof value === "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (params) => _parseDateTimeFromString(params.newValue == null ? null : String(params.newValue)),
        valueFormatter: (params) => {
          if (params.value == null) {
            return "";
          }
          if (!(params.value instanceof Date) || isNaN(params.value.getTime())) {
            return translate("invalidDate", "Invalid Date");
          }
          return _serialiseDate(params.value, false) ?? "";
        },
        dataTypeMatcher: (value) => value instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (value) => _parseDateTimeFromString(value) ?? void 0,
        dateFormatter: (value) => _serialiseDate(value ?? null, false) ?? void 0,
        valueParser: (params) => defaultDateFormatMatcher(String(params.newValue)) ? params.newValue : null,
        valueFormatter: (params) => defaultDateFormatMatcher(String(params.value)) ? params.value : "",
        dataTypeMatcher: (value) => typeof value === "string" && defaultDateFormatMatcher(value)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (params) => _toStringOrNull(params.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc) => destroyFunc());
    this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {};
    this.dataTypeMatchers = {};
    this.formatValueFuncs = {};
    this.columnStateUpdatesPendingInference = {};
    this.destroyColumnStateUpdateListeners();
    super.destroy();
  }
};
function mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
  const mergedDataTypeDefinition = {
    ...parentDataTypeDefinition,
    ...childDataTypeDefinition
  };
  if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) {
    mergedDataTypeDefinition.columnTypes = [
      ...convertColumnTypes(parentDataTypeDefinition.columnTypes),
      ...convertColumnTypes(childDataTypeDefinition.columnTypes)
    ];
  }
  return mergedDataTypeDefinition;
}
function validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
  if (!parentDataTypeDefinition) {
    _warn(45, { parentCellDataType });
    return false;
  }
  if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
    _warn(46);
    return false;
  }
  return true;
}
function createGroupSafeValueFormatter(dataTypeDefinition, gos) {
  if (!dataTypeDefinition.valueFormatter) {
    return void 0;
  }
  return (params) => {
    if (params.node?.group) {
      const aggFunc = (params.colDef.pivotValueColumn ?? params.column).getAggFunc();
      if (aggFunc) {
        if (aggFunc === "first" || aggFunc === "last") {
          return dataTypeDefinition.valueFormatter(params);
        }
        if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
          if (typeof params.value === "number") {
            return dataTypeDefinition.valueFormatter(params);
          }
          if (typeof params.value === "object") {
            if (!params.value) {
              return void 0;
            }
            if ("toNumber" in params.value) {
              return dataTypeDefinition.valueFormatter({
                ...params,
                value: params.value.toNumber()
              });
            }
            if ("value" in params.value) {
              return dataTypeDefinition.valueFormatter({
                ...params,
                value: params.value.value
              });
            }
          }
        }
        return void 0;
      }
      if (gos.get("groupDisplayType") === "groupRows" && !gos.get("treeData")) {
        return void 0;
      }
    } else if (gos.get("groupHideOpenParents") && params.column.isRowGroupActive()) {
      if (typeof params.value === "string" && !dataTypeDefinition.dataTypeMatcher?.(params.value)) {
        return void 0;
      }
    }
    return dataTypeDefinition.valueFormatter(params);
  };
}
function doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
  if (!checkProps[prop]) {
    return false;
  }
  const value = colDef[prop];
  if (value === null) {
    checkProps[prop] = false;
    return false;
  } else {
    return comparisonValue === void 0 ? !!value : value === comparisonValue;
  }
}
function doColDefPropsPreventInference(colDef, propsToCheckForInference) {
  return [
    ["cellRenderer", "agSparklineCellRenderer"],
    ["valueGetter", void 0],
    ["valueParser", void 0],
    ["refData", void 0]
  ].some(
    ([prop, comparisonValue]) => doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue)
  );
}
function getUpdatedColumnState(column, columnStateUpdates) {
  const columnState = getColumnStateFromColDef(column);
  columnStateUpdates.forEach((key) => {
    delete columnState[key];
    if (key === "rowGroup") {
      delete columnState.rowGroupIndex;
    } else if (key === "pivot") {
      delete columnState.pivotIndex;
    }
  });
  return columnState;
}

// packages/ag-grid-community/src/columns/columnModule.ts
var DataTypeModule = {
  moduleName: "DataType",
  version: VERSION,
  beans: [DataTypeService],
  dependsOn: [CheckboxCellRendererModule]
};
var ColumnFlexModule = {
  moduleName: "ColumnFlex",
  version: VERSION,
  beans: [ColumnFlexService]
};
var ColumnApiModule = {
  moduleName: "ColumnApi",
  version: VERSION,
  beans: [ColumnDefFactory],
  apiFunctions: {
    getColumnDef,
    getDisplayNameForColumn,
    getColumn,
    getColumns,
    applyColumnState,
    getColumnState,
    resetColumnState,
    isPinning,
    isPinningLeft,
    isPinningRight,
    getDisplayedColAfter,
    getDisplayedColBefore,
    setColumnsVisible,
    setColumnsPinned,
    getAllGridColumns,
    getDisplayedLeftColumns,
    getDisplayedCenterColumns,
    getDisplayedRightColumns,
    getAllDisplayedColumns,
    getAllDisplayedVirtualColumns,
    getColumnDefs
  }
};

// packages/ag-grid-community/src/columns/columnNameService.ts
function _camelCaseToHumanText(camelCase) {
  if (!camelCase || camelCase == null) {
    return null;
  }
  const rex = /([a-z])([A-Z])/g;
  const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
  const words = camelCase.replace(rex, "$1 $2").replace(rexCaps, "$1 $2$3").replace(/\./g, " ").split(" ");
  return words.map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
}
var ColumnNameService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colNames";
  }
  getDisplayNameForColumn(column, location, includeAggFunc = false) {
    if (!column) {
      return null;
    }
    const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
    const { aggColNameSvc } = this.beans;
    if (includeAggFunc && aggColNameSvc) {
      return aggColNameSvc.getHeaderName(column, headerName);
    }
    return headerName;
  }
  getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
    const colGroupDef = providedColumnGroup?.getColGroupDef();
    if (colGroupDef) {
      return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
    }
    return null;
  }
  getDisplayNameForColumnGroup(columnGroup, location) {
    return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
    const headerValueGetter = colDef.headerValueGetter;
    if (headerValueGetter) {
      const params = this.gos.addGridCommonParams({
        colDef,
        column,
        columnGroup,
        providedColumnGroup,
        location
      });
      if (typeof headerValueGetter === "function") {
        return headerValueGetter(params);
      } else if (typeof headerValueGetter === "string") {
        return this.beans.expressionSvc?.evaluate(headerValueGetter, params) ?? null;
      }
      return "";
    } else if (colDef.headerName != null) {
      return colDef.headerName;
    } else if (colDef.field) {
      return _camelCaseToHumanText(colDef.field);
    }
    return "";
  }
};

// packages/ag-grid-community/src/columns/columnViewportService.ts
var ColumnViewportService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colViewport";
    // cols in center that are in the viewport
    this.colsWithinViewport = [];
    // same as colsWithinViewport, except we always include columns with headerAutoHeight
    this.headerColsWithinViewport = [];
    // A hash key to keep track of changes in viewport columns
    this.colsWithinViewportHash = "";
    // all columns & groups to be rendered, index by row.
    // used by header rows to get all items to render for that row.
    this.rowsOfHeadersToRenderLeft = {};
    this.rowsOfHeadersToRenderRight = {};
    this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(beans) {
    this.visibleCols = beans.visibleCols;
    this.colModel = beans.colModel;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(scrollWidth, scrollPosition, afterScroll = false) {
    const { visibleCols } = this;
    const bodyWidthDirty = visibleCols.isBodyWidthDirty;
    const noChange = scrollWidth === this.scrollWidth && scrollPosition === this.scrollPosition && !bodyWidthDirty;
    if (noChange) {
      return;
    }
    this.scrollWidth = scrollWidth;
    this.scrollPosition = scrollPosition;
    visibleCols.isBodyWidthDirty = true;
    if (this.gos.get("enableRtl")) {
      const bodyWidth = visibleCols.bodyWidth;
      this.viewportLeft = bodyWidth - scrollPosition - scrollWidth;
      this.viewportRight = bodyWidth - scrollPosition;
    } else {
      this.viewportLeft = scrollPosition;
      this.viewportRight = scrollWidth + scrollPosition;
    }
    if (this.colModel.ready) {
      this.checkViewportColumns(afterScroll);
    }
  }
  getHeadersToRender(type, dept) {
    let result;
    switch (type) {
      case "left":
        result = this.rowsOfHeadersToRenderLeft[dept];
        break;
      case "right":
        result = this.rowsOfHeadersToRenderRight[dept];
        break;
      default:
        result = this.rowsOfHeadersToRenderCenter[dept];
        break;
    }
    return result || [];
  }
  extractViewportColumns() {
    const displayedColumnsCenter = this.visibleCols.centerCols;
    if (this.isColumnVirtualisationSuppressed()) {
      this.colsWithinViewport = displayedColumnsCenter;
      this.headerColsWithinViewport = displayedColumnsCenter;
    } else {
      this.colsWithinViewport = displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
      this.headerColsWithinViewport = displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
    }
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear(suppressHashClear) {
    this.rowsOfHeadersToRenderLeft = {};
    this.rowsOfHeadersToRenderRight = {};
    this.rowsOfHeadersToRenderCenter = {};
    if (!suppressHashClear) {
      this.colsWithinViewportHash = "";
    }
  }
  isColumnInHeaderViewport(col) {
    if (col.isAutoHeaderHeight() || isAnyParentAutoHeaderHeight(col)) {
      return true;
    }
    return this.isColumnInRowViewport(col);
  }
  isColumnInRowViewport(col) {
    if (col.isAutoHeight()) {
      return true;
    }
    const columnLeft = col.getLeft() || 0;
    const columnRight = columnLeft + col.getActualWidth();
    const leftBounds = this.viewportLeft - 200;
    const rightBounds = this.viewportRight + 200;
    const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
    const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
    return !columnToMuchLeft && !columnToMuchRight;
  }
  // used by Grid API only
  getViewportColumns() {
    const { leftCols, rightCols } = this.visibleCols;
    const res = this.colsWithinViewport.concat(leftCols).concat(rightCols);
    return res;
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(rowNode) {
    if (!this.colModel.colSpanActive) {
      return this.colsWithinViewport;
    }
    const emptySpaceBeforeColumn = (col) => {
      const left = col.getLeft();
      return _exists(left) && left > this.viewportLeft;
    };
    const inViewportCallback = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this);
    const { visibleCols } = this;
    const displayedColumnsCenter = visibleCols.centerCols;
    return visibleCols.getColsForRow(rowNode, displayedColumnsCenter, inViewportCallback, emptySpaceBeforeColumn);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(afterScroll = false) {
    const viewportColumnsChanged = this.extractViewport();
    if (viewportColumnsChanged) {
      this.eventSvc.dispatchEvent({
        type: "virtualColumnsChanged",
        afterScroll
      });
    }
  }
  calculateHeaderRows() {
    this.clear(true);
    const renderedColIds = {};
    const { leftCols, rightCols, treeLeft, treeRight, treeCenter } = this.visibleCols;
    const allRenderedCols = this.headerColsWithinViewport.concat(leftCols).concat(rightCols);
    allRenderedCols.forEach((col) => renderedColIds[col.getId()] = true);
    const testGroup = (children, result, dept) => {
      let returnValue = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let addThisItem = false;
        if (isColumn(child)) {
          addThisItem = renderedColIds[child.getId()] === true;
        } else {
          const columnGroup = child;
          const displayedChildren = columnGroup.getDisplayedChildren();
          if (displayedChildren) {
            addThisItem = testGroup(displayedChildren, result, dept + 1);
          }
        }
        if (addThisItem) {
          returnValue = true;
          if (!result[dept]) {
            result[dept] = [];
          }
          result[dept].push(child);
        }
      }
      return returnValue;
    };
    testGroup(treeLeft, this.rowsOfHeadersToRenderLeft, 0);
    testGroup(treeRight, this.rowsOfHeadersToRenderRight, 0);
    testGroup(treeCenter, this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const hashColumn = (c) => `${c.getId()}-${c.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const newHash = this.getViewportColumns().map(hashColumn).join("#");
    const changed = this.colsWithinViewportHash !== newHash;
    if (changed) {
      this.colsWithinViewportHash = newHash;
      this.calculateHeaderRows();
    }
    return changed;
  }
};
function isAnyParentAutoHeaderHeight(col) {
  while (col) {
    if (col.isAutoHeaderHeight()) {
      return true;
    }
    col = col.getParent();
  }
  return false;
}

// packages/ag-grid-community/src/components/framework/agComponentUtils.ts
var AgComponentUtils = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "agCompUtils";
  }
  adaptFunction(type, jsCompFunc) {
    if (!type.cellRenderer) {
      return null;
    }
    class Adapter {
      refresh() {
        return false;
      }
      getGui() {
        return this.eGui;
      }
      init(params) {
        const callbackResult = jsCompFunc(params);
        const type2 = typeof callbackResult;
        if (type2 === "string" || type2 === "number" || type2 === "boolean") {
          this.eGui = _loadTemplate("<span>" + callbackResult + "</span>");
          return;
        }
        if (callbackResult == null) {
          this.eGui = _loadTemplate("<span></span>");
          return;
        }
        this.eGui = callbackResult;
      }
    }
    return Adapter;
  }
};

// packages/ag-grid-community/src/components/framework/cellRendererFunctionModule.ts
var CellRendererFunctionModule = {
  moduleName: "CellRendererFunction",
  version: VERSION,
  beans: [AgComponentUtils]
};

// packages/ag-grid-community/src/components/framework/registry.ts
var Registry = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "registry";
    this.agGridDefaults = {};
    this.agGridDefaultParams = {};
    this.jsComps = {};
    this.dynamicBeans = {};
    this.selectors = {};
    this.icons = {};
  }
  postConstruct() {
    const comps = this.gos.get("components");
    if (comps != null) {
      Object.entries(comps).forEach(([key, component]) => {
        this.jsComps[key] = component;
      });
    }
  }
  registerModule(module2) {
    const { icons, userComponents, dynamicBeans, selectors } = module2;
    if (userComponents) {
      const registerUserComponent = (name, component, params) => {
        this.agGridDefaults[name] = component;
        if (params) {
          this.agGridDefaultParams[name] = params;
        }
      };
      for (const name of Object.keys(userComponents)) {
        const comp = userComponents[name];
        if (typeof comp === "object") {
          registerUserComponent(name, comp.classImp, comp.params);
        } else {
          registerUserComponent(name, comp);
        }
      }
    }
    if (dynamicBeans) {
      for (const name of Object.keys(dynamicBeans)) {
        this.dynamicBeans[name] = dynamicBeans[name];
      }
    }
    selectors?.forEach((selector) => {
      this.selectors[selector.selector] = selector;
    });
    if (icons) {
      for (const name of Object.keys(icons)) {
        this.icons[name] = icons[name];
      }
    }
  }
  getUserComponent(propertyName, name) {
    const createResult = (component, componentFromFramework, params) => ({
      componentFromFramework,
      component,
      params
    });
    const { frameworkOverrides } = this.beans;
    const registeredViaFrameworkComp = frameworkOverrides.frameworkComponent(name, this.gos.get("components"));
    if (registeredViaFrameworkComp != null) {
      return createResult(registeredViaFrameworkComp, true);
    }
    const jsComponent = this.jsComps[name];
    if (jsComponent) {
      const isFwkComp = frameworkOverrides.isFrameworkComponent(jsComponent);
      return createResult(jsComponent, isFwkComp);
    }
    const defaultComponent = this.agGridDefaults[name];
    if (defaultComponent) {
      return createResult(defaultComponent, false, this.agGridDefaultParams[name]);
    }
    this.beans.validation?.missingUserComponent(propertyName, name, this.agGridDefaults, this.jsComps);
    return null;
  }
  createDynamicBean(name, mandatory, ...args) {
    const BeanClass = this.dynamicBeans[name];
    if (BeanClass == null) {
      if (mandatory) {
        throw new Error(_errMsg(256));
      }
      return void 0;
    }
    return new BeanClass(...args);
  }
  getSelector(name) {
    return this.selectors[name];
  }
  getIcon(name) {
    return this.icons[name];
  }
};

// packages/ag-grid-community/src/ctrlsService.ts
var NUM_CTRLS = 23;
var CtrlsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "ctrlsSvc";
    this.params = {};
    this.ready = false;
    this.readyCallbacks = [];
  }
  postConstruct() {
    this.addEventListener(
      "ready",
      () => {
        this.updateReady();
        if (this.ready) {
          this.readyCallbacks.forEach((c) => c(this.params));
          this.readyCallbacks.length = 0;
        }
      },
      this.beans.frameworkOverrides.runWhenReadyAsync?.() ?? false
    );
  }
  updateReady() {
    const values = Object.values(this.params);
    this.ready = values.length === NUM_CTRLS && values.every((ctrl) => {
      return ctrl?.isAlive() ?? false;
    });
  }
  whenReady(caller, callback) {
    if (this.ready) {
      callback(this.params);
    } else {
      this.readyCallbacks.push(callback);
    }
    caller.addDestroyFunc(() => {
      const index = this.readyCallbacks.indexOf(callback);
      if (index >= 0) {
        this.readyCallbacks.splice(index, 1);
      }
    });
  }
  register(ctrlType, ctrl) {
    this.params[ctrlType] = ctrl;
    this.updateReady();
    if (this.ready) {
      this.dispatchLocalEvent({ type: "ready" });
    }
    ctrl.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(ctrlType) {
    return this.params[ctrlType];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader, centerHeader, rightHeader } = this.params;
    return [leftHeader, rightHeader, centerHeader];
  }
  getHeaderRowContainerCtrl(pinned) {
    const params = this.params;
    switch (pinned) {
      case "left":
        return params.leftHeader;
      case "right":
        return params.rightHeader;
      default:
        return params.centerHeader;
    }
  }
  getScrollFeature() {
    return this.getGridBodyCtrl().scrollFeature;
  }
};

// packages/ag-grid-community/src/theming/core/core.css-GENERATED.ts
var coreCSS = (
  /*css*/
  `:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none}}:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom,.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}.ag-floating-bottom{border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);height:var(--ag-row-height);white-space:nowrap;width:100%;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px))}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row-hover.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{opacity:1}50%{opacity:.4}to{opacity:1}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-chart,.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}:where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);cursor:pointer;font-family:inherit;padding:var(--ag-spacing) calc(var(--ag-spacing)*2);&:hover{background-color:var(--ag-row-hover-color)}&:active{border-color:var(--ag-accent-color)}&:disabled{background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-column-select-column-readonly{&.ag-icon-grip,.ag-icon-grip{opacity:.35}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{&:hover{background-color:var(--ag-icon-button-hover-color);border-radius:1px;box-shadow:0 0 0 4px var(--ag-icon-button-hover-color)}}.ag-filter-active{--ag-icon-button-hover-color:color-mix(in srgb,transparent,var(--ag-accent-color) 28%);background-color:color-mix(in srgb,transparent,var(--ag-accent-color) 14%);border-radius:1px;outline:solid 4px color-mix(in srgb,transparent,var(--ag-accent-color) 14%);position:relative;&:after{background-color:var(--ag-accent-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z")}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto}.ag-menu,.ag-resizer{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-resizer{pointer-events:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}:where(.ag-ltr) :where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize}&.ag-resizer-topRight{cursor:nesw-resize}&.ag-resizer-bottomRight{cursor:nwse-resize}&.ag-resizer-bottomLeft{cursor:nesw-resize}}:where(.ag-rtl) :where(.ag-resizer){&.ag-resizer-topLeft{cursor:nesw-resize}&.ag-resizer-topRight{cursor:nwse-resize}&.ag-resizer-bottomRight{cursor:nesw-resize}&.ag-resizer-bottomLeft{cursor:nwse-resize}}`
);

// packages/ag-grid-community/src/theming/inject.ts
var IS_SSR = typeof window !== "object" || !window?.document?.fonts?.forEach;
var injections = /* @__PURE__ */ new WeakMap();
var _injectGlobalCSS = (css, container, debugId) => {
  if (IS_SSR)
    return;
  const root = container.getRootNode() === document ? document.head : container;
  let injection = injections.get(root);
  if (!injection) {
    injection = { css: /* @__PURE__ */ new Set() };
    injections.set(root, injection);
  }
  if (injection.css.has(css))
    return;
  const style = document.createElement("style");
  style.dataset.agGlobalCss = debugId;
  style.textContent = css;
  if (injection.last) {
    injection.last.insertAdjacentElement("afterend", style);
  } else {
    root.insertBefore(style, root.querySelector(":not(title, meta)"));
  }
  injection.css.add(css);
  injection.last = style;
};
var _injectCoreAndModuleCSS = (container) => {
  _injectGlobalCSS(coreCSS, container, "core");
  Array.from(_getAllRegisteredModules()).sort((a, b) => a.moduleName.localeCompare(b.moduleName)).forEach(
    (module2) => module2.css?.forEach((css) => _injectGlobalCSS(css, container, `module-${module2.moduleName}`))
  );
};
var gridsUsingThemingAPI = /* @__PURE__ */ new Set();
var _registerGridUsingThemingAPI = (environment) => {
  gridsUsingThemingAPI.add(environment);
};
var _unregisterGridUsingThemingAPI = (environment) => {
  gridsUsingThemingAPI.delete(environment);
  if (gridsUsingThemingAPI.size === 0) {
    injections = /* @__PURE__ */ new WeakMap();
    for (const style of document.head.querySelectorAll("style[data-ag-global-css]")) {
      style.remove();
    }
  }
};

// packages/ag-grid-community/src/theming/Part.ts
var createPart = (args) => new PartImpl(args);
var defaultModeName = "$default";
var partCounter = 0;
var PartImpl = class {
  constructor({ feature, params, modeParams = {}, css, cssImports }) {
    this.feature = feature;
    this.css = css;
    this.cssImports = cssImports;
    this.modeParams = {
      // NOTE: it's important that default is defined first, putting it
      // first in iteration order, because when merging params the default
      // params override any prior modal params, so modal params in this
      // part need to come after default params to prevent them from being
      // immediately overridden.
      [defaultModeName]: {
        ...modeParams[defaultModeName] ?? {},
        ...params ?? {}
      },
      ...modeParams
    };
  }
  use(container) {
    let inject = this._inject;
    if (inject == null) {
      let { css } = this;
      if (css) {
        const className = `ag-theme-${this.feature ?? "part"}-${++partCounter}`;
        if (typeof css === "function")
          css = css();
        css = `:where(.${className}) {
${css}
}
`;
        for (const cssImport of this.cssImports ?? []) {
          css = `@import url(${JSON.stringify(cssImport)});
${css}`;
        }
        inject = { css, class: className };
      } else {
        inject = false;
      }
      this._inject = inject;
    }
    if (inject && container) {
      _injectGlobalCSS(inject.css, container, inject.class);
    }
    return inject ? inject.class : false;
  }
};

// packages/ag-grid-community/src/theming/theme-utils.ts
var kebabCase = (str) => str.replace(/[A-Z]/g, (m) => `-${m}`).toLowerCase();
var paramToVariableName = (paramName) => `--ag-${kebabCase(paramName)}`;
var paramToVariableExpression = (paramName) => `var(${paramToVariableName(paramName)})`;
var clamp = (value, min, max) => Math.max(min, Math.min(max, value));
var memoize = (fn) => {
  const values = /* @__PURE__ */ new Map();
  return (a) => {
    const key = a;
    if (!values.has(key)) {
      values.set(key, fn(a));
    }
    return values.get(key);
  };
};
var accentMix = (mix) => ({ ref: "accentColor", mix });
var foregroundMix = (mix) => ({ ref: "foregroundColor", mix });
var foregroundBackgroundMix = (mix) => ({
  ref: "foregroundColor",
  mix,
  onto: "backgroundColor"
});
var foregroundColor = { ref: "foregroundColor" };
var accentColor = { ref: "accentColor" };

// packages/ag-grid-community/src/theming/core/core-css.ts
var defaultLightColorSchemeParams = {
  backgroundColor: "#fff",
  foregroundColor: "#181d1f",
  borderColor: foregroundMix(0.15),
  chromeBackgroundColor: foregroundBackgroundMix(0.02),
  browserColorScheme: "light"
};
var coreDefaults = {
  ...defaultLightColorSchemeParams,
  textColor: foregroundColor,
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  wrapperBorder: true,
  rowBorder: true,
  headerRowBorder: true,
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: false,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: true,
  pinnedRowBorder: true,
  sidePanelBorder: true,
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  sideButtonBarBackgroundColor: {
    ref: "sideBarBackgroundColor"
  },
  sideButtonBarTopPadding: 0,
  sideButtonSelectedUnderlineWidth: 2,
  sideButtonSelectedUnderlineColor: "transparent",
  sideButtonSelectedUnderlineTransitionDuration: 0,
  sideButtonBackgroundColor: "transparent",
  sideButtonTextColor: { ref: "textColor" },
  sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
  sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBackgroundColor: { ref: "backgroundColor" },
  sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBorder: true,
  sideButtonLeftPadding: { ref: "spacing" },
  sideButtonRightPadding: { ref: "spacing" },
  sideButtonVerticalPadding: { calc: "spacing * 3" },
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  cellFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "headerCellHoverBackgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: accentColor,
  rangeSelectionBackgroundColor: accentMix(0.2),
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: accentMix(0.5),
  rowHoverColor: accentMix(0.08),
  columnHoverColor: accentMix(0.05),
  selectedRowBackgroundColor: accentMix(0.12),
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: {
    ref: "backgroundColor"
  },
  borderRadius: 4,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  spacing: 8,
  fontSize: 14,
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  popupShadow: "0 0 16px #00000026",
  cardShadow: "0 1px 4px 1px #00000018",
  dropdownShadow: { ref: "cardShadow" },
  dragAndDropImageBackgroundColor: {
    ref: "backgroundColor"
  },
  dragAndDropImageBorder: true,
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  dragHandleColor: foregroundMix(0.7),
  focusShadow: {
    spread: 3,
    color: accentMix(0.5)
  },
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  listItemHeight: {
    calc: "iconSize + widgetVerticalSpacing"
  },
  iconSize: 16,
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonOnBackgroundColor: accentColor,
  toggleButtonOffBackgroundColor: foregroundBackgroundMix(0.3),
  toggleButtonSwitchBackgroundColor: {
    ref: "backgroundColor"
  },
  toggleButtonSwitchInset: 2,
  menuBorder: {
    color: foregroundMix(0.2)
  },
  menuBackgroundColor: foregroundBackgroundMix(0.03),
  menuTextColor: foregroundBackgroundMix(0.95),
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: foregroundMix(0.8),
  iconButtonHoverColor: foregroundMix(0.1),
  dialogShadow: {
    ref: "popupShadow"
  },
  cellEditingBorder: {
    color: accentColor
  },
  cellEditingShadow: { ref: "cardShadow" },
  dialogBorder: {
    color: foregroundMix(0.2)
  },
  panelBackgroundColor: {
    ref: "backgroundColor"
  },
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarBorder: true,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: true,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipBorder: true,
  columnDropCellBackgroundColor: foregroundMix(0.07),
  columnDropCellTextColor: {
    ref: "textColor"
  },
  columnDropCellDragHandleColor: {
    ref: "textColor"
  },
  columnDropCellBorder: {
    color: foregroundMix(0.13)
  },
  selectCellBackgroundColor: foregroundMix(0.07),
  selectCellBorder: {
    color: foregroundMix(0.13)
  },
  advancedFilterBuilderButtonBarBorder: true,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  iconButtonHoverBackgroundColor: foregroundMix(0.1),
  rowLoadingSkeletonEffectColor: foregroundMix(0.15)
};

// packages/ag-grid-community/src/theming/theme-types.ts
var paramTypes = [
  "colorScheme",
  "color",
  "length",
  "scale",
  "borderStyle",
  "border",
  "shadow",
  "image",
  "fontFamily",
  "fontWeight",
  "duration"
];
var getParamType = memoize((param) => {
  param = param.toLowerCase();
  return paramTypes.find((type) => param.endsWith(type.toLowerCase())) ?? "length";
});
var literalToCSS = (value) => {
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return String(value);
  return false;
};
var colorValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value && "ref" in value) {
    const colorExpr = paramToVariableExpression(value.ref);
    if (value.mix == null) {
      return colorExpr;
    }
    const backgroundExpr = value.onto ? paramToVariableExpression(value.onto) : "transparent";
    return `color-mix(in srgb, ${backgroundExpr}, ${colorExpr} ${clamp(value.mix * 100, 0, 100)}%)`;
  }
  return false;
};
var colorSchemeValueToCss = literalToCSS;
var lengthValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return `${value}px`;
  if (value && "calc" in value) {
    const valueWithSpaces = value.calc.replace(/ ?[*/+] ?/g, " $& ");
    return `calc(${valueWithSpaces.replace(/-?[a-z][a-z0-9]*\b(?![-(])/gi, (p) => p[0] === "-" ? p : ` ${paramToVariableExpression(p)} `)})`;
  }
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var scaleValueToCss = literalToCSS;
var borderValueToCss = (value, param) => {
  if (typeof value === "string")
    return value;
  if (value === true)
    return "solid 1px var(--ag-border-color)";
  if (value === false)
    return param === "columnBorder" ? "solid 1px transparent" : "none";
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return borderStyleValueToCss(value.style ?? "solid") + " " + lengthValueToCss(value.width ?? 1) + " " + colorValueToCss(value.color ?? { ref: "borderColor" });
};
var shadowValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value === false)
    return "none";
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return [
    lengthValueToCss(value.offsetX ?? 0),
    lengthValueToCss(value.offsetY ?? 0),
    lengthValueToCss(value.radius ?? 0),
    lengthValueToCss(value.spread ?? 0),
    colorValueToCss(value.color ?? { ref: "foregroundColor" })
  ].join(" ");
};
var borderStyleValueToCss = literalToCSS;
var fontFamilyValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value && "googleFont" in value)
    return fontFamilyValueToCss(value.googleFont);
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  if (Array.isArray(value)) {
    return value.map((font) => {
      if (typeof font === "object" && "googleFont" in font) {
        font = font.googleFont;
      }
      return quoteUnsafeChars(font);
    }).join(", ");
  }
  return false;
};
var quoteUnsafeChars = (font) => (
  // don't quote var() expressions or quote safe identifier names, so that
  // people can specify fonts like sans-serif which are keywords not strings,
  // or var(--my-var)
  /^[\w-]+$|\w\(/.test(font) ? font : JSON.stringify(font)
);
var fontWeightValueToCss = literalToCSS;
var imageValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value && "url" in value)
    return `url(${JSON.stringify(value.url)})`;
  if (value && "svg" in value)
    return imageValueToCss({ url: `data:image/svg+xml,${encodeURIComponent(value.svg)}` });
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var durationValueToCss = (value, param) => {
  if (typeof value === "string")
    return value;
  if (typeof value === "number") {
    if (value >= 10) {
      _error(104, { value, param });
    }
    return `${value}s`;
  }
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var paramValidators = {
  color: colorValueToCss,
  colorScheme: colorSchemeValueToCss,
  length: lengthValueToCss,
  scale: scaleValueToCss,
  border: borderValueToCss,
  borderStyle: borderStyleValueToCss,
  shadow: shadowValueToCss,
  image: imageValueToCss,
  fontFamily: fontFamilyValueToCss,
  fontWeight: fontWeightValueToCss,
  duration: durationValueToCss
};
var paramValueToCss = (param, value) => {
  const type = getParamType(param);
  return paramValidators[type](value, param);
};

// packages/ag-grid-community/src/theming/Theme.ts
var _asThemeImpl = (theme) => {
  if (!(theme instanceof ThemeImpl)) {
    throw new Error("theme is not an object created by createTheme");
  }
  return theme;
};
var createTheme = () => new ThemeImpl();
var ThemeImpl = class _ThemeImpl {
  constructor(parts = []) {
    this.parts = parts;
  }
  withPart(part) {
    if (typeof part === "function")
      part = part();
    if (!(part instanceof PartImpl)) {
      _logPreInitErr(259, { part }, "Invalid part");
      return this;
    }
    return new _ThemeImpl([...this.parts, part]);
  }
  withoutPart(feature) {
    return this.withPart(createPart({ feature }));
  }
  withParams(params, mode = defaultModeName) {
    return this.withPart(
      createPart({
        modeParams: { [mode]: params }
      })
    );
  }
  /**
   * Called by a grid instance when it starts using the theme. This installs
   * the theme's parts into document head, or the shadow DOM if the provided
   * container is within a shadow root.
   */
  _startUse({ container, loadThemeGoogleFonts }) {
    if (IS_SSR)
      return;
    uninstallLegacyCSS();
    _injectCoreAndModuleCSS(container);
    const googleFontsUsed = getGoogleFontsUsed(this);
    if (googleFontsUsed.length > 0) {
      for (const googleFont of googleFontsUsed) {
        if (loadThemeGoogleFonts) {
          loadGoogleFont(googleFont);
        }
      }
    }
    for (const part of this.parts) {
      part.use(container);
    }
  }
  /**
   * Return CSS that that applies the params of this theme to elements with
   * the provided class name
   */
  _getCssClass() {
    return this._cssClassCache ?? (this._cssClassCache = deduplicatePartsByFeature(this.parts).map((part) => part.use()).filter(Boolean).join(" "));
  }
  _getModeParams() {
    let paramsCache = this._paramsCache;
    if (!paramsCache) {
      const mergedModeParams = {
        // NOTE: defining the default mode here is important, it ensures
        // that the default mode is first in iteration order, which puts
        // it first in outputted CSS, allowing other modes to override it
        [defaultModeName]: { ...coreDefaults }
      };
      for (const part of deduplicatePartsByFeature(this.parts)) {
        for (const [partMode, partParams] of Object.entries(part.modeParams)) {
          if (partParams) {
            const mergedParams = mergedModeParams[partMode] ?? (mergedModeParams[partMode] = {});
            const partParamNames = /* @__PURE__ */ new Set();
            for (const [partParamName, partParamValue] of Object.entries(partParams)) {
              if (partParamValue !== void 0) {
                mergedParams[partParamName] = partParamValue;
                partParamNames.add(partParamName);
              }
            }
            if (partMode === defaultModeName) {
              for (const [mergedMode, mergedParams2] of Object.entries(mergedModeParams)) {
                if (mergedMode !== defaultModeName) {
                  for (const partParamName of partParamNames) {
                    delete mergedParams2[partParamName];
                  }
                }
              }
            }
          }
        }
      }
      this._paramsCache = paramsCache = mergedModeParams;
    }
    return paramsCache;
  }
  /**
   * Return the CSS chunk that is inserted into the grid DOM, and will
   * therefore be removed automatically when the grid is destroyed or it
   * starts to use a new theme.
   *
   * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
   */
  _getPerGridCss(className) {
    const selectorPlaceholder = "##SELECTOR##";
    let innerParamsCss = this._paramsCssCache;
    if (!innerParamsCss) {
      let variablesCss = "";
      let inheritanceCss = "";
      for (const [mode, params] of Object.entries(this._getModeParams())) {
        if (mode !== defaultModeName) {
          const escapedMode = typeof CSS === "object" ? CSS.escape(mode) : mode;
          const wrapPrefix = `:where([data-ag-theme-mode="${escapedMode}"]) & {
`;
          variablesCss += wrapPrefix;
          inheritanceCss += wrapPrefix;
        }
        for (const [key, value] of Object.entries(params)) {
          const cssValue = paramValueToCss(key, value);
          if (cssValue === false) {
            _error(107, { key, value });
          } else {
            const cssName = paramToVariableName(key);
            const inheritedName = cssName.replace("--ag-", "--ag-inherited-");
            variablesCss += `	${cssName}: var(${inheritedName}, ${cssValue});
`;
            inheritanceCss += `	${inheritedName}: var(${cssName});
`;
          }
        }
        if (mode !== defaultModeName) {
          variablesCss += "}\n";
          inheritanceCss += "}\n";
        }
      }
      let css = `${selectorPlaceholder} {
${variablesCss}}
`;
      css += `:has(> ${selectorPlaceholder}):not(${selectorPlaceholder}) {
${inheritanceCss}}
`;
      this._paramsCssCache = innerParamsCss = css;
    }
    return innerParamsCss.replaceAll(selectorPlaceholder, `:where(.${className})`);
  }
};
var deduplicatePartsByFeature = (parts) => {
  const lastPartByFeature = /* @__PURE__ */ new Map();
  for (const part of parts) {
    lastPartByFeature.set(part.feature, part);
  }
  const result = [];
  for (const part of parts) {
    if (!part.feature || lastPartByFeature.get(part.feature) === part) {
      result.push(part);
    }
  }
  return result;
};
var getGoogleFontsUsed = (theme) => {
  const googleFontsUsed = /* @__PURE__ */ new Set();
  const visitParamValue = (paramValue) => {
    if (Array.isArray(paramValue)) {
      paramValue.forEach(visitParamValue);
    } else {
      const googleFont = paramValue?.googleFont;
      if (typeof googleFont === "string") {
        googleFontsUsed.add(googleFont);
      }
    }
  };
  const allModeValues = Object.values(theme._getModeParams());
  const allValues = allModeValues.flatMap((mv) => Object.values(mv));
  allValues.forEach(visitParamValue);
  return Array.from(googleFontsUsed).sort();
};
var uninstalledLegacyCSS = false;
var uninstallLegacyCSS = () => {
  if (uninstalledLegacyCSS)
    return;
  uninstalledLegacyCSS = true;
  for (const style of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]'))) {
    style.remove();
  }
};
var googleFontsLoaded = /* @__PURE__ */ new Set();
var loadGoogleFont = async (font) => {
  googleFontsLoaded.add(font);
  const css = `@import url('https://${googleFontsDomain}/css2?family=${encodeURIComponent(font)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  _injectGlobalCSS(css, document.head, `googleFont:${font}`);
};
var googleFontsDomain = "fonts.googleapis.com";

// packages/ag-grid-community/src/theming/parts/checkbox-style/checkbox-style-default.css-GENERATED.ts
var checkboxStyleDefaultCSS = (
  /*css*/
  `.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}`
);

// packages/ag-grid-community/src/theming/parts/checkbox-style/checkbox-styles.ts
var checkboxStyleDefault = createPart({
  feature: "checkboxStyle",
  params: {
    checkboxBorderWidth: 1,
    checkboxBorderRadius: {
      ref: "borderRadius"
    },
    checkboxUncheckedBackgroundColor: {
      ref: "backgroundColor"
    },
    checkboxUncheckedBorderColor: foregroundBackgroundMix(0.3),
    checkboxCheckedBackgroundColor: accentColor,
    checkboxCheckedBorderColor: accentColor,
    checkboxCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
    },
    checkboxCheckedShapeColor: {
      ref: "backgroundColor"
    },
    checkboxIndeterminateBackgroundColor: foregroundBackgroundMix(0.3),
    checkboxIndeterminateBorderColor: foregroundBackgroundMix(0.3),
    checkboxIndeterminateShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
    },
    checkboxIndeterminateShapeColor: {
      ref: "backgroundColor"
    },
    radioCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
    }
  },
  css: checkboxStyleDefaultCSS
});

// packages/ag-grid-community/src/theming/parts/color-scheme/color-schemes.ts
var colorSchemeLight = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: defaultLightColorSchemeParams
});
var colorSchemeLightWarm = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: {
    ...defaultLightColorSchemeParams,
    foregroundColor: "#000000de",
    borderColor: "#60300026",
    chromeBackgroundColor: "#60300005"
  }
});
var colorSchemeLightCold = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: {
    ...defaultLightColorSchemeParams,
    foregroundColor: "#000",
    chromeBackgroundColor: "#f3f8f8"
  }
});
var darkParams = {
  ...defaultLightColorSchemeParams,
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: foregroundBackgroundMix(0.05),
  rowHoverColor: accentMix(0.15),
  selectedRowBackgroundColor: accentMix(0.2),
  menuBackgroundColor: foregroundBackgroundMix(0.1),
  browserColorScheme: "dark",
  popupShadow: "0 0px 20px #000A",
  cardShadow: "0 1px 4px 1px #000A",
  advancedFilterBuilderJoinPillColor: "#7a3a37",
  advancedFilterBuilderColumnPillColor: "#355f2d",
  advancedFilterBuilderOptionPillColor: "#5a3168",
  advancedFilterBuilderValuePillColor: "#374c86",
  checkboxUncheckedBorderColor: foregroundBackgroundMix(0.4),
  toggleButtonOffBackgroundColor: foregroundBackgroundMix(0.4)
};
var colorSchemeDark = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: darkParams
});
var colorSchemeDarkWarm = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: {
    backgroundColor: "hsl(29, 10%, 17%)",
    foregroundColor: "#FFF",
    browserColorScheme: "dark"
  }
});
var darkBlueParams = {
  ...darkParams,
  backgroundColor: "#1f2836"
};
var colorSchemeDarkBlue = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: darkBlueParams
});
var colorSchemeVariable = /* @__PURE__ */ createPart({
  feature: "colorScheme",
  params: defaultLightColorSchemeParams,
  modeParams: {
    light: defaultLightColorSchemeParams,
    dark: darkParams,
    "dark-blue": darkBlueParams
  }
});

// packages/ag-grid-community/src/theming/parts/icon-set/shared-icon-styles.css-GENERATED.ts
var sharedIconStylesCSS = (
  /*css*/
  `:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}`
);

// packages/ag-grid-community/src/theming/parts/icon-set/alpine/icon-set-alpine.css-GENERATED.ts
var iconSetAlpineCSS = (
  /*css*/
  `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}`
);

// packages/ag-grid-community/src/theming/parts/icon-set/alpine/icon-set-alpine.ts
var iconSetAlpine = /* @__PURE__ */ createPart({
  feature: "iconSet",
  css: () => sharedIconStylesCSS + iconSetAlpineCSS
});

// packages/ag-grid-community/src/theming/parts/icon-set/material/icon-set-material.css-GENERATED.ts
var iconSetMaterialCSS = (
  /*css*/
  `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eaggregation%3C/title%3E%3Cpath d='M24 5.333H8V8l8.667 8L8 24v2.667h16v-4h-9.333L21.334 16l-6.667-6.667H24z'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Earrows%3C/title%3E%3Cpath d='M13.333 11.556h5.333V8h3.556L16 1.778 9.778 8h3.556zm-1.777 1.777H8V9.777l-6.222 6.222L8 22.221v-3.556h3.556zM30.222 16 24 9.778v3.556h-3.556v5.333H24v3.556l6.222-6.222zm-11.555 4.444h-5.333V24H9.778L16 30.222 22.222 24h-3.556z'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333z'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecancel%3C/title%3E%3Cpath d='M16 2.667C8.627 2.667 2.667 8.627 2.667 16S8.627 29.333 16 29.333 29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cpath d='M6.667 12.267h4v13.067h-4zm7.466-5.6h3.733v18.667h-3.733zM21.6 17.333h3.733v8H21.6z'/%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolor-picker%3C/title%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387H7.361zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolumns%3C/title%3E%3Cpath d='M5.333 10.667h5.333V5.334H5.333zm8 16h5.333v-5.333h-5.333zm-8 0h5.333v-5.333H5.333zm0-8h5.333v-5.333H5.333zm8 0h5.333v-5.333h-5.333zm8-13.334v5.333h5.333V5.333zm-8 5.334h5.333V5.334h-5.333zm8 8h5.333v-5.333h-5.333zm0 8h5.333v-5.333h-5.333z'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Econtracted%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecopy%3C/title%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecross%3C/title%3E%3Cpath d='m25.333 8.547-1.88-1.88L16 14.12 8.547 6.667l-1.88 1.88L14.12 16l-7.453 7.453 1.88 1.88L16 17.88l7.453 7.453 1.88-1.88L17.88 16z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m19 3-6 6 2 2 7-7V3m-10 9.5a.503.503 0 0 1-.5-.5c0-.274.226-.5.5-.5s.5.226.5.5-.226.5-.5.5M6 20c-1.097 0-2-.903-2-2a2 2 0 0 1 2-2c1.097 0 2 .903 2 2a2 2 0 0 1-2 2M6 8c-1.097 0-2-.903-2-2a2 2 0 0 1 2-2c1.097 0 2 .903 2 2a2 2 0 0 1-2 2m3.64-.36c.23-.5.36-1.05.36-1.64 0-2.194-1.806-4-4-4S2 3.806 2 6s1.806 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.194 0-4 1.806-4 4s1.806 4 4 4 4-1.806 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1z' style='fill-rule:nonzero' transform='translate(4 4)'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Edesc%3C/title%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667L26.668 16z'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eexpanded%3C/title%3E%3Cpath d='M20.94 9.88 19.06 8l-8 8 8 8 1.88-1.88L14.833 16z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath d='M21.106 15.088A5.19 5.19 0 0 0 16 10.814a5.17 5.17 0 0 0-3.668 1.522L9.866 9.868a12.2 12.2 0 0 1 6.133-1.646c5.186 0 9.614 3.225 11.408 7.778a12.34 12.34 0 0 1-5.276 6.133l-2.468-2.466a5.17 5.17 0 0 0 1.449-2.802h-2.123c-.148.508-.42.964-.782 1.33l-1.33-1.33h-2.514l2.196 2.196q-.272.049-.56.05a3.11 3.11 0 0 1-2.99-2.245h-2.123a5.19 5.19 0 0 0 7.3 3.836l2.247 2.247a12.2 12.2 0 0 1-4.434.828c-5.186 0-9.614-3.225-11.408-7.778a12.3 12.3 0 0 1 3.781-5.111l2.924 2.924a5.1 5.1 0 0 0-.404 1.275h4.206l-1.296-1.296a3.1 3.1 0 0 1 2.196-.903c1.404 0 2.587.924 2.976 2.199h2.13z'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye%3C/title%3E%3Cpath d='M16 8.222c-5.186 0-9.614 3.225-11.408 7.778 1.794 4.553 6.222 7.778 11.408 7.778S25.614 20.553 27.408 16C25.614 11.447 21.186 8.222 16 8.222m0 12.964c-2.862 0-5.186-2.324-5.186-5.186s2.324-5.186 5.186-5.186 5.186 2.324 5.186 5.186-2.324 5.186-5.186 5.186m0-8.297c-1.721 0-3.111 1.39-3.111 3.111s1.39 3.111 3.111 3.111 3.111-1.39 3.111-3.111-1.39-3.111-3.111-3.111'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efilter%3C/title%3E%3Cpath d='M13.333 24h5.333v-2.667h-5.333zM4 8v2.667h24V8zm4 9.333h16v-2.667H8z'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efirst%3C/title%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egroup%3C/title%3E%3Cpath d='M18.667 21.333h8.889A3.555 3.555 0 0 1 24 24.889h-5.333zm8.888-7.111v3.556h-8.889v-3.556zM24 7.111a3.555 3.555 0 0 1 3.556 3.556h-16V7.111zm-8.889 17.778h-3.556v-3.556h3.556zm0-7.111h-3.556v-3.556h3.556zM8 10.667H4.444A3.555 3.555 0 0 1 8 7.111z'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elast%3C/title%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eleft%3C/title%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227v-2.667z'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elinked%3C/title%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333c-3.68 0-6.667 2.987-6.667 6.667s2.987 6.667 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333c2.28 0 4.133 1.853 4.133 4.133s-1.853 4.133-4.133 4.133h-5.333v2.533h5.333c3.68 0 6.667-2.987 6.667-6.667s-2.987-6.667-6.667-6.667z'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eloading%3C/title%3E%3Cpath d='m17.778 11.708 3.25-3.251 2.516 2.516-3.251 3.25h4.597v3.556h-4.597l3.251 3.25-2.516 2.516-3.25-3.251v4.597h-3.556v-4.597l-3.25 3.251-2.516-2.516 3.251-3.25H7.11v-3.556h4.597l-3.251-3.25 2.516-2.516 3.25 3.251V7.111h3.556zm-3.251 7.847h2.944l2.084-2.084v-2.944l-2.084-2.084h-2.944l-2.084 2.084v2.944z'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Emaximize%3C/title%3E%3Cpath d='M4 4h24v2.667H4z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Emenu%3C/title%3E%3Cpath d='M4 24h24v-2.667H4zm0-6.667h24v-2.667H4zM4 8v2.667h24V8z'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 26.667a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 24q0-1.1.784-1.883A2.57 2.57 0 0 1 16 21.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784m0-8a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 16q0-1.1.784-1.883A2.57 2.57 0 0 1 16 13.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784m0-8a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 8q0-1.1.784-1.883A2.57 2.57 0 0 1 16 5.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eminimize%3C/title%3E%3Cpath d='M8 25.333h16V28H8z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enext%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cpath d='M4 24h16v-2.667H4zM4 8v2.667h24V8zm0 9.333h24v-2.667H4z'/%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enot-allowed%3C/title%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epaste%3C/title%3E%3Cpath d='M25.333 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4zM16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epin%3C/title%3E%3Cpath d='m11.106 22.093-4.444 4.444-1.259-1.259 4.444-4.444zm5.872-16.63 9.618 9.62-.962.962-.962-.962-7.694 3.847 1.924 1.924-2.74 2.74-7.696-7.696 2.741-2.74 1.924 1.925 3.847-7.696-.962-.962z'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epivot%3C/title%3E%3Cpath d='M26.667 30.223H5.334a3.556 3.556 0 0 1-3.556-3.556V5.334a3.556 3.556 0 0 1 3.556-3.556h21.333a3.556 3.556 0 0 1 3.556 3.556v21.333a3.556 3.556 0 0 1-3.556 3.556m-16-8.89H5.334v5.333h5.333zm16-7.11H12.444v12.444h14.223zm-9.15 6.85-2.039 2.037 2.039 2.039-1.257 1.257-3.295-3.296 3.295-3.295q.63.628 1.257 1.257zm-6.85-6.85H5.334v5.333h5.333zm15.74 3.816-1.257 1.256-2.039-2.037-2.037 2.037-1.257-1.256 3.295-3.296zM10.667 5.333H5.334v5.333h5.333zm8.889 0h-7.112v5.333h7.112zm7.111 0h-5.333v5.333h5.333z'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eprevious%3C/title%3E%3Cpath d='M20.94 9.88 19.06 8l-8 8 8 8 1.88-1.88L14.833 16z'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eright%3C/title%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esave%3C/title%3E%3Cpath d='M25.333 16v9.333H6.666V16H3.999v9.333C3.999 26.8 5.199 28 6.666 28h18.667C26.8 28 28 26.8 28 25.333V16zm-8 .893 3.453-3.44 1.88 1.88L15.999 22l-6.667-6.667 1.88-1.88 3.453 3.44V4h2.667v12.893z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-down%3C/title%3E%3Cpath d='M9.333 12.667 16 19.334l6.667-6.667H9.334z'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-left%3C/title%3E%3Cpath d='M19.333 9.333 12.666 16l6.667 6.667V9.334z'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-right%3C/title%3E%3Cpath d='M12.667 22.667 19.334 16l-6.667-6.667v13.333z'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-up%3C/title%3E%3Cpath d='M9.333 19.333 16 12.666l6.667 6.667H9.334z'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etick%3C/title%3E%3Cpath d='m11.727 21.167-5.56-5.56-1.893 1.88 7.453 7.453 16-16-1.88-1.88z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-closed%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-indeterminate%3C/title%3E%3Cpath d='M6.667 14.667h18.667v2.667H6.667z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-open%3C/title%3E%3Cpath d='M22.12 11.06 16 17.167 9.88 11.06 8 12.94l8 8 8-8z'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eunlinked%3C/title%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333z'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egrip%3C/title%3E%3Cpath d='M26.667 12H5.334v2.667h21.333zM5.333 20h21.333v-2.667H5.333z'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}`
);

// packages/ag-grid-community/src/theming/parts/icon-set/material/icon-set-material.ts
var iconSetMaterial = /* @__PURE__ */ createPart({
  feature: "iconSet",
  css: () => sharedIconStylesCSS + iconSetMaterialCSS
});

// packages/ag-grid-community/src/theming/parts/icon-set/overrides/icon-overrides.ts
var iconOverrides = (args) => {
  const cssParts = [sharedIconStylesCSS];
  if (args.type === "image") {
    const { icons, mask } = args;
    for (const [key, value] of Object.entries(icons)) {
      const imageCssValue = imageValueToCss(value);
      if (mask) {
        cssParts.push(`.ag-icon-${key}::before { mask-image: ${imageCssValue}; }`);
      } else {
        cssParts.push(`.ag-icon-${key}::before { background-image: ${imageCssValue}; ${unsetMaskIcon} }`);
      }
    }
  }
  if (args.type === "font") {
    const { family, weight, color, icons } = args;
    let properties = unsetMaskIcon;
    if (family) {
      properties += ` font-family: ${fontFamilyValueToCss(family)};`;
    }
    if (weight) {
      properties += ` font-weight: ${fontWeightValueToCss(weight)};`;
    }
    if (color) {
      properties += ` color: ${colorValueToCss(color)};`;
    }
    for (const [key, value] of Object.entries(icons)) {
      cssParts.push(`.ag-icon-${key}::before { content: ${JSON.stringify(value)}; ${properties} }`);
    }
  }
  return createPart({
    css: cssParts.join(";\n"),
    cssImports: args.cssImports
  });
};
var unsetMaskIcon = `background-color: unset; mask-image: unset; -webkit-mask-image: unset;`;

// packages/ag-grid-community/src/theming/parts/icon-set/quartz/quartz-icon-data.ts
var iconNameToSvgFragment = {
  aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
  arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
  asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
  chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
  "color-picker": '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
  columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
  contracted: '<path d="m9 18 6-6-6-6"/>',
  copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
  cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
  csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
  desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  expanded: '<path d="m15 18-6-6 6-6"/>',
  "eye-slash": '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
  eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
  filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
  first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
  group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
  last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
  left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
  linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
  loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
  maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
  menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
  "menu-alt": '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
  minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
  minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
  next: '<path d="m9 18 6-6-6-6"/>',
  none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
  "not-allowed": '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
  paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
  pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
  pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
  plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
  previous: '<path d="m15 18-6-6 6-6"/>',
  right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
  save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
  "small-left": '<path d="m15 18-6-6 6-6"/>',
  "small-right": '<path d="m9 18 6-6-6-6"/>',
  tick: '<path d="M20 6 9 17l-5-5"/>',
  "tree-closed": '<path d="m9 18 6-6-6-6"/>',
  "tree-indeterminate": '<path d="M5 12h14"/>',
  "tree-open": '<path d="m6 9 6 6 6-6"/>',
  unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
  up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/><g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
  settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>'
};
var iconNameToFullSvg = {
  "small-down": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
  "small-up": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>'
};
var getQuartzIconsCss = (args = {}) => {
  let result = sharedIconStylesCSS;
  for (const iconName of [...Object.keys(iconNameToSvgFragment), ...Object.keys(iconNameToFullSvg)]) {
    const iconSvg = quartzIconSvg(iconName, args.strokeWidth);
    result += `.ag-icon-${iconName}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(iconSvg)}'); }
`;
  }
  return result;
};
var quartzIconSvg = (name, strokeWidth = 1.5) => {
  const fullSVG = iconNameToFullSvg[name];
  if (fullSVG)
    return fullSVG;
  const svgFragment = iconNameToSvgFragment[name];
  if (!svgFragment)
    throw new Error(`Missing icon data for ${name}`);
  return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${strokeWidth}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + svgFragment + "</svg>";
};

// packages/ag-grid-community/src/theming/parts/icon-set/quartz/icon-set-quartz.ts
var iconSetQuartz = (args = {}) => {
  return createPart({
    feature: "iconSet",
    css: () => getQuartzIconsCss(args)
  });
};
var iconSetQuartzLight = /* @__PURE__ */ iconSetQuartz({ strokeWidth: 1 });
var iconSetQuartzRegular = /* @__PURE__ */ iconSetQuartz();
var iconSetQuartzBold = /* @__PURE__ */ iconSetQuartz({ strokeWidth: 2 });

// packages/ag-grid-community/src/theming/parts/input-style/input-style-base.css-GENERATED.ts
var inputStyleBaseCSS = (
  /*css*/
  `:where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}:where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) :where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) :where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}`
);

// packages/ag-grid-community/src/theming/parts/input-style/input-style-bordered.css-GENERATED.ts
var inputStyleBorderedCSS = (
  /*css*/
  `:where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){&:focus{box-shadow:var(--ag-focus-shadow)}}`
);

// packages/ag-grid-community/src/theming/parts/input-style/input-style-underlined.css-GENERATED.ts
var inputStyleUnderlinedCSS = (
  /*css*/
  `:where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){border-left:none;border-right:none;border-top:none}`
);

// packages/ag-grid-community/src/theming/parts/input-style/input-styles.ts
var baseParams = {
  inputBackgroundColor: "transparent",
  inputBorder: false,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPlaceholderTextColor: {
    ref: "inputTextColor",
    mix: 0.5
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  },
  inputIconColor: {
    ref: "inputTextColor"
  }
};
var inputStyleBase = createPart({
  feature: "inputStyle",
  params: baseParams,
  css: inputStyleBaseCSS
});
var inputStyleBordered = /* @__PURE__ */ createPart({
  feature: "inputStyle",
  params: {
    ...baseParams,
    inputBackgroundColor: {
      ref: "backgroundColor"
    },
    inputBorder: true,
    inputBorderRadius: {
      ref: "borderRadius"
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: {
      color: accentColor
    },
    inputFocusShadow: {
      ref: "focusShadow"
    },
    inputDisabledBackgroundColor: foregroundBackgroundMix(0.06),
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputInvalidBorder: {
      color: { ref: "invalidColor" }
    }
  },
  css: () => inputStyleBaseCSS + inputStyleBorderedCSS
});
var inputStyleUnderlined = /* @__PURE__ */ createPart({
  feature: "inputStyle",
  params: {
    ...baseParams,
    inputBorder: {
      width: 2,
      color: foregroundMix(0.3)
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: "solid 2px var(--ag-accent-color)",
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputDisabledBorder: "solid 1px var(--ag-border-color)",
    inputInvalidBorder: {
      width: 2,
      color: {
        ref: "invalidColor",
        mix: 0.3
      }
    }
  },
  css: () => inputStyleBaseCSS + inputStyleUnderlinedCSS
});

// packages/ag-grid-community/src/theming/parts/tab-style/tab-style-base.css-GENERATED.ts
var tabStyleBaseCSS = (
  /*css*/
  `.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:1px solid var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}`
);

// packages/ag-grid-community/src/theming/parts/tab-style/tab-style-rolodex.css-GENERATED.ts
var tabStyleRolodexCSS = (
  /*css*/
  `.ag-tab{border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;border-top:var(--ag-tab-selected-border-width) solid transparent;flex:0;&.ag-tab-selected{border-left-color:var(--ag-tab-selected-border-color);border-right-color:var(--ag-tab-selected-border-color);border-top-color:var(--ag-tab-selected-border-color);margin-bottom:-1px;padding-bottom:calc(var(--ag-tab-bottom-padding) + 1px)}}`
);

// packages/ag-grid-community/src/theming/parts/tab-style/tab-styles.ts
var baseParams2 = {
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: 1,
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: 0,
  tabSelectedUnderlineTransitionDuration: 0,
  tabBarBorder: false
};
var tabStyleBase = createPart({
  feature: "tabStyle",
  params: baseParams2,
  css: tabStyleBaseCSS
});
var tabStyleQuartz = /* @__PURE__ */ createPart({
  feature: "tabStyle",
  params: {
    ...baseParams2,
    tabBarBorder: true,
    tabBarBackgroundColor: foregroundMix(0.05),
    tabTextColor: {
      ref: "textColor",
      mix: 0.7
    },
    tabSelectedTextColor: {
      ref: "textColor"
    },
    tabHoverTextColor: {
      ref: "textColor"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: {
      ref: "backgroundColor"
    }
  },
  css: tabStyleBaseCSS
});
var tabStyleMaterial = /* @__PURE__ */ createPart({
  feature: "tabStyle",
  params: {
    ...baseParams2,
    tabBarBackgroundColor: {
      ref: "chromeBackgroundColor"
    },
    tabSelectedUnderlineColor: {
      ref: "primaryColor"
    },
    tabSelectedUnderlineWidth: 2,
    tabSelectedUnderlineTransitionDuration: 0
  },
  css: tabStyleBaseCSS
});
var tabStyleAlpine = /* @__PURE__ */ createPart({
  feature: "tabStyle",
  params: {
    ...baseParams2,
    tabBarBorder: true,
    tabBarBackgroundColor: {
      ref: "chromeBackgroundColor"
    },
    tabHoverTextColor: accentColor,
    tabSelectedTextColor: accentColor,
    tabSelectedUnderlineColor: accentColor,
    tabSelectedUnderlineWidth: 2,
    tabSelectedUnderlineTransitionDuration: "0.3s"
  },
  css: tabStyleBaseCSS
});
var tabStyleRolodex = /* @__PURE__ */ createPart({
  feature: "tabStyle",
  params: {
    ...baseParams2,
    tabBarBackgroundColor: {
      ref: "chromeBackgroundColor"
    },
    tabBarHorizontalPadding: {
      ref: "spacing"
    },
    tabBarTopPadding: {
      ref: "spacing"
    },
    tabBarBorder: true,
    tabHorizontalPadding: { calc: "spacing * 2" },
    tabTopPadding: {
      ref: "spacing"
    },
    tabBottomPadding: {
      ref: "spacing"
    },
    tabSpacing: {
      ref: "spacing"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: {
      ref: "backgroundColor"
    }
  },
  css: () => tabStyleBaseCSS + tabStyleRolodexCSS
});

// packages/ag-grid-community/src/theming/parts/theme/themes.ts
var themeQuartz = /* @__PURE__ */ createTheme().withPart(checkboxStyleDefault).withPart(colorSchemeVariable).withPart(iconSetQuartzRegular).withPart(tabStyleQuartz).withPart(() => inputStyleBordered).withParams({
  fontFamily: [
    { googleFont: "IBM Plex Sans" },
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu"
  ]
});
var themeAlpine = /* @__PURE__ */ createTheme().withPart(checkboxStyleDefault).withPart(colorSchemeVariable).withPart(iconSetAlpine).withPart(tabStyleAlpine).withPart(inputStyleBordered).withParams({
  accentColor: "#2196f3",
  selectedRowBackgroundColor: accentMix(0.3),
  inputFocusBorder: {
    color: accentMix(0.4)
  },
  fontSize: 13,
  dataFontSize: 14,
  headerFontWeight: 700,
  borderRadius: 3,
  wrapperBorderRadius: 3,
  tabSelectedUnderlineColor: accentColor,
  tabSelectedBorderWidth: 2,
  tabSelectedUnderlineTransitionDuration: 0.3
});
var themeBalham = /* @__PURE__ */ createTheme().withPart(checkboxStyleDefault).withPart(colorSchemeVariable).withPart(iconSetAlpine).withPart(tabStyleRolodex).withPart(inputStyleBordered).withParams({
  spacing: 4,
  borderRadius: 2,
  wrapperBorderRadius: 2,
  headerColumnResizeHandleColor: "transparent",
  headerColumnBorder: true,
  headerColumnBorderHeight: "50%",
  oddRowBackgroundColor: {
    ref: "chromeBackgroundColor",
    mix: 0.5
  },
  headerTextColor: foregroundMix(0.5),
  fontSize: 12,
  headerFontWeight: "bold"
});

// packages/ag-grid-community/src/environment.ts
var ROW_HEIGHT = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
};
var HEADER_HEIGHT = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
};
var LIST_ITEM_HEIGHT = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
};
var ROW_BORDER_WIDTH = {
  cssName: "--ag-row-border",
  changeKey: "rowBorderWidthChanged",
  defaultValue: 1,
  border: true
};
var paramsId = 0;
var Environment = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "environment";
    this.sizeEls = /* @__PURE__ */ new Map();
    this.lastKnownValues = /* @__PURE__ */ new Map();
    this.sizesMeasured = false;
    this.paramsClass = `ag-theme-params-${++paramsId}`;
    this.globalCSS = [];
  }
  wireBeans(beans) {
    this.eGridDiv = beans.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange());
    this.handleThemeGridOptionChange();
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable());
    this.getSizeEl(ROW_HEIGHT);
    this.getSizeEl(HEADER_HEIGHT);
    this.getSizeEl(LIST_ITEM_HEIGHT);
    this.getSizeEl(ROW_BORDER_WIDTH);
    this.refreshRowBorderWidthVariable();
    this.addDestroyFunc(() => _unregisterGridUsingThemingAPI(this));
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(ROW_HEIGHT);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(HEADER_HEIGHT);
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(LIST_ITEM_HEIGHT);
  }
  getRowBorderWidth() {
    return this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
  }
  applyThemeClasses(el) {
    const { gridTheme } = this;
    let themeClass = "";
    if (gridTheme) {
      themeClass = `${this.paramsClass} ${gridTheme._getCssClass()}`;
    } else {
      let node = this.eGridDiv;
      while (node) {
        for (const className of Array.from(node.classList)) {
          if (className.startsWith("ag-theme-")) {
            themeClass = themeClass ? `${themeClass} ${className}` : className;
          }
        }
        node = node.parentElement;
      }
    }
    for (const className of Array.from(el.classList)) {
      if (className.startsWith("ag-theme-")) {
        el.classList.remove(className);
      }
    }
    if (themeClass) {
      const oldClass = el.className;
      el.className = oldClass + (oldClass ? " " : "") + themeClass;
    }
  }
  refreshRowHeightVariable() {
    const { eGridDiv } = this;
    const oldRowHeight = eGridDiv.style.getPropertyValue("--ag-line-height").trim();
    const height = this.gos.get("rowHeight");
    if (height == null || isNaN(height) || !isFinite(height)) {
      if (oldRowHeight !== null) {
        eGridDiv.style.setProperty("--ag-line-height", null);
      }
      return -1;
    }
    const newRowHeight = `${height}px`;
    if (oldRowHeight != newRowHeight) {
      eGridDiv.style.setProperty("--ag-line-height", newRowHeight);
      return height;
    }
    return oldRowHeight != "" ? parseFloat(oldRowHeight) : -1;
  }
  addGlobalCSS(css, debugId) {
    if (this.gridTheme) {
      _injectGlobalCSS(css, this.eGridDiv, debugId);
    } else {
      this.globalCSS.push([css, debugId]);
    }
  }
  getCSSVariablePixelValue(variable) {
    const cached = this.lastKnownValues.get(variable);
    if (cached != null) {
      return cached;
    }
    const measurement = this.measureSizeEl(variable);
    if (measurement === "detached" || measurement === "no-styles") {
      return variable.defaultValue;
    }
    this.lastKnownValues.set(variable, measurement);
    return measurement;
  }
  measureSizeEl(variable) {
    const sizeEl = this.getSizeEl(variable);
    if (sizeEl.offsetParent == null) {
      return "detached";
    }
    const newSize = sizeEl.offsetWidth;
    if (newSize === NO_VALUE_SENTINEL)
      return "no-styles";
    this.sizesMeasured = true;
    return newSize;
  }
  getMeasurementContainer() {
    let container = this.eMeasurementContainer;
    if (!container) {
      container = this.eMeasurementContainer = document.createElement("div");
      container.className = "ag-measurement-container";
      this.eGridDiv.appendChild(container);
    }
    return container;
  }
  getSizeEl(variable) {
    let sizeEl = this.sizeEls.get(variable);
    if (sizeEl) {
      return sizeEl;
    }
    const container = this.getMeasurementContainer();
    sizeEl = document.createElement("div");
    const { border } = variable;
    if (border) {
      sizeEl.className = "ag-measurement-element-border";
      sizeEl.style.setProperty(
        "--ag-internal-measurement-border",
        `var(${variable.cssName}, solid ${NO_VALUE_SENTINEL}px`
      );
    } else {
      sizeEl.style.width = `var(${variable.cssName}, ${NO_VALUE_SENTINEL}px)`;
    }
    container.appendChild(sizeEl);
    this.sizeEls.set(variable, sizeEl);
    let lastMeasurement = this.measureSizeEl(variable);
    if (lastMeasurement === "no-styles") {
      _warn(9, { variable });
    }
    const unsubscribe = _observeResize(this.beans, sizeEl, () => {
      const newMeasurement = this.measureSizeEl(variable);
      if (newMeasurement === "detached" || newMeasurement === "no-styles") {
        return;
      }
      this.lastKnownValues.set(variable, newMeasurement);
      if (newMeasurement !== lastMeasurement) {
        lastMeasurement = newMeasurement;
        this.fireGridStylesChangedEvent(variable.changeKey);
      }
    });
    this.addDestroyFunc(() => unsubscribe());
    return sizeEl;
  }
  fireGridStylesChangedEvent(change) {
    if (change === "rowBorderWidthChanged") {
      this.refreshRowBorderWidthVariable();
    }
    this.eventSvc.dispatchEvent({
      type: "gridStylesChanged",
      [change]: true
    });
  }
  refreshRowBorderWidthVariable() {
    const width = this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
    this.eGridDiv.style.setProperty("--ag-internal-row-border-width", `${width}px`);
  }
  handleThemeGridOptionChange() {
    const { gos, eGridDiv, globalCSS, gridTheme: oldGridTheme } = this;
    const themeGridOption = gos.get("theme");
    let newGridTheme;
    if (themeGridOption === "legacy") {
      newGridTheme = void 0;
    } else {
      const themeOrDefault = themeGridOption ?? themeQuartz;
      if (themeOrDefault instanceof ThemeImpl) {
        newGridTheme = themeOrDefault;
      } else {
        _error(240, { theme: themeOrDefault });
      }
    }
    if (newGridTheme !== oldGridTheme) {
      if (newGridTheme) {
        _registerGridUsingThemingAPI(this);
        _injectCoreAndModuleCSS(eGridDiv);
        for (const [css, debugId] of globalCSS) {
          _injectGlobalCSS(css, eGridDiv, debugId);
        }
        globalCSS.length = 0;
      }
      this.gridTheme = newGridTheme;
      newGridTheme?._startUse({
        loadThemeGoogleFonts: gos.get("loadThemeGoogleFonts"),
        container: eGridDiv
      });
      let eParamsStyle = this.eParamsStyle;
      if (!eParamsStyle) {
        eParamsStyle = this.eParamsStyle = document.createElement("style");
        eGridDiv.appendChild(eParamsStyle);
      }
      if (!IS_SSR) {
        eParamsStyle.textContent = newGridTheme?._getPerGridCss(this.paramsClass) || "";
      }
      this.applyThemeClasses(eGridDiv);
      this.fireGridStylesChangedEvent("themeChanged");
    }
    if (newGridTheme && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded")) {
      if (themeGridOption) {
        _error(106);
      } else {
        _error(239);
      }
    }
  }
};
var NO_VALUE_SENTINEL = 15538;

// packages/ag-grid-community/src/eventService.ts
var EventService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "eventSvc";
    this.globalEventService = new LocalEventService();
  }
  postConstruct() {
    const { globalListener, globalSyncListener } = this.beans;
    if (globalListener) {
      this.addGlobalListener(globalListener, true);
    }
    if (globalSyncListener) {
      this.addGlobalListener(globalSyncListener, false);
    }
  }
  addEventListener(eventType, listener, async) {
    this.globalEventService.addEventListener(eventType, listener, async);
  }
  removeEventListener(eventType, listener, async) {
    this.globalEventService.removeEventListener(eventType, listener, async);
  }
  addGlobalListener(listener, async = false) {
    this.globalEventService.addGlobalListener(listener, async);
  }
  removeGlobalListener(listener, async = false) {
    this.globalEventService.removeGlobalListener(listener, async);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(event) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(event));
  }
  dispatchEventOnce(event) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(event));
  }
};

// packages/ag-grid-community/src/navigation/headerNavigationService.ts
function isAnyChildSpanningHeaderHeight(columnGroup) {
  if (!columnGroup) {
    return false;
  }
  return columnGroup.getLeafColumns().some((col) => col.isSpanHeaderHeight());
}
function getHeaderIndexToFocus(column, currentIndex) {
  let nextColumn;
  if (isColumnGroup2(column) && isAnyChildSpanningHeaderHeight(column) && column.isPadding()) {
    const targetColumn = column;
    nextColumn = targetColumn.getLeafColumns()[0];
    let col = nextColumn;
    while (col !== targetColumn) {
      currentIndex++;
      col = col.getParent();
    }
  }
  return {
    column: nextColumn || column,
    headerRowIndex: currentIndex
  };
}
var HeaderNavigationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "headerNavigation";
    this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    const beans = this.beans;
    beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
    const eDocument = _getDocument(beans);
    this.addManagedElementListeners(eDocument, {
      mousedown: () => {
        this.currentHeaderRowWithoutSpan = -1;
      }
    });
  }
  getHeaderPositionForColumn(colKey, floatingFilter) {
    let column;
    const { colModel, colGroupSvc, ctrlsSvc } = this.beans;
    if (typeof colKey === "string") {
      column = colModel.getCol(colKey);
      if (!column) {
        column = colGroupSvc?.getColumnGroup(colKey) ?? null;
      }
    } else {
      column = colKey;
    }
    if (!column) {
      return null;
    }
    const centerHeaderContainer = ctrlsSvc.getHeaderRowContainerCtrl();
    const allCtrls = centerHeaderContainer?.getAllCtrls();
    const isFloatingFilterVisible = _last(allCtrls || []).type === "filter";
    const headerRowCount = getFocusHeaderRowCount(this.beans) - 1;
    let row = -1;
    let col = column;
    while (col) {
      row++;
      col = col.getParent();
    }
    let headerRowIndex = row;
    if (floatingFilter && isFloatingFilterVisible && headerRowIndex === headerRowCount - 1) {
      headerRowIndex++;
    }
    return headerRowIndex === -1 ? null : {
      headerRowIndex,
      column
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(direction, fromHeader, event) {
    const focusSvc = this.beans.focusSvc;
    if (!fromHeader) {
      fromHeader = focusSvc.focusedHeader;
    }
    if (!fromHeader) {
      return false;
    }
    const { headerRowIndex } = fromHeader;
    const column = fromHeader.column;
    const rowLen = getFocusHeaderRowCount(this.beans);
    const isUp = direction === "UP";
    const currentRowType = this.getHeaderRowType(headerRowIndex);
    let {
      headerRowIndex: nextRow,
      column: nextFocusColumn,
      headerRowIndexWithoutSpan
    } = isUp ? getColumnVisibleParent(currentRowType, column, headerRowIndex) : getColumnVisibleChild(currentRowType, column, headerRowIndex);
    let skipColumn = false;
    if (nextRow < 0) {
      nextRow = 0;
      nextFocusColumn = column;
      skipColumn = true;
    }
    if (nextRow >= rowLen) {
      nextRow = -1;
      this.currentHeaderRowWithoutSpan = -1;
    } else if (headerRowIndexWithoutSpan !== void 0) {
      this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
    }
    if (!skipColumn && !nextFocusColumn) {
      return false;
    }
    return focusSvc.focusHeaderPosition({
      headerPosition: { headerRowIndex: nextRow, column: nextFocusColumn },
      allowUserOverride: true,
      event
    });
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(direction, fromTab = false, event) {
    const { focusSvc, gos } = this.beans;
    const focusedHeader = focusSvc.focusedHeader;
    let nextHeader;
    let normalisedDirection;
    if (this.currentHeaderRowWithoutSpan !== -1) {
      focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
    } else {
      this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
    }
    if (direction === "LEFT" !== gos.get("enableRtl")) {
      normalisedDirection = "Before";
      nextHeader = this.findHeader(focusedHeader, normalisedDirection);
    } else {
      normalisedDirection = "After";
      nextHeader = this.findHeader(focusedHeader, normalisedDirection);
    }
    if (nextHeader || !fromTab) {
      return focusSvc.focusHeaderPosition({
        headerPosition: nextHeader,
        direction: normalisedDirection,
        fromTab,
        allowUserOverride: true,
        event
      });
    } else if (fromTab) {
      const userFunc = gos.getCallback("tabToNextHeader");
      if (userFunc) {
        return focusSvc.focusHeaderPositionFromUserFunc({
          userFunc,
          headerPosition: nextHeader,
          direction: normalisedDirection
        });
      }
    }
    return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
  }
  focusNextHeaderRow(focusedHeader, direction, event) {
    const currentIndex = focusedHeader.headerRowIndex;
    let nextPosition = null;
    let nextRowIndex;
    const beans = this.beans;
    if (direction === "Before") {
      if (currentIndex > 0) {
        nextRowIndex = currentIndex - 1;
        this.currentHeaderRowWithoutSpan -= 1;
        nextPosition = this.findColAtEdgeForHeaderRow(nextRowIndex, "end");
      }
    } else {
      nextRowIndex = currentIndex + 1;
      if (this.currentHeaderRowWithoutSpan < getFocusHeaderRowCount(beans)) {
        this.currentHeaderRowWithoutSpan += 1;
      } else {
        this.currentHeaderRowWithoutSpan = -1;
      }
      nextPosition = this.findColAtEdgeForHeaderRow(nextRowIndex, "start");
    }
    if (!nextPosition) {
      return false;
    }
    const { column, headerRowIndex } = getHeaderIndexToFocus(
      nextPosition.column,
      nextPosition?.headerRowIndex
    );
    return beans.focusSvc.focusHeaderPosition({
      headerPosition: { column, headerRowIndex },
      direction,
      fromTab: true,
      allowUserOverride: true,
      event
    });
  }
  scrollToColumn(column, direction = "After") {
    if (column.getPinned()) {
      return;
    }
    let columnToScrollTo;
    if (isColumnGroup2(column)) {
      const columns = column.getDisplayedLeafColumns();
      columnToScrollTo = direction === "Before" ? _last(columns) : columns[0];
    } else {
      columnToScrollTo = column;
    }
    this.gridBodyCon.scrollFeature.ensureColumnVisible(columnToScrollTo);
  }
  findHeader(focusedHeader, direction) {
    let nextColumn;
    let getColMethod;
    const { colGroupSvc, visibleCols } = this.beans;
    if (isColumnGroup2(focusedHeader.column)) {
      nextColumn = colGroupSvc?.getGroupAtDirection(focusedHeader.column, direction) ?? void 0;
    } else {
      getColMethod = `getCol${direction}`;
      nextColumn = visibleCols[getColMethod](focusedHeader.column);
    }
    if (!nextColumn) {
      return;
    }
    const { headerRowIndex } = focusedHeader;
    if (this.getHeaderRowType(headerRowIndex) !== "filter") {
      const columnsInPath = [nextColumn];
      while (nextColumn.getParent()) {
        nextColumn = nextColumn.getParent();
        columnsInPath.push(nextColumn);
      }
      nextColumn = columnsInPath[Math.max(0, columnsInPath.length - 1 - headerRowIndex)];
    }
    const { column, headerRowIndex: indexToFocus } = getHeaderIndexToFocus(nextColumn, headerRowIndex);
    return {
      column,
      headerRowIndex: indexToFocus
    };
  }
  getHeaderRowType(rowIndex) {
    const centerHeaderContainer = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
    if (centerHeaderContainer) {
      return centerHeaderContainer.getRowType(rowIndex);
    }
  }
  findColAtEdgeForHeaderRow(level, position) {
    const { visibleCols, ctrlsSvc, colGroupSvc } = this.beans;
    const displayedColumns = visibleCols.allCols;
    const column = displayedColumns[position === "start" ? 0 : displayedColumns.length - 1];
    if (!column) {
      return;
    }
    const childContainer = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned());
    const type = childContainer?.getRowType(level);
    if (type == "group") {
      const columnGroup = colGroupSvc?.getColGroupAtLevel(column, level);
      return {
        headerRowIndex: level,
        column: columnGroup
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: type == null ? -1 : level,
      column
    };
  }
};
function getColumnVisibleParent(currentRowType, currentColumn, currentIndex) {
  const isFloatingFilter = currentRowType === "filter";
  const isColumn2 = currentRowType === "column";
  let nextFocusColumn = isFloatingFilter ? currentColumn : currentColumn.getParent();
  let nextRow = currentIndex - 1;
  let headerRowIndexWithoutSpan = nextRow;
  if (isColumn2 && isAnyChildSpanningHeaderHeight(currentColumn.getParent())) {
    while (nextFocusColumn && nextFocusColumn.isPadding()) {
      nextFocusColumn = nextFocusColumn.getParent();
      nextRow--;
    }
    headerRowIndexWithoutSpan = nextRow;
    if (nextRow < 0) {
      nextFocusColumn = currentColumn;
      nextRow = currentIndex;
      headerRowIndexWithoutSpan = void 0;
    }
  }
  return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
}
function getColumnVisibleChild(currentRowType, column, currentIndex, direction = "After") {
  let nextFocusColumn = column;
  let nextRow = currentIndex + 1;
  const headerRowIndexWithoutSpan = nextRow;
  if (currentRowType === "group") {
    const leafColumns = column.getDisplayedLeafColumns();
    const leafColumn = direction === "After" ? leafColumns[0] : _last(leafColumns);
    const columnsInTheWay = [];
    let currentColumn = leafColumn;
    while (currentColumn.getParent() !== column) {
      currentColumn = currentColumn.getParent();
      columnsInTheWay.push(currentColumn);
    }
    nextFocusColumn = leafColumn;
    if (leafColumn.isSpanHeaderHeight()) {
      for (let i = columnsInTheWay.length - 1; i >= 0; i--) {
        const colToFocus = columnsInTheWay[i];
        if (!colToFocus.isPadding()) {
          nextFocusColumn = colToFocus;
          break;
        }
        nextRow++;
      }
    } else {
      nextFocusColumn = _last(columnsInTheWay);
      if (!nextFocusColumn) {
        nextFocusColumn = leafColumn;
      }
    }
  }
  return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
}

// packages/ag-grid-community/src/focusService.ts
var FocusService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "focusSvc";
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
    this.visibleCols = beans.visibleCols;
    this.rowRenderer = beans.rowRenderer;
    this.navigation = beans.navigation;
    this.filterManager = beans.filterManager;
    this.overlays = beans.overlays;
  }
  postConstruct() {
    const clearFocusedCellListener = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: clearFocusedCellListener,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: clearFocusedCellListener,
      columnRowGroupChanged: clearFocusedCellListener
    });
    this.addDestroyFunc(_registerKeyboardFocusEvents(this.beans));
  }
  onColumnEverythingChanged() {
    if (!this.focusedCell) {
      return;
    }
    const col = this.focusedCell.column;
    const colFromColumnModel = this.colModel.getCol(col.getId());
    if (col !== colFromColumnModel) {
      this.clearFocusedCell();
    }
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedCell) {
      return null;
    }
    if (this.isDomDataMissingInHierarchy(_getActiveDomElement(this.beans), DOM_DATA_KEY_ROW_CTRL)) {
      return null;
    }
    return this.focusedCell;
  }
  getFocusHeaderToUseAfterRefresh() {
    if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader) {
      return null;
    }
    if (this.isDomDataMissingInHierarchy(_getActiveDomElement(this.beans), DOM_DATA_KEY_HEADER_CTRL)) {
      return null;
    }
    return this.focusedHeader;
  }
  isDomDataMissingInHierarchy(eBrowserCell, key) {
    let ePointer = eBrowserCell;
    while (ePointer) {
      const data = _getDomData(this.gos, ePointer, key);
      if (data) {
        return false;
      }
      ePointer = ePointer.parentNode;
    }
    return true;
  }
  getFocusedCell() {
    return this.focusedCell;
  }
  shouldRestoreFocus(cell) {
    if (this.isCellRestoreFocused(cell)) {
      setTimeout(() => {
        this.restoredFocusedCell = null;
      }, 0);
      return true;
    }
    return false;
  }
  clearRestoreFocus() {
    this.restoredFocusedCell = null;
    this.awaitRestoreFocusedCell = false;
  }
  restoreFocusedCell(cellPosition, setFocusCallback) {
    this.awaitRestoreFocusedCell = true;
    setTimeout(() => {
      if (!this.awaitRestoreFocusedCell) {
        return;
      }
      this.setRestoreFocusedCell(cellPosition);
      setFocusCallback();
    });
  }
  isCellRestoreFocused(cellPosition) {
    if (this.restoredFocusedCell == null) {
      return false;
    }
    return _areCellsEqual(cellPosition, this.restoredFocusedCell);
  }
  setRestoreFocusedCell(cellPosition) {
    if (this.beans.frameworkOverrides.renderingEngine === "react") {
      this.restoredFocusedCell = cellPosition;
    }
  }
  getFocusEventParams(focusedCellPosition) {
    const { rowIndex, rowPinned, column } = focusedCellPosition;
    const params = {
      rowIndex,
      rowPinned,
      column,
      isFullWidthCell: false
    };
    const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
    if (rowCtrl) {
      params.isFullWidthCell = rowCtrl.isFullWidth();
    }
    return params;
  }
  clearFocusedCell() {
    this.restoredFocusedCell = null;
    if (this.focusedCell == null) {
      return;
    }
    const focusEventParams = this.getFocusEventParams(this.focusedCell);
    this.focusedCell = null;
    this.eventSvc.dispatchEvent({
      type: "cellFocusCleared",
      ...focusEventParams
    });
  }
  setFocusedCell(params) {
    const { column, rowIndex, rowPinned, forceBrowserFocus = false, preventScrollOnBrowserFocus = false } = params;
    const gridColumn = this.colModel.getCol(column);
    if (!gridColumn) {
      this.focusedCell = null;
      return;
    }
    this.focusedCell = {
      rowIndex,
      rowPinned: _makeNull(rowPinned),
      column: gridColumn
    };
    this.eventSvc.dispatchEvent({
      type: "cellFocused",
      ...this.getFocusEventParams(this.focusedCell),
      forceBrowserFocus,
      preventScrollOnBrowserFocus
    });
  }
  isCellFocused(cellPosition) {
    if (this.focusedCell == null) {
      return false;
    }
    return _areCellsEqual(cellPosition, this.focusedCell);
  }
  isRowNodeFocused(rowNode) {
    return this.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
  }
  isHeaderWrapperFocused(headerCtrl) {
    if (this.focusedHeader == null) {
      return false;
    }
    const {
      column,
      rowCtrl: { rowIndex: headerRowIndex, pinned }
    } = headerCtrl;
    const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeader;
    return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
  }
  focusHeaderPosition(params) {
    if (_isHeaderFocusSuppressed(this.beans)) {
      return false;
    }
    const { direction, fromTab, allowUserOverride, event, fromCell, rowWithoutSpanValue } = params;
    let { headerPosition } = params;
    if (fromCell && this.filterManager?.isAdvFilterHeaderActive()) {
      return this.focusAdvancedFilter(headerPosition);
    }
    if (allowUserOverride) {
      const currentPosition = this.focusedHeader;
      const headerRowCount = getFocusHeaderRowCount(this.beans);
      if (fromTab) {
        const userFunc = this.gos.getCallback("tabToNextHeader");
        if (userFunc) {
          headerPosition = this.getHeaderPositionFromUserFunc({
            userFunc,
            direction,
            currentPosition,
            headerPosition,
            headerRowCount
          });
        }
      } else {
        const userFunc = this.gos.getCallback("navigateToNextHeader");
        if (userFunc && event) {
          const params2 = {
            key: event.key,
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount,
            event
          };
          headerPosition = userFunc(params2);
        }
      }
    }
    if (!headerPosition) {
      return false;
    }
    return this.focusProvidedHeaderPosition({
      headerPosition,
      direction,
      event,
      fromCell,
      rowWithoutSpanValue
    });
  }
  focusHeaderPositionFromUserFunc(params) {
    if (_isHeaderFocusSuppressed(this.beans)) {
      return false;
    }
    const { userFunc, headerPosition, direction, event } = params;
    const currentPosition = this.focusedHeader;
    const headerRowCount = getFocusHeaderRowCount(this.beans);
    const newHeaderPosition = this.getHeaderPositionFromUserFunc({
      userFunc,
      direction,
      currentPosition,
      headerPosition,
      headerRowCount
    });
    return !!newHeaderPosition && this.focusProvidedHeaderPosition({
      headerPosition: newHeaderPosition,
      direction,
      event
    });
  }
  getHeaderPositionFromUserFunc(params) {
    const { userFunc, direction, currentPosition, headerPosition, headerRowCount } = params;
    const userFuncParams = {
      backwards: direction === "Before",
      previousHeaderPosition: currentPosition,
      nextHeaderPosition: headerPosition,
      headerRowCount
    };
    const userResult = userFunc(userFuncParams);
    if (userResult === true) {
      return currentPosition;
    }
    if (userResult === false) {
      return null;
    }
    return userResult;
  }
  focusProvidedHeaderPosition(params) {
    const { headerPosition, direction, fromCell, rowWithoutSpanValue, event } = params;
    const { column, headerRowIndex } = headerPosition;
    const { filterManager, ctrlsSvc, headerNavigation } = this.beans;
    if (headerRowIndex === -1) {
      if (filterManager?.isAdvFilterHeaderActive()) {
        return this.focusAdvancedFilter(headerPosition);
      }
      return this.focusGridView(column);
    }
    headerNavigation?.scrollToColumn(column, direction);
    const headerRowContainerCtrl = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned());
    const focusSuccess = headerRowContainerCtrl?.focusHeader(headerPosition.headerRowIndex, column, event) || false;
    if (headerNavigation && focusSuccess && (rowWithoutSpanValue != null || fromCell)) {
      headerNavigation.currentHeaderRowWithoutSpan = rowWithoutSpanValue ?? -1;
    }
    return focusSuccess;
  }
  focusFirstHeader() {
    if (this.overlays?.isExclusive() && this.focusOverlay()) {
      return true;
    }
    let firstColumn = this.visibleCols.allCols[0];
    if (!firstColumn) {
      return false;
    }
    const { colGroupSvc } = this.beans;
    if (colGroupSvc && firstColumn.getParent()) {
      firstColumn = colGroupSvc.getColGroupAtLevel(firstColumn, 0);
    }
    const headerPosition = getHeaderIndexToFocus(firstColumn, 0);
    return this.focusHeaderPosition({
      headerPosition,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(event) {
    if (this.overlays?.isExclusive() && this.focusOverlay(true)) {
      return true;
    }
    const headerRowIndex = getFocusHeaderRowCount(this.beans) - 1;
    const column = _last(this.visibleCols.allCols);
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex, column },
      rowWithoutSpanValue: -1,
      event
    });
  }
  focusPreviousFromFirstCell(event) {
    if (this.filterManager?.isAdvFilterHeaderActive()) {
      return this.focusAdvancedFilter(null);
    }
    return this.focusLastHeader(event);
  }
  isAnyCellFocused() {
    return !!this.focusedCell;
  }
  isRowFocused(rowIndex, rowPinnedType) {
    if (this.focusedCell == null) {
      return false;
    }
    return this.focusedCell.rowIndex === rowIndex && this.focusedCell.rowPinned === _makeNull(rowPinnedType);
  }
  focusOverlay(backwards) {
    const overlayGui = this.overlays?.isVisible() && this.overlays.eWrapper?.getGui();
    return !!overlayGui && _focusInto(overlayGui, backwards);
  }
  focusGridView(column, backwards = false, canFocusOverlay = true) {
    if (this.overlays?.isExclusive()) {
      return canFocusOverlay && this.focusOverlay(backwards);
    }
    if (_isCellFocusSuppressed(this.beans)) {
      if (backwards) {
        if (!_isHeaderFocusSuppressed(this.beans)) {
          return this.focusLastHeader();
        }
      }
      if (canFocusOverlay && this.focusOverlay(backwards)) {
        return true;
      }
      return _focusNextGridCoreContainer(this.beans, false);
    }
    const nextRow = backwards ? _getLastRow(this.beans) : _getFirstRow(this.beans);
    if (nextRow) {
      const { rowIndex, rowPinned } = nextRow;
      column ?? (column = this.focusedHeader?.column);
      if (column && rowIndex !== void 0 && rowIndex !== null) {
        this.navigation?.ensureCellVisible({ rowIndex, column, rowPinned });
        if (backwards) {
          const rowCtrl = this.rowRenderer.getRowByPosition(nextRow);
          if (rowCtrl?.isFullWidth() && this.navigation?.tryToFocusFullWidthRow(nextRow, backwards)) {
            return true;
          }
        }
        this.setFocusedCell({
          rowIndex,
          column,
          rowPinned: _makeNull(rowPinned),
          forceBrowserFocus: true
        });
        this.beans.rangeSvc?.setRangeToCell({ rowIndex, rowPinned, column });
        return true;
      }
    }
    if (canFocusOverlay && this.focusOverlay(backwards)) {
      return true;
    }
    if (backwards && this.focusLastHeader()) {
      return true;
    }
    return false;
  }
  focusAdvancedFilter(position) {
    this.advFilterFocusColumn = position?.column;
    return this.beans.advancedFilter?.getCtrl().focusHeaderComp() ?? false;
  }
  focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
    const column = (forceFirstColumn ? void 0 : this.advFilterFocusColumn) ?? this.visibleCols.allCols?.[0];
    if (backwards) {
      return this.focusHeaderPosition({
        headerPosition: {
          column,
          headerRowIndex: getFocusHeaderRowCount(this.beans) - 1
        }
      });
    } else {
      return this.focusGridView(column);
    }
  }
  clearAdvancedFilterColumn() {
    this.advFilterFocusColumn = void 0;
  }
};

// packages/ag-grid-community/src/gridBodyComp/scrollVisibleService.ts
var ScrollVisibleService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "scrollVisibleSvc";
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.colAnimation = beans.colAnimation;
  }
  postConstruct() {
    this.getScrollbarWidth();
    this.addManagedEventListeners({
      displayedColumnsChanged: this.updateScrollVisible.bind(this),
      displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
    });
  }
  updateScrollVisible() {
    const { colAnimation } = this;
    if (colAnimation?.isActive()) {
      colAnimation.executeLaterVMTurn(() => {
        colAnimation.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
      });
    } else {
      this.updateScrollVisibleImpl();
    }
  }
  updateScrollVisibleImpl() {
    const centerRowCtrl = this.ctrlsSvc.get("center");
    if (!centerRowCtrl || this.colAnimation?.isActive()) {
      return;
    }
    const params = {
      horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.verticalScrollShowing
    };
    this.setScrollsVisible(params);
    this.updateScrollGap();
  }
  updateScrollGap() {
    const centerRowCtrl = this.ctrlsSvc.get("center");
    const horizontalGap = centerRowCtrl.hasHorizontalScrollGap();
    const verticalGap = centerRowCtrl.hasVerticalScrollGap();
    const atLeastOneDifferent = this.horizontalScrollGap !== horizontalGap || this.verticalScrollGap !== verticalGap;
    if (atLeastOneDifferent) {
      this.horizontalScrollGap = horizontalGap;
      this.verticalScrollGap = verticalGap;
      this.eventSvc.dispatchEvent({
        type: "scrollGapChanged"
      });
    }
  }
  setScrollsVisible(params) {
    const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing;
    if (atLeastOneDifferent) {
      this.horizontalScrollShowing = params.horizontalScrollShowing;
      this.verticalScrollShowing = params.verticalScrollShowing;
      this.eventSvc.dispatchEvent({
        type: "scrollVisibilityChanged"
      });
    }
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const gridOptionsScrollbarWidth = this.gos.get("scrollbarWidth");
      const useGridOptions = typeof gridOptionsScrollbarWidth === "number" && gridOptionsScrollbarWidth >= 0;
      const scrollbarWidth = useGridOptions ? gridOptionsScrollbarWidth : _getScrollbarWidth();
      if (scrollbarWidth != null) {
        this.scrollbarWidth = scrollbarWidth;
        this.eventSvc.dispatchEvent({
          type: "scrollbarWidthChanged"
        });
      }
    }
    return this.scrollbarWidth;
  }
};

// packages/ag-grid-community/src/gridDestroyService.ts
var GridDestroyService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "gridDestroySvc";
    this.destroyCalled = false;
  }
  destroy() {
    if (this.destroyCalled) {
      return;
    }
    const { stateSvc, ctrlsSvc, context } = this.beans;
    this.eventSvc.dispatchEvent({
      type: "gridPreDestroyed",
      state: stateSvc?.getState() ?? {}
    });
    this.destroyCalled = true;
    ctrlsSvc.get("gridCtrl")?.destroyGridUi();
    context.destroy();
    super.destroy();
  }
};

// packages/ag-grid-community/src/events.ts
var ALWAYS_SYNC_GLOBAL_EVENTS = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]);

// packages/ag-grid-community/src/gridOptionsDefault.ts
var GRID_OPTION_DEFAULTS = {
  suppressContextMenu: false,
  preventDefaultOnContextMenu: false,
  allowContextMenuWithControlKey: false,
  suppressMenuHide: true,
  enableBrowserTooltips: false,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: false,
  tooltipShowMode: "standard",
  tooltipInteraction: false,
  copyHeadersToClipboard: false,
  copyGroupHeadersToClipboard: false,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: false,
  suppressCopySingleCellRanges: false,
  suppressLastEmptyLineOnPaste: false,
  suppressClipboardPaste: false,
  suppressClipboardApi: false,
  suppressCutToClipboard: false,
  maintainColumnOrder: false,
  enableStrictPivotColumnOrder: false,
  suppressFieldDotNotation: false,
  allowDragFromColumnsToolPanel: false,
  suppressMovableColumns: false,
  suppressColumnMoveAnimation: false,
  suppressMoveWhenColumnDragging: false,
  suppressDragLeaveHidesColumns: false,
  suppressRowGroupHidesColumns: false,
  suppressAutoSize: false,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: false,
  singleClickEdit: false,
  suppressClickEdit: false,
  readOnlyEdit: false,
  stopEditingWhenCellsLoseFocus: false,
  enterNavigatesVertically: false,
  enterNavigatesVerticallyAfterEdit: false,
  enableCellEditingOnBackspace: false,
  undoRedoCellEditing: false,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: false,
  suppressExcelExport: false,
  cacheQuickFilter: false,
  includeHiddenColumnsInQuickFilter: false,
  excludeChildrenWhenTreeDataFiltering: false,
  enableAdvancedFilter: false,
  includeHiddenColumnsInAdvancedFilter: false,
  enableCharts: false,
  masterDetail: false,
  keepDetailRows: false,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: false,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: false,
  valueCacheNeverExpires: false,
  enableCellExpressions: false,
  suppressTouch: false,
  suppressFocusAfterRefresh: false,
  suppressBrowserResizeObserver: false,
  suppressPropertyNamesCheck: false,
  suppressChangeDetection: false,
  debug: false,
  suppressLoadingOverlay: false,
  suppressNoRowsOverlay: false,
  pagination: false,
  paginationPageSize: 100,
  paginationPageSizeSelector: true,
  paginationAutoPageSize: false,
  paginateChildRows: false,
  suppressPaginationPanel: false,
  pivotMode: false,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: false,
  suppressExpandablePivotGroups: false,
  functionsReadOnly: false,
  suppressAggFuncInHeader: false,
  alwaysAggregateAtRootLevel: false,
  aggregateOnlyChangedColumns: false,
  suppressAggFilteredOnly: false,
  removePivotHeaderRowWhenSingleValueColumn: false,
  animateRows: true,
  cellFlashDuration: 500,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: false,
  domLayout: "normal",
  ensureDomOrder: false,
  enableRtl: false,
  suppressColumnVirtualisation: false,
  suppressMaxRenderedRowRestriction: false,
  suppressRowVirtualisation: false,
  rowDragManaged: false,
  suppressRowDrag: false,
  suppressMoveWhenRowDragging: false,
  rowDragEntireRow: false,
  rowDragMultiRow: false,
  embedFullWidthRows: false,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: false,
  groupSelectsChildren: false,
  groupSuppressBlankHeader: false,
  groupSelectsFiltered: false,
  showOpenedGroup: false,
  groupRemoveSingleChildren: false,
  groupRemoveLowestSingleChildren: false,
  groupHideOpenParents: false,
  groupAllowUnbalanced: false,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: false,
  treeData: false,
  rowGroupPanelSuppressSort: false,
  suppressGroupRowsSticky: false,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: false,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: false,
  serverSideSortAllLevels: false,
  serverSideOnlyRefreshFilteredGroups: false,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: false,
  alwaysShowVerticalScroll: false,
  debounceVerticalScrollbar: false,
  suppressHorizontalScroll: false,
  suppressScrollOnNewData: false,
  suppressScrollWhenPopupsAreOpen: false,
  suppressAnimationFrame: false,
  suppressMiddleClickScrolls: false,
  suppressPreventDefaultOnMouseWheel: false,
  rowMultiSelectWithClick: false,
  suppressRowDeselection: false,
  suppressRowClickSelection: false,
  suppressCellFocus: false,
  suppressHeaderFocus: false,
  suppressMultiRangeSelection: false,
  enableCellTextSelection: false,
  enableRangeSelection: false,
  enableRangeHandle: false,
  enableFillHandle: false,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: false,
  accentedSort: false,
  unSortIcon: false,
  suppressMultiSort: false,
  alwaysMultiSort: false,
  suppressMaintainUnsortedOrder: false,
  suppressRowHoverHighlight: false,
  suppressRowTransform: false,
  columnHoverHighlight: false,
  deltaSort: false,
  enableGroupEdit: false,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: false,
  suppressServerSideFullWidthLoadingRow: false,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: true,
  suppressSetFilterByDefault: false
};

// packages/ag-grid-community/src/gridOptionsService.ts
var changeSetId = 0;
var gridInstanceSequence = 0;
var GridOptionsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "gos";
    this.domDataKey = "__AG_" + Math.random().toString();
    /** This is only used for the main DOM element */
    this.gridInstanceId = gridInstanceSequence++;
    this.propEventSvc = new LocalEventService();
    // responsible for calling the onXXX functions on gridOptions
    // It forces events defined in GridOptionsService.alwaysSyncGlobalEvents to be fired synchronously.
    // This is required for events such as GridPreDestroyed.
    // Other events can be fired asynchronously or synchronously depending on config.
    this.globalEventHandlerFactory = (restrictToSyncOnly) => {
      return (eventName, event) => {
        if (!this.isAlive()) {
          return;
        }
        const alwaysSync = ALWAYS_SYNC_GLOBAL_EVENTS.has(eventName);
        if (alwaysSync && !restrictToSyncOnly || !alwaysSync && restrictToSyncOnly) {
          return;
        }
        const eventHandlerName = _getCallbackForEvent(eventName);
        const eventHandler = this.gridOptions[eventHandlerName];
        if (typeof eventHandler === "function") {
          this.beans.frameworkOverrides.wrapOutgoing(() => {
            eventHandler(event);
          });
        }
      };
    };
  }
  wireBeans(beans) {
    this.gridOptions = beans.gridOptions;
    this.validation = beans.validation;
    this.api = beans.gridApi;
    this.gridId = beans.context.getGridId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions["context"];
  }
  postConstruct() {
    this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), true);
    this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
    this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides);
    this.addManagedEventListeners({
      gridOptionsChanged: ({ options }) => {
        this.updateGridOptions({ options, force: true, source: "gridOptionsUpdated" });
      }
    });
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(property) {
    return this.gridOptions[property] ?? GRID_OPTION_DEFAULTS[property];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(property) {
    return this.mergeGridCommonParams(this.gridOptions[property]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(property) {
    return _exists(this.gridOptions[property]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(callback) {
    if (callback) {
      const wrapped = (callbackParams) => {
        return callback(this.addGridCommonParams(callbackParams));
      };
      return wrapped;
    }
    return callback;
  }
  updateGridOptions({
    options,
    force,
    source = "api"
  }) {
    const changeSet = { id: changeSetId++, properties: [] };
    const events = [];
    const { gridOptions, validation: validation2 } = this;
    Object.entries(options).forEach(([key, value]) => {
      validation2?.warnOnInitialPropertyUpdate(source, key);
      const shouldForce = force || typeof value === "object" && source === "api";
      const previousValue = gridOptions[key];
      if (shouldForce || previousValue !== value) {
        gridOptions[key] = value;
        const event = {
          type: key,
          currentValue: value,
          previousValue,
          changeSet,
          source
        };
        events.push(event);
      }
    });
    validation2?.processGridOptions(this.gridOptions);
    changeSet.properties = events.map((event) => event.type);
    events.forEach((event) => {
      _logIfDebug(this, `Updated property ${event.type} from`, event.previousValue, ` to `, event.currentValue);
      this.propEventSvc.dispatchEvent(event);
    });
  }
  addPropertyEventListener(key, listener) {
    this.propEventSvc.addEventListener(key, listener);
  }
  removePropertyEventListener(key, listener) {
    this.propEventSvc.removeEventListener(key, listener);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  getGridCommonParams() {
    return {
      api: this.api,
      context: this.gridOptionsContext
    };
  }
  addGridCommonParams(params) {
    const updatedParams = params;
    updatedParams.api = this.api;
    updatedParams.context = this.gridOptionsContext;
    return updatedParams;
  }
  assertModuleRegistered(moduleName, reasonOrId) {
    const registered = Array.isArray(moduleName) ? moduleName.some((modName) => this.isModuleRegistered(modName)) : this.isModuleRegistered(moduleName);
    if (!registered) {
      _error(200, {
        ...this.getModuleErrorParams(),
        moduleName,
        reasonOrId
      });
    }
    return registered;
  }
  getModuleErrorParams() {
    return {
      gridId: this.gridId,
      gridScoped: _areModulesGridScoped(),
      rowModelType: this.get("rowModelType")
    };
  }
  isModuleRegistered(moduleName) {
    return _isModuleRegistered(moduleName, this.gridId, this.get("rowModelType"));
  }
};

// packages/ag-grid-community/src/headerRendering/cells/column/headerComp.ts
function getHeaderCompTemplate(includeSortIndicator) {
  return (
    /* html */
    `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            ${includeSortIndicator ? '<ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>' : ""}
        </div>
    </div>`
  );
}
var HeaderComp = class extends Component {
  constructor() {
    super(...arguments);
    this.eFilter = RefPlaceholder;
    this.eFilterButton = RefPlaceholder;
    this.eSortIndicator = RefPlaceholder;
    this.eMenu = RefPlaceholder;
    this.eLabel = RefPlaceholder;
    this.eText = RefPlaceholder;
    /**
     * Selectors for custom headers templates
     */
    this.eSortOrder = RefPlaceholder;
    this.eSortAsc = RefPlaceholder;
    this.eSortDesc = RefPlaceholder;
    this.eSortMixed = RefPlaceholder;
    this.eSortNone = RefPlaceholder;
    this.isLoadingInnerComponent = false;
  }
  refresh(params) {
    const oldParams = this.params;
    this.params = params;
    if (this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || params.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || oldParams.enableFilterButton != params.enableFilterButton || oldParams.enableFilterIcon != params.enableFilterIcon) {
      return false;
    }
    this.setDisplayName(params);
    return true;
  }
  workOutTemplate() {
    const { params, beans } = this;
    const template = params.template ?? getHeaderCompTemplate(!!beans.sortSvc);
    return template?.trim ? template.trim() : template;
  }
  init(params) {
    this.params = params;
    const { sortSvc, touchSvc, userCompFactory } = this.beans;
    this.currentTemplate = this.workOutTemplate();
    this.setTemplate(this.currentTemplate, sortSvc ? [sortSvc.getSortIndicatorSelector()] : void 0);
    touchSvc?.setupForHeader(this);
    this.setMenu();
    this.setupSort();
    this.setupFilterIcon();
    this.setupFilterButton();
    this.workOutInnerHeaderComponent(userCompFactory, params);
    this.setDisplayName(params);
  }
  workOutInnerHeaderComponent(userCompFactory, params) {
    const userCompDetails = _getInnerHeaderCompDetails(userCompFactory, params, params);
    if (!userCompDetails) {
      return;
    }
    this.isLoadingInnerComponent = true;
    userCompDetails.newAgStackInstance().then((comp) => {
      this.isLoadingInnerComponent = false;
      if (!comp) {
        return;
      }
      if (this.isAlive()) {
        this.innerHeaderComponent = comp;
        this.eText.appendChild(comp.getGui());
      } else {
        this.destroyBean(comp);
      }
    });
  }
  setDisplayName(params) {
    const { displayName } = params;
    const oldDisplayName = this.currentDisplayName;
    this.currentDisplayName = displayName;
    if (oldDisplayName === displayName || this.innerHeaderComponent || this.isLoadingInnerComponent) {
      return;
    }
    const displayNameSanitised = _escapeString(displayName, true);
    this.eText.innerText = displayNameSanitised;
  }
  addInIcon(iconName, eParent, column) {
    if (eParent == null) {
      return;
    }
    const eIcon = _createIconNoSpan(iconName, this.beans, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  workOutShowMenu() {
    return this.params.enableMenu && !!this.beans.menuSvc?.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return !!this.beans.menuSvc?.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu) {
      return;
    }
    this.currentShowMenu = this.workOutShowMenu();
    if (!this.currentShowMenu) {
      _removeFromParent(this.eMenu);
      this.eMenu = void 0;
      return;
    }
    const { gos, eMenu, params } = this;
    const isLegacyMenu = _isLegacyMenuEnabled(gos);
    this.addInIcon(isLegacyMenu ? "menu" : "menuAlt", eMenu, params.column);
    eMenu.classList.toggle("ag-header-menu-icon", !isLegacyMenu);
    const currentSuppressMenuHide = this.shouldSuppressMenuHide();
    this.currentSuppressMenuHide = currentSuppressMenuHide;
    this.addManagedElementListeners(eMenu, { click: () => params.showColumnMenu(eMenu) });
    eMenu.classList.toggle("ag-header-menu-always-show", currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(isFilterShortcut) {
    const { params, gos, beans, eMenu, eFilterButton } = this;
    const column = params.column;
    const isLegacyMenuEnabled = _isLegacyMenuEnabled(gos);
    if (isFilterShortcut && !isLegacyMenuEnabled) {
      if (beans.menuSvc?.isFilterMenuInHeaderEnabled(column)) {
        params.showFilter(eFilterButton ?? eMenu ?? this.getGui());
        return true;
      }
    } else if (params.enableMenu) {
      params.showColumnMenu(eMenu ?? eFilterButton ?? this.getGui());
      return true;
    }
    return false;
  }
  setupSort() {
    const { sortSvc } = this.beans;
    if (!sortSvc) {
      return;
    }
    const { enableSorting, column } = this.params;
    this.currentSort = enableSorting;
    if (!this.eSortIndicator) {
      this.eSortIndicator = this.createBean(sortSvc.createSortIndicator(true));
      const { eSortIndicator, eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone } = this;
      eSortIndicator.attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone);
    }
    this.eSortIndicator.setupSort(column);
    if (!this.currentSort) {
      return;
    }
    sortSvc.setupHeader(this, column, this.eLabel);
  }
  setupFilterIcon() {
    const { eFilter, params } = this;
    if (!eFilter) {
      return;
    }
    this.configureFilter(params.enableFilterIcon, eFilter, this.onFilterChangedIcon.bind(this), "filterActive");
  }
  setupFilterButton() {
    const { eFilterButton, params } = this;
    if (!eFilterButton) {
      return;
    }
    const configured = this.configureFilter(
      params.enableFilterButton,
      eFilterButton,
      this.onFilterChangedButton.bind(this),
      "filter"
    );
    if (configured) {
      this.addManagedElementListeners(eFilterButton, {
        click: () => params.showFilter(eFilterButton)
      });
    } else {
      this.eFilterButton = void 0;
    }
  }
  configureFilter(enabled, element, filterChangedCallback, icon) {
    if (!enabled) {
      _removeFromParent(element);
      return false;
    }
    const column = this.params.column;
    this.addInIcon(icon, element, column);
    this.addManagedListeners(column, { filterChanged: filterChangedCallback });
    filterChangedCallback();
    return true;
  }
  onFilterChangedIcon() {
    const filterPresent = this.params.column.isFilterActive();
    _setDisplayed(this.eFilter, filterPresent, { skipAriaHidden: true });
  }
  onFilterChangedButton() {
    const filterPresent = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", filterPresent);
  }
  getAnchorElementForMenu(isFilter) {
    const { eFilterButton, eMenu } = this;
    if (isFilter) {
      return eFilterButton ?? eMenu ?? this.getGui();
    }
    return eMenu ?? eFilterButton ?? this.getGui();
  }
  destroy() {
    super.destroy();
    if (this.innerHeaderComponent) {
      this.destroyBean(this.innerHeaderComponent);
      this.innerHeaderComponent = void 0;
    }
  }
};

// packages/ag-grid-community/src/headerRendering/cells/columnGroup/headerGroupComp.ts
var HeaderGroupComp = class extends Component {
  constructor() {
    super(
      /* html */
      `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`
    );
    this.agOpened = RefPlaceholder;
    this.agClosed = RefPlaceholder;
    this.agLabel = RefPlaceholder;
    this.isLoadingInnerComponent = false;
  }
  init(params) {
    const { userCompFactory } = this.beans;
    this.params = params;
    this.checkWarnings();
    this.workOutInnerHeaderGroupComponent(userCompFactory, params);
    this.setupLabel(params);
    this.addGroupExpandIcon(params);
    this.setupExpandIcons();
  }
  checkWarnings() {
    const paramsAny = this.params;
    if (paramsAny.template) {
      _warn(89);
    }
  }
  workOutInnerHeaderGroupComponent(userCompFactory, params) {
    const userCompDetails = _getInnerHeaderGroupCompDetails(userCompFactory, params, params);
    if (!userCompDetails) {
      return;
    }
    this.isLoadingInnerComponent = true;
    userCompDetails.newAgStackInstance().then((comp) => {
      this.isLoadingInnerComponent = false;
      if (!comp) {
        return;
      }
      if (this.isAlive()) {
        this.innerHeaderGroupComponent = comp;
        this.agLabel.appendChild(comp.getGui());
      } else {
        this.destroyBean(comp);
      }
    });
  }
  setupExpandIcons() {
    const {
      agOpened,
      agClosed,
      params: { columnGroup },
      beans
    } = this;
    this.addInIcon("columnGroupOpened", agOpened);
    this.addInIcon("columnGroupClosed", agClosed);
    const expandAction = (event) => {
      if (_isStopPropagationForAgGrid(event)) {
        return;
      }
      const newExpandedValue = !columnGroup.isExpanded();
      beans.colGroupSvc.setColumnGroupOpened(
        columnGroup.getProvidedColumnGroup(),
        newExpandedValue,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(beans, agClosed, expandAction);
    this.addTouchAndClickListeners(beans, agOpened, expandAction);
    const stopPropagationAction = (event) => {
      _stopPropagationForAgGrid(event);
    };
    this.addManagedElementListeners(agClosed, { dblclick: stopPropagationAction });
    this.addManagedElementListeners(agOpened, { dblclick: stopPropagationAction });
    this.addManagedElementListeners(this.getGui(), { dblclick: expandAction });
    this.updateIconVisibility();
    const providedColumnGroup = columnGroup.getProvidedColumnGroup();
    const updateIcon = this.updateIconVisibility.bind(this);
    this.addManagedListeners(providedColumnGroup, {
      expandedChanged: updateIcon,
      expandableChanged: updateIcon
    });
  }
  addTouchAndClickListeners(beans, eElement, action) {
    beans.touchSvc?.setupForHeaderGroup(this, eElement, action);
    this.addManagedElementListeners(eElement, { click: action });
  }
  updateIconVisibility() {
    const {
      agOpened,
      agClosed,
      params: { columnGroup }
    } = this;
    if (columnGroup.isExpandable()) {
      const expanded = columnGroup.isExpanded();
      _setDisplayed(agOpened, expanded);
      _setDisplayed(agClosed, !expanded);
    } else {
      _setDisplayed(agOpened, false);
      _setDisplayed(agClosed, false);
    }
  }
  addInIcon(iconName, element) {
    const eIcon = _createIconNoSpan(iconName, this.beans, null);
    if (eIcon) {
      element.appendChild(eIcon);
    }
  }
  addGroupExpandIcon(params) {
    if (!params.columnGroup.isExpandable()) {
      const { agOpened, agClosed } = this;
      _setDisplayed(agOpened, false);
      _setDisplayed(agClosed, false);
      return;
    }
  }
  setupLabel(params) {
    const { displayName, columnGroup } = params;
    const hasInnerComponent = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
    if (_exists(displayName) && !hasInnerComponent) {
      const displayNameSanitised = _escapeString(displayName, true);
      this.agLabel.textContent = displayNameSanitised;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !columnGroup.getColGroupDef()?.suppressStickyLabel);
  }
  destroy() {
    super.destroy();
    if (this.innerHeaderGroupComponent) {
      this.destroyBean(this.innerHeaderGroupComponent);
      this.innerHeaderGroupComponent = void 0;
    }
  }
};

// packages/ag-grid-community/src/headerRendering/cells/headerModule.ts
var ColumnHeaderCompModule = {
  moduleName: "ColumnHeaderComp",
  version: VERSION,
  userComponents: {
    agColumnHeader: HeaderComp
  },
  icons: {
    // button to launch legacy column menu
    menu: "menu",
    // button to launch new enterprise column menu
    menuAlt: "menu-alt"
  }
};
var ColumnGroupHeaderCompModule = {
  moduleName: "ColumnGroupHeaderComp",
  version: VERSION,
  userComponents: {
    agColumnGroupHeader: HeaderGroupComp
  },
  icons: {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted"
  }
};

// packages/ag-grid-community/src/misc/animationFrameModule.ts
var AnimationFrameModule = {
  moduleName: "AnimationFrame",
  version: VERSION,
  beans: [AnimationFrameService]
};

// packages/ag-grid-community/src/misc/touchService.ts
var TouchService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "touchSvc";
  }
  mockBodyContextMenu(ctrl, listener) {
    this.mockContextMenu(ctrl, ctrl.eBodyViewport, listener);
  }
  mockHeaderContextMenu(ctrl, listener) {
    this.mockContextMenu(ctrl, ctrl.eGui, listener);
  }
  mockRowContextMenu(ctrl) {
    if (!_isIOSUserAgent()) {
      return;
    }
    const listener = (mouseListener, touch, touchEvent) => {
      const { rowCtrl, cellCtrl } = ctrl.getControlsForEventTarget(touchEvent?.target ?? null);
      if (cellCtrl?.column) {
        cellCtrl.dispatchCellContextMenuEvent(touchEvent ?? null);
      }
      this.beans.contextMenuSvc?.handleContextMenuMouseEvent(void 0, touchEvent, rowCtrl, cellCtrl);
    };
    this.mockContextMenu(ctrl, ctrl.element, listener);
  }
  handleCellDoubleClick(ctrl, mouseEvent) {
    const isDoubleClickOnIPad = () => {
      if (!_isIOSUserAgent() || _isEventSupported("dblclick")) {
        return false;
      }
      const nowMillis = (/* @__PURE__ */ new Date()).getTime();
      const res = nowMillis - ctrl.lastIPadMouseClickEvent < 200;
      ctrl.lastIPadMouseClickEvent = nowMillis;
      return res;
    };
    if (isDoubleClickOnIPad()) {
      ctrl.onCellDoubleClicked(mouseEvent);
      mouseEvent.preventDefault();
      return true;
    }
    return false;
  }
  setupForHeader(comp) {
    const { gos, sortSvc } = this.beans;
    if (gos.get("suppressTouch")) {
      return;
    }
    const { params, eMenu, eFilterButton } = comp;
    const touchListener = new TouchListener(comp.getGui(), true);
    const suppressMenuHide = comp.shouldSuppressMenuHide();
    const tapMenuButton = suppressMenuHide && _exists(eMenu);
    const menuTouchListener = tapMenuButton ? new TouchListener(eMenu, true) : touchListener;
    if (params.enableMenu) {
      const eventType = tapMenuButton ? "tap" : "longTap";
      const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
      comp.addManagedListeners(menuTouchListener, { [eventType]: showMenuFn });
    }
    if (params.enableSorting) {
      const tapListener = (event) => {
        const target = event.touchStart.target;
        if (suppressMenuHide && (eMenu?.contains(target) || eFilterButton?.contains(target))) {
          return;
        }
        sortSvc?.progressSort(params.column, false, "uiColumnSorted");
      };
      comp.addManagedListeners(touchListener, { tap: tapListener });
    }
    if (params.enableFilterButton && eFilterButton) {
      const filterButtonTouchListener = new TouchListener(eFilterButton, true);
      comp.addManagedListeners(filterButtonTouchListener, {
        tap: () => params.showFilter(eFilterButton)
      });
      comp.addDestroyFunc(() => filterButtonTouchListener.destroy());
    }
    comp.addDestroyFunc(() => touchListener.destroy());
    if (tapMenuButton) {
      comp.addDestroyFunc(() => menuTouchListener.destroy());
    }
  }
  setupForHeaderGroup(comp, eElement, action) {
    const touchListener = new TouchListener(eElement, true);
    comp.addManagedListeners(touchListener, { tap: action });
    comp.addDestroyFunc(() => touchListener.destroy());
  }
  mockContextMenu(ctrl, element, listener) {
    if (!_isIOSUserAgent()) {
      return;
    }
    const touchListener = new TouchListener(element);
    const longTapListener = (event) => {
      listener(void 0, event.touchStart, event.touchEvent);
    };
    ctrl.addManagedListeners(touchListener, { longTap: longTapListener });
    ctrl.addDestroyFunc(() => touchListener.destroy());
  }
};

// packages/ag-grid-community/src/misc/touchModule.ts
var TouchModule = {
  moduleName: "Touch",
  version: VERSION,
  beans: [TouchService]
};

// packages/ag-grid-community/src/navigation/cellNavigationService.ts
var CellNavigationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "cellNavigation";
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
    if (ctrlPressed) {
      return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
    }
    return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
  }
  getNextCellToFocusWithCtrlPressed(key, focusedCell) {
    const upKey = key === KeyCode.UP;
    const downKey = key === KeyCode.DOWN;
    const leftKey = key === KeyCode.LEFT;
    let column;
    let rowIndex;
    const { pageBounds, gos, visibleCols } = this.beans;
    if (upKey || downKey) {
      rowIndex = upKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
      column = focusedCell.column;
    } else {
      const allColumns = visibleCols.allCols;
      const isRtl = gos.get("enableRtl");
      rowIndex = focusedCell.rowIndex;
      column = leftKey !== isRtl ? allColumns[0] : _last(allColumns);
    }
    return {
      rowIndex,
      rowPinned: null,
      column
    };
  }
  getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
    let pointer = focusedCell;
    let finished = false;
    while (!finished) {
      switch (key) {
        case KeyCode.UP:
          pointer = this.getCellAbove(pointer);
          break;
        case KeyCode.DOWN:
          pointer = this.getCellBelow(pointer);
          break;
        case KeyCode.RIGHT:
          pointer = this.gos.get("enableRtl") ? this.getCellToLeft(pointer) : this.getCellToRight(pointer);
          break;
        case KeyCode.LEFT:
          pointer = this.gos.get("enableRtl") ? this.getCellToRight(pointer) : this.getCellToLeft(pointer);
          break;
        default:
          pointer = null;
          _warn(8, { key });
          break;
      }
      if (pointer) {
        finished = this.isCellGoodToFocusOn(pointer);
      } else {
        finished = true;
      }
    }
    return pointer;
  }
  isCellGoodToFocusOn(gridCell) {
    const column = gridCell.column;
    let rowNode;
    const { pinnedRowModel, rowModel } = this.beans;
    switch (gridCell.rowPinned) {
      case "top":
        rowNode = pinnedRowModel?.getPinnedTopRow(gridCell.rowIndex);
        break;
      case "bottom":
        rowNode = pinnedRowModel?.getPinnedBottomRow(gridCell.rowIndex);
        break;
      default:
        rowNode = rowModel.getRow(gridCell.rowIndex);
        break;
    }
    if (!rowNode) {
      return false;
    }
    const suppressNavigable = this.isSuppressNavigable(column, rowNode);
    return !suppressNavigable;
  }
  getCellToLeft(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToLeft = this.beans.visibleCols.getColBefore(lastCell.column);
    if (!colToLeft) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToLeft,
      rowPinned: lastCell.rowPinned
    };
  }
  getCellToRight(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToRight = this.beans.visibleCols.getColAfter(lastCell.column);
    if (!colToRight) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToRight,
      rowPinned: lastCell.rowPinned
    };
  }
  getRowBelow(rowPosition) {
    const index = rowPosition.rowIndex;
    const pinned = rowPosition.rowPinned;
    let ignoreSticky = false;
    const { pageBounds, pinnedRowModel, rowModel } = this.beans;
    if (this.isLastRowInContainer(rowPosition)) {
      switch (pinned) {
        case "bottom":
          return null;
        case "top":
          if (rowModel.isRowsToRender()) {
            return { rowIndex: pageBounds.getFirstRow(), rowPinned: null };
          }
          if (pinnedRowModel?.isRowsToRender("bottom")) {
            return { rowIndex: 0, rowPinned: "bottom" };
          }
          return null;
        default:
          if (pinnedRowModel?.isRowsToRender("bottom")) {
            return { rowIndex: 0, rowPinned: "bottom" };
          }
          return null;
      }
    } else if (pinned) {
      ignoreSticky = true;
    }
    const rowNode = rowModel.getRow(rowPosition.rowIndex);
    const nextStickyPosition = ignoreSticky ? void 0 : this.getNextStickyPosition(rowNode);
    if (nextStickyPosition) {
      return nextStickyPosition;
    }
    return { rowIndex: index + 1, rowPinned: pinned };
  }
  getNextStickyPosition(rowNode, up) {
    const { gos, rowRenderer } = this.beans;
    if (!_isGroupRowsSticky(gos) || !rowNode || !rowNode.sticky) {
      return;
    }
    const isTopCtrls = rowRenderer.getStickyTopRowCtrls().some((ctrl) => ctrl.rowNode.rowIndex === rowNode.rowIndex);
    let stickyRowCtrls = [];
    if (isTopCtrls) {
      stickyRowCtrls = [...rowRenderer.getStickyTopRowCtrls()].sort(
        (a, b) => a.rowNode.rowIndex - b.rowNode.rowIndex
      );
    } else {
      stickyRowCtrls = [...rowRenderer.getStickyBottomRowCtrls()].sort(
        (a, b) => b.rowNode.rowIndex - a.rowNode.rowIndex
      );
    }
    const diff = up ? -1 : 1;
    const idx = stickyRowCtrls.findIndex((ctrl) => ctrl.rowNode.rowIndex === rowNode.rowIndex);
    const nextCtrl = stickyRowCtrls[idx + diff];
    if (nextCtrl) {
      return { rowIndex: nextCtrl.rowNode.rowIndex, rowPinned: null };
    }
  }
  getCellBelow(lastCell) {
    if (!lastCell) {
      return null;
    }
    const rowBelow = this.getRowBelow(lastCell);
    if (rowBelow) {
      return {
        rowIndex: rowBelow.rowIndex,
        column: lastCell.column,
        rowPinned: rowBelow.rowPinned
      };
    }
    return null;
  }
  isLastRowInContainer(rowPosition) {
    const pinned = rowPosition.rowPinned;
    const index = rowPosition.rowIndex;
    const { pinnedRowModel, pageBounds } = this.beans;
    if (pinned === "top") {
      const lastTopIndex = pinnedRowModel?.getPinnedTopRowCount() ?? 0 - 1;
      return lastTopIndex <= index;
    }
    if (pinned === "bottom") {
      const lastBottomIndex = pinnedRowModel?.getPinnedBottomRowCount() ?? 0 - 1;
      return lastBottomIndex <= index;
    }
    const lastBodyIndex = pageBounds.getLastRow();
    return lastBodyIndex <= index;
  }
  getRowAbove(rowPosition) {
    const index = rowPosition.rowIndex;
    const pinned = rowPosition.rowPinned;
    const { pageBounds, pinnedRowModel, rowModel } = this.beans;
    const isFirstRow = pinned ? index === 0 : index === pageBounds.getFirstRow();
    let ignoreSticky = false;
    const getLastFloatingTopRow = () => {
      const lastFloatingRow = pinnedRowModel?.getPinnedTopRowCount() ?? 0 - 1;
      return { rowIndex: lastFloatingRow, rowPinned: "top" };
    };
    if (isFirstRow) {
      if (pinned === "top") {
        return null;
      }
      if (!pinned) {
        if (pinnedRowModel?.isRowsToRender("top")) {
          return getLastFloatingTopRow();
        }
        return null;
      }
      if (rowModel.isRowsToRender()) {
        const lastBodyRow = pageBounds.getLastRow();
        return { rowIndex: lastBodyRow, rowPinned: null };
      }
      if (pinnedRowModel?.isRowsToRender("top")) {
        return getLastFloatingTopRow();
      }
      return null;
    } else if (pinned) {
      ignoreSticky = true;
    }
    const rowNode = rowModel.getRow(rowPosition.rowIndex);
    const nextStickyPosition = ignoreSticky ? void 0 : this.getNextStickyPosition(rowNode, true);
    if (nextStickyPosition) {
      return nextStickyPosition;
    }
    return { rowIndex: index - 1, rowPinned: pinned };
  }
  getCellAbove(lastCell) {
    if (!lastCell) {
      return null;
    }
    const rowAbove = this.getRowAbove({ rowIndex: lastCell.rowIndex, rowPinned: lastCell.rowPinned });
    if (rowAbove) {
      return {
        rowIndex: rowAbove.rowIndex,
        column: lastCell.column,
        rowPinned: rowAbove.rowPinned
      };
    }
    return null;
  }
  getNextTabbedCell(gridCell, backwards) {
    if (backwards) {
      return this.getNextTabbedCellBackwards(gridCell);
    }
    return this.getNextTabbedCellForwards(gridCell);
  }
  getNextTabbedCellForwards(gridCell) {
    const { visibleCols, pagination } = this.beans;
    const displayedColumns = visibleCols.allCols;
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = visibleCols.getColAfter(gridCell.column);
    if (!newColumn) {
      newColumn = displayedColumns[0];
      const rowBelow = this.getRowBelow(gridCell);
      if (_missing(rowBelow)) {
        return null;
      }
      if (!rowBelow.rowPinned && !(pagination?.isRowInPage(rowBelow) ?? true)) {
        return null;
      }
      newRowIndex = rowBelow ? rowBelow.rowIndex : null;
      newFloating = rowBelow ? rowBelow.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
  getNextTabbedCellBackwards(gridCell) {
    const { visibleCols, pagination } = this.beans;
    const displayedColumns = visibleCols.allCols;
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = visibleCols.getColBefore(gridCell.column);
    if (!newColumn) {
      newColumn = _last(displayedColumns);
      const rowAbove = this.getRowAbove({ rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });
      if (_missing(rowAbove)) {
        return null;
      }
      if (!rowAbove.rowPinned && !(pagination?.isRowInPage(rowAbove) ?? true)) {
        return null;
      }
      newRowIndex = rowAbove ? rowAbove.rowIndex : null;
      newFloating = rowAbove ? rowAbove.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
  isSuppressNavigable(column, rowNode) {
    const { suppressNavigable } = column.colDef;
    if (typeof suppressNavigable === "boolean") {
      return suppressNavigable;
    }
    if (typeof suppressNavigable === "function") {
      const params = column.createColumnFunctionCallbackParams(rowNode);
      const userFunc = suppressNavigable;
      return userFunc(params);
    }
    return false;
  }
};

// packages/ag-grid-community/src/navigation/navigationApi.ts
function getFocusedCell(beans) {
  return beans.focusSvc.getFocusedCell();
}
function clearFocusedCell(beans) {
  return beans.focusSvc.clearFocusedCell();
}
function setFocusedCell(beans, rowIndex, colKey, rowPinned) {
  beans.focusSvc.setFocusedCell({ rowIndex, column: colKey, rowPinned, forceBrowserFocus: true });
}
function tabToNextCell(beans, event) {
  return beans.navigation?.tabToNextCell(false, event) ?? false;
}
function tabToPreviousCell(beans, event) {
  return beans.navigation?.tabToNextCell(true, event) ?? false;
}
function setFocusedHeader(beans, colKey, floatingFilter = false) {
  const headerPosition = beans.headerNavigation?.getHeaderPositionForColumn(colKey, floatingFilter);
  if (!headerPosition) {
    return;
  }
  beans.focusSvc.focusHeaderPosition({ headerPosition });
}

// packages/ag-grid-community/src/navigation/navigationService.ts
var NavigationService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "navigation";
    this.onPageDown = _throttle(this.onPageDown, 100);
    this.onPageUp = _throttle(this.onPageUp, 100);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(event, fromFullWidth = false) {
    const key = event.key;
    const alt = event.altKey;
    const ctrl = event.ctrlKey || event.metaKey;
    const rangeServiceShouldHandleShift = !!this.beans.rangeSvc && event.shiftKey;
    const currentCell = _getCellPositionForEvent(this.gos, event);
    let processed = false;
    switch (key) {
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (!ctrl && !alt) {
          this.onHomeOrEndKey(key);
          processed = true;
        }
        break;
      case KeyCode.LEFT:
      case KeyCode.RIGHT:
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (!currentCell) {
          return false;
        }
        if (ctrl && !alt && !rangeServiceShouldHandleShift) {
          this.onCtrlUpDownLeftRight(key, currentCell);
          processed = true;
        }
        break;
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
        if (!ctrl && !alt) {
          processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
        }
        break;
    }
    if (processed) {
      event.preventDefault();
    }
    return processed;
  }
  handlePageUpDown(key, currentCell, fromFullWidth) {
    if (fromFullWidth) {
      currentCell = this.beans.focusSvc.getFocusedCell();
    }
    if (!currentCell) {
      return false;
    }
    if (key === KeyCode.PAGE_UP) {
      this.onPageUp(currentCell);
    } else {
      this.onPageDown(currentCell);
    }
    return true;
  }
  navigateTo(navigateParams) {
    const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;
    const { scrollFeature } = this.gridBodyCon;
    if (_exists(scrollColumn) && !scrollColumn.isPinned()) {
      scrollFeature.ensureColumnVisible(scrollColumn);
    }
    if (_exists(scrollIndex)) {
      scrollFeature.ensureIndexVisible(scrollIndex, scrollType);
    }
    if (!navigateParams.isAsync) {
      scrollFeature.ensureIndexVisible(focusIndex);
    }
    const { focusSvc, rangeSvc } = this.beans;
    focusSvc.setFocusedCell({
      rowIndex: focusIndex,
      column: focusColumn,
      rowPinned: null,
      forceBrowserFocus: true
    });
    rangeSvc?.setRangeToCell({ rowIndex: focusIndex, rowPinned: null, column: focusColumn });
  }
  // this method is throttled, see the `constructor`
  onPageDown(gridCell) {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const pixelsInOnePage = this.getViewportHeight();
    const { pageBounds, rowModel, rowAutoHeight } = beans;
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
    const currentPageBottomRow = rowModel.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
    if (rowAutoHeight?.active) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
    } else {
      this.navigateToNextPage(gridCell, currentPageBottomRow);
    }
  }
  // this method is throttled, see the `constructor`
  onPageUp(gridCell) {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const { pageBounds, rowModel, rowAutoHeight } = beans;
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentPageTopPixel = scrollPosition.top;
    const currentPageTopRow = rowModel.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
    if (rowAutoHeight?.active) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
    } else {
      this.navigateToNextPage(gridCell, currentPageTopRow, true);
    }
  }
  navigateToNextPage(gridCell, scrollIndex, up = false) {
    const { pageBounds, rowModel } = this.beans;
    const pixelsInOnePage = this.getViewportHeight();
    const firstRow = pageBounds.getFirstRow();
    const lastRow = pageBounds.getLastRow();
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentRowNode = rowModel.getRow(gridCell.rowIndex);
    const rowPixelDiff = up ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      currentRowNode?.rowHeight - pixelsInOnePage - pagingPixelOffset
    ) : pixelsInOnePage - pagingPixelOffset;
    const nextCellPixel = currentRowNode?.rowTop + rowPixelDiff;
    let focusIndex = rowModel.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
    if (focusIndex === gridCell.rowIndex) {
      const diff = up ? -1 : 1;
      scrollIndex = focusIndex = gridCell.rowIndex + diff;
    }
    let scrollType;
    if (up) {
      scrollType = "bottom";
      if (focusIndex < firstRow) {
        focusIndex = firstRow;
      }
      if (scrollIndex < firstRow) {
        scrollIndex = firstRow;
      }
    } else {
      scrollType = "top";
      if (focusIndex > lastRow) {
        focusIndex = lastRow;
      }
      if (scrollIndex > lastRow) {
        scrollIndex = lastRow;
      }
    }
    if (this.isRowTallerThanView(rowModel.getRow(focusIndex))) {
      scrollIndex = focusIndex;
      scrollType = "top";
    }
    this.navigateTo({
      scrollIndex,
      scrollType,
      scrollColumn: null,
      focusIndex,
      focusColumn: gridCell.column
    });
  }
  navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
    this.navigateTo({
      scrollIndex,
      scrollType: up ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: scrollIndex,
      focusColumn: gridCell.column
    });
    setTimeout(() => {
      const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
      this.navigateTo({
        scrollIndex,
        scrollType: up ? "bottom" : "top",
        scrollColumn: null,
        focusIndex,
        focusColumn: gridCell.column,
        isAsync: true
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(gridCell, up = false) {
    const step = up ? -1 : 1;
    const pixelsInOnePage = this.getViewportHeight();
    const { pageBounds, rowModel } = this.beans;
    const lastRowIndex = pageBounds.getLastRow();
    let pixelSum = 0;
    let currentIndex = gridCell.rowIndex;
    while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
      const currentCell = rowModel.getRow(currentIndex);
      if (currentCell) {
        const currentCellHeight = currentCell.rowHeight ?? 0;
        if (pixelSum + currentCellHeight > pixelsInOnePage) {
          break;
        }
        pixelSum += currentCellHeight;
      }
      currentIndex += step;
    }
    return Math.max(0, Math.min(currentIndex, lastRowIndex));
  }
  getViewportHeight() {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const scrollbarWidth = this.beans.scrollVisibleSvc.getScrollbarWidth();
    let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
    if (beans.ctrlsSvc.get("center").isHorizontalScrollShowing()) {
      pixelsInOnePage -= scrollbarWidth;
    }
    return pixelsInOnePage;
  }
  isRowTallerThanView(rowNode) {
    if (!rowNode) {
      return false;
    }
    const rowHeight = rowNode.rowHeight;
    if (typeof rowHeight !== "number") {
      return false;
    }
    return rowHeight > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(key, gridCell) {
    const cellToFocus = this.beans.cellNavigation.getNextCellToFocus(key, gridCell, true);
    const { rowIndex } = cellToFocus;
    const column = cellToFocus.column;
    this.navigateTo({
      scrollIndex: rowIndex,
      scrollType: null,
      scrollColumn: column,
      focusIndex: rowIndex,
      focusColumn: column
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(key) {
    const homeKey = key === KeyCode.PAGE_HOME;
    const { visibleCols, pageBounds } = this.beans;
    const allColumns = visibleCols.allCols;
    const columnToSelect = homeKey ? allColumns[0] : _last(allColumns);
    const scrollIndex = homeKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
    this.navigateTo({
      scrollIndex,
      scrollType: null,
      scrollColumn: columnToSelect,
      focusIndex: scrollIndex,
      focusColumn: columnToSelect
    });
  }
  // result of keyboard event
  onTabKeyDown(previous, keyboardEvent) {
    const backwards = keyboardEvent.shiftKey;
    const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
    const beans = this.beans;
    const { ctrlsSvc, pageBounds, focusSvc, gos } = beans;
    if (movedToNextCell !== false) {
      if (movedToNextCell) {
        keyboardEvent.preventDefault();
      } else if (movedToNextCell === null) {
        ctrlsSvc.get("gridCtrl").allowFocusForNextCoreContainer(backwards);
      }
      return;
    }
    if (backwards) {
      const { rowIndex, rowPinned } = previous.getRowPosition();
      const firstRow = rowPinned ? rowIndex === 0 : rowIndex === pageBounds.getFirstRow();
      if (firstRow) {
        if (gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(beans)) {
          _focusNextGridCoreContainer(beans, true, true);
        } else {
          keyboardEvent.preventDefault();
          focusSvc.focusPreviousFromFirstCell(keyboardEvent);
        }
      }
    } else {
      if (previous instanceof CellCtrl) {
        previous.focusCell(true);
      }
      if (!backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards)) {
        keyboardEvent.preventDefault();
      }
    }
  }
  // comes from API
  tabToNextCell(backwards, event) {
    const beans = this.beans;
    const { focusSvc, rowRenderer } = beans;
    const focusedCell = focusSvc.getFocusedCell();
    if (!focusedCell) {
      return false;
    }
    let cellOrRow = _getCellByPosition(beans, focusedCell);
    if (!cellOrRow) {
      cellOrRow = rowRenderer.getRowByPosition(focusedCell);
      if (!cellOrRow || !cellOrRow.isFullWidth()) {
        return false;
      }
    }
    return !!this.tabToNextCellCommon(cellOrRow, backwards, event);
  }
  tabToNextCellCommon(previous, backwards, event) {
    let editing = previous.editing;
    if (!editing && previous instanceof CellCtrl) {
      const cell = previous;
      const row = cell.rowCtrl;
      if (row) {
        editing = row.editing;
      }
    }
    let res;
    if (editing) {
      if (this.gos.get("editType") === "fullRow") {
        res = this.moveToNextEditingRow(previous, backwards, event);
      } else {
        res = this.moveToNextEditingCell(previous, backwards, event);
      }
    } else {
      res = this.moveToNextCellNotEditing(previous, backwards);
    }
    if (res === null) {
      return res;
    }
    return res || !!this.beans.focusSvc.focusedHeader;
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(previousCell, backwards, event = null) {
    const previousPos = previousCell.cellPosition;
    previousCell.eGui.focus();
    previousCell.stopEditing();
    const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
    if (nextCell === false) {
      return null;
    }
    if (nextCell == null) {
      return false;
    }
    this.beans.editSvc?.startEditing(nextCell, null, true, event);
    nextCell.focusCell(false);
    return true;
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(previousCell, backwards, event = null) {
    const previousPos = previousCell.cellPosition;
    const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
    if (nextCell === false) {
      return null;
    }
    if (nextCell == null) {
      return false;
    }
    const nextPos = nextCell.cellPosition;
    const previousEditable = this.isCellEditable(previousPos);
    const nextEditable = this.isCellEditable(nextPos);
    const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;
    const { editSvc, rowEditSvc } = this.beans;
    if (previousEditable) {
      editSvc?.setFocusOutOnEditor(previousCell);
    }
    if (!rowsMatch) {
      const pRow = previousCell.rowCtrl;
      editSvc?.stopRowEditing(pRow);
      const nRow = nextCell.rowCtrl;
      rowEditSvc?.startEditing(nRow, void 0, void 0, event);
    }
    if (nextEditable) {
      editSvc?.setFocusInOnEditor(nextCell);
      nextCell.focusCell();
    } else {
      nextCell.focusCell(true);
    }
    return true;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(previousCell, backwards) {
    const displayedColumns = this.beans.visibleCols.allCols;
    let cellPos;
    if (previousCell instanceof RowCtrl) {
      cellPos = {
        ...previousCell.getRowPosition(),
        column: backwards ? displayedColumns[0] : _last(displayedColumns)
      };
    } else {
      cellPos = previousCell.cellPosition;
    }
    const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);
    if (nextCell === false) {
      return null;
    }
    if (nextCell instanceof CellCtrl) {
      nextCell.focusCell(true);
    } else if (nextCell) {
      return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);
    }
    return _exists(nextCell);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(previousPosition, backwards, startEditing) {
    let nextPosition = previousPosition;
    const beans = this.beans;
    const { cellNavigation, gos, focusSvc, rowRenderer, rangeSvc } = beans;
    while (true) {
      if (previousPosition !== nextPosition) {
        previousPosition = nextPosition;
      }
      if (!backwards) {
        nextPosition = this.getLastCellOfColSpan(nextPosition);
      }
      nextPosition = cellNavigation.getNextTabbedCell(nextPosition, backwards);
      const userFunc = gos.getCallback("tabToNextCell");
      if (_exists(userFunc)) {
        const params = {
          backwards,
          editing: startEditing,
          previousCellPosition: previousPosition,
          nextCellPosition: nextPosition ? nextPosition : null
        };
        const userResult = userFunc(params);
        if (userResult === true) {
          nextPosition = previousPosition;
        } else if (userResult === false) {
          return false;
        } else {
          nextPosition = {
            rowIndex: userResult.rowIndex,
            column: userResult.column,
            rowPinned: userResult.rowPinned
          };
        }
      }
      if (!nextPosition) {
        return null;
      }
      if (nextPosition.rowIndex < 0) {
        const headerLen = getFocusHeaderRowCount(beans);
        focusSvc.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: headerLen + nextPosition.rowIndex,
            column: nextPosition.column
          },
          fromCell: true
        });
        return null;
      }
      const fullRowEdit = gos.get("editType") === "fullRow";
      if (startEditing && !fullRowEdit) {
        const cellIsEditable = this.isCellEditable(nextPosition);
        if (!cellIsEditable) {
          continue;
        }
      }
      this.ensureCellVisible(nextPosition);
      const nextCell = _getCellByPosition(beans, nextPosition);
      if (!nextCell) {
        const row = rowRenderer.getRowByPosition(nextPosition);
        if (!row || !row.isFullWidth() || startEditing) {
          continue;
        }
        return row;
      }
      if (cellNavigation.isSuppressNavigable(nextCell.column, nextCell.rowNode)) {
        continue;
      }
      rangeSvc?.setRangeToCell(nextPosition);
      return nextCell;
    }
  }
  isCellEditable(cell) {
    const rowNode = this.lookupRowNodeForCell(cell);
    if (rowNode) {
      return cell.column.isCellEditable(rowNode);
    }
    return false;
  }
  lookupRowNodeForCell({ rowIndex, rowPinned }) {
    const { pinnedRowModel, rowModel } = this.beans;
    if (rowPinned === "top") {
      return pinnedRowModel?.getPinnedTopRow(rowIndex);
    }
    if (rowPinned === "bottom") {
      return pinnedRowModel?.getPinnedBottomRow(rowIndex);
    }
    return rowModel.getRow(rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(event, key, currentCell, allowUserOverride) {
    let nextCell = currentCell;
    let hitEdgeOfGrid = false;
    const beans = this.beans;
    const { cellNavigation, focusSvc, gos } = beans;
    while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
      if (gos.get("enableRtl")) {
        if (key === KeyCode.LEFT) {
          nextCell = this.getLastCellOfColSpan(nextCell);
        }
      } else if (key === KeyCode.RIGHT) {
        nextCell = this.getLastCellOfColSpan(nextCell);
      }
      nextCell = cellNavigation.getNextCellToFocus(key, nextCell);
      hitEdgeOfGrid = _missing(nextCell);
    }
    if (hitEdgeOfGrid && event && event.key === KeyCode.UP) {
      nextCell = {
        rowIndex: -1,
        rowPinned: null,
        column: currentCell.column
      };
    }
    if (allowUserOverride) {
      const userFunc = gos.getCallback("navigateToNextCell");
      if (_exists(userFunc)) {
        const params = {
          key,
          previousCellPosition: currentCell,
          nextCellPosition: nextCell ? nextCell : null,
          event
        };
        const userCell = userFunc(params);
        if (_exists(userCell)) {
          nextCell = {
            rowPinned: userCell.rowPinned,
            rowIndex: userCell.rowIndex,
            column: userCell.column
          };
        } else {
          nextCell = null;
        }
      }
    }
    if (!nextCell) {
      return;
    }
    if (nextCell.rowIndex < 0) {
      const headerLen = getFocusHeaderRowCount(beans);
      focusSvc.focusHeaderPosition({
        headerPosition: { headerRowIndex: headerLen + nextCell.rowIndex, column: currentCell.column },
        event: event || void 0,
        fromCell: true
      });
      return;
    }
    const normalisedPosition = this.getNormalisedPosition(nextCell);
    if (normalisedPosition) {
      this.focusPosition(normalisedPosition);
    } else {
      this.tryToFocusFullWidthRow(nextCell);
    }
  }
  getNormalisedPosition(cellPosition) {
    this.ensureCellVisible(cellPosition);
    const cellCtrl = _getCellByPosition(this.beans, cellPosition);
    if (!cellCtrl) {
      return null;
    }
    cellPosition = cellCtrl.cellPosition;
    this.ensureCellVisible(cellPosition);
    return cellPosition;
  }
  tryToFocusFullWidthRow(position, backwards) {
    const { visibleCols, rowRenderer, focusSvc, eventSvc } = this.beans;
    const displayedColumns = visibleCols.allCols;
    const rowComp = rowRenderer.getRowByPosition(position);
    if (!rowComp || !rowComp.isFullWidth()) {
      return false;
    }
    const currentCellFocused = focusSvc.getFocusedCell();
    const cellPosition = {
      rowIndex: position.rowIndex,
      rowPinned: position.rowPinned,
      column: position.column || (backwards ? _last(displayedColumns) : displayedColumns[0])
    };
    this.focusPosition(cellPosition);
    const fromBelow = backwards == null ? currentCellFocused != null && _isRowBefore(cellPosition, currentCellFocused) : backwards;
    eventSvc.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: cellPosition.rowIndex,
      rowPinned: cellPosition.rowPinned,
      column: cellPosition.column,
      isFullWidthCell: true,
      fromBelow
    });
    return true;
  }
  focusPosition(cellPosition) {
    const { focusSvc, rangeSvc } = this.beans;
    focusSvc.setFocusedCell({
      rowIndex: cellPosition.rowIndex,
      column: cellPosition.column,
      rowPinned: cellPosition.rowPinned,
      forceBrowserFocus: true
    });
    rangeSvc?.setRangeToCell(cellPosition);
  }
  isValidNavigateCell(cell) {
    const rowNode = _getRowNode(this.beans, cell);
    return !!rowNode;
  }
  getLastCellOfColSpan(cell) {
    const cellCtrl = _getCellByPosition(this.beans, cell);
    if (!cellCtrl) {
      return cell;
    }
    const colSpanningList = cellCtrl.getColSpanningList();
    if (colSpanningList.length === 1) {
      return cell;
    }
    return {
      rowIndex: cell.rowIndex,
      column: _last(colSpanningList),
      rowPinned: cell.rowPinned
    };
  }
  ensureCellVisible(gridCell) {
    const isGroupStickyEnabled = _isGroupRowsSticky(this.gos);
    const rowNode = this.beans.rowModel.getRow(gridCell.rowIndex);
    const skipScrollToRow = isGroupStickyEnabled && rowNode?.sticky;
    const { scrollFeature } = this.gridBodyCon;
    if (!skipScrollToRow && _missing(gridCell.rowPinned)) {
      scrollFeature.ensureIndexVisible(gridCell.rowIndex);
    }
    if (!gridCell.column.isPinned()) {
      scrollFeature.ensureColumnVisible(gridCell.column);
    }
  }
};
function getVScroll(beans) {
  return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}

// packages/ag-grid-community/src/navigation/navigationModule.ts
var KeyboardNavigationModule = {
  moduleName: "KeyboardNavigation",
  version: VERSION,
  beans: [NavigationService, CellNavigationService, HeaderNavigationService],
  apiFunctions: {
    getFocusedCell,
    clearFocusedCell,
    setFocusedCell,
    setFocusedHeader,
    tabToNextCell,
    tabToPreviousCell
  }
};

// packages/ag-grid-community/src/pagination/pageBoundsListener.ts
var PageBoundsListener = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pageBoundsListener";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    });
    this.onModelUpdated();
  }
  onModelUpdated(modelUpdatedEvent) {
    this.calculatePages();
    this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: modelUpdatedEvent?.animate ?? false,
      newData: modelUpdatedEvent?.newData ?? false,
      newPage: modelUpdatedEvent?.newPage ?? false,
      newPageSize: modelUpdatedEvent?.newPageSize ?? false,
      keepRenderedRows: modelUpdatedEvent?.keepRenderedRows ?? false
    });
  }
  calculatePages() {
    const { pageBounds, pagination, rowModel } = this.beans;
    if (pagination) {
      pagination.calculatePages();
    } else {
      pageBounds.calculateBounds(0, rowModel.getRowCount() - 1);
    }
  }
};

// packages/ag-grid-community/src/pagination/pageBoundsService.ts
var PageBoundsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pageBounds";
    this.pixelOffset = 0;
  }
  getFirstRow() {
    return this.topRowBounds?.rowIndex ?? -1;
  }
  getLastRow() {
    return this.bottomRowBounds?.rowIndex ?? -1;
  }
  getCurrentPageHeight() {
    const { topRowBounds, bottomRowBounds } = this;
    if (!topRowBounds || !bottomRowBounds) {
      return 0;
    }
    return Math.max(bottomRowBounds.rowTop + bottomRowBounds.rowHeight - topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const { topRowBounds, bottomRowBounds } = this;
    const pageFirstPixel = topRowBounds?.rowTop ?? 0;
    const pageLastPixel = bottomRowBounds ? bottomRowBounds.rowTop + bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel, pageLastPixel };
  }
  calculateBounds(topDisplayedRowIndex, bottomDisplayedRowIndex) {
    const { rowModel } = this.beans;
    const topRowBounds = rowModel.getRowBounds(topDisplayedRowIndex);
    if (topRowBounds) {
      topRowBounds.rowIndex = topDisplayedRowIndex;
    }
    this.topRowBounds = topRowBounds;
    const bottomRowBounds = rowModel.getRowBounds(bottomDisplayedRowIndex);
    if (bottomRowBounds) {
      bottomRowBounds.rowIndex = bottomDisplayedRowIndex;
    }
    this.bottomRowBounds = bottomRowBounds;
    this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    const value = this.topRowBounds?.rowTop ?? 0;
    if (this.pixelOffset === value) {
      return;
    }
    this.pixelOffset = value;
    this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" });
  }
};

// packages/ag-grid-community/src/pinnedColumns/pinnedColumnModule.css-GENERATED.ts
var pinnedColumnModuleCSS = (
  /*css*/
  `.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{display:inline-block;min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}`
);

// packages/ag-grid-community/src/gridBodyComp/rowContainer/setPinnedWidthFeature.ts
var SetPinnedWidthFeature = class extends BeanStub {
  constructor(element, isLeft) {
    super();
    this.element = element;
    this.isLeft = isLeft;
    this.getWidth = isLeft ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
  }
  postConstruct() {
    this.addManagedEventListeners({
      [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this)
    });
  }
  onPinnedWidthChanged() {
    const width = this.getWidth();
    const displayed = width > 0;
    _setDisplayed(this.element, displayed);
    _setFixedWidth(this.element, width);
  }
};

// packages/ag-grid-community/src/pinnedColumns/pinnedColumnService.ts
var PinnedColumnService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pinnedCols";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
    });
    const listener = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: listener,
      displayedColumnsWidthChanged: listener
    });
    this.addManagedPropertyListener("domLayout", listener);
  }
  checkContainerWidths() {
    const { gos, visibleCols, eventSvc } = this.beans;
    const printLayout = _isDomLayout(gos, "print");
    const newLeftWidth = printLayout ? 0 : visibleCols.getColsLeftWidth();
    const newRightWidth = printLayout ? 0 : visibleCols.getDisplayedColumnsRightWidth();
    if (newLeftWidth != this.leftWidth) {
      this.leftWidth = newLeftWidth;
      eventSvc.dispatchEvent({ type: "leftPinnedWidthChanged" });
    }
    if (newRightWidth != this.rightWidth) {
      this.rightWidth = newRightWidth;
      eventSvc.dispatchEvent({ type: "rightPinnedWidthChanged" });
    }
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
    const bodyWidth = _getInnerWidth(eBodyViewport);
    if (bodyWidth <= 50) {
      return;
    }
    let columnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
    const processUnpinnedColumns = this.gos.getCallback("processUnpinnedColumns");
    if (!columnsToRemove.length) {
      return;
    }
    if (processUnpinnedColumns) {
      const params = {
        columns: columnsToRemove,
        viewportWidth: bodyWidth
      };
      columnsToRemove = processUnpinnedColumns(params);
    }
    this.setColsPinned(columnsToRemove, null, "viewportSizeFeature");
  }
  createPinnedWidthFeature(element, isLeft) {
    return new SetPinnedWidthFeature(element, isLeft);
  }
  setColsPinned(keys, pinned, source) {
    const { colModel, colAnimation, visibleCols, gos } = this.beans;
    if (!colModel.cols) {
      return;
    }
    if (!keys?.length) {
      return;
    }
    if (_isDomLayout(gos, "print")) {
      _warn(37);
      return;
    }
    colAnimation?.start();
    let actualPinned;
    if (pinned === true || pinned === "left") {
      actualPinned = "left";
    } else if (pinned === "right") {
      actualPinned = "right";
    } else {
      actualPinned = null;
    }
    const updatedCols = [];
    keys.forEach((key) => {
      if (!key) {
        return;
      }
      const column = colModel.getCol(key);
      if (!column) {
        return;
      }
      if (column.getPinned() !== actualPinned) {
        this.setColPinned(column, actualPinned);
        updatedCols.push(column);
      }
    });
    if (updatedCols.length) {
      visibleCols.refresh(source);
      dispatchColumnPinnedEvent(this.eventSvc, updatedCols, source);
    }
    colAnimation?.finish();
  }
  initCol(column) {
    const { pinned, initialPinned } = column.colDef;
    if (pinned !== void 0) {
      this.setColPinned(column, pinned);
    } else {
      this.setColPinned(column, initialPinned);
    }
  }
  setColPinned(column, pinned) {
    if (pinned === true || pinned === "left") {
      column.pinned = "left";
    } else if (pinned === "right") {
      column.pinned = "right";
    } else {
      column.pinned = null;
    }
    column.dispatchStateUpdatedEvent("pinned");
  }
  setupHeaderPinnedWidth(ctrl) {
    const { scrollVisibleSvc } = this.beans;
    if (ctrl.pinned == null) {
      return;
    }
    const pinningLeft = ctrl.pinned === "left";
    const pinningRight = ctrl.pinned === "right";
    ctrl.hidden = true;
    const listener = () => {
      const width = pinningLeft ? this.leftWidth : this.rightWidth;
      if (width == null) {
        return;
      }
      const hidden = width == 0;
      const hiddenChanged = ctrl.hidden !== hidden;
      const isRtl = this.gos.get("enableRtl");
      const scrollbarWidth = scrollVisibleSvc.getScrollbarWidth();
      const addPaddingForScrollbar = scrollVisibleSvc.verticalScrollShowing && (isRtl && pinningLeft || !isRtl && pinningRight);
      const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
      ctrl.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
      ctrl.comp.setDisplayed(!hidden);
      if (hiddenChanged) {
        ctrl.hidden = hidden;
        ctrl.refresh();
      }
    };
    ctrl.addManagedEventListeners({
      leftPinnedWidthChanged: listener,
      rightPinnedWidthChanged: listener,
      scrollVisibilityChanged: listener,
      scrollbarWidthChanged: listener
    });
  }
  getHeaderResizeDiff(diff, column) {
    const pinned = column.getPinned();
    if (pinned) {
      const { leftWidth, rightWidth } = this;
      const bodyWidth = _getInnerWidth(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (leftWidth + rightWidth + diff > bodyWidth) {
        if (bodyWidth > leftWidth + rightWidth) {
          diff = bodyWidth - leftWidth - rightWidth;
        } else {
          return 0;
        }
      }
    }
    return diff;
  }
  getPinnedColumnsOverflowingViewport(viewportWidth) {
    const pinnedRightWidth = this.rightWidth ?? 0;
    const pinnedLeftWidth = this.leftWidth ?? 0;
    const totalPinnedWidth = pinnedRightWidth + pinnedLeftWidth;
    if (totalPinnedWidth < viewportWidth) {
      return [];
    }
    const { visibleCols } = this.beans;
    const pinnedLeftColumns = [...visibleCols.leftCols];
    const pinnedRightColumns = [...visibleCols.rightCols];
    let indexRight = 0;
    let indexLeft = 0;
    const totalWidthRemoved = 0;
    const columnsToRemove = [];
    let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
    while ((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0) {
      if (indexRight < pinnedRightColumns.length) {
        const currentColumn = pinnedRightColumns[indexRight++];
        spaceNecessary -= currentColumn.getActualWidth();
        columnsToRemove.push(currentColumn);
      }
      if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
        const currentColumn = pinnedLeftColumns[indexLeft++];
        spaceNecessary -= currentColumn.getActualWidth();
        columnsToRemove.push(currentColumn);
      }
    }
    return columnsToRemove;
  }
};

// packages/ag-grid-community/src/pinnedColumns/pinnedColumnModule.ts
var PinnedColumnModule = {
  moduleName: "PinnedColumn",
  version: VERSION,
  beans: [PinnedColumnService],
  css: [pinnedColumnModuleCSS]
};

// packages/ag-grid-community/src/rendering/ariaAnnouncementService.ts
var AriaAnnouncementService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "ariaAnnounce";
    this.descriptionContainer = null;
    this.pendingAnnouncements = /* @__PURE__ */ new Map();
    this.lastAnnouncement = "";
    this.updateAnnouncement = _debounce(this, this.updateAnnouncement.bind(this), 200);
  }
  postConstruct() {
    const beans = this.beans;
    const eDocument = _getDocument(beans);
    const div = this.descriptionContainer = eDocument.createElement("div");
    div.classList.add("ag-aria-description-container");
    _setAriaLive(div, "polite");
    _setAriaRelevant(div, "additions text");
    _setAriaAtomic(div, true);
    beans.eGridDiv.appendChild(div);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(value, key) {
    this.pendingAnnouncements.set(key, value);
    this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer) {
      return;
    }
    const value = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear();
    this.descriptionContainer.textContent = "";
    setTimeout(() => {
      if (this.isAlive() && this.descriptionContainer) {
        let valueToAnnounce = value;
        if (this.lastAnnouncement === valueToAnnounce) {
          valueToAnnounce = `${valueToAnnounce}.`;
        }
        this.lastAnnouncement = valueToAnnounce;
        this.descriptionContainer.textContent = valueToAnnounce;
      }
    }, 50);
  }
  destroy() {
    super.destroy();
    const { descriptionContainer } = this;
    if (descriptionContainer) {
      _clearElement(descriptionContainer);
      descriptionContainer.parentElement?.removeChild(descriptionContainer);
    }
    this.descriptionContainer = null;
    this.pendingAnnouncements.clear();
  }
};

// packages/ag-grid-community/src/rendering/ariaModule.ts
var AriaModule = {
  moduleName: "Aria",
  version: VERSION,
  beans: [AriaAnnouncementService]
};

// packages/ag-grid-community/src/rendering/overlays/overlayApi.ts
function showLoadingOverlay(beans) {
  beans.overlays?.showLoadingOverlay();
}
function showNoRowsOverlay(beans) {
  beans.overlays?.showNoRowsOverlay();
}
function hideOverlay(beans) {
  beans.overlays?.hideOverlay();
}

// packages/ag-grid-community/src/rendering/overlays/overlayWrapperComponent.css-GENERATED.ts
var overlayWrapperComponentCSS = (
  /*css*/
  `.ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}`
);

// packages/ag-grid-community/src/rendering/overlays/overlayWrapperComponent.ts
var OverlayWrapperComponent = class extends Component {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`
    );
    this.eOverlayWrapper = RefPlaceholder;
    this.activePromise = null;
    this.activeOverlay = null;
    this.updateListenerDestroyFunc = null;
    this.activeCssClass = null;
    this.elToFocusAfter = null;
    this.registerCSS(overlayWrapperComponentCSS);
  }
  handleKeyDown(e) {
    if (e.key !== KeyCode.TAB || e.defaultPrevented || _isStopPropagationForAgGrid(e)) {
      return;
    }
    const beans = this.beans;
    const nextEl = _findNextFocusableElement(beans, this.eOverlayWrapper, false, e.shiftKey);
    if (nextEl) {
      return;
    }
    let isFocused = false;
    if (e.shiftKey) {
      isFocused = beans.focusSvc.focusGridView(_last(beans.visibleCols.allCols), true, false);
    } else {
      isFocused = _focusNextGridCoreContainer(beans, false);
    }
    if (isFocused) {
      e.preventDefault();
    }
  }
  updateLayoutClasses(cssClass, params) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
    overlayWrapperClassList.toggle(AUTO_HEIGHT, params.autoHeight);
    overlayWrapperClassList.toggle(NORMAL, params.normal);
    overlayWrapperClassList.toggle(PRINT, params.print);
  }
  postConstruct() {
    this.createManagedBean(new LayoutFeature(this));
    this.setDisplayed(false, { skipAriaHidden: true });
    this.beans.overlays.setOverlayWrapperComp(this);
    this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(overlayWrapperCssClass) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    if (this.activeCssClass) {
      overlayWrapperClassList.toggle(this.activeCssClass, false);
    }
    this.activeCssClass = overlayWrapperCssClass;
    overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
  }
  showOverlay(overlayComponentPromise, overlayWrapperCssClass, exclusive, gridOption) {
    this.setWrapperTypeClass(overlayWrapperCssClass);
    this.destroyActiveOverlay();
    this.elToFocusAfter = null;
    this.activePromise = overlayComponentPromise;
    if (!overlayComponentPromise) {
      return;
    }
    this.setDisplayed(true, { skipAriaHidden: true });
    if (exclusive && this.isGridFocused()) {
      const activeElement = _getActiveDomElement(this.beans);
      if (activeElement && !_isNothingFocused(this.beans)) {
        this.elToFocusAfter = activeElement;
      }
    }
    overlayComponentPromise.then((comp) => {
      if (this.activePromise !== overlayComponentPromise) {
        if (this.activeOverlay !== comp) {
          this.destroyBean(comp);
          comp = null;
        }
        return;
      }
      this.activePromise = null;
      if (!comp) {
        return;
      }
      if (this.activeOverlay !== comp) {
        this.eOverlayWrapper.appendChild(comp.getGui());
        this.activeOverlay = comp;
        if (gridOption) {
          const component = comp;
          this.updateListenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue }) => {
            component.refresh?.(this.gos.addGridCommonParams({ ...currentValue ?? {} }));
          });
        }
      }
      if (exclusive && this.isGridFocused()) {
        _focusInto(this.eOverlayWrapper);
      }
    });
  }
  updateOverlayWrapperPaddingTop(padding) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${padding}px`);
  }
  destroyActiveOverlay() {
    this.activePromise = null;
    const activeOverlay = this.activeOverlay;
    if (!activeOverlay) {
      return;
    }
    let elementToFocus = this.elToFocusAfter;
    this.activeOverlay = null;
    this.elToFocusAfter = null;
    if (elementToFocus && !this.isGridFocused()) {
      elementToFocus = null;
    }
    const updateListenerDestroyFunc = this.updateListenerDestroyFunc;
    if (updateListenerDestroyFunc) {
      updateListenerDestroyFunc();
      this.updateListenerDestroyFunc = null;
    }
    this.destroyBean(activeOverlay);
    _clearElement(this.eOverlayWrapper);
    elementToFocus?.focus?.({ preventScroll: true });
  }
  hideOverlay() {
    this.destroyActiveOverlay();
    this.setDisplayed(false, { skipAriaHidden: true });
  }
  isGridFocused() {
    const activeEl = _getActiveDomElement(this.beans);
    return !!activeEl && this.beans.eGridDiv.contains(activeEl);
  }
  destroy() {
    this.elToFocusAfter = null;
    this.destroyActiveOverlay();
    this.beans.overlays.setOverlayWrapperComp(void 0);
    super.destroy();
  }
};
var OverlayWrapperSelector = {
  selector: "AG-OVERLAY-WRAPPER",
  component: OverlayWrapperComponent
};

// packages/ag-grid-community/src/rendering/overlays/overlayService.ts
var OverlayService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "overlays";
    this.state = 0 /* Hidden */;
    this.showInitialOverlay = true;
    this.wrapperPadding = 0;
  }
  postConstruct() {
    this.isClientSide = _isClientSideRowModel(this.gos);
    const updateOverlayVisibility = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: updateOverlayVisibility,
      rowDataUpdated: updateOverlayVisibility,
      gridSizeChanged: this.refreshWrapperPadding.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = false;
        this.updateOverlayVisibility();
      }
    });
    this.addManagedPropertyListener("loading", updateOverlayVisibility);
  }
  setOverlayWrapperComp(overlayWrapperComp) {
    this.eWrapper = overlayWrapperComp;
    this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 /* Hidden */ && !!this.eWrapper;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 /* Loading */ && !!this.eWrapper;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = false;
    const gos = this.gos;
    const loading = gos.get("loading");
    if (!loading && (loading !== void 0 || gos.get("suppressLoadingOverlay"))) {
      return;
    }
    this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = false;
    const gos = this.gos;
    if (gos.get("loading") || gos.get("suppressNoRowsOverlay")) {
      return;
    }
    this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    this.showInitialOverlay = false;
    if (this.gos.get("loading")) {
      _warn(99);
      return;
    }
    this.doHideOverlay();
  }
  getOverlayWrapperSelector() {
    return OverlayWrapperSelector;
  }
  getOverlayWrapperCompClass() {
    return OverlayWrapperComponent;
  }
  updateOverlayVisibility() {
    if (!this.eWrapper) {
      this.state = 0 /* Hidden */;
      return;
    }
    const {
      state,
      isClientSide,
      beans: { gos, colModel, rowModel }
    } = this;
    let loading = this.gos.get("loading");
    if (loading !== void 0) {
      this.showInitialOverlay = false;
    }
    if (this.showInitialOverlay && loading === void 0 && !gos.get("suppressLoadingOverlay")) {
      loading = !gos.get("columnDefs") || !colModel.ready || !gos.get("rowData") && isClientSide;
    }
    if (loading) {
      if (state !== 1 /* Loading */) {
        this.doShowLoadingOverlay();
      }
    } else {
      this.showInitialOverlay = false;
      if (rowModel.isEmpty() && !gos.get("suppressNoRowsOverlay") && isClientSide) {
        if (state !== 2 /* NoRows */) {
          this.doShowNoRowsOverlay();
        }
      } else if (state !== 0 /* Hidden */) {
        this.doHideOverlay();
      }
    }
  }
  doShowLoadingOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 1 /* Loading */;
    this.showOverlay(
      _getLoadingOverlayCompDetails(this.beans.userCompFactory, {}),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    );
    this.updateExclusive();
  }
  doShowNoRowsOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 2 /* NoRows */;
    this.showOverlay(
      _getNoRowsOverlayCompDetails(this.beans.userCompFactory, {}),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    );
    this.updateExclusive();
  }
  doHideOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 0 /* Hidden */;
    this.eWrapper.hideOverlay();
    this.updateExclusive();
  }
  showOverlay(compDetails, wrapperCssClass, gridOption) {
    const promise = compDetails?.newAgStackInstance() ?? null;
    this.eWrapper?.showOverlay(promise, wrapperCssClass, this.isExclusive(), gridOption);
    this.refreshWrapperPadding();
  }
  updateExclusive() {
    const wasExclusive = this.exclusive;
    this.exclusive = this.isExclusive();
    if (this.exclusive !== wasExclusive) {
      this.eventSvc.dispatchEvent({
        type: "overlayExclusiveChanged"
      });
    }
  }
  refreshWrapperPadding() {
    const eWrapper = this.eWrapper;
    if (!eWrapper) {
      return;
    }
    let newPadding = 0;
    if (this.state === 2 /* NoRows */) {
      const headerCtrl = this.beans.ctrlsSvc.get("gridHeaderCtrl");
      const headerHeight = headerCtrl?.headerHeight || 0;
      newPadding = headerHeight;
    } else if (this.wrapperPadding !== 0) {
      newPadding = 0;
    }
    if (this.wrapperPadding === newPadding) {
      return;
    }
    this.wrapperPadding = newPadding;
    eWrapper.updateOverlayWrapperPaddingTop(newPadding);
  }
};

// packages/ag-grid-community/src/rendering/overlays/overlayModule.ts
var OverlayModule = {
  moduleName: "Overlay",
  version: VERSION,
  userComponents: {
    agLoadingOverlay: LoadingOverlayComponent2,
    agNoRowsOverlay: NoRowsOverlayComponent2
  },
  apiFunctions: {
    showLoadingOverlay,
    showNoRowsOverlay,
    hideOverlay
  },
  beans: [OverlayService]
};

// packages/ag-grid-community/src/rendering/rowContainerHeightService.ts
var RowContainerHeightService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowContainerHeight";
    // the scrollY position
    this.scrollY = 0;
    // how tall the body is
    this.uiBodyHeight = 0;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) });
    this.maxDivHeight = _getMaxDivHeight();
    _logIfDebug(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  updateOffset() {
    if (!this.stretching) {
      return;
    }
    const newScrollY = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top;
    const newBodyHeight = this.getUiBodyHeight();
    const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
    if (atLeastOneChanged) {
      this.scrollY = newScrollY;
      this.uiBodyHeight = newBodyHeight;
      this.calculateOffset();
    }
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight);
    this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
    this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const scrollPercent = this.scrollY / this.maxScrollY;
    const divStretchOffset = scrollPercent * this.pixelsToShave;
    _logIfDebug(
      this.gos,
      `RowContainerHeightService - Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`
    );
    this.setDivStretchOffset(divStretchOffset);
  }
  setUiContainerHeight(height) {
    if (height !== this.uiContainerHeight) {
      this.uiContainerHeight = height;
      this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" });
    }
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight);
    this.pixelsToShave = 0;
    this.setDivStretchOffset(0);
  }
  setDivStretchOffset(newOffset) {
    const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
    if (this.divStretchOffset === newOffsetFloor) {
      return;
    }
    this.divStretchOffset = newOffsetFloor;
    this.eventSvc.dispatchEvent({ type: "heightScaleChanged" });
  }
  setModelHeight(modelHeight) {
    this.modelHeight = modelHeight;
    this.stretching = modelHeight != null && // null happens when in print layout
    this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
    if (this.stretching) {
      this.calculateOffset();
    } else {
      this.clearOffset();
    }
  }
  getRealPixelPosition(modelPixel) {
    return modelPixel - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const pos = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
    return pos.bottom - pos.top;
  }
  getScrollPositionForPixel(rowTop) {
    if (this.pixelsToShave <= 0) {
      return rowTop;
    }
    const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
    const scrollPercent = rowTop / modelMaxScroll;
    const scrollPixel = this.maxScrollY * scrollPercent;
    return scrollPixel;
  }
};

// packages/ag-grid-community/src/rendering/rowRenderer.ts
var ROW_ANIMATION_TIMEOUT = 400;
var RowRenderer = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowRenderer";
    this.destroyFuncsForColumnListeners = [];
    // map of row ids to row objects. keeps track of which elements
    // are rendered for which rows in the dom.
    this.rowCtrlsByRowIndex = {};
    this.zombieRowCtrls = {};
    this.allRowCtrls = [];
    this.topRowCtrls = [];
    this.bottomRowCtrls = [];
    // we only allow one refresh at a time, otherwise the internal memory structure here
    // will get messed up. this can happen if the user has a cellRenderer, and inside the
    // renderer they call an API method that results in another pass of the refresh,
    // then it will be trying to draw rows in the middle of a refresh.
    this.refreshInProgress = false;
    this.dataFirstRenderedFired = false;
    this.setupRangeSelectionListeners = () => {
      const onCellSelectionChanged = () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellSelectionChanged());
      };
      const onColumnMovedPinnedVisible = () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
      };
      const addCellSelectionListeners = () => {
        this.eventSvc.addEventListener("cellSelectionChanged", onCellSelectionChanged);
        this.eventSvc.addEventListener("columnMoved", onColumnMovedPinnedVisible);
        this.eventSvc.addEventListener("columnPinned", onColumnMovedPinnedVisible);
        this.eventSvc.addEventListener("columnVisible", onColumnMovedPinnedVisible);
      };
      const removeCellSelectionListeners = () => {
        this.eventSvc.removeEventListener("cellSelectionChanged", onCellSelectionChanged);
        this.eventSvc.removeEventListener("columnMoved", onColumnMovedPinnedVisible);
        this.eventSvc.removeEventListener("columnPinned", onColumnMovedPinnedVisible);
        this.eventSvc.removeEventListener("columnVisible", onColumnMovedPinnedVisible);
      };
      this.addDestroyFunc(() => removeCellSelectionListeners());
      this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        const isEnabled = _isCellSelectionEnabled(this.gos);
        if (isEnabled) {
          addCellSelectionListeners();
        } else {
          removeCellSelectionListeners();
        }
      });
      const cellSelectionEnabled = _isCellSelectionEnabled(this.gos);
      if (cellSelectionEnabled) {
        addCellSelectionListeners();
      }
    };
  }
  wireBeans(beans) {
    this.pageBounds = beans.pageBounds;
    this.colModel = beans.colModel;
    this.pinnedRowModel = beans.pinnedRowModel;
    this.rowModel = beans.rowModel;
    this.focusSvc = beans.focusSvc;
    this.rowContainerHeight = beans.rowContainerHeight;
    this.ctrlsSvc = beans.ctrlsSvc;
  }
  postConstruct() {
    this.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
      this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    });
    this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged());
    this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw());
    this.addManagedPropertyListener("suppressCellFocus", (e) => this.onSuppressCellFocusChanged(e.currentValue));
    this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    );
    this.addManagedPropertyListener("cellSelection", ({ currentValue, previousValue }) => {
      if (!previousValue && currentValue || previousValue && !currentValue) {
        this.redrawRows();
      }
    });
    const { stickyRowSvc, gos } = this.beans;
    if (stickyRowSvc) {
      this.stickyRowFeature = stickyRowSvc.createStickyRowFeature(
        this,
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      );
    } else {
      const gridBodyCtrl = this.gridBodyCtrl;
      gridBodyCtrl.setStickyTopHeight(0);
      gridBodyCtrl.setStickyBottomHeight(0);
    }
    this.registerCellEventListeners();
    this.initialiseCache();
    this.printLayout = _isDomLayout(gos, "print");
    this.embedFullWidthRows = this.printLayout || gos.get("embedFullWidthRows");
    this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const countProp = this.getKeepDetailRowsCount();
      const count = countProp != null ? countProp : 3;
      this.cachedRowCtrls = new RowCtrlCache(count);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature?.stickyTopRowCtrls ?? [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature?.stickyBottomRowCtrls ?? [];
  }
  updateAllRowCtrls() {
    const liveList = Object.values(this.rowCtrlsByRowIndex);
    const zombieList = Object.values(this.zombieRowCtrls);
    const cachedList = this.cachedRowCtrls?.getEntries() ?? [];
    if (zombieList.length > 0 || cachedList.length > 0) {
      this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];
    } else {
      this.allRowCtrls = liveList;
    }
  }
  onCellFocusChanged(event) {
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
    this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onSuppressCellFocusChanged(suppressCellFocus));
    this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onSuppressCellFocusChanged(suppressCellFocus));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (event) => {
        this.onCellFocusChanged(event);
      },
      cellFocusCleared: () => this.onCellFocusChanged(),
      flashCells: (event) => {
        const { cellFlashSvc } = this.beans;
        if (cellFlashSvc) {
          this.getAllCellCtrls().forEach((cellCtrl) => cellFlashSvc.onFlashCells(cellCtrl, event));
        }
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        if (this.printLayout) {
          this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
        }
      }
    });
    this.setupRangeSelectionListeners();
    this.refreshListenersToColumnsForCellComps();
    this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    });
    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((func) => func());
    this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners();
    const cols = this.colModel.getCols();
    cols.forEach((col) => {
      const forEachCellWithThisCol = (callback) => {
        this.getAllCellCtrls().forEach((cellCtrl) => {
          if (cellCtrl.column === col) {
            callback(cellCtrl);
          }
        });
      };
      const leftChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
      };
      const widthChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
      };
      const firstRightPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
      };
      const lastLeftPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
      };
      const colDefChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
      };
      col.addEventListener("leftChanged", leftChangedListener);
      col.addEventListener("widthChanged", widthChangedListener);
      col.addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
      col.addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
      col.addEventListener("colDefChanged", colDefChangedListener);
      this.destroyFuncsForColumnListeners.push(() => {
        col.removeEventListener("leftChanged", leftChangedListener);
        col.removeEventListener("widthChanged", widthChangedListener);
        col.removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
        col.removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
        col.removeEventListener("colDefChanged", colDefChangedListener);
      });
    });
  }
  onDomLayoutChanged() {
    const printLayout = _isDomLayout(this.gos, "print");
    const embedFullWidthRows = printLayout || this.gos.get("embedFullWidthRows");
    const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
    this.printLayout = printLayout;
    this.embedFullWidthRows = embedFullWidthRows;
    if (destroyRows) {
      this.redrawAfterModelUpdate({ domLayoutChanged: true });
    }
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0;
    this.lastRenderedRow = -1;
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove);
  }
  onPageLoaded(event) {
    const params = {
      recycleRows: event.keepRenderedRows,
      animate: event.animate,
      newData: event.newData,
      newPage: event.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: true
    };
    this.redrawAfterModelUpdate(params);
  }
  /**
   * @param column AgColumn
   * @returns An array with HTMLElement for every cell of the column passed as param.
   * If the cell is spanning across multiple columns, it only returns the html element
   * if the column passed is the first column of the span (used for auto width calculation).
   */
  getAllCellsNotSpanningForColumn(column) {
    const res = [];
    this.getAllRowCtrls().forEach((rowCtrl) => {
      const eCell = rowCtrl.getCellCtrl(column, true)?.eGui;
      if (eCell) {
        res.push(eCell);
      }
    });
    return res;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, "top");
    this.refreshFloatingRows(this.bottomRowCtrls, "bottom");
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(rowCtrls, floating) {
    const { pinnedRowModel, beans, printLayout } = this;
    const rowCtrlMap = Object.fromEntries(rowCtrls.map((ctrl) => [ctrl.rowNode.id, ctrl]));
    pinnedRowModel?.forEachPinnedRow(floating, (node, i) => {
      const rowCtrl = rowCtrls[i];
      const rowCtrlDoesNotExist = rowCtrl && pinnedRowModel.getPinnedRowById(rowCtrl.rowNode.id, floating) === void 0;
      if (rowCtrlDoesNotExist) {
        rowCtrl.destroyFirstPass();
        rowCtrl.destroySecondPass();
      }
      if (node.id in rowCtrlMap) {
        rowCtrls[i] = rowCtrlMap[node.id];
        delete rowCtrlMap[node.id];
      } else {
        rowCtrls[i] = new RowCtrl(node, beans, false, false, printLayout);
      }
    });
    const rowNodeCount = (floating === "top" ? pinnedRowModel?.getPinnedTopRowCount() : pinnedRowModel?.getPinnedBottomRowCount()) ?? 0;
    rowCtrls.length = rowNodeCount;
  }
  onPinnedRowDataChanged() {
    const params = {
      recycleRows: true
    };
    this.redrawAfterModelUpdate(params);
  }
  redrawRow(rowNode, suppressEvent = false) {
    if (rowNode.sticky) {
      this.stickyRowFeature?.refreshStickyNode(rowNode);
    } else if (this.cachedRowCtrls?.has(rowNode)) {
      this.cachedRowCtrls.removeRow(rowNode);
      return;
    } else {
      const destroyAndRecreateCtrl = (dataStruct) => {
        const ctrl = dataStruct[rowNode.rowIndex];
        if (!ctrl) {
          return;
        }
        if (ctrl.rowNode !== rowNode) {
          return;
        }
        ctrl.destroyFirstPass();
        ctrl.destroySecondPass();
        dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
      };
      switch (rowNode.rowPinned) {
        case "top":
          destroyAndRecreateCtrl(this.topRowCtrls);
          break;
        case "bottom":
          destroyAndRecreateCtrl(this.bottomRowCtrls);
          break;
        default:
          destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
          this.updateAllRowCtrls();
      }
    }
    if (!suppressEvent) {
      this.dispatchDisplayedRowsChanged(false);
    }
  }
  redrawRows(rowNodes) {
    const partialRefresh = rowNodes != null;
    if (partialRefresh) {
      rowNodes?.forEach((node) => this.redrawRow(node, true));
      this.dispatchDisplayedRowsChanged(false);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(params) {
    const focusedCell = params?.suppressKeepFocus ? null : this.focusSvc.getFocusCellToUseAfterRefresh();
    if (focusedCell == null) {
      return null;
    }
    const activeElement = _getActiveDomElement(this.beans);
    const cellDomData = _getDomData(this.gos, activeElement, DOM_DATA_KEY_CELL_CTRL);
    const rowDomData = _getDomData(this.gos, activeElement, DOM_DATA_KEY_ROW_CTRL);
    const gridElementFocused = cellDomData || rowDomData;
    return gridElementFocused ? focusedCell : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(params = {}) {
    this.getLockOnRefresh();
    const focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);
    this.updateContainerHeights();
    this.scrollToTopIfNewData(params);
    const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
    const animate = params.animate && _isAnimateRows(this.gos);
    const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
    if (!recycleRows) {
      this.removeAllRowComps();
    }
    this.workOutFirstAndLastRowsToRender();
    const { stickyRowFeature } = this;
    if (stickyRowFeature) {
      stickyRowFeature.checkStickyRows();
      const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
      if (extraHeight) {
        this.updateContainerHeights(extraHeight);
      }
    }
    this.recycleRows(rowsToRecycle, animate);
    this.gridBodyCtrl.updateRowCount();
    if (!params.onlyBody) {
      this.refreshFloatingRowComps();
    }
    this.dispatchDisplayedRowsChanged();
    if (focusedCell != null) {
      this.restoreFocusedCell(focusedCell);
    }
    this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(params) {
    const scrollToTop = params.newData || params.newPage;
    const suppressScrollToTop = this.gos.get("suppressScrollOnNewData");
    if (scrollToTop && !suppressScrollToTop) {
      this.gridBodyCtrl.scrollFeature.scrollToTop();
      this.stickyRowFeature?.resetOffsets();
    }
  }
  updateContainerHeights(additionalHeight = 0) {
    const { rowContainerHeight } = this;
    if (this.printLayout) {
      rowContainerHeight.setModelHeight(null);
      return;
    }
    let containerHeight = this.pageBounds.getCurrentPageHeight();
    if (containerHeight === 0) {
      containerHeight = 1;
    }
    rowContainerHeight.setModelHeight(containerHeight + additionalHeight);
  }
  getLockOnRefresh() {
    if (this.refreshInProgress) {
      throw new Error(_errMsg(252));
    }
    this.refreshInProgress = true;
    this.beans.frameworkOverrides.getLockOnRefresh?.();
  }
  releaseLockOnRefresh() {
    this.refreshInProgress = false;
    this.beans.frameworkOverrides.releaseLockOnRefresh?.();
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(cellPosition) {
    if (!cellPosition) {
      return;
    }
    this.focusSvc.restoreFocusedCell(cellPosition, () => {
      this.onCellFocusChanged(
        this.gos.addGridCommonParams({
          rowIndex: cellPosition.rowIndex,
          column: cellPosition.column,
          rowPinned: cellPosition.rowPinned,
          forceBrowserFocus: true,
          preventScrollOnBrowserFocus: true,
          type: "cellFocused"
        })
      );
    });
  }
  getAllCellCtrls() {
    const res = [];
    const rowCtrls = this.getAllRowCtrls();
    const rowCtrlsLength = rowCtrls.length;
    for (let i = 0; i < rowCtrlsLength; i++) {
      const cellCtrls = rowCtrls[i].getAllCellCtrls();
      const cellCtrlsLength = cellCtrls.length;
      for (let j = 0; j < cellCtrlsLength; j++) {
        res.push(cellCtrls[j]);
      }
    }
    return res;
  }
  getAllRowCtrls() {
    const stickyTopRowCtrls = this.getStickyTopRowCtrls();
    const stickyBottomRowCtrls = this.getStickyBottomRowCtrls();
    const res = [
      ...this.topRowCtrls,
      ...this.bottomRowCtrls,
      ...stickyTopRowCtrls,
      ...stickyBottomRowCtrls,
      ...Object.values(this.rowCtrlsByRowIndex)
    ];
    return res;
  }
  addRenderedRowListener(eventName, rowIndex, callback) {
    const rowComp = this.rowCtrlsByRowIndex[rowIndex];
    if (rowComp) {
      rowComp.addEventListener(eventName, callback);
    }
  }
  refreshCells(params = {}) {
    const refreshCellParams = {
      forceRefresh: params.force,
      newData: false,
      suppressFlash: params.suppressFlash
    };
    for (const cellCtrl of this.getCellCtrls(params.rowNodes, params.columns)) {
      cellCtrl.refreshOrDestroyCell(refreshCellParams);
    }
    this.refreshFullWidth(params.rowNodes);
  }
  refreshFullWidth(rowNodes) {
    if (!rowNodes) {
      return;
    }
    let cellFocused = null;
    if (this.stickyRowFeature) {
      cellFocused = this.getCellToRestoreFocusToAfterRefresh() || null;
    }
    for (const rowCtrl of this.getRowCtrls(rowNodes)) {
      if (!rowCtrl.isFullWidth()) {
        continue;
      }
      const refreshed = rowCtrl.refreshFullWidth();
      if (!refreshed) {
        this.redrawRow(rowCtrl.rowNode, true);
      }
    }
    this.dispatchDisplayedRowsChanged(false);
    if (cellFocused) {
      this.restoreFocusedCell(cellFocused);
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(rowNodes) {
    const rowIdsMap = mapRowNodes(rowNodes);
    const allRowCtrls = this.getAllRowCtrls();
    if (!rowNodes || !rowIdsMap) {
      return allRowCtrls;
    }
    return allRowCtrls.filter((rowCtrl) => {
      const rowNode = rowCtrl.rowNode;
      return isRowInMap(rowNode, rowIdsMap);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(rowNodes, columns) {
    let colIdsMap;
    if (_exists(columns)) {
      colIdsMap = {};
      columns.forEach((colKey) => {
        const column = this.colModel.getCol(colKey);
        if (_exists(column)) {
          colIdsMap[column.getId()] = true;
        }
      });
    }
    const res = [];
    this.getRowCtrls(rowNodes).forEach((rowCtrl) => {
      rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
        const colId = cellCtrl.column.getId();
        const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
        if (excludeColFromRefresh) {
          return;
        }
        res.push(cellCtrl);
      });
    });
    return res;
  }
  destroy() {
    this.removeAllRowComps(true);
    super.destroy();
  }
  removeAllRowComps(suppressAnimation = false) {
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove, suppressAnimation);
    this.stickyRowFeature?.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const stubNodeIndexes = [];
    for (const [index, rowCtrl] of Object.entries(this.rowCtrlsByRowIndex)) {
      const stubNode = rowCtrl.rowNode.id == null;
      if (stubNode) {
        stubNodeIndexes.push(index);
      }
    }
    this.removeRowCtrls(stubNodeIndexes);
    const ctrlsByIdMap = {};
    for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
      const rowNode = rowCtrl.rowNode;
      ctrlsByIdMap[rowNode.id] = rowCtrl;
    }
    this.rowCtrlsByRowIndex = {};
    return ctrlsByIdMap;
  }
  // takes array of row indexes
  removeRowCtrls(rowsToRemove, suppressAnimation = false) {
    rowsToRemove.forEach((indexToRemove) => {
      const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
      if (rowCtrl) {
        rowCtrl.destroyFirstPass(suppressAnimation);
        rowCtrl.destroySecondPass();
      }
      delete this.rowCtrlsByRowIndex[indexToRemove];
    });
  }
  onBodyScroll(e) {
    if (e.direction !== "vertical") {
      return;
    }
    this.redraw({ afterScroll: true });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(params = {}) {
    const { afterScroll } = params;
    let cellFocused;
    const stickyRowFeature = this.stickyRowFeature;
    if (stickyRowFeature) {
      cellFocused = this.getCellToRestoreFocusToAfterRefresh() || void 0;
    }
    const oldFirstRow = this.firstRenderedRow;
    const oldLastRow = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let hasStickyRowChanges = false;
    if (stickyRowFeature) {
      hasStickyRowChanges = stickyRowFeature.checkStickyRows();
      const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
      if (extraHeight) {
        this.updateContainerHeights(extraHeight);
      }
    }
    const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
    if (afterScroll && !hasStickyRowChanges && !rangeChanged) {
      return;
    }
    this.getLockOnRefresh();
    this.recycleRows(null, false, afterScroll);
    this.releaseLockOnRefresh();
    this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
    if (cellFocused != null) {
      const newFocusedCell = this.getCellToRestoreFocusToAfterRefresh();
      if (cellFocused != null && newFocusedCell == null) {
        this.beans.animationFrameSvc?.flushAllFrames();
        this.restoreFocusedCell(cellFocused);
      }
    }
  }
  removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
    const indexesToDrawMap = {};
    indexesToDraw.forEach((index) => indexesToDrawMap[index] = true);
    const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
    const indexesNotToDraw = existingIndexes.filter((index) => !indexesToDrawMap[index]);
    this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
  }
  calculateIndexesToDraw(rowsToRecycle) {
    const indexesToDraw = [];
    for (let i = this.firstRenderedRow; i <= this.lastRenderedRow; i++) {
      indexesToDraw.push(i);
    }
    const checkRowToDraw = (rowComp) => {
      const index = rowComp.rowNode.rowIndex;
      if (index == null) {
        return;
      }
      if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
        if (this.doNotUnVirtualiseRow(rowComp)) {
          indexesToDraw.push(index);
        }
      }
    };
    for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
      checkRowToDraw(rowCtrl);
    }
    if (rowsToRecycle) {
      for (const rowCtrl of Object.values(rowsToRecycle)) {
        checkRowToDraw(rowCtrl);
      }
    }
    indexesToDraw.sort((a, b) => a - b);
    const ret = [];
    for (let i = 0; i < indexesToDraw.length; i++) {
      const currRow = indexesToDraw[i];
      const rowNode = this.rowModel.getRow(currRow);
      if (rowNode && !rowNode.sticky) {
        ret.push(currRow);
      }
    }
    return ret;
  }
  recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
    const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
    if (this.printLayout || afterScroll) {
      animate = false;
    }
    this.removeRowCompsNotToDraw(indexesToDraw, !animate);
    const rowCtrls = [];
    indexesToDraw.forEach((rowIndex) => {
      const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
      if (_exists(rowCtrl)) {
        rowCtrls.push(rowCtrl);
      }
    });
    if (rowsToRecycle) {
      const { animationFrameSvc } = this.beans;
      const useAnimationFrame = animationFrameSvc && afterScroll && !this.gos.get("suppressAnimationFrame") && !this.printLayout;
      if (useAnimationFrame) {
        animationFrameSvc.addDestroyTask(() => {
          this.destroyRowCtrls(rowsToRecycle, animate);
          this.updateAllRowCtrls();
          this.dispatchDisplayedRowsChanged();
        });
      } else {
        this.destroyRowCtrls(rowsToRecycle, animate);
      }
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(afterScroll = false) {
    this.eventSvc.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll
    });
  }
  onDisplayedColumnsChanged() {
    const { visibleCols } = this.beans;
    const pinningLeft = visibleCols.isPinningLeft();
    const pinningRight = visibleCols.isPinningRight();
    const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
    if (atLeastOneChanged) {
      this.pinningLeft = pinningLeft;
      this.pinningRight = pinningRight;
      if (this.embedFullWidthRows) {
        this.redrawFullWidthEmbeddedRows();
      }
    }
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const rowsToRemove = [];
    this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
      const rowIndex = fullWidthCtrl.rowNode.rowIndex;
      rowsToRemove.push(rowIndex.toString());
    });
    this.refreshFloatingRowComps();
    this.removeRowCtrls(rowsToRemove);
    this.redraw({ afterScroll: true });
  }
  getFullWidthRowCtrls(rowNodes) {
    const rowNodesMap = mapRowNodes(rowNodes);
    return this.getAllRowCtrls().filter((rowCtrl) => {
      if (!rowCtrl.isFullWidth()) {
        return false;
      }
      const rowNode = rowCtrl.rowNode;
      if (rowNodesMap != null && !isRowInMap(rowNode, rowNodesMap)) {
        return false;
      }
      return true;
    });
  }
  createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
    let rowNode;
    let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
    if (!rowCtrl) {
      rowNode = this.rowModel.getRow(rowIndex);
      if (_exists(rowNode) && _exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
        rowCtrl = rowsToRecycle[rowNode.id];
        rowsToRecycle[rowNode.id] = null;
      }
    }
    const creatingNewRowCtrl = !rowCtrl;
    if (creatingNewRowCtrl) {
      if (!rowNode) {
        rowNode = this.rowModel.getRow(rowIndex);
      }
      if (_exists(rowNode)) {
        rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
      } else {
        return;
      }
    }
    if (rowNode) {
      rowNode.alreadyRendered = true;
    }
    this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
    return rowCtrl;
  }
  destroyRowCtrls(rowCtrlsMap, animate) {
    const executeInAWhileFuncs = [];
    if (rowCtrlsMap) {
      for (const rowCtrl of Object.values(rowCtrlsMap)) {
        if (!rowCtrl) {
          continue;
        }
        if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
          this.cachedRowCtrls.addRow(rowCtrl);
          continue;
        }
        rowCtrl.destroyFirstPass(!animate);
        if (animate) {
          const instanceId = rowCtrl.instanceId;
          this.zombieRowCtrls[instanceId] = rowCtrl;
          executeInAWhileFuncs.push(() => {
            rowCtrl.destroySecondPass();
            delete this.zombieRowCtrls[instanceId];
          });
        } else {
          rowCtrl.destroySecondPass();
        }
      }
    }
    if (animate) {
      executeInAWhileFuncs.push(() => {
        this.updateAllRowCtrls();
        this.dispatchDisplayedRowsChanged();
      });
      window.setTimeout(() => executeInAWhileFuncs.forEach((func) => func()), ROW_ANIMATION_TIMEOUT);
    }
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const rowsToBuffer = this.getRowBuffer();
    const defaultRowHeight = _getRowHeightAsNumber(this.beans);
    return rowsToBuffer * defaultRowHeight;
  }
  workOutFirstAndLastRowsToRender() {
    const { rowContainerHeight, pageBounds, rowModel } = this;
    rowContainerHeight.updateOffset();
    let newFirst;
    let newLast;
    if (!rowModel.isRowsToRender()) {
      newFirst = 0;
      newLast = -1;
    } else if (this.printLayout) {
      this.beans.environment.refreshRowHeightVariable();
      newFirst = pageBounds.getFirstRow();
      newLast = pageBounds.getLastRow();
    } else {
      const bufferPixels = this.getRowBufferInPixels();
      const scrollFeature = this.ctrlsSvc.getScrollFeature();
      const suppressRowVirtualisation = this.gos.get("suppressRowVirtualisation");
      let rowHeightsChanged = false;
      let firstPixel;
      let lastPixel;
      do {
        const paginationOffset = pageBounds.getPixelOffset();
        const { pageFirstPixel, pageLastPixel } = pageBounds.getCurrentPagePixelRange();
        const divStretchOffset = rowContainerHeight.divStretchOffset;
        const bodyVRange = scrollFeature.getVScrollPosition();
        const bodyTopPixel = bodyVRange.top;
        const bodyBottomPixel = bodyVRange.bottom;
        if (suppressRowVirtualisation) {
          firstPixel = pageFirstPixel + divStretchOffset;
          lastPixel = pageLastPixel + divStretchOffset;
        } else {
          firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
          lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
        }
        this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
        this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
        rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
      } while (rowHeightsChanged);
      let firstRowIndex = rowModel.getRowIndexAtPixel(firstPixel);
      let lastRowIndex = rowModel.getRowIndexAtPixel(lastPixel);
      const pageFirstRow = pageBounds.getFirstRow();
      const pageLastRow = pageBounds.getLastRow();
      if (firstRowIndex < pageFirstRow) {
        firstRowIndex = pageFirstRow;
      }
      if (lastRowIndex > pageLastRow) {
        lastRowIndex = pageLastRow;
      }
      newFirst = firstRowIndex;
      newLast = lastRowIndex;
    }
    const rowLayoutNormal = _isDomLayout(this.gos, "normal");
    const suppressRowCountRestriction = this.gos.get("suppressMaxRenderedRowRestriction");
    const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
    if (rowLayoutNormal && !suppressRowCountRestriction) {
      if (newLast - newFirst > rowBufferMaxSize) {
        newLast = newFirst + rowBufferMaxSize;
      }
    }
    const firstDiffers = newFirst !== this.firstRenderedRow;
    const lastDiffers = newLast !== this.lastRenderedRow;
    if (firstDiffers || lastDiffers) {
      this.firstRenderedRow = newFirst;
      this.lastRenderedRow = newLast;
      this.eventSvc.dispatchEvent({
        type: "viewportChanged",
        firstRow: newFirst,
        lastRow: newLast
      });
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired) {
      return;
    }
    this.dataFirstRenderedFired = true;
    window.requestAnimationFrame(() => {
      this.beans.eventSvc.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
    const pinnedRowHeightsChanged = this.pinnedRowModel?.ensureRowHeightsValid();
    const stickyHeightsChanged = this.stickyRowFeature?.ensureRowHeightsValid();
    const { pageBounds, rowModel } = this;
    const rowModelHeightsChanged = rowModel.ensureRowHeightsValid(
      topPixel,
      bottomPixel,
      pageBounds.getFirstRow(),
      pageBounds.getLastRow()
    );
    if (rowModelHeightsChanged || stickyHeightsChanged) {
      this.eventSvc.dispatchEvent({
        type: "recalculateRowBounds"
      });
    }
    if (stickyHeightsChanged || rowModelHeightsChanged || pinnedRowHeightsChanged) {
      this.updateContainerHeights();
      return true;
    }
    return false;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(rowCtrl) {
    const REMOVE_ROW = false;
    const KEEP_ROW = true;
    const rowNode = rowCtrl.rowNode;
    const rowHasFocus = this.focusSvc.isRowNodeFocused(rowNode);
    const rowIsEditing = rowCtrl.editing;
    const rowIsDetail = rowNode.detail;
    const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
    if (!mightWantToKeepRow) {
      return REMOVE_ROW;
    }
    const rowNodePresent = this.isRowPresent(rowNode);
    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
  }
  isRowPresent(rowNode) {
    if (!this.rowModel.isRowPresent(rowNode)) {
      return false;
    }
    return this.beans.pagination?.isRowPresent(rowNode) ?? true;
  }
  createRowCon(rowNode, animate, afterScroll) {
    const rowCtrlFromCache = this.cachedRowCtrls?.getRow(rowNode) ?? null;
    if (rowCtrlFromCache) {
      return rowCtrlFromCache;
    }
    const suppressAnimationFrame = this.gos.get("suppressAnimationFrame");
    const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout && !!this.beans.animationFrameSvc;
    const res = new RowCtrl(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
    return res;
  }
  getRenderedNodes() {
    const renderedRows = this.rowCtrlsByRowIndex;
    return Object.values(renderedRows).map((rowCtrl) => rowCtrl.rowNode);
  }
  getRowByPosition(rowPosition) {
    let rowCtrl;
    const { rowIndex } = rowPosition;
    switch (rowPosition.rowPinned) {
      case "top":
        rowCtrl = this.topRowCtrls[rowIndex];
        break;
      case "bottom":
        rowCtrl = this.bottomRowCtrls[rowIndex];
        break;
      default:
        rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        if (!rowCtrl) {
          rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
          if (!rowCtrl) {
            rowCtrl = this.getStickyBottomRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
          }
        }
        break;
    }
    return rowCtrl;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(startIndex, endIndex) {
    const parentClosed = startIndex == null || endIndex == null;
    if (parentClosed) {
      return false;
    }
    const blockAfterViewport = startIndex > this.lastRenderedRow;
    const blockBeforeViewport = endIndex < this.firstRenderedRow;
    const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
    return blockInsideViewport;
  }
};
var RowCtrlCache = class {
  constructor(maxCount) {
    // map for fast access
    this.entriesMap = {};
    // list for keeping order
    this.entriesList = [];
    this.maxCount = maxCount;
  }
  addRow(rowCtrl) {
    this.entriesMap[rowCtrl.rowNode.id] = rowCtrl;
    this.entriesList.push(rowCtrl);
    rowCtrl.setCached(true);
    if (this.entriesList.length > this.maxCount) {
      const rowCtrlToDestroy = this.entriesList[0];
      rowCtrlToDestroy.destroyFirstPass();
      rowCtrlToDestroy.destroySecondPass();
      this.removeFromCache(rowCtrlToDestroy);
    }
  }
  getRow(rowNode) {
    if (rowNode == null || rowNode.id == null) {
      return null;
    }
    const res = this.entriesMap[rowNode.id];
    if (!res) {
      return null;
    }
    this.removeFromCache(res);
    res.setCached(false);
    const rowNodeMismatch = res.rowNode != rowNode;
    return rowNodeMismatch ? null : res;
  }
  has(rowNode) {
    return this.entriesMap[rowNode.id] != null;
  }
  removeRow(rowNode) {
    const rowNodeId = rowNode.id;
    const ctrl = this.entriesMap[rowNodeId];
    delete this.entriesMap[rowNodeId];
    _removeFromArray(this.entriesList, ctrl);
  }
  removeFromCache(rowCtrl) {
    const rowNodeId = rowCtrl.rowNode.id;
    delete this.entriesMap[rowNodeId];
    _removeFromArray(this.entriesList, rowCtrl);
  }
  getEntries() {
    return this.entriesList;
  }
};
function mapRowNodes(rowNodes) {
  if (!rowNodes) {
    return;
  }
  const res = {
    top: {},
    bottom: {},
    normal: {}
  };
  rowNodes.forEach((rowNode) => {
    const id = rowNode.id;
    switch (rowNode.rowPinned) {
      case "top":
        res.top[id] = rowNode;
        break;
      case "bottom":
        res.bottom[id] = rowNode;
        break;
      default:
        res.normal[id] = rowNode;
        break;
    }
  });
  return res;
}
function isRowInMap(rowNode, rowIdsMap) {
  const id = rowNode.id;
  const floating = rowNode.rowPinned;
  switch (floating) {
    case "top":
      return rowIdsMap.top[id] != null;
    case "bottom":
      return rowIdsMap.bottom[id] != null;
    default:
      return rowIdsMap.normal[id] != null;
  }
}

// packages/ag-grid-community/src/sort/rowNodeSorter.ts
var RowNodeSorter = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowNodeSorter";
  }
  postConstruct() {
    const { gos } = this;
    this.isAccentedSort = gos.get("accentedSort");
    this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos);
    this.addManagedPropertyListener(
      "accentedSort",
      (propChange) => this.isAccentedSort = propChange.currentValue
    );
    this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos)
    );
  }
  doFullSort(rowNodes, sortOptions) {
    const sortedRowNodes = rowNodes.map((rowNode, currentPos) => ({
      currentPos,
      rowNode
    }));
    sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
    return sortedRowNodes.map((item) => item.rowNode);
  }
  compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
    const nodeA = sortedNodeA.rowNode;
    const nodeB = sortedNodeB.rowNode;
    for (let i = 0, len = sortOptions.length; i < len; i++) {
      const sortOption = sortOptions[i];
      const isDescending = sortOption.sort === "desc";
      const valueA = this.getValue(nodeA, sortOption.column);
      const valueB = this.getValue(nodeB, sortOption.column);
      let comparatorResult;
      const providedComparator = this.getComparator(sortOption, nodeA);
      if (providedComparator) {
        comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
      } else {
        comparatorResult = _defaultComparator(valueA, valueB, this.isAccentedSort);
      }
      const validResult = !isNaN(comparatorResult);
      if (validResult && comparatorResult !== 0) {
        return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
      }
    }
    return sortedNodeA.currentPos - sortedNodeB.currentPos;
  }
  getComparator(sortOption, rowNode) {
    const column = sortOption.column;
    const comparatorOnCol = column.getColDef().comparator;
    if (comparatorOnCol != null) {
      return comparatorOnCol;
    }
    if (!column.getColDef().showRowGroup) {
      return;
    }
    const groupLeafField = !rowNode.group && column.getColDef().field;
    if (!groupLeafField) {
      return;
    }
    const primaryColumn = this.beans.colModel.getColDefCol(groupLeafField);
    if (!primaryColumn) {
      return;
    }
    return primaryColumn.getColDef().comparator;
  }
  getValue(node, column) {
    const { valueSvc, colModel, showRowGroupCols, gos } = this.beans;
    if (!this.primaryColumnsSortGroups) {
      return valueSvc.getValue(column, node, false);
    }
    const isNodeGroupedAtLevel = node.rowGroupColumn === column;
    if (isNodeGroupedAtLevel) {
      const isGroupRows = _isGroupUseEntireRow(gos, colModel.isPivotActive());
      if (isGroupRows) {
        const leafChild = node.allLeafChildren?.[0];
        if (leafChild) {
          return valueSvc.getValue(column, leafChild, false);
        }
        return void 0;
      }
      const displayCol = showRowGroupCols?.getShowRowGroupCol(column.getId());
      if (!displayCol) {
        return void 0;
      }
      return node.groupData?.[displayCol.getId()];
    }
    if (node.group && column.getColDef().showRowGroup) {
      return void 0;
    }
    return valueSvc.getValue(column, node, false);
  }
};

// packages/ag-grid-community/src/sort/sortApi.ts
function onSortChanged(beans) {
  beans.sortSvc?.onSortChanged("api");
}

// packages/ag-grid-community/src/sort/sortIndicatorComp.ts
function makeSpan(dataRefSuffix, classSuffix) {
  return (
    /* html */
    `<span data-ref="eSort${dataRefSuffix}" class="ag-sort-indicator-icon ag-sort-${classSuffix} ag-hidden" aria-hidden="true"></span>`
  );
}
var SortIndicatorTemplate = (
  /* html */
  `<span class="ag-sort-indicator-container">
        ${makeSpan("Order", "order")}
        ${makeSpan("Asc", "ascending-icon")}
        ${makeSpan("Desc", "descending-icon")}
        ${makeSpan("Mixed", "mixed-icon")}
        ${makeSpan("None", "none-icon")}
    </span>`
);
var SortIndicatorComp = class extends Component {
  constructor(skipTemplate) {
    super();
    this.eSortOrder = RefPlaceholder;
    this.eSortAsc = RefPlaceholder;
    this.eSortDesc = RefPlaceholder;
    this.eSortMixed = RefPlaceholder;
    this.eSortNone = RefPlaceholder;
    if (!skipTemplate) {
      this.setTemplate(SortIndicatorTemplate);
    }
  }
  attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
    this.eSortOrder = eSortOrder;
    this.eSortAsc = eSortAsc;
    this.eSortDesc = eSortDesc;
    this.eSortMixed = eSortMixed;
    this.eSortNone = eSortNone;
  }
  setupSort(column, suppressOrder = false) {
    this.column = column;
    this.suppressOrder = suppressOrder;
    this.setupMultiSortIndicator();
    if (!column.isSortable() && !column.getColDef().showRowGroup) {
      return;
    }
    this.addInIcon("sortAscending", this.eSortAsc, column);
    this.addInIcon("sortDescending", this.eSortDesc, column);
    this.addInIcon("sortUnSort", this.eSortNone, column);
    const updateIcons = this.updateIcons.bind(this);
    const sortUpdated = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", updateIcons);
    this.addManagedEventListeners({
      newColumnsLoaded: updateIcons,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: sortUpdated,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: sortUpdated
    });
    this.onSortChanged();
  }
  addInIcon(iconName, eParent, column) {
    if (eParent == null) {
      return;
    }
    const eIcon = _createIconNoSpan(iconName, this.beans, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  onSortChanged() {
    this.updateIcons();
    if (!this.suppressOrder) {
      this.updateSortOrder();
    }
  }
  updateIcons() {
    const { eSortAsc, eSortDesc, eSortNone, column, gos, beans } = this;
    const sortDirection = beans.sortSvc.getDisplaySortForColumn(column);
    if (eSortAsc) {
      const isAscending = sortDirection === "asc";
      _setDisplayed(eSortAsc, isAscending, { skipAriaHidden: true });
    }
    if (eSortDesc) {
      const isDescending = sortDirection === "desc";
      _setDisplayed(eSortDesc, isDescending, { skipAriaHidden: true });
    }
    if (eSortNone) {
      const alwaysHideNoSort = !column.getColDef().unSortIcon && !gos.get("unSortIcon");
      const isNone = sortDirection === null || sortDirection === void 0;
      _setDisplayed(eSortNone, !alwaysHideNoSort && isNone, { skipAriaHidden: true });
    }
  }
  setupMultiSortIndicator() {
    const { eSortMixed, column, gos } = this;
    this.addInIcon("sortUnSort", eSortMixed, column);
    const isColumnShowingRowGroup = column.getColDef().showRowGroup;
    const areGroupsCoupled = _isColumnsSortingCoupledToGroup(gos);
    if (areGroupsCoupled && isColumnShowingRowGroup) {
      this.addManagedEventListeners({
        // Watch global events, as row group columns can effect their display column.
        sortChanged: this.updateMultiSortIndicator.bind(this),
        // when grouping changes so can sort indexes and icons
        columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
      });
      this.updateMultiSortIndicator();
    }
  }
  updateMultiSortIndicator() {
    const { eSortMixed, beans, column } = this;
    if (eSortMixed) {
      const isMixedSort = beans.sortSvc.getDisplaySortForColumn(column) === "mixed";
      _setDisplayed(eSortMixed, isMixedSort, { skipAriaHidden: true });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    const {
      eSortOrder,
      column,
      beans: { sortSvc }
    } = this;
    if (!eSortOrder) {
      return;
    }
    const allColumnsWithSorting = sortSvc.getColumnsWithSortingOrdered();
    const indexThisCol = sortSvc.getDisplaySortIndexForColumn(column) ?? -1;
    const moreThanOneColSorting = allColumnsWithSorting.some(
      (col) => sortSvc.getDisplaySortIndexForColumn(col) ?? -1 >= 1
    );
    const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
    _setDisplayed(eSortOrder, showIndex, { skipAriaHidden: true });
    if (indexThisCol >= 0) {
      eSortOrder.textContent = (indexThisCol + 1).toString();
    } else {
      _clearElement(eSortOrder);
    }
  }
};
var SortIndicatorSelector = {
  selector: "AG-SORT-INDICATOR",
  component: SortIndicatorComp
};

// packages/ag-grid-community/src/sort/sortService.ts
var DEFAULT_SORTING_ORDER = ["asc", "desc", null];
var SortService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "sortSvc";
  }
  progressSort(column, multiSort, source) {
    const nextDirection = this.getNextSortDirection(column);
    this.setSortForColumn(column, nextDirection, multiSort, source);
  }
  progressSortFromEvent(column, event) {
    const sortUsingCtrl = this.gos.get("multiSortKey") === "ctrl";
    const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
    this.progressSort(column, multiSort, "uiColumnSorted");
  }
  setSortForColumn(column, sort, multiSort, source) {
    if (sort !== "asc" && sort !== "desc") {
      sort = null;
    }
    const { gos, showRowGroupCols } = this.beans;
    const isColumnsSortingCoupledToGroup = _isColumnsSortingCoupledToGroup(gos);
    let columnsToUpdate = [column];
    if (isColumnsSortingCoupledToGroup) {
      if (column.getColDef().showRowGroup) {
        const rowGroupColumns = showRowGroupCols?.getSourceColumnsForGroupColumn?.(column);
        const sortableRowGroupColumns = rowGroupColumns?.filter((col) => col.isSortable());
        if (sortableRowGroupColumns) {
          columnsToUpdate = [column, ...sortableRowGroupColumns];
        }
      }
    }
    columnsToUpdate.forEach((col) => this.setColSort(col, sort, source));
    const doingMultiSort = (multiSort || gos.get("alwaysMultiSort")) && !gos.get("suppressMultiSort");
    const updatedColumns = [];
    if (!doingMultiSort) {
      const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
      updatedColumns.push(...clearedColumns);
    }
    this.updateSortIndex(column);
    updatedColumns.push(...columnsToUpdate);
    this.dispatchSortChangedEvents(source, updatedColumns);
  }
  updateSortIndex(lastColToChange) {
    const { gos, colModel, showRowGroupCols } = this.beans;
    const isCoupled = _isColumnsSortingCoupledToGroup(gos);
    const groupParent = showRowGroupCols?.getShowRowGroupCol(lastColToChange.getId());
    const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
    const allSortedCols = this.getColumnsWithSortingOrdered();
    colModel.getAllCols().forEach((col) => this.setColSortIndex(col, null));
    const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col) => {
      if (isCoupled && col.getColDef().showRowGroup) {
        return false;
      }
      return col !== lastSortIndexCol;
    });
    const sortedColsWithIndices = lastSortIndexCol.getSort() ? [...allSortedColsWithoutChangesOrGroups, lastSortIndexCol] : allSortedColsWithoutChangesOrGroups;
    sortedColsWithIndices.forEach((col, idx) => this.setColSortIndex(col, idx));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(source, columns) {
    this.dispatchSortChangedEvents(source, columns);
  }
  isSortActive() {
    const allCols = this.beans.colModel.getAllCols();
    const sortedCols = allCols.filter((column) => !!column.getSort());
    return sortedCols && sortedCols.length > 0;
  }
  dispatchSortChangedEvents(source, columns) {
    const event = {
      type: "sortChanged",
      source
    };
    if (columns) {
      event.columns = columns;
    }
    this.eventSvc.dispatchEvent(event);
  }
  clearSortBarTheseColumns(columnsToSkip, source) {
    const clearedColumns = [];
    this.beans.colModel.getAllCols().forEach((columnToClear) => {
      if (!columnsToSkip.includes(columnToClear)) {
        if (columnToClear.getSort()) {
          clearedColumns.push(columnToClear);
        }
        this.setColSort(columnToClear, void 0, source);
      }
    });
    return clearedColumns;
  }
  getNextSortDirection(column) {
    const sortingOrder = column.getColDef().sortingOrder ?? this.gos.get("sortingOrder") ?? DEFAULT_SORTING_ORDER;
    const currentIndex = sortingOrder.indexOf(column.getSort());
    const notInArray = currentIndex < 0;
    const lastItemInArray = currentIndex == sortingOrder.length - 1;
    return notInArray || lastItemInArray ? sortingOrder[0] : sortingOrder[currentIndex + 1];
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    const { gos, colModel, showRowGroupCols, rowGroupColsSvc } = this.beans;
    let allSortedCols = colModel.getAllCols().filter((col) => !!col.getSort());
    if (colModel.isPivotMode()) {
      const isSortingLinked = _isColumnsSortingCoupledToGroup(gos);
      allSortedCols = allSortedCols.filter((col) => {
        const isAggregated = !!col.getAggFunc();
        const isSecondary = !col.isPrimary();
        const isGroup = isSortingLinked ? showRowGroupCols?.getShowRowGroupCol(col.getId()) : col.getColDef().showRowGroup;
        return isAggregated || isSecondary || isGroup;
      });
    }
    const sortedRowGroupCols = rowGroupColsSvc?.columns.filter((col) => !!col.getSort()) ?? [];
    const allColsIndexes = {};
    allSortedCols.forEach((col, index) => allColsIndexes[col.getId()] = index);
    allSortedCols.sort((a, b) => {
      const iA = a.getSortIndex();
      const iB = b.getSortIndex();
      if (iA != null && iB != null) {
        return iA - iB;
      } else if (iA == null && iB == null) {
        const posA = allColsIndexes[a.getId()];
        const posB = allColsIndexes[b.getId()];
        return posA > posB ? 1 : -1;
      } else if (iB == null) {
        return -1;
      } else {
        return 1;
      }
    });
    const isSortLinked = _isColumnsSortingCoupledToGroup(gos) && !!sortedRowGroupCols.length;
    if (isSortLinked) {
      allSortedCols = [
        ...new Set(
          // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
          allSortedCols.map((col) => showRowGroupCols?.getShowRowGroupCol(col.getId()) ?? col)
        )
      ];
    }
    const indexMap = /* @__PURE__ */ new Map();
    allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
    if (isSortLinked) {
      sortedRowGroupCols.forEach((col) => {
        const groupDisplayCol = showRowGroupCols.getShowRowGroupCol(col.getId());
        indexMap.set(col, indexMap.get(groupDisplayCol));
      });
    }
    return indexMap;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([col1, idx1], [col2, idx2]) => idx1 - idx2).map(([col]) => col);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
      sort: column.getSort(),
      colId: column.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
      sort: column.getSort(),
      column
    }));
  }
  canColumnDisplayMixedSort(column) {
    const isColumnSortCouplingActive = _isColumnsSortingCoupledToGroup(this.gos);
    const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
    return isColumnSortCouplingActive && isGroupDisplayColumn;
  }
  getDisplaySortForColumn(column) {
    const linkedColumns = this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column);
    if (!this.canColumnDisplayMixedSort(column) || !linkedColumns?.length) {
      return column.getSort();
    }
    const columnHasUniqueData = column.getColDef().field != null || !!column.getColDef().valueGetter;
    const sortableColumns = columnHasUniqueData ? [column, ...linkedColumns] : linkedColumns;
    const firstSort = sortableColumns[0].getSort();
    const allMatch = sortableColumns.every((col) => col.getSort() == firstSort);
    if (!allMatch) {
      return "mixed";
    }
    return firstSort;
  }
  getDisplaySortIndexForColumn(column) {
    return this.getIndexedSortMap().get(column);
  }
  setupHeader(comp, column, clickElement) {
    let lastMovingChanged = 0;
    comp.addManagedListeners(column, {
      movingChanged: () => {
        lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }
    });
    if (clickElement) {
      comp.addManagedElementListeners(clickElement, {
        click: (event) => {
          const moving = column.isMoving();
          const nowTime = (/* @__PURE__ */ new Date()).getTime();
          const movedRecently = nowTime - lastMovingChanged < 50;
          const columnMoving = moving || movedRecently;
          if (!columnMoving) {
            this.progressSortFromEvent(column, event);
          }
        }
      });
    }
    const onSortingChanged = () => {
      const sort = column.getSort();
      comp.addOrRemoveCssClass("ag-header-cell-sorted-asc", sort === "asc");
      comp.addOrRemoveCssClass("ag-header-cell-sorted-desc", sort === "desc");
      comp.addOrRemoveCssClass("ag-header-cell-sorted-none", !sort);
      if (column.getColDef().showRowGroup) {
        const sourceColumns = this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column);
        const sortDirectionsMatch = sourceColumns?.every(
          (sourceCol) => column.getSort() == sourceCol.getSort()
        );
        const isMultiSorting = !sortDirectionsMatch;
        comp.addOrRemoveCssClass("ag-header-cell-sorted-mixed", isMultiSorting);
      }
    };
    comp.addManagedEventListeners({
      sortChanged: onSortingChanged,
      columnRowGroupChanged: onSortingChanged
    });
  }
  initCol(column) {
    const { sort, initialSort, sortIndex, initialSortIndex } = column.colDef;
    if (sort !== void 0) {
      if (sort === "asc" || sort === "desc") {
        column.sort = sort;
      }
    } else {
      if (initialSort === "asc" || initialSort === "desc") {
        column.sort = initialSort;
      }
    }
    if (sortIndex !== void 0) {
      if (sortIndex !== null) {
        column.sortIndex = sortIndex;
      }
    } else {
      if (initialSortIndex !== null) {
        column.sortIndex = initialSortIndex;
      }
    }
  }
  updateColSort(column, sort, source) {
    if (sort !== void 0) {
      if (sort === "desc" || sort === "asc") {
        this.setColSort(column, sort, source);
      } else {
        this.setColSort(column, void 0, source);
      }
    }
  }
  setColSort(column, sort, source) {
    if (column.sort !== sort) {
      column.sort = sort;
      column.dispatchColEvent("sortChanged", source);
    }
    column.dispatchStateUpdatedEvent("sort");
  }
  setColSortIndex(column, sortOrder) {
    column.sortIndex = sortOrder;
    column.dispatchStateUpdatedEvent("sortIndex");
  }
  createSortIndicator(skipTemplate) {
    return new SortIndicatorComp(skipTemplate);
  }
  getSortIndicatorSelector() {
    return SortIndicatorSelector;
  }
};

// packages/ag-grid-community/src/sort/sortModule.ts
var SortModule = {
  moduleName: "Sort",
  version: VERSION,
  beans: [SortService, RowNodeSorter],
  apiFunctions: {
    onSortChanged
  },
  userComponents: {
    agSortIndicator: SortIndicatorComp
  },
  icons: {
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none"
  }
};

// packages/ag-grid-community/src/syncService.ts
var SyncService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "syncSvc";
    this.waitingForColumns = false;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (event) => this.setColumnDefs(event));
  }
  start() {
    this.beans.ctrlsSvc.whenReady(this, () => {
      const columnDefs = this.gos.get("columnDefs");
      if (columnDefs) {
        this.setColumnsAndData(columnDefs);
      } else {
        this.waitingForColumns = true;
      }
      this.gridReady();
    });
  }
  setColumnsAndData(columnDefs) {
    const { colModel, rowModel } = this.beans;
    colModel.setColumnDefs(columnDefs ?? [], "gridInitializing");
    rowModel.start();
  }
  gridReady() {
    const { eventSvc, gos } = this;
    eventSvc.dispatchEvent({
      type: "gridReady"
    });
    _logIfDebug(gos, `initialised successfully, enterprise = ${gos.isModuleRegistered("EnterpriseCore")}`);
  }
  setColumnDefs(event) {
    const columnDefs = this.gos.get("columnDefs");
    if (!columnDefs) {
      return;
    }
    if (this.waitingForColumns) {
      this.waitingForColumns = false;
      this.setColumnsAndData(columnDefs);
      return;
    }
    this.beans.colModel.setColumnDefs(columnDefs, _convertColumnEventSourceType(event.source));
  }
};

// packages/ag-grid-community/src/valueService/cellApi.ts
function expireValueCache(beans) {
  beans.valueCache?.expire();
}
function getCellValue(beans, params) {
  const { colKey, rowNode, useFormatter } = params;
  const column = beans.colModel.getColDefCol(colKey) ?? beans.colModel.getCol(colKey);
  if (_missing(column)) {
    return null;
  }
  const value = beans.valueSvc.getValueForDisplay(column, rowNode);
  if (useFormatter) {
    const formattedValue = beans.valueSvc.formatValue(column, rowNode, value);
    return formattedValue ?? _escapeString(value, true);
  }
  return value;
}

// packages/ag-grid-community/src/utils/changedPath.ts
var ChangedPath = class {
  constructor(keepingColumns, rootNode) {
    // whether changed path is active of not. it is active when a) doing
    // a transaction update or b) doing change detection. if we are doing
    // a CSRM refresh for other reasons (after sort or filter, or user calling
    // setRowData() without delta mode) then we are not active. we are also
    // marked as not active if secondary columns change in pivot (as this impacts
    // aggregations).
    // can be set inactive by:
    // a) ClientSideRowModel, if no transactions or
    // b) PivotService, if secondary columns changed
    this.active = true;
    // for each node in the change path, we also store which columns need
    // to be re-aggregated.
    this.nodeIdsToColumns = {};
    // for quick lookup, all items in the change path are mapped by nodeId
    this.mapToItems = {};
    this.keepingColumns = keepingColumns;
    this.pathRoot = {
      rowNode: rootNode,
      children: null
    };
    this.mapToItems[rootNode.id] = this.pathRoot;
  }
  depthFirstSearchChangedPath(pathItem, callback) {
    const { rowNode, children } = pathItem;
    if (children) {
      for (let i = 0; i < children.length; ++i) {
        this.depthFirstSearchChangedPath(children[i], callback);
      }
    }
    callback(rowNode);
  }
  depthFirstSearchEverything(rowNode, callback, traverseEverything) {
    const childrenAfterGroup = rowNode.childrenAfterGroup;
    if (childrenAfterGroup) {
      for (let i = 0, len = childrenAfterGroup.length; i < len; ++i) {
        const childNode = childrenAfterGroup[i];
        if (childNode.childrenAfterGroup) {
          this.depthFirstSearchEverything(childNode, callback, traverseEverything);
        } else if (traverseEverything) {
          callback(childNode);
        }
      }
    }
    callback(rowNode);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
    if (this.active && !includeUnchangedNodes) {
      this.depthFirstSearchChangedPath(this.pathRoot, callback);
    } else {
      this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
    }
  }
  executeFromRootNode(callback) {
    callback(this.pathRoot.rowNode);
  }
  createPathItems(rowNode) {
    let pointer = rowNode;
    let newEntryCount = 0;
    while (!this.mapToItems[pointer.id]) {
      const newEntry = {
        rowNode: pointer,
        children: null
      };
      this.mapToItems[pointer.id] = newEntry;
      newEntryCount++;
      pointer = pointer.parent;
    }
    return newEntryCount;
  }
  populateColumnsMap(rowNode, columns) {
    if (!this.keepingColumns || !columns) {
      return;
    }
    let pointer = rowNode;
    while (pointer) {
      if (!this.nodeIdsToColumns[pointer.id]) {
        this.nodeIdsToColumns[pointer.id] = {};
      }
      columns.forEach((col) => this.nodeIdsToColumns[pointer.id][col.getId()] = true);
      pointer = pointer.parent;
    }
  }
  linkPathItems(rowNode, newEntryCount) {
    let pointer = rowNode;
    for (let i = 0; i < newEntryCount; i++) {
      const thisItem = this.mapToItems[pointer.id];
      const parentItem = this.mapToItems[pointer.parent.id];
      if (!parentItem.children) {
        parentItem.children = [];
      }
      parentItem.children.push(thisItem);
      pointer = pointer.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(rowNode, columns) {
    if (!rowNode || rowNode.isRowPinned()) {
      return;
    }
    const newEntryCount = this.createPathItems(rowNode);
    this.linkPathItems(rowNode, newEntryCount);
    this.populateColumnsMap(rowNode, columns);
  }
  canSkip(rowNode) {
    return this.active && !this.mapToItems[rowNode.id];
  }
  getValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return valueColumns;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => colsForThisNode[col.getId()]);
    return result;
  }
  getNotValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return null;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => !colsForThisNode[col.getId()]);
    return result;
  }
};

// packages/ag-grid-community/src/valueService/changeDetectionService.ts
var SOURCE_PASTE = "paste";
var ChangeDetectionService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "changeDetectionSvc";
    this.clientSideRowModel = null;
  }
  postConstruct() {
    const { gos, rowModel } = this.beans;
    if (_isClientSideRowModel(gos, rowModel)) {
      this.clientSideRowModel = rowModel;
    }
    this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(event) {
    const { gos, rowRenderer } = this.beans;
    if (event.source === SOURCE_PASTE || gos.get("suppressChangeDetection")) {
      return;
    }
    const rowNode = event.node;
    const nodesToRefresh = [rowNode];
    const clientSideRowModel = this.clientSideRowModel;
    const rootNode = clientSideRowModel?.rootNode;
    if (rootNode && !rowNode.isRowPinned()) {
      const onlyChangedColumns = gos.get("aggregateOnlyChangedColumns");
      const changedPath = new ChangedPath(onlyChangedColumns, rootNode);
      changedPath.addParentNode(rowNode.parent, [event.column]);
      clientSideRowModel.doAggregate(changedPath);
      changedPath.forEachChangedNodeDepthFirst((rowNode2) => {
        nodesToRefresh.push(rowNode2);
      });
    }
    rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
  }
};

// packages/ag-grid-community/src/valueService/expressionService.ts
var ExpressionService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "expressionSvc";
    this.cache = {};
  }
  evaluate(expression, params) {
    if (typeof expression === "string") {
      return this.evaluateExpression(expression, params);
    } else {
      _error(15, { expression });
    }
  }
  evaluateExpression(expression, params) {
    try {
      const javaScriptFunction = this.createExpressionFunction(expression);
      const result = javaScriptFunction(
        params.value,
        params.context,
        params.oldValue,
        params.newValue,
        params.value,
        params.node,
        params.data,
        params.colDef,
        params.rowIndex,
        params.api,
        params.getValue,
        params.column,
        params.columnGroup
      );
      return result;
    } catch (e) {
      _error(16, { expression, params, e });
      return null;
    }
  }
  createExpressionFunction(expression) {
    const expressionToFunctionCache = this.cache;
    if (expressionToFunctionCache[expression]) {
      return expressionToFunctionCache[expression];
    }
    const functionBody = this.createFunctionBody(expression);
    const theFunction = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      functionBody
    );
    expressionToFunctionCache[expression] = theFunction;
    return theFunction;
  }
  createFunctionBody(expression) {
    if (expression.indexOf("return") >= 0) {
      return expression;
    } else {
      return "return " + expression + ";";
    }
  }
};

// packages/ag-grid-community/src/valueService/valueCache.ts
var ValueCache = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "valueCache";
    this.cacheVersion = 0;
  }
  postConstruct() {
    const gos = this.gos;
    this.active = gos.get("valueCache");
    this.neverExpires = gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    if (this.neverExpires) {
      return;
    }
    this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(rowNode, colId, value) {
    if (this.active) {
      const cacheVersion = this.cacheVersion;
      if (rowNode.__cacheVersion !== cacheVersion) {
        rowNode.__cacheVersion = cacheVersion;
        rowNode.__cacheData = {};
      }
      rowNode.__cacheData[colId] = value;
    }
  }
  getValue(rowNode, colId) {
    if (!this.active || rowNode.__cacheVersion !== this.cacheVersion) {
      return void 0;
    }
    return rowNode.__cacheData[colId];
  }
};

// packages/ag-grid-community/src/valueService/valueModule.ts
var ValueCacheModule = {
  moduleName: "ValueCache",
  version: VERSION,
  beans: [ValueCache],
  apiFunctions: {
    expireValueCache
  }
};
var ExpressionModule = {
  moduleName: "Expression",
  version: VERSION,
  beans: [ExpressionService]
};
var ChangeDetectionModule = {
  moduleName: "ChangeDetection",
  version: VERSION,
  beans: [ChangeDetectionService]
};
var CellApiModule = {
  moduleName: "CellApi",
  version: VERSION,
  apiFunctions: {
    getCellValue
  }
};

// packages/ag-grid-community/src/valueService/valueService.ts
var ValueService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "valueSvc";
    this.initialised = false;
    this.isSsrm = false;
  }
  wireBeans(beans) {
    this.expressionSvc = beans.expressionSvc;
    this.colModel = beans.colModel;
    this.valueCache = beans.valueCache;
    this.dataTypeSvc = beans.dataTypeSvc;
  }
  postConstruct() {
    if (!this.initialised) {
      this.init();
    }
  }
  init() {
    this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this);
    this.isSsrm = _isServerSideRowModel(this.gos);
    this.cellExpressions = this.gos.get("enableCellExpressions");
    this.isTreeData = this.gos.get("treeData");
    this.initialised = true;
    const listener = (event) => this.callColumnCellValueChangedHandler(event);
    this.eventSvc.addEventListener("cellValueChanged", listener, true);
    this.addDestroyFunc(() => this.eventSvc.removeEventListener("cellValueChanged", listener, true));
    this.addManagedPropertyListener("treeData", (propChange) => this.isTreeData = propChange.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * This hides values in expanded group rows which are instead displayed by the footer row.
   */
  getValueForDisplay(column, node) {
    const lockedClosedGroup = node.leafGroup && this.colModel.isPivotMode();
    const isOpenGroup = node.group && node.expanded && !node.footer && !lockedClosedGroup;
    const groupAlwaysShowAggData = this.gos.get("groupSuppressBlankHeader");
    if (!isOpenGroup || groupAlwaysShowAggData) {
      return this.getValue(column, node);
    }
    let includeFooter = false;
    const groupIncludeFooterOpt = this.gos.get("groupTotalRow");
    if (typeof groupIncludeFooterOpt !== "function") {
      includeFooter = !!groupIncludeFooterOpt;
    } else {
      const groupIncludeFooterCb = this.gos.getCallback("groupTotalRow");
      includeFooter = !!groupIncludeFooterCb({ node: this });
    }
    const ignoreAggData = isOpenGroup && includeFooter;
    return this.getValue(column, node, ignoreAggData);
  }
  getValue(column, rowNode, ignoreAggData = false) {
    if (!this.initialised) {
      this.init();
    }
    if (!rowNode) {
      return;
    }
    const colDef = column.getColDef();
    const field = colDef.field;
    const colId = column.getColId();
    const data = rowNode.data;
    let result;
    const groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== void 0;
    const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
    const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!column.getColDef().aggFunc;
    const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (column.getColDef().showRowGroup === true || column.getColDef().showRowGroup === rowNode.field);
    if (this.isTreeData && aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (this.isTreeData && colDef.valueGetter) {
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (this.isTreeData && field && data) {
      result = _getValueUsingField(data, field, column.isFieldContainsDots());
    } else if (groupDataExists) {
      result = rowNode.groupData[colId];
    } else if (aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (colDef.valueGetter) {
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (ssrmFooterGroupCol) {
      result = _getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
    } else if (field && data && !ignoreSsrmAggData) {
      result = _getValueUsingField(data, field, column.isFieldContainsDots());
    }
    if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
      const cellValueGetter = result.substring(1);
      result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
    }
    if (result == null) {
      const openedGroup = this.getOpenedGroup(rowNode, column);
      if (openedGroup != null) {
        return openedGroup;
      }
    }
    return result;
  }
  parseValue(column, rowNode, newValue, oldValue) {
    const colDef = column.getColDef();
    const valueParser = colDef.valueParser;
    if (_exists(valueParser)) {
      const params = this.gos.addGridCommonParams({
        node: rowNode,
        data: rowNode?.data,
        oldValue,
        newValue,
        colDef,
        column
      });
      if (typeof valueParser === "function") {
        return valueParser(params);
      }
      return this.expressionSvc?.evaluate(valueParser, params);
    }
    return newValue;
  }
  getDeleteValue(column, rowNode) {
    if (_exists(column.getColDef().valueParser)) {
      return this.parseValue(column, rowNode, "", this.getValueForDisplay(column, rowNode)) ?? null;
    }
    return null;
  }
  formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
    let result = null;
    let formatter;
    const colDef = column.getColDef();
    if (suppliedFormatter) {
      formatter = suppliedFormatter;
    } else if (useFormatterFromColumn) {
      formatter = colDef.valueFormatter;
    }
    if (formatter) {
      const params = this.gos.addGridCommonParams({
        value,
        node,
        data: node ? node.data : null,
        colDef,
        column
      });
      if (typeof formatter === "function") {
        result = formatter(params);
      } else {
        result = this.expressionSvc ? this.expressionSvc.evaluate(formatter, params) : null;
      }
    } else if (colDef.refData) {
      return colDef.refData[value] || "";
    }
    if (result == null && Array.isArray(value)) {
      result = value.join(", ");
    }
    return result;
  }
  getOpenedGroup(rowNode, column) {
    if (!this.gos.get("showOpenedGroup")) {
      return;
    }
    const colDef = column.getColDef();
    if (!colDef.showRowGroup) {
      return;
    }
    const showRowGroup = column.getColDef().showRowGroup;
    let pointer = rowNode.parent;
    while (pointer != null) {
      if (pointer.rowGroupColumn && (showRowGroup === true || showRowGroup === pointer.rowGroupColumn.getColId())) {
        return pointer.key;
      }
      pointer = pointer.parent;
    }
    return void 0;
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(rowNode, colKey, newValue, eventSource) {
    const column = this.colModel.getColDefCol(colKey);
    if (!rowNode || !column) {
      return false;
    }
    if (_missing(rowNode.data)) {
      rowNode.data = {};
    }
    const { field, valueSetter } = column.getColDef();
    if (_missing(field) && _missing(valueSetter)) {
      _warn(17);
      return false;
    }
    if (this.dataTypeSvc && !this.dataTypeSvc.checkType(column, newValue)) {
      _warn(135);
      return false;
    }
    const params = this.gos.addGridCommonParams({
      node: rowNode,
      data: rowNode.data,
      oldValue: this.getValue(column, rowNode),
      newValue,
      colDef: column.getColDef(),
      column
    });
    params.newValue = newValue;
    let valueWasDifferent;
    if (_exists(valueSetter)) {
      if (typeof valueSetter === "function") {
        valueWasDifferent = valueSetter(params);
      } else {
        valueWasDifferent = this.expressionSvc?.evaluate(valueSetter, params);
      }
    } else {
      valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
    }
    if (valueWasDifferent === void 0) {
      valueWasDifferent = true;
    }
    if (!valueWasDifferent) {
      return false;
    }
    rowNode.resetQuickFilterAggregateText();
    this.valueCache?.onDataChanged();
    const savedValue = this.getValue(column, rowNode);
    this.eventSvc.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: rowNode.rowIndex,
      rowPinned: rowNode.rowPinned,
      column: params.column,
      colDef: params.colDef,
      data: rowNode.data,
      node: rowNode,
      oldValue: params.oldValue,
      newValue: savedValue,
      value: savedValue,
      source: eventSource
    });
    return true;
  }
  callColumnCellValueChangedHandler(event) {
    const onCellValueChanged = event.colDef.onCellValueChanged;
    if (typeof onCellValueChanged === "function") {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        onCellValueChanged({
          node: event.node,
          data: event.data,
          oldValue: event.oldValue,
          newValue: event.newValue,
          colDef: event.colDef,
          column: event.column,
          api: event.api,
          context: event.context
        });
      });
    }
  }
  setValueUsingField(data, field, newValue, isFieldContainsDots) {
    if (!field) {
      return false;
    }
    let valuesAreSame = false;
    if (!isFieldContainsDots) {
      valuesAreSame = data[field] === newValue;
      if (!valuesAreSame) {
        data[field] = newValue;
      }
    } else {
      const fieldPieces = field.split(".");
      let currentObject = data;
      while (fieldPieces.length > 0 && currentObject) {
        const fieldPiece = fieldPieces.shift();
        if (fieldPieces.length === 0) {
          valuesAreSame = currentObject[fieldPiece] === newValue;
          if (!valuesAreSame) {
            currentObject[fieldPiece] = newValue;
          }
        } else {
          currentObject = currentObject[fieldPiece];
        }
      }
    }
    return !valuesAreSame;
  }
  executeValueGetterWithValueCache(valueGetter, data, column, rowNode) {
    const colId = column.getColId();
    const valueFromCache = this.valueCache.getValue(rowNode, colId);
    if (valueFromCache !== void 0) {
      return valueFromCache;
    }
    const result = this.executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode);
    this.valueCache.setValue(rowNode, colId, result);
    return result;
  }
  executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode) {
    const params = this.gos.addGridCommonParams({
      data,
      node: rowNode,
      column,
      colDef: column.getColDef(),
      getValue: this.getValueCallback.bind(this, rowNode)
    });
    let result;
    if (typeof valueGetter === "function") {
      result = valueGetter(params);
    } else {
      result = this.expressionSvc?.evaluate(valueGetter, params);
    }
    return result;
  }
  getValueCallback(node, field) {
    const otherColumn = this.colModel.getColDefCol(field);
    if (otherColumn) {
      return this.getValue(otherColumn, node);
    }
    return null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(col, rowNode) {
    const value = this.getValue(col, rowNode);
    const keyCreator = col.getColDef().keyCreator;
    let result = value;
    if (keyCreator) {
      const keyParams = this.gos.addGridCommonParams({
        value,
        colDef: col.getColDef(),
        column: col,
        node: rowNode,
        data: rowNode.data
      });
      result = keyCreator(keyParams);
    }
    if (typeof result === "string" || result == null) {
      return result;
    }
    result = String(result);
    if (result === "[object Object]") {
      _warn(121);
    }
    return result;
  }
};

// packages/ag-grid-community/src/gridCoreModule.ts
var CommunityCoreModule = {
  moduleName: "CommunityCore",
  version: VERSION,
  beans: [
    GridDestroyService,
    ApiFunctionService,
    Registry,
    UserComponentFactory,
    RowContainerHeightService,
    VisibleColsService,
    EventService,
    GridOptionsService,
    ColumnModel,
    PageBoundsService,
    PageBoundsListener,
    RowRenderer,
    ValueService,
    FocusService,
    Environment,
    ScrollVisibleService,
    CtrlsService,
    SyncService,
    ColumnNameService,
    ColumnViewportService
  ],
  icons: {
    // icon on select dropdowns (select cell editor, charts tool panels)
    selectOpen: "small-down",
    /** @deprecated v33 */
    smallDown: "small-down",
    /** @deprecated v33 */
    colorPicker: "color-picker",
    /** @deprecated v33 */
    smallUp: "small-up",
    /** @deprecated v33 */
    checkboxChecked: "small-up",
    /** @deprecated v33 */
    checkboxIndeterminate: "checkbox-indeterminate",
    /** @deprecated v33 */
    checkboxUnchecked: "checkbox-unchecked",
    /** @deprecated v33 */
    radioButtonOn: "radio-button-on",
    /** @deprecated v33 */
    radioButtonOff: "radio-button-off",
    /** @deprecated v33 */
    smallLeft: "small-left",
    /** @deprecated v33 */
    smallRight: "small-right"
  },
  apiFunctions: {
    getGridId,
    destroy,
    isDestroyed,
    getGridOption,
    setGridOption,
    updateGridOptions
  },
  dependsOn: [
    DataTypeModule,
    ColumnMoveModule,
    ColumnResizeModule,
    SortModule,
    ColumnHeaderCompModule,
    ColumnGroupModule,
    ColumnGroupHeaderCompModule,
    OverlayModule,
    ChangeDetectionModule,
    AnimationFrameModule,
    KeyboardNavigationModule,
    PinnedColumnModule,
    AriaModule,
    TouchModule,
    CellRendererFunctionModule,
    ColumnFlexModule,
    ExpressionModule
  ]
};

// packages/ag-grid-community/src/grid.ts
var _GlobalGridOptions = class _GlobalGridOptions {
  /**
   * @param providedOptions
   * @returns Shallow copy of the provided options with global options merged in.
   */
  static applyGlobalGridOptions(providedOptions) {
    if (!_GlobalGridOptions.gridOptions) {
      return { ...providedOptions };
    }
    let mergedGridOps = {};
    _mergeDeep(mergedGridOps, _GlobalGridOptions.gridOptions, true, true);
    if (_GlobalGridOptions.mergeStrategy === "deep") {
      _mergeDeep(mergedGridOps, providedOptions, true, true);
    } else {
      mergedGridOps = { ...mergedGridOps, ...providedOptions };
    }
    if (_GlobalGridOptions.gridOptions.context) {
      mergedGridOps.context = _GlobalGridOptions.gridOptions.context;
    }
    if (providedOptions.context) {
      if (_GlobalGridOptions.mergeStrategy === "deep" && mergedGridOps.context) {
        _mergeDeep(providedOptions.context, mergedGridOps.context, true, true);
      }
      mergedGridOps.context = providedOptions.context;
    }
    return mergedGridOps;
  }
};
_GlobalGridOptions.gridOptions = void 0;
_GlobalGridOptions.mergeStrategy = "shallow";
var GlobalGridOptions = _GlobalGridOptions;
function provideGlobalGridOptions(gridOptions, mergeStrategy = "shallow") {
  GlobalGridOptions.gridOptions = gridOptions;
  GlobalGridOptions.mergeStrategy = mergeStrategy;
}
function _getGlobalGridOption(gridOption) {
  return GlobalGridOptions.gridOptions?.[gridOption];
}
function createGrid(eGridDiv, gridOptions, params) {
  if (!gridOptions) {
    _error(11);
    return {};
  }
  const gridParams = params;
  let destroyCallback;
  if (!gridParams?.setThemeOnGridDiv) {
    const newGridDiv = document.createElement("div");
    newGridDiv.style.height = "100%";
    eGridDiv.appendChild(newGridDiv);
    eGridDiv = newGridDiv;
    destroyCallback = () => eGridDiv.remove();
  }
  const api = new GridCoreCreator().create(
    eGridDiv,
    gridOptions,
    (context) => {
      const gridComp = new GridComp(eGridDiv);
      context.createBean(gridComp);
    },
    void 0,
    params,
    destroyCallback
  );
  return api;
}
var nextGridId = 1;
var GridCoreCreator = class {
  create(eGridDiv, providedOptions, createUi, acceptChanges, params, destroyCallback) {
    const gridOptions = GlobalGridOptions.applyGlobalGridOptions(providedOptions);
    const gridId = gridOptions.gridId ?? String(nextGridId++);
    const rowModelType = gridOptions.rowModelType ?? "clientSide";
    const registeredModules = this.getRegisteredModules(params, gridId, rowModelType);
    const beanClasses = this.createBeansList(rowModelType, registeredModules, gridId);
    const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
    if (!beanClasses) {
      return void 0;
    }
    const contextParams = {
      providedBeanInstances,
      beanClasses,
      gridId,
      beanInitComparator: gridBeanInitComparator,
      beanDestroyComparator: gridBeanDestroyComparator,
      derivedBeans: [createGridApi],
      destroyCallback
    };
    const context = new Context(contextParams);
    this.registerModuleFeatures(context, registeredModules);
    createUi(context);
    context.getBean("syncSvc").start();
    if (acceptChanges) {
      acceptChanges(context);
    }
    return context.getBean("gridApi");
  }
  getRegisteredModules(params, gridId, rowModelType) {
    _registerModule(CommunityCoreModule, void 0);
    params?.modules?.forEach((m) => _registerModule(m, gridId));
    return _getRegisteredModules(gridId, rowModelType);
  }
  registerModuleFeatures(context, registeredModules) {
    const registry = context.getBean("registry");
    const apiFunctionSvc = context.getBean("apiFunctionSvc");
    registeredModules.forEach((module2) => {
      registry.registerModule(module2);
      const apiFunctions = module2.apiFunctions;
      if (apiFunctions) {
        const names = Object.keys(apiFunctions);
        names.forEach((name) => {
          apiFunctionSvc?.addFunction(name, apiFunctions[name]);
        });
      }
    });
  }
  createProvidedBeans(eGridDiv, gridOptions, params) {
    let frameworkOverrides = params ? params.frameworkOverrides : null;
    if (_missing(frameworkOverrides)) {
      frameworkOverrides = new VanillaFrameworkOverrides();
    }
    const seed = {
      gridOptions,
      eGridDiv,
      globalListener: params ? params.globalListener : null,
      globalSyncListener: params ? params.globalSyncListener : null,
      frameworkOverrides
    };
    if (params && params.providedBeanInstances) {
      Object.assign(seed, params.providedBeanInstances);
    }
    return seed;
  }
  createBeansList(rowModelType, registeredModules, gridId) {
    const rowModelModuleNames = {
      clientSide: "ClientSideRowModel",
      infinite: "InfiniteRowModel",
      serverSide: "ServerSideRowModel",
      viewport: "ViewportRowModel"
    };
    const rowModuleModelName = rowModelModuleNames[rowModelType];
    if (!rowModuleModelName) {
      _logPreInitErr(201, { rowModelType }, `Unknown rowModelType ${rowModelType}.`);
      return;
    }
    if (!_isModuleRegistered(rowModuleModelName, gridId, rowModelType)) {
      _logPreInitErr(
        200,
        {
          reasonOrId: `rowModelType = '${rowModelType}'`,
          moduleName: rowModuleModelName,
          gridScoped: _areModulesGridScoped(),
          gridId,
          rowModelType
        },
        `Missing module ${rowModuleModelName}Module for rowModelType ${rowModelType}. 
If upgrading from before v33, see ${baseDocLink}/upgrading-to-ag-grid-33/#changes-to-modules/`
      );
      return;
    }
    const beans = /* @__PURE__ */ new Set();
    registeredModules.forEach((module2) => module2.beans?.forEach((bean) => beans.add(bean)));
    return Array.from(beans);
  }
};

// packages/ag-grid-community/src/api/rowModelApiUtils.ts
function _getClientSideRowModel(beans) {
  const rowModel = beans.rowModel;
  return rowModel.getType() === "clientSide" ? rowModel : void 0;
}
function _getInfiniteRowModel(beans) {
  const rowModel = beans.rowModel;
  return rowModel.getType() === "infinite" ? rowModel : void 0;
}
function _getServerSideRowModel(beans) {
  const rowModel = beans.rowModel;
  return rowModel.getType() === "serverSide" ? rowModel : void 0;
}

// packages/ag-grid-community/src/eventTypes.ts
var _PUBLIC_EVENTS = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel"
];
var _INTERNAL_EVENTS = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "scrollGapChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnGroupHeaderHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged",
  "overlayExclusiveChanged",
  "beforeRefreshModel"
];
var _ALL_EVENTS = [..._PUBLIC_EVENTS, ..._INTERNAL_EVENTS];

// packages/ag-grid-community/src/misc/locale/localeService.ts
var LocaleService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "localeSvc";
  }
  getLocaleTextFunc() {
    const gos = this.gos;
    const getLocaleText = gos.getCallback("getLocaleText");
    if (getLocaleText) {
      return (key, defaultValue, variableValues) => {
        const params = {
          key,
          defaultValue,
          variableValues
        };
        return getLocaleText(params);
      };
    }
    const localeText = gos.get("localeText");
    return (key, defaultValue, variableValues) => {
      let localisedText = localeText && localeText[key];
      if (localisedText && variableValues && variableValues.length) {
        let found = 0;
        while (true) {
          if (found >= variableValues.length) {
            break;
          }
          const idx = localisedText.indexOf("${variable}");
          if (idx === -1) {
            break;
          }
          localisedText = localisedText.replace("${variable}", variableValues[found++]);
        }
      }
      return localisedText ?? defaultValue;
    };
  }
};

// packages/ag-grid-community/src/propertyKeys.ts
var STRING_GRID_OPTIONS = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
  // 'treeDataChildrenField',
];
var OBJECT_GRID_OPTIONS = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy",
  "selectionColumnDef"
];
var ARRAY_GRID_OPTIONS = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
var _NUMBER_GRID_OPTIONS = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
var OTHER_GRID_OPTIONS = ["theme", "rowSelection"];
var _BOOLEAN_MIXED_GRID_OPTIONS = [
  "cellSelection",
  "sideBar",
  "suppressGroupChangesColumnVisibility",
  "groupAggFiltering",
  "suppressStickyTotalRow",
  "groupHideParentOfSingleChild"
];
var _BOOLEAN_GRID_OPTIONS = [
  "loadThemeGoogleFonts",
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault"
];
var _FUNCTION_GRID_OPTIONS = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "chartMenuItems",
  "groupTotalRow",
  "alwaysPassFilter"
];
var _ALL_GRID_OPTIONS = [
  ...ARRAY_GRID_OPTIONS,
  ...OBJECT_GRID_OPTIONS,
  ...STRING_GRID_OPTIONS,
  ..._NUMBER_GRID_OPTIONS,
  ..._FUNCTION_GRID_OPTIONS,
  ..._BOOLEAN_GRID_OPTIONS,
  ..._BOOLEAN_MIXED_GRID_OPTIONS,
  ...OTHER_GRID_OPTIONS
];

// packages/ag-grid-community/src/components/framework/frameworkComponentWrapper.ts
var BaseComponentWrapper = class {
  wrap(OriginalConstructor, mandatoryMethods, optionalMethods, componentType) {
    const wrapper = this.createWrapper(OriginalConstructor, componentType);
    mandatoryMethods?.forEach((methodName) => {
      this.createMethod(wrapper, methodName, true);
    });
    optionalMethods?.forEach((methodName) => {
      this.createMethod(wrapper, methodName, false);
    });
    return wrapper;
  }
  createMethod(wrapper, methodName, mandatory) {
    wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
  }
  createMethodProxy(wrapper, methodName, mandatory) {
    return function() {
      if (wrapper.hasMethod(methodName)) {
        return wrapper.callMethod(methodName, arguments);
      }
      if (mandatory) {
        _warn(49, { methodName });
      }
      return null;
    };
  }
};

// packages/ag-grid-community/src/tooltip/tooltipComponent.ts
var TooltipComponent2 = class extends PopupComponent {
  constructor() {
    super(
      /* html */
      `<div class="ag-tooltip"></div>`
    );
  }
  // will need to type params
  init(params) {
    const { value } = params;
    this.getGui().textContent = _escapeString(value, true);
  }
};

// packages/ag-grid-community/src/utils/fuzzyMatch.ts
function _fuzzySuggestions(params) {
  const { inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch, addSequentialWeight } = params;
  let thisSuggestions = allSuggestions.map((text, idx) => ({
    value: text,
    relevance: levenshteinDistance(inputValue.toLowerCase(), text.toLocaleLowerCase(), addSequentialWeight),
    idx
  }));
  thisSuggestions.sort((a, b) => b.relevance - a.relevance);
  if (hideIrrelevant) {
    thisSuggestions = thisSuggestions.filter((suggestion) => suggestion.relevance !== 0);
  }
  if (thisSuggestions.length > 0 && filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
    const bestMatch = thisSuggestions[0].relevance;
    const limit = bestMatch * filterByPercentageOfBestMatch;
    thisSuggestions = thisSuggestions.filter((suggestion) => limit - suggestion.relevance < 0);
  }
  const values = [];
  const indices = [];
  for (const suggestion of thisSuggestions) {
    values.push(suggestion.value);
    indices.push(suggestion.idx);
  }
  return { values, indices };
}
function getAllSubstrings(str) {
  const result = [];
  const size = str.length;
  for (let len = 1; len <= size; len++) {
    for (let i = 0; i <= size - len; i++) {
      const j = i + len - 1;
      result.push(str.slice(i, j + 1));
    }
  }
  return result;
}
function levenshteinDistance(str1, str2, addSequentialWeight = false) {
  const a = str1.replace(/\s/g, "");
  const b = str2.replace(/\s/g, "");
  const len1 = a.length;
  const len2 = b.length;
  const m = new Array(len1 + 1).fill(null).map(() => new Array(len2 + 1).fill(0));
  for (let i = 0; i <= len1; i += 1) {
    m[i][0] = i;
  }
  for (let j = 0; j <= len2; j += 1) {
    m[0][j] = j;
  }
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      if (a[i - 1] === b[j - 1]) {
        m[i][j] = m[i - 1][j - 1];
      } else {
        m[i][j] = 1 + Math.min(m[i][j - 1], Math.min(m[i - 1][j], m[i - 1][j - 1]));
      }
    }
  }
  const distance = m[len1][len2];
  const maxDistance = Math.max(len1, len2);
  let weight = maxDistance - distance;
  if (addSequentialWeight) {
    const substrings = getAllSubstrings(a);
    for (let i = 0; i < substrings.length; i++) {
      const currentSubstring = substrings[i];
      if (b.indexOf(currentSubstring) !== -1) {
        weight += 1;
        weight *= currentSubstring.length;
      }
    }
  }
  return weight;
}

// packages/ag-grid-community/src/utils/number.ts
function _formatNumberCommas(value, getLocaleTextFunc) {
  if (typeof value !== "number") {
    return "";
  }
  const localeTextFunc = getLocaleTextFunc();
  const thousandSeparator = localeTextFunc("thousandSeparator", ",");
  const decimalSeparator = localeTextFunc("decimalSeparator", ".");
  return value.toString().replace(".", decimalSeparator).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${thousandSeparator}`);
}

// packages/ag-grid-community/src/export/baseCreator.ts
var BaseCreator = class extends BeanStub {
  getFileName(fileName) {
    const extension = this.getDefaultFileExtension();
    if (fileName == null || !fileName.length) {
      fileName = this.getDefaultFileName();
    }
    return fileName.indexOf(".") === -1 ? `${fileName}.${extension}` : fileName;
  }
  getData(params) {
    const serializingSession = this.createSerializingSession(params);
    return this.beans.gridSerializer.serialize(serializingSession, params);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
};

// packages/ag-grid-community/src/export/baseGridSerializingSession.ts
var BaseGridSerializingSession = class {
  constructor(config) {
    this.groupColumns = [];
    const {
      colModel,
      rowGroupColsSvc,
      colNames,
      valueSvc,
      gos,
      processCellCallback,
      processHeaderCallback,
      processGroupHeaderCallback,
      processRowGroupCallback
    } = config;
    this.colModel = colModel;
    this.rowGroupColsSvc = rowGroupColsSvc;
    this.colNames = colNames;
    this.valueSvc = valueSvc;
    this.gos = gos;
    this.processCellCallback = processCellCallback;
    this.processHeaderCallback = processHeaderCallback;
    this.processGroupHeaderCallback = processGroupHeaderCallback;
    this.processRowGroupCallback = processRowGroupCallback;
  }
  prepare(columnsToExport) {
    this.groupColumns = columnsToExport.filter((col) => !!col.getColDef().showRowGroup);
  }
  extractHeaderValue(column) {
    const value = this.getHeaderName(this.processHeaderCallback, column);
    return value ?? "";
  }
  extractRowCellValue(column, index, accumulatedRowIndex, type, node) {
    const hideOpenParents = this.gos.get("groupHideOpenParents");
    const value = (!hideOpenParents || node.footer) && this.shouldRenderGroupSummaryCell(node, column, index) ? this.createValueForGroupNode(column, node) : this.valueSvc.getValue(column, node);
    const processedValue = this.processCell({
      accumulatedRowIndex,
      rowNode: node,
      column,
      value,
      processCellCallback: this.processCellCallback,
      type
    });
    return processedValue;
  }
  shouldRenderGroupSummaryCell(node, column, currentColumnIndex) {
    const isGroupNode = node.group && !this.gos.get("treeData");
    if (!isGroupNode) {
      return false;
    }
    const currentColumnGroupIndex = this.groupColumns.indexOf(column);
    if (currentColumnGroupIndex !== -1) {
      if (node.groupData?.[column.getId()] !== void 0) {
        return true;
      }
      if (_isServerSideRowModel(this.gos) && node.group) {
        return true;
      }
      if (node.footer && node.level === -1) {
        const colDef = column.getColDef();
        const isFullWidth = colDef == null || colDef.showRowGroup === true;
        return isFullWidth || colDef.showRowGroup === this.rowGroupColsSvc?.columns[0].getId();
      }
    }
    const isGroupUseEntireRow = _isGroupUseEntireRow(this.gos, this.colModel.isPivotMode());
    return currentColumnIndex === 0 && isGroupUseEntireRow;
  }
  getHeaderName(callback, column) {
    if (callback) {
      return callback(this.gos.addGridCommonParams({ column }));
    }
    return this.colNames.getDisplayNameForColumn(column, "csv", true);
  }
  createValueForGroupNode(column, node) {
    if (this.processRowGroupCallback) {
      return this.processRowGroupCallback(this.gos.addGridCommonParams({ column, node }));
    }
    const isTreeData = this.gos.get("treeData");
    const getValueFromNode = (node2) => {
      if (isTreeData) {
        return node2.key;
      }
      const value = node2.groupData?.[column.getId()];
      if (!value || !node2.rowGroupColumn || node2.rowGroupColumn.getColDef().useValueFormatterForExport === false) {
        return value;
      }
      return this.valueSvc.formatValue(node2.rowGroupColumn, node2, value) ?? value;
    };
    const isFooter = node.footer;
    const keys = [getValueFromNode(node)];
    if (!_isGroupMultiAutoColumn(this.gos)) {
      while (node.parent) {
        node = node.parent;
        keys.push(getValueFromNode(node));
      }
    }
    const groupValue = keys.reverse().join(" -> ");
    return isFooter ? `Total ${groupValue}` : groupValue;
  }
  processCell(params) {
    const { accumulatedRowIndex, rowNode, column, value, processCellCallback, type } = params;
    if (processCellCallback) {
      return {
        value: processCellCallback(
          this.gos.addGridCommonParams({
            accumulatedRowIndex,
            column,
            node: rowNode,
            value,
            type,
            parseValue: (valueToParse) => this.valueSvc.parseValue(
              column,
              rowNode,
              valueToParse,
              this.valueSvc.getValue(column, rowNode)
            ),
            formatValue: (valueToFormat) => this.valueSvc.formatValue(column, rowNode, valueToFormat) ?? valueToFormat
          })
        ) ?? ""
      };
    }
    if (column.getColDef().useValueFormatterForExport !== false) {
      return {
        value: value ?? "",
        valueFormatted: this.valueSvc.formatValue(column, rowNode, value)
      };
    }
    return { value: value ?? "" };
  }
};

// packages/ag-grid-community/src/export/downloader.ts
function _downloadFile(fileName, content) {
  const win = document.defaultView || window;
  if (!win) {
    _warn(52);
    return;
  }
  const element = document.createElement("a");
  const url = win.URL.createObjectURL(content);
  element.setAttribute("href", url);
  element.setAttribute("download", fileName);
  element.style.display = "none";
  document.body.appendChild(element);
  element.dispatchEvent(
    new MouseEvent("click", {
      bubbles: false,
      cancelable: true,
      view: win
    })
  );
  document.body.removeChild(element);
  win.setTimeout(() => {
    win.URL.revokeObjectURL(url);
  }, 0);
}

// packages/ag-grid-community/src/gridOptionsInitial.ts
var INITIAL_GRID_OPTION_KEYS = {
  enableBrowserTooltips: true,
  tooltipTrigger: true,
  tooltipMouseTrack: true,
  tooltipShowMode: true,
  tooltipInteraction: true,
  defaultColGroupDef: true,
  suppressAutoSize: true,
  skipHeaderOnAutoSize: true,
  autoSizeStrategy: true,
  components: true,
  stopEditingWhenCellsLoseFocus: true,
  undoRedoCellEditing: true,
  undoRedoCellEditingLimit: true,
  excelStyles: true,
  cacheQuickFilter: true,
  customChartThemes: true,
  chartThemeOverrides: true,
  chartToolPanelsDef: true,
  loadingCellRendererSelector: true,
  localeText: true,
  keepDetailRows: true,
  keepDetailRowsCount: true,
  detailRowHeight: true,
  detailRowAutoHeight: true,
  tabIndex: true,
  valueCache: true,
  valueCacheNeverExpires: true,
  enableCellExpressions: true,
  suppressTouch: true,
  suppressBrowserResizeObserver: true,
  suppressPropertyNamesCheck: true,
  debug: true,
  dragAndDropImageComponent: true,
  loadingOverlayComponent: true,
  suppressLoadingOverlay: true,
  noRowsOverlayComponent: true,
  paginationPageSizeSelector: true,
  paginateChildRows: true,
  pivotPanelShow: true,
  pivotSuppressAutoColumn: true,
  suppressExpandablePivotGroups: true,
  aggFuncs: true,
  allowShowChangeAfterFilter: true,
  ensureDomOrder: true,
  enableRtl: true,
  suppressColumnVirtualisation: true,
  suppressMaxRenderedRowRestriction: true,
  suppressRowVirtualisation: true,
  rowDragText: true,
  groupLockGroupColumns: true,
  suppressGroupRowsSticky: true,
  rowModelType: true,
  cacheOverflowSize: true,
  infiniteInitialRowCount: true,
  serverSideInitialRowCount: true,
  maxBlocksInCache: true,
  maxConcurrentDatasourceRequests: true,
  blockLoadDebounceMillis: true,
  serverSideOnlyRefreshFilteredGroups: true,
  serverSidePivotResultFieldSeparator: true,
  viewportRowModelPageSize: true,
  viewportRowModelBufferSize: true,
  debounceVerticalScrollbar: true,
  suppressAnimationFrame: true,
  suppressPreventDefaultOnMouseWheel: true,
  scrollbarWidth: true,
  icons: true,
  suppressRowTransform: true,
  gridId: true,
  enableGroupEdit: true,
  initialState: true,
  processUnpinnedColumns: true,
  createChartContainer: true,
  getLocaleText: true,
  getRowId: true,
  reactiveCustomComponents: true,
  columnMenu: true,
  suppressSetFilterByDefault: true,
  getDataPath: true
};

// packages/ag-grid-community/src/validation/apiFunctionValidator.ts
var clientSide = "clientSide";
var serverSide = "serverSide";
var infinite = "infinite";
var functionRowModels = {
  onGroupExpandedOrCollapsed: [clientSide],
  refreshClientSideRowModel: [clientSide],
  isRowDataEmpty: [clientSide],
  forEachLeafNode: [clientSide],
  forEachNodeAfterFilter: [clientSide],
  forEachNodeAfterFilterAndSort: [clientSide],
  resetRowHeights: [clientSide],
  applyTransaction: [clientSide],
  applyTransactionAsync: [clientSide],
  flushAsyncTransactions: [clientSide],
  getBestCostNodeSelection: [clientSide],
  getServerSideSelectionState: [serverSide],
  setServerSideSelectionState: [serverSide],
  applyServerSideTransaction: [serverSide],
  applyServerSideTransactionAsync: [serverSide],
  applyServerSideRowData: [serverSide],
  retryServerSideLoads: [serverSide],
  flushServerSideAsyncTransactions: [serverSide],
  refreshServerSide: [serverSide],
  getServerSideGroupLevelState: [serverSide],
  refreshInfiniteCache: [infinite],
  purgeInfiniteCache: [infinite],
  getInfiniteRowCount: [infinite],
  isLastRowIndexKnown: [infinite, serverSide],
  expandAll: [clientSide, serverSide],
  collapseAll: [clientSide, serverSide],
  onRowHeightChanged: [clientSide, serverSide],
  setRowCount: [infinite, serverSide],
  getCacheBlockState: [infinite, serverSide]
};
var deprecatedFunctions = {
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  },
  clearRangeSelection: {
    version: "v32.2",
    message: "Use `clearCellSelection` instead."
  },
  getInfiniteRowCount: {
    version: "v32.2",
    old: "getInfiniteRowCount()",
    new: "getDisplayedRowCount()"
  },
  selectAllFiltered: {
    version: "v33",
    old: "selectAllFiltered()",
    new: 'selectAll("filtered")'
  },
  deselectAllFiltered: {
    version: "v33",
    old: "deselectAllFiltered()",
    new: 'deselectAll("filtered")'
  },
  selectAllOnCurrentPage: {
    version: "v33",
    old: "selectAllOnCurrentPage()",
    new: 'selectAll("currentPage")'
  },
  deselectAllOnCurrentPage: {
    version: "v33",
    old: "deselectAllOnCurrentPage()",
    new: 'deselectAll("currentPage")'
  }
};
function validateApiFunction(functionName, apiFunction, beans) {
  const deprecation = deprecatedFunctions[functionName];
  if (deprecation) {
    const { version, new: replacement, old, message } = deprecation;
    const apiMethod = old ?? functionName;
    return (...args) => {
      const replacementMessage = replacement ? `Please use ${replacement} instead. ` : "";
      _warnOnce(`Since ${version} api.${apiMethod} is deprecated. ${replacementMessage}${message ?? ""}`);
      return apiFunction.apply(apiFunction, args);
    };
  }
  const rowModels = functionRowModels[functionName];
  if (rowModels) {
    return (...args) => {
      const rowModel = beans.rowModel.getType();
      if (!rowModels.includes(rowModel)) {
        _errorOnce(
          `api.${functionName} can only be called when gridOptions.rowModelType is ${rowModels.join(" or ")}`
        );
        return void 0;
      }
      return apiFunction.apply(apiFunction, args);
    };
  }
  return apiFunction;
}

// packages/ag-grid-community/src/validation/enterpriseModuleNames.ts
var ENTERPRISE_MODULE_NAMES = {
  AdvancedFilter: 1,
  AllEnterprise: 1,
  CellSelection: 1,
  Clipboard: 1,
  ColumnMenu: 1,
  ColumnsToolPanel: 1,
  ContextMenu: 1,
  ExcelExport: 1,
  FiltersToolPanel: 1,
  GridCharts: 1,
  IntegratedCharts: 1,
  GroupFilter: 1,
  MasterDetail: 1,
  Menu: 1,
  MultiFilter: 1,
  Pivot: 1,
  RangeSelection: 1,
  RichSelect: 1,
  RowGrouping: 1,
  RowGroupingPanel: 1,
  ServerSideRowModelApi: 1,
  ServerSideRowModel: 1,
  SetFilter: 1,
  SideBar: 1,
  Sparklines: 1,
  StatusBar: 1,
  TreeData: 1,
  ViewportRowModel: 1
};

// packages/ag-grid-community/src/validation/resolvableModuleNames.ts
var ALL_COLUMN_FILTERS = [
  "TextFilter",
  "NumberFilter",
  "DateFilter",
  "SetFilter",
  "MultiFilter",
  "GroupFilter",
  "CustomFilter"
];
var RESOLVABLE_MODULE_NAMES = {
  EditCore: [
    "TextEditor",
    "NumberEditor",
    "DateEditor",
    "CheckboxEditor",
    "LargeTextEditor",
    "SelectEditor",
    "RichSelect",
    "CustomEditor"
  ],
  CheckboxCellRenderer: ["AllCommunity"],
  ClientSideRowModelHierarchy: ["RowGrouping", "Pivot", "TreeData"],
  ColumnFilter: ALL_COLUMN_FILTERS,
  ColumnGroupHeaderComp: ["AllCommunity"],
  ColumnGroup: ["AllCommunity"],
  ColumnHeaderComp: ["AllCommunity"],
  ColumnMove: ["AllCommunity"],
  ColumnResize: ["AllCommunity"],
  CommunityCore: ["AllCommunity"],
  CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  EnterpriseCore: ["AllEnterprise"],
  FilterCore: [...ALL_COLUMN_FILTERS, "QuickFilter", "ExternalFilter", "AdvancedFilter"],
  GroupCellRenderer: ["RowGrouping", "Pivot", "TreeData", "MasterDetail", "ServerSideRowModel"],
  KeyboardNavigation: ["AllCommunity"],
  LoadingCellRenderer: ["ServerSideRowModel"],
  MenuCore: ["ColumnMenu", "ContextMenu"],
  MenuItem: ["ColumnMenu", "ContextMenu", "MultiFilter", "IntegratedCharts", "ColumnsToolPanel"],
  Overlay: ["AllCommunity"],
  PinnedColumn: ["AllCommunity"],
  SharedAggregation: ["RowGrouping", "Pivot", "TreeData", "ServerSideRowModel"],
  SharedDragAndDrop: ["AllCommunity"],
  SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
  SharedMenu: [...ALL_COLUMN_FILTERS, "ColumnMenu", "ContextMenu"],
  SharedPivot: ["Pivot", "ServerSideRowModel"],
  SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
  SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
  SkeletonCellRenderer: ["ServerSideRowModel"],
  Sort: ["AllCommunity"],
  SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
  SharedTreeData: ["TreeData", "ServerSideRowModel"]
};
var MODULES_FOR_ROW_MODELS = {
  InfiniteRowModel: "infinite",
  ClientSideRowModelApi: "clientSide",
  ClientSideRowModel: "clientSide",
  ServerSideRowModelApi: "serverSide",
  ServerSideRowModel: "serverSide",
  ViewportRowModel: "viewport"
};
function resolveModuleNames(moduleName, rowModelType) {
  const resolvedModuleNames = [];
  (Array.isArray(moduleName) ? moduleName : [moduleName]).forEach((modName) => {
    const resolved = RESOLVABLE_MODULE_NAMES[modName];
    if (resolved) {
      resolved.forEach((resolvedModName) => {
        const rowModelForModule = MODULES_FOR_ROW_MODELS[resolvedModName];
        if (!rowModelForModule || rowModelForModule === rowModelType) {
          resolvedModuleNames.push(resolvedModName);
        }
      });
    } else {
      resolvedModuleNames.push(modName);
    }
  });
  return resolvedModuleNames;
}

// packages/ag-grid-community/src/validation/rules/userCompValidations.ts
var USER_COMP_MODULES = {
  agSetColumnFilter: "SetFilter",
  agSetColumnFloatingFilter: "SetFilter",
  agMultiColumnFilter: "MultiFilter",
  agMultiColumnFloatingFilter: "MultiFilter",
  agGroupColumnFilter: "GroupFilter",
  agGroupColumnFloatingFilter: "GroupFilter",
  agGroupCellRenderer: "GroupCellRenderer",
  agGroupRowRenderer: "GroupCellRenderer",
  agRichSelect: "RichSelect",
  agRichSelectCellEditor: "RichSelect",
  agDetailCellRenderer: "SharedMasterDetail",
  agSparklineCellRenderer: "Sparklines",
  agDragAndDropImage: "SharedDragAndDrop",
  agColumnHeader: "ColumnHeaderComp",
  agColumnGroupHeader: "ColumnGroupHeaderComp",
  agSortIndicator: "Sort",
  agAnimateShowChangeCellRenderer: "HighlightChanges",
  agAnimateSlideCellRenderer: "HighlightChanges",
  agLoadingCellRenderer: "LoadingCellRenderer",
  agSkeletonCellRenderer: "SkeletonCellRenderer",
  agCheckboxCellRenderer: "CheckboxCellRenderer",
  agLoadingOverlay: "Overlay",
  agNoRowsOverlay: "Overlay",
  agTooltipComponent: "Tooltip",
  agReadOnlyFloatingFilter: "CustomFilter",
  agTextColumnFilter: "TextFilter",
  agNumberColumnFilter: "NumberFilter",
  agDateColumnFilter: "DateFilter",
  agDateInput: "DateFilter",
  agTextColumnFloatingFilter: "TextFilter",
  agNumberColumnFloatingFilter: "NumberFilter",
  agDateColumnFloatingFilter: "DateFilter",
  agCellEditor: "TextEditor",
  agSelectCellEditor: "SelectEditor",
  agTextCellEditor: "TextEditor",
  agNumberCellEditor: "NumberEditor",
  agDateCellEditor: "DateEditor",
  agDateStringCellEditor: "DateEditor",
  agCheckboxCellEditor: "CheckboxEditor",
  agLargeTextCellEditor: "LargeTextEditor",
  agMenuItem: "MenuItem",
  agColumnsToolPanel: "ColumnsToolPanel",
  agFiltersToolPanel: "FiltersToolPanel",
  agAggregationComponent: "StatusBar",
  agSelectedRowCountComponent: "StatusBar",
  agTotalRowCountComponent: "StatusBar",
  agFilteredRowCountComponent: "StatusBar",
  agTotalAndFilteredRowCountComponent: "StatusBar"
};

// packages/ag-grid-community/src/validation/errorMessages/errorText.ts
var moduleImportMsg = (moduleNames) => {
  const imports = moduleNames.map(
    (moduleName) => `import { ${convertToUserModuleName(moduleName)} } from '${ENTERPRISE_MODULE_NAMES[moduleName] ? "ag-grid-enterprise" : "ag-grid-community"}';`
  ).join(" \n");
  return `import { ModuleRegistry } from 'ag-grid-community'; 
${imports} 

ModuleRegistry.registerModules([ ${moduleNames.map(convertToUserModuleName).join(", ")} ]); 

For more info see: ${baseDocLink}/modules/`;
};
function convertToUserModuleName(moduleName) {
  return `${moduleName}Module`;
}
var missingModule = ({
  reasonOrId,
  moduleName,
  gridScoped,
  gridId,
  rowModelType,
  additionalText
}) => {
  const resolvedModuleNames = resolveModuleNames(moduleName, rowModelType);
  const reason = typeof reasonOrId === "string" ? reasonOrId : MISSING_MODULE_REASONS[reasonOrId];
  return `Unable to use ${reason} as ${resolvedModuleNames.length > 1 ? "one of " + resolvedModuleNames.map(convertToUserModuleName).join(", ") : convertToUserModuleName(resolvedModuleNames[0])} is not registered${gridScoped ? " for gridId: " + gridId : ""}. Check if you have registered the module:
${moduleImportMsg(resolvedModuleNames)}` + (additionalText ? ` 

${additionalText}` : "");
};
var missingChartsWithModule = (gridModule) => {
  return `${gridModule} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${gridModule} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${gridModule}.with(AgChartsEnterpriseModule)]);
    `;
};
var clipboardApiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`;
var AG_GRID_ERRORS = {
  1: () => "`rowData` must be an array",
  2: ({ nodeId }) => `Duplicate node id '${nodeId}' detected from getRowId callback, this could cause issues in your grid.`,
  3: () => "Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.",
  4: ({ id }) => `Could not find row id=${id}, data item was not found for this id`,
  5: ({ data }) => [
    `Could not find data item as object was not found.`,
    data,
    " Consider using getRowId to help the Grid find matching row data"
  ],
  6: () => `'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'`,
  7: () => "Pivoting is not supported with aligned grids as it may produce different columns in each grid.",
  8: ({ key }) => `Unknown key for navigation ${key}`,
  9: ({ variable }) => `No value for ${variable.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${variable.defaultValue} will be used and updated when styles load.`,
  10: ({ eventType }) => `As of v33, the '${eventType}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
  11: () => "No gridOptions provided to createGrid",
  12: ({ colKey }) => ["column ", colKey, " not found"],
  13: () => "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.",
  14: ({ groupPrefix }) => `Row IDs cannot start with ${groupPrefix}, this is a reserved prefix for AG Grid's row grouping feature.`,
  15: ({ expression }) => ["value should be either a string or a function", expression],
  16: ({ expression, params, e }) => [
    "Processing of the expression failed",
    "Expression = ",
    expression,
    "Params = ",
    params,
    "Exception = ",
    e
  ],
  17: () => "you need either field or valueSetter set on colDef for editing to work",
  18: () => `alignedGrids contains an undefined option.`,
  19: () => `alignedGrids - No api found on the linked grid.`,
  20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
  21: () => "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.",
  22: ({ key }) => `${key} is an initial property and cannot be updated.`,
  23: () => "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.",
  24: () => "row height must be a number if not using standard row model",
  25: ({ id }) => [`The getRowId callback must return a string. The ID `, id, ` is being cast to a string.`],
  26: ({ fnName, preDestroyLink }) => {
    return `Grid API function ${fnName}() cannot be called as the grid has been destroyed.
 Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
 To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${preDestroyLink}`;
  },
  27: ({ fnName, module: module2 }) => `API function '${fnName}' not registered to module '${module2}'`,
  28: () => "setRowCount cannot be used while using row grouping.",
  29: () => "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?",
  30: ({ toIndex }) => [
    "tried to insert columns in invalid location, toIndex = ",
    toIndex,
    "remember that you should not count the moving columns when calculating the new index"
  ],
  31: () => "infinite loop in resizeColumnSets",
  32: () => "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.",
  33: () => "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.",
  34: ({ key }) => `the column type '${key}' is a default column type and cannot be overridden.`,
  35: () => `Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.`,
  36: ({ t }) => "colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes",
  37: () => `Changing the column pinning status is not allowed with domLayout='print'`,
  38: ({ iconName }) => `provided icon '${iconName}' needs to be a string or a function`,
  39: () => "Applying column order broke a group where columns should be married together. Applying new order has been discarded.",
  40: ({ e, method }) => `${e}
${clipboardApiError(method)}`,
  41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
  42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
  43: ({ iconName }) => `As of v33, icon '${iconName}' is deprecated. Use the icon CSS name instead.`,
  44: () => 'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
  45: ({ parentCellDataType }) => `The data type definition ${parentCellDataType} does not exist.`,
  46: () => 'The "baseDataType" property of a data type definition must match that of its parent.',
  47: ({ cellDataType }) => `Missing data type definition - "${cellDataType}"`,
  48: ({ property }) => `Cell data type is "object" but no Value ${property} has been provided. Please either provide an object data type definition with a Value ${property}, or set "colDef.value${property}"`,
  49: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
  50: ({ compName }) => `Could not find component ${compName}, did you forget to configure this component?`,
  51: () => `Export cancelled. Export is not allowed as per your configuration.`,
  52: () => "There is no `window` associated with the current `document`",
  53: () => `unknown value type during csv conversion`,
  54: () => "Could not find document body, it is needed for drag and drop and context menu.",
  55: () => "addRowDropZone - A container target needs to be provided",
  56: () => "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.",
  57: () => "unable to show popup filter, filter instantiation failed",
  58: () => "no values found for select cellEditor",
  59: () => "cannot select pinned rows",
  60: () => "cannot select node until it has finished loading",
  61: () => "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.",
  62: ({ colId }) => `setFilterModel() - no column found for colId: ${colId}`,
  63: ({ colId }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${colId}`,
  64: ({ colId }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${colId}`,
  65: () => "filter missing setModel method, which is needed for setFilterModel",
  66: () => "filter API missing getModel method, which is needed for getFilterModel",
  67: () => "Filter is missing isFilterActive() method",
  68: () => "Column Filter API methods have been disabled as Advanced Filters are enabled.",
  69: ({ guiFromFilter }) => `getGui method from filter returned ${guiFromFilter}; it should be a DOM element.`,
  70: ({ newFilter }) => `Grid option quickFilterText only supports string inputs, received: ${typeof newFilter}`,
  71: () => "debounceMs is ignored when apply button is present",
  72: ({ keys }) => [`ignoring FilterOptionDef as it doesn't contain one of `, keys],
  73: () => `invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`,
  74: () => "no filter options for filter",
  75: () => "Unknown button type specified",
  76: ({ filterModelType }) => [
    'Unexpected type of filter "',
    filterModelType,
    '", it looks like the filter was configured with incorrect Filter Options'
  ],
  77: () => `Filter model is missing 'conditions'`,
  78: () => 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
  79: () => '"filterParams.maxNumConditions" must be greater than or equal to zero.',
  80: () => '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
  81: () => '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
  82: ({ param }) => `DateFilter ${param} is not a number`,
  83: () => `DateFilter minValidYear should be <= maxValidYear`,
  84: () => `DateFilter minValidDate should be <= maxValidDate`,
  85: () => "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.",
  86: () => "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.",
  87: () => "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.",
  88: ({ index }) => `Invalid row index for ensureIndexVisible: ${index}`,
  89: () => `A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`,
  90: () => `datasource is missing getRows method`,
  91: () => "Filter is missing method doesFilterPass",
  92: ({ methodName }) => `AnimationFrameService.${methodName} called but animation frames are off`,
  93: () => "cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`",
  94: ({
    paginationPageSizeOption,
    pageSizeSet,
    pageSizesSet,
    pageSizeOptions
  }) => `'paginationPageSize=${paginationPageSizeOption}'${pageSizeSet ? "" : " (default value)"}, but ${paginationPageSizeOption} is not included in${pageSizesSet ? "" : " the default"} paginationPageSizeSelector=[${pageSizeOptions.join(", ")}].`,
  95: ({
    paginationPageSizeOption,
    paginationPageSizeSelector: paginationPageSizeSelector2
  }) => `Either set '${paginationPageSizeSelector2}' to an array that includes ${paginationPageSizeOption} or to 'false' to disable the page size selector.`,
  96: ({ id, data }) => [
    "Duplicate ID",
    id,
    "found for pinned row with data",
    data,
    "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
  ],
  97: ({ colId }) => `cellEditor for column ${colId} is missing getGui() method`,
  98: () => "popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.",
  99: () => "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.",
  100: ({ rowModelType }) => `selectAll only available when rowModelType='clientSide', ie not ${rowModelType}`,
  101: ({
    propertyName,
    componentName,
    agGridDefaults,
    jsComps
  }) => {
    const textOutput = [];
    const validComponents = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(agGridDefaults).filter(
        (k) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(k)
      ),
      ...Object.keys(jsComps)
    ];
    const suggestions = _fuzzySuggestions({
      inputValue: componentName,
      allSuggestions: validComponents,
      hideIrrelevant: true,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    textOutput.push(
      `Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.
`
    );
    if (suggestions.length > 0) {
      textOutput.push(`         Did you mean: [${suggestions.slice(0, 3)}]?
`);
    }
    textOutput.push(`If using a custom component check it has been registered correctly.`);
    return textOutput;
  },
  102: () => "selecting just filtered only works when gridOptions.rowModelType='clientSide'",
  103: () => "Invalid selection state. When using client-side row model, the state must conform to `string[]`.",
  104: ({ value, param }) => `Numeric value ${value} passed to ${param} param will be interpreted as ${value} seconds. If this is intentional use "${value}s" to silence this warning.`,
  105: ({ e }) => [`chart rendering failed`, e],
  106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${baseDocLink}/theming-migration/`,
  107: ({ key, value }) => `Invalid value for theme param ${key} - ${value}`,
  108: ({ e }) => ["chart update failed", e],
  109: ({ aggFuncOrString }) => `unrecognised aggregation function ${aggFuncOrString}`,
  110: () => "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup",
  111: () => "Invalid selection state. When `groupSelectsChildren` is enabled, the state must conform to `IServerSideGroupSelectionState`.",
  113: () => "Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values",
  114: ({ component }) => `Could not find component with name of ${component}. Is it in Vue.components?`,
  115: () => "The provided selection state should be an object.",
  116: () => "Invalid selection state. The state must conform to `IServerSideSelectionState`.",
  117: () => "selectAll must be of boolean type.",
  118: () => "Infinite scrolling must be enabled in order to set the row count.",
  119: () => "Unable to instantiate filter",
  120: () => "MultiFloatingFilterComp expects MultiFilter as its parent",
  121: () => "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key",
  122: () => "could not find the document, document is empty",
  123: () => "Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.",
  124: () => "No active charts to update.",
  125: ({ chartId }) => `Unable to update chart. No active chart found with ID: ${chartId}.`,
  126: () => "unable to restore chart as no chart model is provided",
  127: ({ allRange }) => `unable to create chart as ${allRange ? "there are no columns in the grid" : "no range is selected"}.`,
  128: ({ feature }) => `${feature} is only available if using 'multiRow' selection mode.`,
  129: ({ feature, rowModel }) => `${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModel}.`,
  130: () => 'cannot multi select unless selection mode is "multiRow"',
  131: () => "cannot range select while selecting multiple rows",
  132: () => "Row selection features are not available unless `rowSelection` is enabled.",
  133: ({ iconName }) => `icon '${iconName}' function should return back a string or a dom object`,
  134: ({ iconName }) => `Did not find icon '${iconName}'`,
  135: () => `Data type of the new value does not match the cell data type of the column`,
  136: () => `Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`,
  137: ({ type, currentChartType }) => `Unable to update chart as a '${type}' update type is not permitted on a ${currentChartType}.`,
  138: ({ chartType }) => `invalid chart type supplied: ${chartType}`,
  139: ({ customThemeName }) => `a custom chart theme with the name ${customThemeName} has been supplied but not added to the 'chartThemes' list`,
  140: ({ name }) => `no stock theme exists with the name '${name}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
  141: () => "cross filtering with row grouping is not supported.",
  142: () => "cross filtering is only supported in the client side row model.",
  143: ({ panel }) => `'${panel}' is not a valid Chart Tool Panel name`,
  144: ({ type }) => `Invalid charts data panel group name supplied: '${type}'`,
  145: ({ group }) => `As of v32, only one charts customize panel group can be expanded at a time. '${group}' will not be expanded.`,
  146: ({ comp }) => `Unable to instantiate component '${comp}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
  147: ({ group }) => `Invalid charts customize panel group name supplied: '${group}'`,
  148: ({ group }) => `invalid chartGroupsDef config '${group}'`,
  149: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
  150: () => `'seriesChartTypes' are required when the 'customCombo' chart type is specified.`,
  151: ({ chartType }) => `invalid chartType '${chartType}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
  152: ({ colId }) => `no 'seriesChartType' found for colId = '${colId}', defaulting to 'line'.`,
  153: ({ chartDataType }) => `unexpected chartDataType value '${chartDataType}' supplied, instead use 'category', 'series' or 'excluded'`,
  154: ({ colId }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${colId}`,
  155: ({ option }) => `'${option}' is not a valid Chart Toolbar Option`,
  156: ({ panel }) => `Invalid panel in chartToolPanelsDef.panels: '${panel}'`,
  157: ({ unrecognisedGroupIds }) => ["unable to find group(s) for supplied groupIds:", unrecognisedGroupIds],
  158: () => "can not expand a column item that does not represent a column group header",
  159: () => "Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.",
  160: () => `Export cancelled. Export is not allowed as per your configuration.`,
  161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
  162: ({ id, dataType }) => `Unrecognized data type for excel export [${id}.dataType=${dataType}]`,
  163: ({ featureName }) => `Excel table export does not work with ${featureName}. The exported Excel file will not contain any Excel tables.
 Please turn off ${featureName} to enable Excel table exports.`,
  164: () => "Unable to add data table to Excel sheet: A table already exists.",
  165: () => "Unable to add data table to Excel sheet: Missing required parameters.",
  166: ({ unrecognisedGroupIds }) => ["unable to find groups for these supplied groupIds:", unrecognisedGroupIds],
  167: ({ unrecognisedColIds }) => ["unable to find columns for these supplied colIds:", unrecognisedColIds],
  168: () => "detailCellRendererParams.template should be function or string",
  169: () => 'Reference to eDetailGrid was missing from the details template. Please add data-ref="eDetailGrid" to the template.',
  170: ({ providedStrategy }) => `invalid cellRendererParams.refreshStrategy = ${providedStrategy} supplied, defaulting to refreshStrategy = 'rows'.`,
  171: () => "could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions",
  172: () => "could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData",
  173: ({ group }) => `invalid chartGroupsDef config '${group}'`,
  174: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
  175: ({ menuTabName, itemsToConsider }) => [
    `Trying to render an invalid menu item '${menuTabName}'. Check that your 'menuTabs' contains one of `,
    itemsToConsider
  ],
  176: ({ key }) => `unknown menu item type ${key}`,
  177: () => `valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.`,
  178: ({ colId }) => `column ${colId} is not visible`,
  179: () => "totalValueGetter should be either a function or a string (expression)",
  180: () => "agRichSelectCellEditor requires cellEditorParams.values to be set",
  181: () => "agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.",
  182: () => 'you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data',
  183: () => "Group Column Filter only works on group columns. Please use a different filter.",
  184: ({ parentGroupData, childNodeData }) => [`duplicate group keys for row data, keys should be unique`, [parentGroupData, childNodeData]],
  185: ({ data }) => [`getDataPath() should not return an empty path`, [data]],
  186: ({
    rowId,
    rowData,
    duplicateRowsData
  }) => [`duplicate group keys for row data, keys should be unique`, rowId, rowData, ...duplicateRowsData],
  187: ({ rowId, firstData, secondData }) => [
    `Duplicate node id ${rowId}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
    "first instance",
    firstData,
    "second instance",
    secondData
  ],
  188: () => `getRowId callback must be provided for Server Side Row Model selection to work correctly.`,
  189: ({ startRow }) => `invalid value ${startRow} for startRow, the value should be >= 0`,
  190: ({ rowGroupId, data }) => [
    `null and undefined values are not allowed for server side row model keys`,
    rowGroupId ? `column = ${rowGroupId}` : ``,
    `data is `,
    data
  ],
  191: () => `cannot multi select unless selection mode is 'multiRow'`,
  192: () => `cannot use range selection when multi selecting rows`,
  193: () => "cannot multi select unless selection mode is 'multiRow'",
  194: ({ method }) => `calling gridApi.${method}() is only possible when using rowModelType=\`clientSide\`.`,
  195: ({ justCurrentPage }) => `selecting just ${justCurrentPage ? "current page" : "filtered"} only works when gridOptions.rowModelType='clientSide'`,
  196: ({ key }) => `Provided ids must be of string type. Invalid id provided: ${key}`,
  197: () => "`toggledNodes` must be an array of string ids.",
  198: () => `cannot multi select unless selection mode is 'multiRow'`,
  199: () => `getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
  200: missingModule,
  201: ({ rowModelType }) => `Could not find row model for rowModelType = ${rowModelType}`,
  202: () => `\`getSelectedNodes\` and \`getSelectedRows\` functions cannot be used with \`groupSelectsChildren\` and the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
  203: () => "Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.",
  204: () => "Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.",
  205: ({ duplicateIdText }) => `Unable to display rows as duplicate row ids (${duplicateIdText}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
  206: () => "getRowId callback must be implemented for transactions to work. Transaction was ignored.",
  207: () => 'The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.',
  208: () => `Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.`,
  209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${baseDocLink}/filter-set-filter-list/#filter-value-types`,
  210: () => "Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?",
  211: () => "property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.",
  212: () => `please review all your toolPanel components, it seems like at least one of them doesn't have an id`,
  213: () => "Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.",
  214: ({ key }) => `unable to lookup Tool Panel as invalid key supplied: ${key}`,
  215: ({ key, defaultByKey }) => `the key ${key} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(defaultByKey).join(",")}`,
  216: ({ name }) => `Missing component for '${name}'`,
  217: ({ invalidColIds }) => ["unable to find grid columns for the supplied colDef(s):", invalidColIds],
  218: ({ property, defaultOffset }) => `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`,
  219: ({ property }) => `Property ${property} does not exist on the target object.`,
  220: ({ lineDash }) => `'${lineDash}' is not a valid 'lineDash' option.`,
  221: () => `agAggregationComponent should only be used with the client and server side row model.`,
  222: () => `agFilteredRowCountComponent should only be used with the client side row model.`,
  223: () => `agSelectedRowCountComponent should only be used with the client and server side row model.`,
  224: () => `agTotalAndFilteredRowCountComponent should only be used with the client side row model.`,
  225: () => "agTotalRowCountComponent should only be used with the client side row model.",
  226: () => "viewport is missing init method.",
  227: () => "menu item icon must be DOM node or string",
  228: ({ menuItemOrString }) => `unrecognised menu item ${menuItemOrString}`,
  229: ({ index }) => ["invalid row index for ensureIndexVisible: ", index],
  230: () => "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/",
  // @deprecated v32 mark for removal as part of v32 deprecated features
  231: () => "As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.",
  232: () => "Using both rowData and v-model. rowData will be ignored.",
  233: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
  234: () => 'Group Column Filter does not work with the colDef property "field". This property will be ignored.',
  235: () => 'Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.',
  236: () => 'Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.',
  237: () => "Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.",
  238: () => "setRowCount can only accept a positive row count.",
  239: () => 'Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string "legacy" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.',
  240: ({ theme }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${theme}`,
  241: () => `cannot select multiple rows when rowSelection.mode is set to 'singleRow'`,
  242: () => "cannot select multiple rows when using rangeSelect",
  243: () => "Failed to deserialize state - each provided state object must be an object.",
  244: () => "Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.",
  245: () => "Failed to deserialize state - `toggledNodes` must be an array.",
  246: () => "Failed to deserialize state - Every `toggledNode` requires an associated string id.",
  247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. 
Please rebuild the selection state and reapply it.`,
  248: () => "SetFloatingFilter expects SetFilter as its parent",
  249: () => "Must supply a Value Formatter in Set Filter params when using a Key Creator",
  250: () => "Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.",
  251: ({ chartType }) => `AG Grid: Unable to create chart as an invalid chartType = '${chartType}' was supplied.`,
  252: () => "cannot get grid to draw rows when it is in the middle of drawing rows. \nYour code probably called a grid API method while the grid was in the render stage. \nTo overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). \nTo see what part of your code that caused the refresh check this stacktrace.",
  253: ({ version }) => ["Illegal version string: ", version],
  254: () => "Cannot create chart: no chart themes available.",
  255: ({ point }) => `Lone surrogate U+${point.toString(16).toUpperCase()} is not a scalar value`,
  256: () => "Unable to initialise. See validation error, or load ValidationModule if missing.",
  257: () => missingChartsWithModule("IntegratedChartsModule"),
  258: () => missingChartsWithModule("SparklinesModule"),
  259: ({ part }) => `the argument to theme.withPart must be a Theming API part object, received: ${part}`,
  260: ({
    propName,
    compName,
    gridScoped,
    gridId,
    rowModelType
  }) => missingModule({
    reasonOrId: `AG Grid '${propName}' component: ${compName}`,
    moduleName: USER_COMP_MODULES[compName],
    gridId,
    gridScoped,
    rowModelType
  }),
  261: () => "As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.",
  262: () => 'As of v33, icon key "smallDown" is deprecated. Use "advancedFilterBuilderSelect" for Advanced Filter Builder dropdown, "selectOpen" for Select cell editor and dropdowns (e.g. Integrated Charts menu), "richSelectOpen" for Rich Select cell editor',
  263: () => 'As of v33, icon key "smallLeft" is deprecated. Use "panelDelimiterRtl" for Row Group Panel / Pivot Panel, "subMenuOpenRtl" for sub-menus.',
  264: () => 'As of v33, icon key "smallRight" is deprecated. Use "panelDelimiter" for Row Group Panel / Pivot Panel, "subMenuOpen" for sub-menus'
};
function getError(errorId, args) {
  const msgOrFunc = AG_GRID_ERRORS[errorId];
  if (!msgOrFunc) {
    return [`Missing error text for error id ${errorId}!`];
  }
  const errorBody = msgOrFunc(args);
  const errorLink = getErrorLink(errorId, args);
  const errorSuffix = `
See ${errorLink}`;
  return Array.isArray(errorBody) ? errorBody.concat(errorSuffix) : [errorBody, errorSuffix];
}
var MISSING_MODULE_REASONS = {
  1: "Charting Aggregation",
  2: "pivotResultFields",
  3: "setTooltip"
};

// packages/ag-grid-community/src/validation/rules/colDefValidations.ts
var COLUMN_DEFINITION_DEPRECATIONS = () => ({
  checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." },
  headerCheckboxSelection: {
    version: "32.2",
    message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
  },
  headerCheckboxSelectionFilteredOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.'
  },
  headerCheckboxSelectionCurrentPageOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.'
  },
  showDisabledCheckboxes: {
    version: "32.2",
    message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
  }
});
var COLUMN_DEFINITION_VALIDATIONS = () => ({
  aggFunc: { module: "SharedAggregation" },
  autoHeight: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "RowAutoHeight"
  },
  cellClass: { module: "CellStyle" },
  cellClassRules: { module: "CellStyle" },
  cellEditor: ({ cellEditor, editable }) => {
    if (!editable) {
      return null;
    }
    if (typeof cellEditor === "string") {
      const module2 = USER_COMP_MODULES[cellEditor];
      if (module2) {
        return { module: module2 };
      }
    }
    return { module: "CustomEditor" };
  },
  cellRenderer: ({ cellRenderer }) => {
    if (typeof cellRenderer !== "string") {
      return null;
    }
    const module2 = USER_COMP_MODULES[cellRenderer];
    if (module2) {
      return { module: module2 };
    }
    return null;
  },
  cellRendererParams: {
    validate: (colDef) => {
      const groupColumn = colDef.rowGroup != null || colDef.rowGroupIndex != null || colDef.cellRenderer === "agGroupCellRenderer";
      if (groupColumn && "checkbox" in colDef.cellRendererParams) {
        return 'Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = "autoGroupColumn"` instead.';
      }
      return null;
    }
  },
  cellStyle: { module: "CellStyle" },
  children: () => COL_DEF_VALIDATORS(),
  columnChooserParams: {
    module: "ColumnMenu"
  },
  contextMenuItems: { module: "ContextMenu" },
  dndSource: { module: "DragAndDrop" },
  dndSourceOnRowDrag: { module: "DragAndDrop" },
  editable: ({ editable, cellEditor }) => {
    if (editable && !cellEditor) {
      return {
        module: "TextEditor"
      };
    }
    return null;
  },
  enableCellChangeFlash: { module: "HighlightChanges" },
  enablePivot: { module: "SharedPivot" },
  enableRowGroup: { module: "SharedRowGrouping" },
  enableValue: { module: "SharedAggregation" },
  filter: ({ filter }) => {
    if (filter && typeof filter !== "string" && typeof filter !== "boolean") {
      return { module: "CustomFilter" };
    }
    if (typeof filter === "string") {
      const module2 = USER_COMP_MODULES[filter];
      if (module2) {
        return { module: module2 };
      }
    }
    return { module: "ColumnFilter" };
  },
  floatingFilter: { module: "ColumnFilter" },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerTooltip: { module: "Tooltip" },
  headerValueGetter: {
    validate: (_options) => {
      const headerValueGetter = _options.headerValueGetter;
      if (typeof headerValueGetter === "function" || typeof headerValueGetter === "string") {
        return null;
      }
      return "headerValueGetter must be a function or a valid string expression";
    }
  },
  icons: {
    validate: ({ icons }) => {
      if (icons) {
        if (icons["smallDown"]) {
          return _errMsg(262);
        }
        if (icons["smallLeft"]) {
          return _errMsg(263);
        }
        if (icons["smallRight"]) {
          return _errMsg(264);
        }
      }
      return null;
    }
  },
  mainMenuItems: { module: "ColumnMenu" },
  menuTabs: (options) => {
    const enterpriseMenuTabs = ["columnsMenuTab", "generalMenuTab"];
    if (options.menuTabs?.some((tab) => enterpriseMenuTabs.includes(tab))) {
      return {
        module: "ColumnMenu"
      };
    }
    return null;
  },
  pivot: { module: "SharedPivot" },
  pivotIndex: { module: "SharedPivot" },
  rowDrag: { module: "RowDrag" },
  rowGroup: { module: "SharedRowGrouping" },
  rowGroupIndex: { module: "SharedRowGrouping" },
  sortingOrder: {
    validate: (_options) => {
      const sortingOrder = _options.sortingOrder;
      if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
        const invalidItems = sortingOrder.filter((a) => !DEFAULT_SORTING_ORDER.includes(a));
        if (invalidItems.length > 0) {
          return `sortingOrder must be an array with elements from [${DEFAULT_SORTING_ORDER.map(toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(toStringWithNullUndefined).join()}]`;
        }
      } else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
        return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
      }
      return null;
    }
  },
  tooltipField: { module: "Tooltip" },
  tooltipValueGetter: { module: "Tooltip" },
  type: {
    validate: (_options) => {
      const type = _options.type;
      if (type instanceof Array) {
        const invalidArray = type.some((a) => typeof a !== "string");
        if (invalidArray) {
          return "if colDef.type is supplied an array it should be of type 'string[]'";
        }
        return null;
      }
      if (typeof type === "string") {
        return null;
      }
      return "colDef.type should be of type 'string' | 'string[]'";
    }
  },
  rowSpan: {
    validate: (_options, { suppressRowTransform }) => {
      if (!suppressRowTransform) {
        return "colDef.rowSpan requires suppressRowTransform to be enabled.";
      }
      return null;
    }
  }
});
var colDefPropertyMap = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0
};
var ALL_PROPERTIES = () => Object.keys(colDefPropertyMap);
var COL_DEF_VALIDATORS = () => ({
  objectName: "colDef",
  allProperties: ALL_PROPERTIES(),
  docsUrl: "column-properties/",
  deprecations: COLUMN_DEFINITION_DEPRECATIONS(),
  validations: COLUMN_DEFINITION_VALIDATIONS()
});

// packages/ag-grid-community/src/validation/rules/gridOptionsValidations.ts
var GRID_OPTION_DEPRECATIONS = () => ({
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." },
  enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." },
  suppressMultiRangeSelection: {
    version: "32.2",
    message: "Use `cellSelection.suppressMultiRanges` instead."
  },
  suppressClearOnFillReduction: {
    version: "32.2",
    message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
  },
  fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." },
  fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." },
  suppressRowClickSelection: {
    version: "32.2",
    message: "Use `rowSelection.enableClickSelection` instead."
  },
  suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." },
  rowMultiSelectWithClick: {
    version: "32.2",
    message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
  },
  groupSelectsChildren: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "descendants"` instead.'
  },
  groupSelectsFiltered: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.'
  },
  isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." },
  suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." },
  onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." },
  onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." },
  suppressBrowserResizeObserver: {
    version: "32.2",
    message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
  },
  onColumnEverythingChanged: {
    version: "32.2",
    message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
  },
  groupRemoveSingleChildren: {
    version: "33",
    message: "Use `groupHideParentOfSingleChild` instead."
  },
  groupRemoveLowestSingleChildren: {
    version: "33",
    message: 'Use `groupHideParentOfSingleChild: "leafGroupsOnly"` instead.'
  },
  suppressRowGroupHidesColumns: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressHideOnGroup"` instead.'
  },
  suppressMakeColumnVisibleAfterUnGroup: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressShowOnUngroup"` instead.'
  },
  unSortIcon: { version: "33", message: "Use `defaultColDef.unSortIcon` instead." },
  sortingOrder: { version: "33", message: "Use `defaultColDef.sortingOrder` instead." },
  suppressPropertyNamesCheck: {
    version: "33",
    message: "`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant."
  }
});
function toConstrainedNum(key, value, min, max = Number.MAX_VALUE) {
  if (typeof value === "number" || value == null) {
    if (value == null) {
      return null;
    }
    if (value >= min && value <= max) {
      return null;
    }
    if (max === Number.MAX_VALUE) {
      return `${key}: value should be greater than or equal to ${min}`;
    }
    return `${key}: value should be between ${min} and ${max}`;
  }
  return `${key}: value should be a number`;
}
var GRID_OPTION_VALIDATIONS = () => {
  const definedValidations = {
    alignedGrids: { module: "AlignedGrids" },
    allowContextMenuWithControlKey: { module: "ContextMenu" },
    autoSizePadding: {
      validate({ autoSizePadding }) {
        return toConstrainedNum("autoSizePadding", autoSizePadding, 0);
      }
    },
    autoSizeStrategy: { module: "ColumnAutoSize" },
    cacheBlockSize: {
      supportedRowModels: ["serverSide", "infinite"],
      validate({ cacheBlockSize }) {
        return toConstrainedNum("cacheBlockSize", cacheBlockSize, 1);
      }
    },
    cacheOverflowSize: {
      validate({ cacheOverflowSize }) {
        return toConstrainedNum("cacheOverflowSize", cacheOverflowSize, 1);
      }
    },
    cellSelection: {
      module: "CellSelection"
    },
    columnHoverHighlight: { module: "ColumnHover" },
    datasource: {
      supportedRowModels: ["infinite"],
      module: "InfiniteRowModel"
    },
    doesExternalFilterPass: { module: "ExternalFilter" },
    domLayout: {
      validate: (options) => {
        const domLayout = options.domLayout;
        const validLayouts = ["autoHeight", "normal", "print"];
        if (domLayout && !validLayouts.includes(domLayout)) {
          return `domLayout must be one of [${validLayouts.join()}], currently it's ${domLayout}`;
        }
        return null;
      }
    },
    editType: {
      module: "EditCore"
    },
    enableAdvancedFilter: { module: "AdvancedFilter" },
    enableCharts: { module: "IntegratedCharts" },
    enableFillHandle: {
      dependencies: {
        enableRangeSelection: { required: [true] }
      }
    },
    enableRangeHandle: {
      dependencies: {
        enableRangeSelection: { required: [true] }
      }
    },
    enableRangeSelection: {
      module: "CellSelection",
      dependencies: {
        rowDragEntireRow: { required: [false, void 0] }
      }
    },
    getContextMenuItems: { module: "ContextMenu" },
    getLocaleText: { module: "Locale" },
    getMainMenuItems: { module: "ColumnMenu" },
    getRowClass: { module: "RowStyle" },
    getRowStyle: { module: "RowStyle" },
    grandTotalRow: { module: "SharedRowGrouping" },
    groupDefaultExpanded: {
      supportedRowModels: ["clientSide"]
    },
    groupHideOpenParents: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: {
        groupTotalRow: { required: [void 0, "bottom"] },
        treeData: {
          required: [void 0, false],
          reason: "Tree Data has values at the group level so it doesn't make sense to hide them."
        }
      }
    },
    groupHideParentOfSingleChild: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, false] }
      }
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, false] },
        groupRemoveSingleChildren: { required: [void 0, false] }
      }
    },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, false] },
        groupRemoveLowestSingleChildren: { required: [void 0, false] }
      }
    },
    groupSelectsChildren: {
      dependencies: {
        rowSelection: { required: ["multiple"] }
      }
    },
    icons: {
      validate: ({ icons }) => {
        if (icons) {
          if (icons["smallDown"]) {
            return _errMsg(262);
          }
          if (icons["smallLeft"]) {
            return _errMsg(263);
          }
          if (icons["smallRight"]) {
            return _errMsg(264);
          }
        }
        return null;
      }
    },
    infiniteInitialRowCount: {
      validate({ infiniteInitialRowCount }) {
        return toConstrainedNum("infiniteInitialRowCount", infiniteInitialRowCount, 1);
      }
    },
    initialGroupOrderComparator: {
      supportedRowModels: ["clientSide"]
    },
    initialState: { module: "GridState" },
    isExternalFilterPresent: { module: "ExternalFilter" },
    keepDetailRowsCount: {
      validate({ keepDetailRowsCount }) {
        return toConstrainedNum("keepDetailRowsCount", keepDetailRowsCount, 1);
      }
    },
    localeText: {
      module: "Locale"
    },
    masterDetail: { module: "SharedMasterDetail" },
    pagination: { module: "Pagination" },
    paginationPageSize: {
      validate({ paginationPageSize }) {
        return toConstrainedNum("paginationPageSize", paginationPageSize, 1);
      }
    },
    paginationPageSizeSelector: {
      validate: (options) => {
        const values = options.paginationPageSizeSelector;
        if (typeof values === "boolean" || values == null) {
          return null;
        }
        if (!values.length) {
          return `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
        }
        return null;
      }
    },
    pinnedTopRowData: {
      module: "PinnedRow"
    },
    pinnedBottomRowData: {
      module: "PinnedRow"
    },
    pivotMode: {
      dependencies: {
        treeData: {
          required: [false, void 0],
          reason: "Pivot Mode is not supported with Tree Data."
        }
      },
      module: "SharedPivot"
    },
    pivotPanelShow: { module: "RowGroupingPanel" },
    quickFilterText: {
      supportedRowModels: ["clientSide"],
      module: "QuickFilter"
    },
    rowBuffer: {
      validate({ rowBuffer }) {
        return toConstrainedNum("rowBuffer", rowBuffer, 0);
      }
    },
    rowClass: {
      validate: (options) => {
        const rowClass = options.rowClass;
        if (typeof rowClass === "function") {
          return "rowClass should not be a function, please use getRowClass instead";
        }
        return null;
      },
      module: "RowStyle"
    },
    rowClassRules: { module: "RowStyle" },
    rowData: {
      supportedRowModels: ["clientSide"],
      module: "ClientSideRowModel"
    },
    rowDragManaged: {
      supportedRowModels: ["clientSide"],
      dependencies: {
        treeData: {
          required: [false, void 0]
        },
        pagination: {
          required: [false, void 0]
        }
      },
      module: "RowDrag"
    },
    rowGroupPanelShow: { module: "RowGroupingPanel" },
    rowSelection: {
      validate({ rowSelection }) {
        if (rowSelection && typeof rowSelection === "string") {
          return 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.';
        }
        if (rowSelection && typeof rowSelection !== "object") {
          return "Expected `RowSelectionOptions` object for the `rowSelection` property.";
        }
        if (rowSelection && rowSelection.mode !== "multiRow" && rowSelection.mode !== "singleRow") {
          return `Selection mode "${rowSelection.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.`;
        }
        return null;
      },
      module: "SharedRowSelection"
    },
    rowStyle: {
      validate: (options) => {
        const rowStyle = options.rowStyle;
        if (rowStyle && typeof rowStyle === "function") {
          return "rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead";
        }
        return null;
      },
      module: "RowStyle"
    },
    serverSideDatasource: {
      supportedRowModels: ["serverSide"],
      module: "ServerSideRowModel"
    },
    serverSideInitialRowCount: {
      supportedRowModels: ["serverSide"],
      validate({ serverSideInitialRowCount }) {
        return toConstrainedNum("serverSideInitialRowCount", serverSideInitialRowCount, 1);
      }
    },
    serverSideOnlyRefreshFilteredGroups: {
      supportedRowModels: ["serverSide"]
    },
    serverSideSortAllLevels: {
      supportedRowModels: ["serverSide"]
    },
    sideBar: { module: "SideBar" },
    sortingOrder: {
      validate: (_options) => {
        const sortingOrder = _options.sortingOrder;
        if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
          const invalidItems = sortingOrder.filter((a) => !DEFAULT_SORTING_ORDER.includes(a));
          if (invalidItems.length > 0) {
            return `sortingOrder must be an array with elements from [${DEFAULT_SORTING_ORDER.map(toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(toStringWithNullUndefined).join()}]`;
          }
        } else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
          return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
        }
        return null;
      }
    },
    statusBar: { module: "StatusBar" },
    tooltipHideDelay: {
      validate: (options) => {
        if (options.tooltipHideDelay && options.tooltipHideDelay < 0) {
          return "tooltipHideDelay should not be lower than 0";
        }
        return null;
      }
    },
    tooltipShowDelay: {
      validate: (options) => {
        if (options.tooltipShowDelay && options.tooltipShowDelay < 0) {
          return "tooltipShowDelay should not be lower than 0";
        }
        return null;
      }
    },
    treeData: {
      supportedRowModels: ["clientSide", "serverSide"],
      module: "SharedTreeData",
      validate: (options) => {
        const rowModel = options.rowModelType ?? "clientSide";
        switch (rowModel) {
          case "clientSide": {
            const csrmWarning = `treeData requires 'getDataPath' in the ${rowModel} row model.`;
            return options.treeDataChildrenField || options.getDataPath ? null : csrmWarning;
          }
          case "serverSide": {
            const ssrmWarning = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${rowModel} row model.`;
            return options.isServerSideGroup && options.getServerSideGroupKey ? null : ssrmWarning;
          }
        }
        return null;
      }
    },
    ["treeDataChildrenField"]: {
      module: "SharedTreeData"
    },
    undoRedoCellEditing: { module: "UndoRedoEdit" },
    valueCache: { module: "ValueCache" },
    viewportDatasource: {
      supportedRowModels: ["viewport"],
      module: "ViewportRowModel"
    },
    viewportRowModelBufferSize: {
      validate({ viewportRowModelBufferSize }) {
        return toConstrainedNum("viewportRowModelBufferSize", viewportRowModelBufferSize, 0);
      }
    },
    viewportRowModelPageSize: {
      validate({ viewportRowModelPageSize }) {
        return toConstrainedNum("viewportRowModelPageSize", viewportRowModelPageSize, 1);
      }
    },
    rowDragEntireRow: {
      dependencies: {
        cellSelection: { required: [void 0] }
      }
    }
  };
  const validations = {};
  _BOOLEAN_GRID_OPTIONS.forEach((key) => {
    validations[key] = { expectedType: "boolean" };
  });
  _NUMBER_GRID_OPTIONS.forEach((key) => {
    validations[key] = { expectedType: "number" };
  });
  _mergeDeep(validations, definedValidations);
  return validations;
};
var GRID_OPTIONS_VALIDATORS = () => ({
  objectName: "gridOptions",
  allProperties: [..._ALL_GRID_OPTIONS, ..._ALL_EVENTS.map((event) => _getCallbackForEvent(event))],
  propertyExceptions: ["api", "treeDataChildrenField"],
  docsUrl: "grid-options/",
  deprecations: GRID_OPTION_DEPRECATIONS(),
  validations: GRID_OPTION_VALIDATIONS()
});

// packages/ag-grid-community/src/validation/rules/iconValidations.ts
var ICON_VALUES = {
  expanded: 1,
  contracted: 1,
  "tree-closed": 1,
  "tree-open": 1,
  "tree-indeterminate": 1,
  pin: 1,
  "eye-slash": 1,
  arrows: 1,
  left: 1,
  right: 1,
  group: 1,
  aggregation: 1,
  pivot: 1,
  "not-allowed": 1,
  chart: 1,
  cross: 1,
  cancel: 1,
  tick: 1,
  first: 1,
  previous: 1,
  next: 1,
  last: 1,
  linked: 1,
  unlinked: 1,
  "color-picker": 1,
  loading: 1,
  menu: 1,
  "menu-alt": 1,
  filter: 1,
  columns: 1,
  maximize: 1,
  minimize: 1,
  copy: 1,
  cut: 1,
  paste: 1,
  grip: 1,
  save: 1,
  csv: 1,
  excel: 1,
  "small-down": 1,
  "small-left": 1,
  "small-right": 1,
  "small-up": 1,
  asc: 1,
  desc: 1,
  none: 1,
  up: 1,
  down: 1,
  plus: 1,
  minus: 1,
  settings: 1,
  "checkbox-checked": 1,
  "checkbox-indeterminate": 1,
  "checkbox-unchecked": 1,
  "radio-button-on": 1,
  "radio-button-off": 1,
  eye: 1
};
var ICON_MODULES = {
  chart: "MenuCore",
  cancel: "EnterpriseCore",
  first: "Pagination",
  previous: "Pagination",
  next: "Pagination",
  last: "Pagination",
  linked: "IntegratedCharts",
  loadingMenuItems: "MenuCore",
  unlinked: "IntegratedCharts",
  menu: "ColumnHeaderComp",
  legacyMenu: "ColumnMenu",
  filter: "ColumnFilter",
  filterActive: "ColumnFilter",
  filterTab: "ColumnMenu",
  filtersToolPanel: "FiltersToolPanel",
  columns: ["MenuCore"],
  columnsToolPanel: ["ColumnsToolPanel"],
  maximize: "EnterpriseCore",
  minimize: "EnterpriseCore",
  save: "MenuCore",
  columnGroupOpened: "ColumnGroupHeaderComp",
  columnGroupClosed: "ColumnGroupHeaderComp",
  accordionOpen: "EnterpriseCore",
  accordionClosed: "EnterpriseCore",
  accordionIndeterminate: "EnterpriseCore",
  columnSelectClosed: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectOpen: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectIndeterminate: ["ColumnsToolPanel", "ColumnMenu"],
  columnMovePin: "SharedDragAndDrop",
  columnMoveHide: "SharedDragAndDrop",
  columnMoveMove: "SharedDragAndDrop",
  columnMoveLeft: "SharedDragAndDrop",
  columnMoveRight: "SharedDragAndDrop",
  columnMoveGroup: "SharedDragAndDrop",
  columnMoveValue: "SharedDragAndDrop",
  columnMovePivot: "SharedDragAndDrop",
  dropNotAllowed: "SharedDragAndDrop",
  groupContracted: "GroupCellRenderer",
  groupExpanded: "GroupCellRenderer",
  setFilterGroupClosed: "SetFilter",
  setFilterGroupOpen: "SetFilter",
  setFilterGroupIndeterminate: "SetFilter",
  close: "EnterpriseCore",
  check: "MenuItem",
  colorPicker: "CommunityCore",
  groupLoading: "LoadingCellRenderer",
  menuAlt: "ColumnHeaderComp",
  menuPin: "MenuCore",
  menuValue: "MenuCore",
  menuAddRowGroup: ["MenuCore", "ColumnsToolPanel"],
  menuRemoveRowGroup: ["MenuCore", "ColumnsToolPanel"],
  clipboardCopy: "MenuCore",
  clipboardCut: "MenuCore",
  clipboardPaste: "MenuCore",
  pivotPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  rowGroupPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  valuePanel: "ColumnsToolPanel",
  columnDrag: "EnterpriseCore",
  rowDrag: ["RowDrag", "DragAndDrop"],
  csvExport: "MenuCore",
  excelExport: "MenuCore",
  smallDown: "CommunityCore",
  selectOpen: "CommunityCore",
  richSelectOpen: "RichSelect",
  richSelectRemove: "RichSelect",
  smallLeft: "CommunityCore",
  smallRight: "CommunityCore",
  subMenuOpen: "MenuItem",
  subMenuOpenRtl: "MenuItem",
  panelDelimiter: "RowGroupingPanel",
  panelDelimiterRtl: "RowGroupingPanel",
  smallUp: "CommunityCore",
  sortAscending: ["MenuCore", "Sort"],
  sortDescending: ["MenuCore", "Sort"],
  sortUnSort: ["MenuCore", "Sort"],
  advancedFilterBuilder: "AdvancedFilter",
  advancedFilterBuilderDrag: "AdvancedFilter",
  advancedFilterBuilderInvalid: "AdvancedFilter",
  advancedFilterBuilderMoveUp: "AdvancedFilter",
  advancedFilterBuilderMoveDown: "AdvancedFilter",
  advancedFilterBuilderAdd: "AdvancedFilter",
  advancedFilterBuilderRemove: "AdvancedFilter",
  advancedFilterBuilderSelectOpen: "AdvancedFilter",
  chartsMenu: "IntegratedCharts",
  chartsMenuEdit: "IntegratedCharts",
  chartsMenuAdvancedSettings: "IntegratedCharts",
  chartsMenuAdd: "IntegratedCharts",
  chartsColorPicker: "IntegratedCharts",
  chartsThemePrevious: "IntegratedCharts",
  chartsThemeNext: "IntegratedCharts",
  chartsDownload: "IntegratedCharts",
  checkboxChecked: "CommunityCore",
  checkboxIndeterminate: "CommunityCore",
  checkboxUnchecked: "CommunityCore",
  radioButtonOn: "CommunityCore",
  radioButtonOff: "CommunityCore"
};
var DEPRECATED_ICONS_V33 = /* @__PURE__ */ new Set([
  "colorPicker",
  "smallUp",
  "checkboxChecked",
  "checkboxIndeterminate",
  "checkboxUnchecked",
  "radioButtonOn",
  "radioButtonOff",
  "smallDown",
  "smallLeft",
  "smallRight"
]);

// packages/ag-grid-community/src/validation/rules/menuItemValidations.ts
var MENU_ITEM_MODULES = {
  pinSubMenu: "PinnedColumn",
  pinLeft: "PinnedColumn",
  pinRight: "PinnedColumn",
  clearPinned: "PinnedColumn",
  valueAggSubMenu: "SharedAggregation",
  autoSizeThis: "ColumnAutoSize",
  autoSizeAll: "ColumnAutoSize",
  rowGroup: "SharedRowGrouping",
  rowUnGroup: "SharedRowGrouping",
  resetColumns: "CommunityCore",
  expandAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  contractAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  copy: "Clipboard",
  copyWithHeaders: "Clipboard",
  copyWithGroupHeaders: "Clipboard",
  cut: "Clipboard",
  paste: "Clipboard",
  export: ["CsvExport", "ExcelExport"],
  csvExport: "CsvExport",
  excelExport: "ExcelExport",
  separator: "CommunityCore",
  pivotChart: "IntegratedCharts",
  chartRange: "IntegratedCharts",
  columnFilter: "ColumnFilter",
  columnChooser: "ColumnMenu",
  sortAscending: "Sort",
  sortDescending: "Sort",
  sortUnSort: "Sort"
};

// packages/ag-grid-community/src/validation/validationService.ts
var ValidationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "validation";
  }
  wireBeans(beans) {
    this.gridOptions = beans.gridOptions;
    provideValidationServiceLogger(this);
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  warnOnInitialPropertyUpdate(source, key) {
    if (source === "api" && INITIAL_GRID_OPTION_KEYS[key]) {
      _warn(22, { key });
    }
  }
  processGridOptions(options) {
    this.processOptions(options, GRID_OPTIONS_VALIDATORS());
  }
  validateApiFunction(functionName, apiFunction) {
    return validateApiFunction(functionName, apiFunction, this.beans);
  }
  missingUserComponent(propertyName, componentName, agGridDefaults, jsComps) {
    const moduleForComponent = USER_COMP_MODULES[componentName];
    if (moduleForComponent) {
      this.gos.assertModuleRegistered(
        moduleForComponent,
        `AG Grid '${propertyName}' component: ${componentName}`
      );
    } else {
      _warn(101, {
        propertyName,
        componentName,
        agGridDefaults,
        jsComps
      });
    }
  }
  checkRowEvents(eventType) {
    if (DEPRECATED_ROW_NODE_EVENTS.has(eventType)) {
      _warn(10, { eventType });
    }
  }
  validateIcon(iconName) {
    if (DEPRECATED_ICONS_V33.has(iconName)) {
      _warn(43, { iconName });
    }
    if (ICON_VALUES[iconName]) {
      return;
    }
    const moduleName = ICON_MODULES[iconName];
    if (moduleName) {
      _error(200, {
        reasonOrId: `icon '${iconName}'`,
        moduleName,
        gridScoped: _areModulesGridScoped(),
        gridId: this.beans.context.getGridId(),
        rowModelType: this.gos.get("rowModelType"),
        additionalText: "Alternatively, use the CSS icon name directly."
      });
      return;
    }
    _warn(134, { iconName });
  }
  validateMenuItem(key) {
    const moduleName = MENU_ITEM_MODULES[key];
    if (moduleName) {
      this.gos.assertModuleRegistered(moduleName, `menu item '${key}'`);
    }
  }
  isProvidedUserComp(compName) {
    return !!USER_COMP_MODULES[compName];
  }
  validateColDef(colDef, colId, skipInferenceCheck) {
    if (skipInferenceCheck || !this.beans.dataTypeSvc?.isColPendingInference(colId)) {
      this.processOptions(colDef, COL_DEF_VALIDATORS());
    }
  }
  processOptions(options, validator) {
    const { validations, deprecations, allProperties, propertyExceptions, objectName, docsUrl } = validator;
    if (allProperties && this.gridOptions.suppressPropertyNamesCheck !== true) {
      this.checkProperties(
        options,
        [...propertyExceptions ?? [], ...Object.keys(deprecations)],
        allProperties,
        objectName,
        docsUrl
      );
    }
    const warnings = /* @__PURE__ */ new Set();
    const getRules = (key) => {
      const rulesOrGetter = validations[key];
      if (!rulesOrGetter) {
        return;
      } else if (typeof rulesOrGetter === "function") {
        const fromGetter = rulesOrGetter(options, this.gridOptions, this.beans);
        if (!fromGetter) {
          return;
        }
        if ("objectName" in fromGetter) {
          const value = options[key];
          if (Array.isArray(value)) {
            value.forEach((item) => {
              this.processOptions(item, fromGetter);
            });
            return;
          }
          this.processOptions(options[key], fromGetter);
          return;
        }
        return fromGetter;
      } else {
        return rulesOrGetter;
      }
    };
    const optionKeys = Object.keys(options);
    optionKeys.forEach((key) => {
      const deprecation = deprecations[key];
      if (deprecation) {
        const { message, version } = deprecation;
        warnings.add(`As of v${version}, ${String(key)} is deprecated. ${message ?? ""}`);
      }
      const value = options[key];
      if (value == null || value === false) {
        return;
      }
      const rules = getRules(key);
      if (!rules) {
        return;
      }
      const { module: module2, dependencies, validate, supportedRowModels, expectedType } = rules;
      if (expectedType) {
        const actualType = typeof value;
        if (actualType !== expectedType) {
          warnings.add(
            `${String(key)} should be of type '${expectedType}' but received '${actualType}' (${value}).`
          );
          return;
        }
      }
      if (supportedRowModels) {
        const rowModel = this.gridOptions.rowModelType ?? "clientSide";
        if (!supportedRowModels.includes(rowModel)) {
          warnings.add(
            `${String(key)} is not supported with the '${rowModel}' row model. It is only valid with: ${supportedRowModels.join(", ")}.`
          );
          return;
        }
      }
      if (module2) {
        const modules = Array.isArray(module2) ? module2 : [module2];
        let allRegistered = true;
        modules.forEach((m) => {
          if (!this.gos.assertModuleRegistered(m, String(key))) {
            allRegistered = false;
          }
        });
        if (!allRegistered) {
          return;
        }
      }
      if (dependencies) {
        const warning = this.checkForRequiredDependencies(key, dependencies, options);
        if (warning) {
          warnings.add(warning);
          return;
        }
      }
      if (validate) {
        const warning = validate(options, this.gridOptions, this.beans);
        if (warning) {
          warnings.add(warning);
          return;
        }
      }
    });
    if (warnings.size > 0) {
      warnings.forEach((warning) => {
        _warnOnce(warning);
      });
    }
  }
  checkForRequiredDependencies(key, validator, options) {
    const optionEntries = Object.entries(validator);
    const failedOptions = optionEntries.filter(([key2, value]) => {
      const gridOptionValue = options[key2];
      return !value.required.includes(gridOptionValue);
    });
    if (failedOptions.length === 0) {
      return null;
    }
    return failedOptions.map(
      ([failedKey, possibleOptions]) => `'${String(key)}' requires '${failedKey}' to be one of [${possibleOptions.required.map((o) => {
        if (o === null) {
          return "null";
        } else if (o === void 0) {
          return "undefined";
        }
        return o;
      }).join(", ")}]. ${possibleOptions.reason ?? ""}`
    ).join("\n           ");
  }
  checkProperties(object, exceptions, validProperties, containerName, docsUrl) {
    const VUE_FRAMEWORK_PROPS = ["__ob__", "__v_skip", "__metadata__"];
    const invalidProperties = _fuzzyCheckStrings(
      Object.getOwnPropertyNames(object),
      [...VUE_FRAMEWORK_PROPS, ...exceptions, ...validProperties],
      validProperties
    );
    Object.entries(invalidProperties).forEach(([key, value]) => {
      let message = `invalid ${containerName} property '${key}' did you mean any of these: ${value.slice(0, 8).join(", ")}.`;
      if (validProperties.includes("context")) {
        message += `
If you are trying to annotate ${containerName} with application data, use the '${containerName}.context' property instead.`;
      }
      _warnOnce(message);
    });
    if (Object.keys(invalidProperties).length > 0 && docsUrl) {
      const url = this.beans.frameworkOverrides.getDocLink(docsUrl);
      _warnOnce(`to see all the valid ${containerName} properties please check: ${url}`);
    }
  }
  getConsoleMessage(id, args) {
    return getError(id, args);
  }
};
function _fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
  const fuzzyMatches = {};
  const invalidInputs = inputValues.filter(
    (inputValue) => !validValues.some((validValue) => validValue === inputValue)
  );
  if (invalidInputs.length > 0) {
    invalidInputs.forEach(
      (invalidInput) => fuzzyMatches[invalidInput] = _fuzzySuggestions({ inputValue: invalidInput, allSuggestions }).values
    );
  }
  return fuzzyMatches;
}
var DEPRECATED_ROW_NODE_EVENTS = /* @__PURE__ */ new Set([
  "firstChildChanged",
  "lastChildChanged",
  "childIndexChanged"
]);

// packages/ag-grid-community/src/validation/validationModule.ts
var ValidationModule = {
  moduleName: "Validation",
  version: VERSION,
  beans: [ValidationService]
};

// packages/ag-grid-community/src/clientSideRowModel/filterStage.ts
function updateRowNodeAfterFilter(rowNode) {
  if (rowNode.sibling) {
    rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
  }
}
var FilterStage = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "filterStage";
    this.refreshProps = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]);
    this.step = "filter";
  }
  wireBeans(beans) {
    this.filterManager = beans.filterManager;
  }
  execute(params) {
    const { changedPath } = params;
    this.filter(changedPath);
  }
  filter(changedPath) {
    const filterActive = !!this.filterManager?.isChildFilterPresent();
    this.filterNodes(filterActive, changedPath);
  }
  filterNodes(filterActive, changedPath) {
    const filterCallback = (rowNode, includeChildNodes) => {
      if (rowNode.hasChildren()) {
        if (filterActive && !includeChildNodes) {
          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {
            const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
            const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });
            return passBecauseChildren || passBecauseDataPasses;
          });
        } else {
          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
        }
      } else {
        rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
      }
      updateRowNodeAfterFilter(rowNode);
    };
    if (this.doingTreeDataFiltering()) {
      const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {
        if (rowNode.childrenAfterGroup) {
          for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
            const childNode = rowNode.childrenAfterGroup[i];
            const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });
            if (childNode.childrenAfterGroup) {
              treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
            } else {
              filterCallback(childNode, foundInParent);
            }
          }
        }
        filterCallback(rowNode, alreadyFoundInParent);
      };
      const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);
      changedPath.executeFromRootNode(treeDataFilterCallback);
    } else {
      const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);
      changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
};

// packages/ag-grid-community/src/headerRendering/cells/floatingFilter/headerFilterCellCtrl.ts
var HeaderFilterCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor() {
    super(...arguments);
    this.iconCreated = false;
  }
  setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody, compBeanInput) {
    this.comp = comp;
    const compBean = setupCompBean(this, this.beans.context, compBeanInput);
    this.eButtonShowMainFilter = eButtonShowMainFilter;
    this.eFloatingFilterBody = eFloatingFilterBody;
    this.setGui(eGui, compBean);
    this.setupActive();
    this.setupWidth(compBean);
    this.setupLeft(compBean);
    this.setupHover(compBean);
    this.setupFocus(compBean);
    this.setupAria();
    this.setupFilterButton();
    this.setupUserComp();
    this.setupSyncWithFilter(compBean);
    this.setupUi();
    compBean.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) });
    this.setupFilterChangedListener(compBean);
    compBean.addManagedListeners(this.column, { colDefChanged: () => this.onColDefChanged(compBean) });
    compBean.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null;
      this.eFloatingFilterBody = null;
      this.userCompDetails = null;
      this.clearComponent();
    });
  }
  // empty abstract method
  resizeHeader() {
  }
  moveHeader() {
  }
  setupActive() {
    const colDef = this.column.getColDef();
    const filterExists = !!colDef.filter;
    const floatingFilterExists = !!colDef.floatingFilter;
    this.active = filterExists && floatingFilterExists;
  }
  setupUi() {
    this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
    this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton);
    this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
    if (!this.active || this.iconCreated) {
      return;
    }
    const eMenuIcon = _createIconNoSpan("filter", this.beans, this.column);
    if (eMenuIcon) {
      this.iconCreated = true;
      this.eButtonShowMainFilter.appendChild(eMenuIcon);
    }
  }
  setupFocus(compBean) {
    compBean.createManagedBean(
      new ManagedFocusFeature(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const localeTextFunc = this.getLocaleTextFunc();
    _setAriaLabel(this.eButtonShowMainFilter, localeTextFunc("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    const { beans } = this;
    const activeEl = _getActiveDomElement(beans);
    const wrapperHasFocus = activeEl === this.eGui;
    if (wrapperHasFocus) {
      return;
    }
    const nextFocusableEl = _findNextFocusableElement(beans, this.eGui, null, e.shiftKey);
    if (nextFocusableEl) {
      beans.headerNavigation?.scrollToColumn(this.column);
      e.preventDefault();
      nextFocusableEl.focus();
      return;
    }
    const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
    if (!nextFocusableColumn) {
      return;
    }
    if (beans.focusSvc.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.rowCtrl.rowIndex,
        column: nextFocusableColumn
      },
      event: e
    })) {
      e.preventDefault();
    }
  }
  findNextColumnWithFloatingFilter(backwards) {
    const presentedColsService = this.beans.visibleCols;
    let nextCol = this.column;
    do {
      nextCol = backwards ? presentedColsService.getColBefore(nextCol) : presentedColsService.getColAfter(nextCol);
      if (!nextCol) {
        break;
      }
    } while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
    return nextCol;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const wrapperHasFocus = this.getWrapperHasFocus();
    switch (e.key) {
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (!wrapperHasFocus) {
          e.preventDefault();
        }
      case KeyCode.LEFT:
      case KeyCode.RIGHT:
        if (wrapperHasFocus) {
          return;
        }
        e.stopPropagation();
      case KeyCode.ENTER:
        if (wrapperHasFocus) {
          if (_focusInto(this.eGui)) {
            e.preventDefault();
          }
        }
        break;
      case KeyCode.ESCAPE:
        if (!wrapperHasFocus) {
          this.eGui.focus();
        }
    }
  }
  onFocusIn(e) {
    const isRelatedWithin = this.eGui.contains(e.relatedTarget);
    if (isRelatedWithin) {
      return;
    }
    const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter");
    const fromWithinHeader = !!e.relatedTarget && _isElementChildOfClass(e.relatedTarget, "ag-floating-filter");
    if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
      const lastFocusEvent = this.lastFocusEvent;
      const fromTab = !!(lastFocusEvent && lastFocusEvent.key === KeyCode.TAB);
      if (lastFocusEvent && fromTab) {
        const shouldFocusLast = lastFocusEvent.shiftKey;
        _focusInto(this.eGui, shouldFocusLast);
      }
    }
    this.focusThis();
  }
  setupHover(compBean) {
    this.beans.colHover?.addHeaderFilterColumnHoverListener(compBean, this.comp, this.column, this.eGui);
  }
  setupLeft(compBean) {
    const setLeftFeature = new SetLeftFeature(this.column, this.eGui, this.beans);
    compBean.createManagedBean(setLeftFeature);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.beans.menuSvc?.isFloatingFilterButtonEnabled(this.column);
    this.highlightFilterButtonWhenActive = !_isLegacyMenuEnabled(this.gos);
  }
  setupUserComp() {
    if (!this.active) {
      return;
    }
    const compDetails = this.beans.filterManager?.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    if (compDetails) {
      this.setCompDetails(compDetails);
    }
  }
  setCompDetails(compDetails) {
    this.userCompDetails = compDetails;
    this.comp.setCompDetails(compDetails);
  }
  showParentFilter() {
    const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.beans.menuSvc?.showFilterMenu({
      column: this.column,
      buttonElement: eventSource,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter(compBean) {
    if (!this.active) {
      return;
    }
    const { filterManager } = this.beans;
    const syncWithFilter = (event) => {
      if (event?.source === "filterDestroyed" && !this.isAlive()) {
        return;
      }
      const compPromise = this.comp.getFloatingFilterComp();
      if (!compPromise) {
        return;
      }
      compPromise.then((comp) => {
        if (comp) {
          const parentModel = filterManager?.getCurrentFloatingFilterParentModel(this.column);
          const filterChangedEvent = event ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...event,
            columns: event.columns ?? [],
            source: event.source === "api" ? "api" : "columnFilter"
          } : null;
          comp.onParentModelChanged(parentModel, filterChangedEvent);
        }
      });
    };
    [this.destroySyncListener] = compBean.addManagedListeners(this.column, { filterChanged: syncWithFilter });
    if (filterManager?.isFilterActive(this.column)) {
      syncWithFilter(null);
    }
  }
  setupWidth(compBean) {
    const listener = () => {
      const width = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(width);
    };
    compBean.addManagedListeners(this.column, { widthChanged: listener });
    listener();
  }
  setupFilterChangedListener(compBean) {
    if (this.active) {
      [this.destroyFilterChangedListener] = compBean.addManagedListeners(this.column, {
        filterChanged: this.updateFilterButton.bind(this)
      });
      this.updateFilterButton();
    }
  }
  updateFilterButton() {
    if (!this.suppressFilterButton && this.comp) {
      const isFilterAllowed = !!this.beans.filterManager?.isFilterAllowed(this.column);
      this.comp.setButtonWrapperDisplayed(isFilterAllowed);
      if (this.highlightFilterButtonWhenActive && isFilterAllowed) {
        this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
      }
    }
  }
  onColDefChanged(compBean) {
    const wasActive = this.active;
    this.setupActive();
    const becomeActive = !wasActive && this.active;
    if (wasActive && !this.active) {
      this.destroySyncListener();
      this.destroyFilterChangedListener();
    }
    const newCompDetails = this.active ? this.beans.filterManager?.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null;
    const compPromise = this.comp.getFloatingFilterComp();
    if (!compPromise || !newCompDetails) {
      this.updateCompDetails(compBean, newCompDetails, becomeActive);
    } else {
      compPromise.then((compInstance) => {
        if (!compInstance || this.beans.filterManager?.areFilterCompsDifferent(this.userCompDetails ?? null, newCompDetails)) {
          this.updateCompDetails(compBean, newCompDetails, becomeActive);
        } else {
          this.updateFloatingFilterParams(newCompDetails);
        }
      });
    }
  }
  updateCompDetails(compBean, compDetails, becomeActive) {
    if (!this.isAlive()) {
      return;
    }
    this.setCompDetails(compDetails);
    this.setupFilterButton();
    this.setupUi();
    if (becomeActive) {
      this.setupSyncWithFilter(compBean);
      this.setupFilterChangedListener(compBean);
    }
  }
  updateFloatingFilterParams(userCompDetails) {
    if (!userCompDetails) {
      return;
    }
    const params = userCompDetails.params;
    this.comp.getFloatingFilterComp()?.then((floatingFilter) => {
      if (floatingFilter?.refresh && typeof floatingFilter.refresh === "function") {
        floatingFilter.refresh(params);
      }
    });
  }
  addResizeAndMoveKeyboardListeners() {
  }
  destroy() {
    super.destroy();
    this.destroySyncListener = null;
    this.destroyFilterChangedListener = null;
  }
};

// packages/ag-grid-community/src/misc/menu/menuApi.ts
function showColumnMenu(beans, colKey) {
  const column = beans.colModel.getCol(colKey);
  if (!column) {
    _error(12, { colKey });
    return;
  }
  beans.menuSvc?.showColumnMenu({
    column,
    positionBy: "auto"
  });
}
function hidePopupMenu(beans) {
  beans.menuSvc?.hidePopupMenu();
}

// packages/ag-grid-community/src/misc/menu/sharedMenuModule.ts
var SharedMenuModule = {
  moduleName: "SharedMenu",
  version: VERSION,
  beans: [MenuService],
  apiFunctions: {
    showColumnMenu,
    hidePopupMenu
  }
};

// packages/ag-grid-community/src/widgets/popupService.ts
var instanceIdSeq = 0;
var WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
var PopupService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "popupSvc";
    this.popupList = [];
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridCtrl = p.gridCtrl;
    });
    this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const ePopupParent = this.gos.get("popupParent");
    if (ePopupParent) {
      return ePopupParent;
    }
    return this.gridCtrl.getGui();
  }
  positionPopupForMenu(params) {
    const { eventSource, ePopup } = params;
    const popupIdx = this.getPopupIndex(ePopup);
    if (popupIdx !== -1) {
      const popup = this.popupList[popupIdx];
      popup.alignedToElement = eventSource;
    }
    const sourceRect = eventSource.getBoundingClientRect();
    const parentRect = this.getParentRect();
    const y = this.keepXYWithinBounds(ePopup, sourceRect.top - parentRect.top, 0 /* vertical */);
    const minWidth = ePopup.clientWidth > 0 ? ePopup.clientWidth : 200;
    ePopup.style.minWidth = `${minWidth}px`;
    const widthOfParent = parentRect.right - parentRect.left;
    const maxX = widthOfParent - minWidth;
    let x;
    if (this.gos.get("enableRtl")) {
      x = xLeftPosition();
      if (x < 0) {
        x = xRightPosition();
        this.setAlignedStyles(ePopup, "left");
      }
      if (x > maxX) {
        x = 0;
        this.setAlignedStyles(ePopup, "right");
      }
    } else {
      x = xRightPosition();
      if (x > maxX) {
        x = xLeftPosition();
        this.setAlignedStyles(ePopup, "right");
      }
      if (x < 0) {
        x = 0;
        this.setAlignedStyles(ePopup, "left");
      }
    }
    ePopup.style.left = `${x}px`;
    ePopup.style.top = `${y}px`;
    function xRightPosition() {
      return sourceRect.right - parentRect.left - 2;
    }
    function xLeftPosition() {
      return sourceRect.left - parentRect.left - minWidth;
    }
  }
  positionPopupUnderMouseEvent(params) {
    const { ePopup, nudgeX, nudgeY, skipObserver } = params;
    this.positionPopup({
      ePopup,
      nudgeX,
      nudgeY,
      keepWithinBounds: true,
      skipObserver,
      updatePosition: () => this.calculatePointerAlign(params.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        params.type,
        params.ePopup,
        null,
        params.mouseEvent,
        params.column,
        params.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const parentRect = this.getParentRect();
    return {
      x: e.clientX - parentRect.left,
      y: e.clientY - parentRect.top
    };
  }
  positionPopupByComponent(params) {
    const {
      ePopup,
      nudgeX,
      nudgeY,
      keepWithinBounds,
      eventSource,
      alignSide = "left",
      position = "over",
      column,
      rowNode,
      type
    } = params;
    const sourceRect = eventSource.getBoundingClientRect();
    const parentRect = this.getParentRect();
    const popupIdx = this.getPopupIndex(ePopup);
    if (popupIdx !== -1) {
      const popup = this.popupList[popupIdx];
      popup.alignedToElement = eventSource;
    }
    const updatePosition = () => {
      let x = sourceRect.left - parentRect.left;
      if (alignSide === "right") {
        x -= ePopup.offsetWidth - sourceRect.width;
      }
      let y;
      if (position === "over") {
        y = sourceRect.top - parentRect.top;
        this.setAlignedStyles(ePopup, "over");
      } else {
        this.setAlignedStyles(ePopup, "under");
        const alignSide2 = this.shouldRenderUnderOrAbove(ePopup, sourceRect, parentRect, params.nudgeY || 0);
        if (alignSide2 === "under") {
          y = sourceRect.top - parentRect.top + sourceRect.height;
        } else {
          y = sourceRect.top - ePopup.offsetHeight - (nudgeY || 0) * 2 - parentRect.top;
        }
      }
      return { x, y };
    };
    this.positionPopup({
      ePopup,
      nudgeX,
      nudgeY,
      keepWithinBounds,
      updatePosition,
      postProcessCallback: () => this.callPostProcessPopup(type, ePopup, eventSource, null, column, rowNode)
    });
  }
  shouldRenderUnderOrAbove(ePopup, targetCompRect, parentRect, nudgeY) {
    const spaceAvailableUnder = parentRect.bottom - targetCompRect.bottom;
    const spaceAvailableAbove = targetCompRect.top - parentRect.top;
    const spaceRequired = ePopup.offsetHeight + nudgeY;
    if (spaceAvailableUnder > spaceRequired) {
      return "under";
    }
    if (spaceAvailableAbove > spaceRequired || spaceAvailableAbove > spaceAvailableUnder) {
      return "above";
    }
    return "under";
  }
  setAlignedStyles(ePopup, positioned) {
    const popupIdx = this.getPopupIndex(ePopup);
    if (popupIdx === -1) {
      return;
    }
    const popup = this.popupList[popupIdx];
    const { alignedToElement } = popup;
    if (!alignedToElement) {
      return;
    }
    const positions = ["right", "left", "over", "above", "under"];
    positions.forEach((position) => {
      alignedToElement.classList.remove(`ag-has-popup-positioned-${position}`);
      ePopup.classList.remove(`ag-popup-positioned-${position}`);
    });
    if (!positioned) {
      return;
    }
    alignedToElement.classList.add(`ag-has-popup-positioned-${positioned}`);
    ePopup.classList.add(`ag-popup-positioned-${positioned}`);
  }
  callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
    const callback = this.gos.getCallback("postProcessPopup");
    if (callback) {
      const params = {
        column,
        rowNode,
        ePopup,
        type,
        eventSource,
        mouseEvent
      };
      callback(params);
    }
  }
  positionPopup(params) {
    const { ePopup, keepWithinBounds, nudgeX, nudgeY, skipObserver, updatePosition } = params;
    const lastSize = { width: 0, height: 0 };
    const updatePopupPosition = (fromResizeObserver = false) => {
      let { x, y } = updatePosition();
      if (fromResizeObserver && ePopup.clientWidth === lastSize.width && ePopup.clientHeight === lastSize.height) {
        return;
      }
      lastSize.width = ePopup.clientWidth;
      lastSize.height = ePopup.clientHeight;
      if (nudgeX) {
        x += nudgeX;
      }
      if (nudgeY) {
        y += nudgeY;
      }
      if (keepWithinBounds) {
        x = this.keepXYWithinBounds(ePopup, x, 1 /* horizontal */);
        y = this.keepXYWithinBounds(ePopup, y, 0 /* vertical */);
      }
      ePopup.style.left = `${x}px`;
      ePopup.style.top = `${y}px`;
      if (params.postProcessCallback) {
        params.postProcessCallback();
      }
    };
    updatePopupPosition();
    if (!skipObserver) {
      const resizeObserverDestroyFunc = _observeResize(this.beans, ePopup, () => updatePopupPosition(true));
      setTimeout(() => resizeObserverDestroyFunc(), WAIT_FOR_POPUP_CONTENT_RESIZE);
    }
  }
  getActivePopups() {
    return this.popupList.map((popup) => popup.element);
  }
  getParentRect() {
    const eDocument = _getDocument(this.beans);
    let popupParent = this.getPopupParent();
    if (popupParent === eDocument.body) {
      popupParent = eDocument.documentElement;
    } else if (getComputedStyle(popupParent).position === "static") {
      popupParent = popupParent.offsetParent;
    }
    return _getElementRectWithOffset(popupParent);
  }
  keepXYWithinBounds(ePopup, position, direction) {
    const isVertical = direction === 0 /* vertical */;
    const sizeProperty = isVertical ? "clientHeight" : "clientWidth";
    const anchorProperty = isVertical ? "top" : "left";
    const offsetProperty = isVertical ? "height" : "width";
    const scrollPositionProperty = isVertical ? "scrollTop" : "scrollLeft";
    const eDocument = _getDocument(this.beans);
    const docElement = eDocument.documentElement;
    const popupParent = this.getPopupParent();
    const popupRect = ePopup.getBoundingClientRect();
    const parentRect = popupParent.getBoundingClientRect();
    const documentRect = eDocument.documentElement.getBoundingClientRect();
    const isBody = popupParent === eDocument.body;
    const offsetSize = Math.ceil(popupRect[offsetProperty]);
    const getSize2 = isVertical ? _getAbsoluteHeight : _getAbsoluteWidth;
    let sizeOfParent = isBody ? getSize2(docElement) + docElement[scrollPositionProperty] : popupParent[sizeProperty];
    if (isBody) {
      sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
    }
    const max = sizeOfParent - offsetSize;
    return Math.min(Math.max(position, 0), Math.abs(max));
  }
  addPopup(params) {
    const eDocument = _getDocument(this.beans);
    const { eChild, ariaLabel, alwaysOnTop, positionCallback, anchorToElement } = params;
    if (!eDocument) {
      _warn(122);
      return { hideFunc: () => {
      } };
    }
    const pos = this.getPopupIndex(eChild);
    if (pos !== -1) {
      const popup = this.popupList[pos];
      return { hideFunc: popup.hideFunc };
    }
    this.initialisePopupPosition(eChild);
    const wrapperEl = this.createPopupWrapper(eChild, ariaLabel, !!alwaysOnTop);
    const removeListeners = this.addEventListenersToPopup({ ...params, wrapperEl });
    if (positionCallback) {
      positionCallback();
    }
    this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
    return {
      hideFunc: removeListeners
    };
  }
  initialisePopupPosition(element) {
    const ePopupParent = this.getPopupParent();
    const ePopupParentRect = ePopupParent.getBoundingClientRect();
    if (!_exists(element.style.top)) {
      element.style.top = `${ePopupParentRect.top * -1}px`;
    }
    if (!_exists(element.style.left)) {
      element.style.left = `${ePopupParentRect.left * -1}px`;
    }
  }
  createPopupWrapper(element, ariaLabel, alwaysOnTop) {
    const ePopupParent = this.getPopupParent();
    const eWrapper = document.createElement("div");
    const { environment, gos } = this.beans;
    environment.applyThemeClasses(eWrapper);
    eWrapper.classList.add("ag-popup");
    element.classList.add(gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child");
    if (!element.hasAttribute("role")) {
      _setAriaRole(element, "dialog");
    }
    _setAriaLabel(element, ariaLabel);
    eWrapper.appendChild(element);
    ePopupParent.appendChild(eWrapper);
    if (alwaysOnTop) {
      this.setAlwaysOnTop(element, true);
    } else {
      this.bringPopupToFront(element);
    }
    return eWrapper;
  }
  handleThemeChange(e) {
    if (e.themeChanged) {
      const environment = this.beans.environment;
      for (const popup of this.popupList) {
        environment.applyThemeClasses(popup.wrapper);
      }
    }
  }
  addEventListenersToPopup(params) {
    const beans = this.beans;
    const eDocument = _getDocument(beans);
    const ePopupParent = this.getPopupParent();
    const { wrapperEl, eChild: popupEl, closedCallback, afterGuiAttached, closeOnEsc, modal } = params;
    let popupHidden = false;
    const hidePopupOnKeyboardEvent = (event) => {
      if (!wrapperEl.contains(_getActiveDomElement(beans))) {
        return;
      }
      const key = event.key;
      if (key === KeyCode.ESCAPE && !_isStopPropagationForAgGrid(event)) {
        removeListeners({ keyboardEvent: event });
      }
    };
    const hidePopupOnMouseEvent = (event) => removeListeners({ mouseEvent: event });
    const hidePopupOnTouchEvent = (event) => removeListeners({ touchEvent: event });
    const removeListeners = (popupParams = {}) => {
      const { mouseEvent, touchEvent, keyboardEvent, forceHide } = popupParams;
      if (!forceHide && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent, touchEvent }, popupEl) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      popupHidden)) {
        return;
      }
      popupHidden = true;
      ePopupParent.removeChild(wrapperEl);
      eDocument.removeEventListener("keydown", hidePopupOnKeyboardEvent);
      eDocument.removeEventListener("mousedown", hidePopupOnMouseEvent);
      eDocument.removeEventListener("touchstart", hidePopupOnTouchEvent);
      eDocument.removeEventListener("contextmenu", hidePopupOnMouseEvent);
      this.eventSvc.removeEventListener("dragStarted", hidePopupOnMouseEvent);
      if (closedCallback) {
        closedCallback(mouseEvent || touchEvent || keyboardEvent);
      }
      this.removePopupFromPopupList(popupEl);
    };
    if (afterGuiAttached) {
      afterGuiAttached({ hidePopup: removeListeners });
    }
    window.setTimeout(() => {
      if (closeOnEsc) {
        eDocument.addEventListener("keydown", hidePopupOnKeyboardEvent);
      }
      if (modal) {
        eDocument.addEventListener("mousedown", hidePopupOnMouseEvent);
        this.eventSvc.addEventListener("dragStarted", hidePopupOnMouseEvent);
        eDocument.addEventListener("touchstart", hidePopupOnTouchEvent);
        eDocument.addEventListener("contextmenu", hidePopupOnMouseEvent);
      }
    }, 0);
    return removeListeners;
  }
  addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
    this.popupList.push({
      element,
      wrapper: wrapperEl,
      hideFunc: removeListeners,
      instanceId: instanceIdSeq++,
      isAnchored: !!anchorToElement
    });
    if (anchorToElement) {
      this.setPopupPositionRelatedToElement(element, anchorToElement);
    }
  }
  getPopupIndex(el) {
    return this.popupList.findIndex((p) => p.element === el);
  }
  setPopupPositionRelatedToElement(popupEl, relativeElement) {
    const popupIndex = this.getPopupIndex(popupEl);
    if (popupIndex === -1) {
      return;
    }
    const popup = this.popupList[popupIndex];
    if (popup.stopAnchoringPromise) {
      popup.stopAnchoringPromise.then((destroyFunc) => destroyFunc && destroyFunc());
    }
    popup.stopAnchoringPromise = void 0;
    popup.isAnchored = false;
    if (!relativeElement) {
      return;
    }
    const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
      element: relativeElement,
      ePopup: popupEl,
      hidePopup: popup.hideFunc
    });
    popup.stopAnchoringPromise = destroyPositionTracker;
    popup.isAnchored = true;
    return destroyPositionTracker;
  }
  removePopupFromPopupList(element) {
    this.setAlignedStyles(element, null);
    this.setPopupPositionRelatedToElement(element, null);
    this.popupList = this.popupList.filter((p) => p.element !== element);
  }
  keepPopupPositionedRelativeTo(params) {
    const eParent = this.getPopupParent();
    const parentRect = eParent.getBoundingClientRect();
    const { element, ePopup } = params;
    const sourceRect = element.getBoundingClientRect();
    const extractFromPixelValue = (pxSize) => parseInt(pxSize.substring(0, pxSize.length - 1), 10);
    const createPosition = (prop, direction) => {
      const initialDiff = parentRect[prop] - sourceRect[prop];
      const initial = extractFromPixelValue(ePopup.style[prop]);
      return {
        initialDiff,
        lastDiff: initialDiff,
        initial,
        last: initial,
        direction
      };
    };
    const topPosition = createPosition("top", 0 /* vertical */);
    const leftPosition = createPosition("left", 1 /* horizontal */);
    const fwOverrides = this.beans.frameworkOverrides;
    return new AgPromise((resolve) => {
      fwOverrides.wrapIncoming(() => {
        fwOverrides.setInterval(() => {
          const pRect = eParent.getBoundingClientRect();
          const sRect = element.getBoundingClientRect();
          const elementNotInDom = sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0;
          if (elementNotInDom) {
            params.hidePopup();
            return;
          }
          const calculateNewPosition = (position, prop) => {
            const current = extractFromPixelValue(ePopup.style[prop]);
            if (position.last !== current) {
              position.initial = current;
              position.last = current;
            }
            const currentDiff = pRect[prop] - sRect[prop];
            if (currentDiff != position.lastDiff) {
              const newValue = this.keepXYWithinBounds(
                ePopup,
                position.initial + position.initialDiff - currentDiff,
                position.direction
              );
              ePopup.style[prop] = `${newValue}px`;
              position.last = newValue;
            }
            position.lastDiff = currentDiff;
          };
          calculateNewPosition(topPosition, "top");
          calculateNewPosition(leftPosition, "left");
        }, 200).then((intervalId) => {
          const result = () => {
            if (intervalId != null) {
              window.clearInterval(intervalId);
            }
          };
          resolve(result);
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((popup) => popup.isAnchored);
  }
  isEventFromCurrentPopup(params, target) {
    const { mouseEvent, touchEvent } = params;
    const event = mouseEvent ? mouseEvent : touchEvent;
    if (!event) {
      return false;
    }
    const indexOfThisChild = this.getPopupIndex(target);
    if (indexOfThisChild === -1) {
      return false;
    }
    for (let i = indexOfThisChild; i < this.popupList.length; i++) {
      const popup = this.popupList[i];
      if (_isElementInEventPath(popup.element, event)) {
        return true;
      }
    }
    return this.isElementWithinCustomPopup(event.target);
  }
  isElementWithinCustomPopup(el) {
    const eDocument = _getDocument(this.beans);
    while (el && el !== eDocument.body) {
      if (el.classList.contains("ag-custom-component-popup") || el.parentElement === null) {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }
  getWrapper(ePopup) {
    while (!ePopup.classList.contains("ag-popup") && ePopup.parentElement) {
      ePopup = ePopup.parentElement;
    }
    return ePopup.classList.contains("ag-popup") ? ePopup : null;
  }
  setAlwaysOnTop(ePopup, alwaysOnTop) {
    const eWrapper = this.getWrapper(ePopup);
    if (!eWrapper) {
      return;
    }
    eWrapper.classList.toggle("ag-always-on-top", !!alwaysOnTop);
    if (alwaysOnTop) {
      this.bringPopupToFront(eWrapper);
    }
  }
  /** @return true if moved */
  bringPopupToFront(ePopup) {
    const parent = this.getPopupParent();
    const popupList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup"));
    const popupLen = popupList.length;
    const eWrapper = this.getWrapper(ePopup);
    if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) {
      return;
    }
    const standardPopupList = [];
    const alwaysOnTopList = [];
    for (const popup of popupList) {
      if (popup === eWrapper) {
        continue;
      }
      if (popup.classList.contains("ag-always-on-top")) {
        alwaysOnTopList.push(popup);
      } else {
        standardPopupList.push(popup);
      }
    }
    const innerElsScrollMap = [];
    const onTopLength = alwaysOnTopList.length;
    const isPopupAlwaysOnTop = eWrapper.classList.contains("ag-always-on-top");
    const shouldBeLast = isPopupAlwaysOnTop || !onTopLength;
    const targetList = shouldBeLast ? [...standardPopupList, ...alwaysOnTopList, eWrapper] : [...standardPopupList, eWrapper, ...alwaysOnTopList];
    for (let i = 0; i <= popupLen; i++) {
      const currentPopup = targetList[i];
      if (popupList[i] === targetList[i] || currentPopup === eWrapper) {
        continue;
      }
      const innerEls = currentPopup.querySelectorAll("div");
      innerEls.forEach((el) => {
        if (el.scrollTop !== 0) {
          innerElsScrollMap.push([el, el.scrollTop]);
        }
      });
      if (i === 0) {
        parent.insertAdjacentElement("afterbegin", currentPopup);
      } else {
        targetList[i - 1].insertAdjacentElement("afterend", currentPopup);
      }
    }
    while (innerElsScrollMap.length) {
      const currentEl = innerElsScrollMap.pop();
      currentEl[0].scrollTop = currentEl[1];
    }
  }
};

// packages/ag-grid-community/src/widgets/popupModule.ts
var PopupModule = {
  moduleName: "Popup",
  version: VERSION,
  beans: [PopupService]
};

// packages/ag-grid-community/src/filter/column-filters.css-GENERATED.ts
var columnFiltersCSS = (
  /*css*/
  `.ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-set-floating-filter-input [disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:1px solid var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}`
);

// packages/ag-grid-community/src/filter/columnFilterApi.ts
function isColumnFilterPresent(beans) {
  const filterManager = beans.filterManager;
  return !!filterManager?.isColumnFilterPresent() || !!filterManager?.isAggregateFilterPresent();
}
function getColumnFilterInstance(beans, key) {
  return beans.filterManager?.getColumnFilterInstance(key) ?? Promise.resolve(void 0);
}
function destroyFilter(beans, key) {
  const column = beans.colModel.getColDefCol(key);
  if (column) {
    return beans.filterManager?.destroyFilter(column, "api");
  }
}
function setFilterModel(beans, model) {
  beans.frameworkOverrides.wrapIncoming(() => beans.filterManager?.setFilterModel(model));
}
function getFilterModel(beans) {
  return beans.filterManager?.getFilterModel() ?? {};
}
function getColumnFilterModel(beans, column) {
  return beans.filterManager?.getColumnFilterModel(column) ?? null;
}
function setColumnFilterModel(beans, column, model) {
  return beans.filterManager?.setColumnFilterModel(column, model) ?? Promise.resolve();
}
function showColumnFilter(beans, colKey) {
  const column = beans.colModel.getCol(colKey);
  if (!column) {
    _error(12, { colKey });
    return;
  }
  beans.menuSvc?.showFilterMenu({
    column,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}

// packages/ag-grid-community/src/filter/columnFilterService.ts
var MONTH_LOCALE_TEXT = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
};
var MONTH_KEYS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
function setFilterNumberComparator(a, b) {
  if (a == null) {
    return -1;
  }
  if (b == null) {
    return 1;
  }
  return parseFloat(a) - parseFloat(b);
}
var ColumnFilterService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colFilter";
    this.allColumnFilters = /* @__PURE__ */ new Map();
    this.allColumnListeners = /* @__PURE__ */ new Map();
    this.activeAggregateFilters = [];
    this.activeColumnFilters = [];
    // this is true when the grid is processing the filter change. this is used by the cell comps, so that they
    // don't flash when data changes due to filter changes. there is no need to flash when filter changes as the
    // user is in control, so doesn't make sense to show flashing changes. for example, go to main demo where
    // this feature is turned off (hack code to always return false for isSuppressFlashingCellsBecauseFiltering(), put in)
    // 100,000 rows and group by country. then do some filtering. all the cells flash, which is silly.
    this.processingFilterChange = false;
    // when we're waiting for cell data types to be inferred, we need to defer filter model updates
    this.filterModelUpdateQueue = [];
    this.columnFilterModelUpdateQueue = [];
  }
  postConstruct() {
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      beforeRefreshModel: ({ params }) => {
        if (params.rowDataUpdated || params.changedProps?.has("treeData")) {
          this.onNewRowsLoaded("rowDataUpdated");
        }
      },
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    });
    this.initialFilterModel = {
      ...this.gos.get("initialState")?.filter?.filterModel ?? {}
    };
  }
  setFilterModel(model, source = "api") {
    const { colModel, dataTypeSvc, filterManager } = this.beans;
    if (dataTypeSvc?.isPendingInference) {
      this.filterModelUpdateQueue.push({ model, source });
      return;
    }
    const allPromises = [];
    const previousModel = this.getFilterModel(true);
    if (model) {
      const modelKeys = new Set(Object.keys(model));
      this.allColumnFilters.forEach((filterWrapper, colId) => {
        const newModel = model[colId];
        allPromises.push(setModelOnFilterWrapper(filterWrapper.filterPromise, newModel));
        modelKeys.delete(colId);
      });
      modelKeys.forEach((colId) => {
        const column = colModel.getColDefCol(colId) || colModel.getCol(colId);
        if (!column) {
          _warn(62, { colId });
          return;
        }
        if (!column.isFilterAllowed()) {
          _warn(63, { colId });
          return;
        }
        const filterWrapper = this.getOrCreateFilterWrapper(column);
        if (!filterWrapper) {
          _warn(64, { colId });
          return;
        }
        allPromises.push(setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]));
      });
    } else {
      this.allColumnFilters.forEach((filterWrapper) => {
        allPromises.push(setModelOnFilterWrapper(filterWrapper.filterPromise, null));
      });
    }
    AgPromise.all(allPromises).then(() => {
      const currentModel = this.getFilterModel(true);
      const columns = [];
      this.allColumnFilters.forEach((filterWrapper, colId) => {
        const before = previousModel ? previousModel[colId] : null;
        const after = currentModel ? currentModel[colId] : null;
        if (!_jsonEquals(before, after)) {
          columns.push(filterWrapper.column);
        }
      });
      if (columns.length > 0) {
        filterManager?.onFilterChanged({ columns, source });
      }
    });
  }
  getFilterModel(excludeInitialState) {
    const result = {};
    const {
      allColumnFilters,
      initialFilterModel,
      beans: { colModel }
    } = this;
    allColumnFilters.forEach((filterWrapper, key) => {
      const model = this.getModelFromFilterWrapper(filterWrapper);
      if (_exists(model)) {
        result[key] = model;
      }
    });
    if (!excludeInitialState) {
      Object.entries(initialFilterModel).forEach(([colId, model]) => {
        if (_exists(model) && !allColumnFilters.has(colId) && colModel.getCol(colId)?.isFilterAllowed()) {
          result[colId] = model;
        }
      });
    }
    return result;
  }
  getModelFromFilterWrapper(filterWrapper) {
    const { filter } = filterWrapper;
    if (filter) {
      if (typeof filter.getModel !== "function") {
        _warn(66);
        return null;
      }
      return filter.getModel();
    } else {
      return this.getModelFromInitialState(filterWrapper.column);
    }
  }
  getModelFromInitialState(column) {
    return this.initialFilterModel[column.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    const { allColumnFilters } = this;
    if (allColumnFilters.size) {
      allColumnFilters.forEach(
        (filterWrapper) => this.disposeFilterWrapper(filterWrapper, "advancedFilterEnabled")
      );
      return true;
    }
    return false;
  }
  doAggregateFiltersPass(node, filterToSkip) {
    return this.doColumnFiltersPass(node, filterToSkip, true);
  }
  updateActiveFilters() {
    const isFilterActive = (filter) => {
      if (!filter) {
        return false;
      }
      if (!filter.isFilterActive) {
        _warn(67);
        return false;
      }
      return filter.isFilterActive();
    };
    const { colModel, gos } = this.beans;
    const groupFilterEnabled = !!_getGroupAggFiltering(gos);
    const isAggFilter = (column) => {
      const isSecondary = !column.isPrimary();
      if (isSecondary) {
        return true;
      }
      const isShowingPrimaryColumns = !colModel.isPivotActive();
      const isValueActive = column.isValueActive();
      if (!isValueActive || !isShowingPrimaryColumns) {
        return false;
      }
      if (colModel.isPivotMode()) {
        return true;
      }
      return groupFilterEnabled;
    };
    const activeAggregateFilters = [];
    const activeColumnFilters = [];
    return this.forEachColumnFilter((filter, filterWrapper) => {
      const filterActive = isFilterActive(filter);
      if (filterActive) {
        if (isAggFilter(filterWrapper.column)) {
          activeAggregateFilters.push(filter);
        } else {
          activeColumnFilters.push(filter);
        }
      }
    }).then(() => {
      this.activeAggregateFilters = activeAggregateFilters;
      this.activeColumnFilters = activeColumnFilters;
    });
  }
  updateFilterFlagInColumns(source, additionalEventAttributes) {
    return this.forEachColumnFilter(
      (filter, filterWrapper) => this.setColFilterActive(filterWrapper.column, filter.isFilterActive(), source, additionalEventAttributes)
    );
  }
  forEachColumnFilter(callback) {
    const promises = [];
    this.allColumnFilters.forEach((filterWrapper) => {
      const filterPromise = filterWrapper.filterPromise;
      if (filterPromise) {
        promises.push(filterPromise.then((filter) => callback(filter, filterWrapper)));
      }
    });
    return AgPromise.all(promises);
  }
  doColumnFiltersPass(node, filterToSkip, targetAggregates) {
    const { data, aggData } = node;
    const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
    const targetedData = targetAggregates ? aggData : data;
    for (let i = 0; i < targetedFilters.length; i++) {
      const filter = targetedFilters[i];
      if (filter == null || filter === filterToSkip) {
        continue;
      }
      if (typeof filter.doesFilterPass !== "function") {
        _error(91);
        continue;
      }
      if (!filter.doesFilterPass({ node, data: targetedData })) {
        return false;
      }
    }
    return true;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(params) {
    const { rowRenderer, filterManager } = this.beans;
    const action = () => {
      if (this.isAlive()) {
        filterManager?.onFilterChanged(params);
      }
    };
    if (rowRenderer.isRefreshInProgress()) {
      setTimeout(action, 0);
    } else {
      action();
    }
  }
  updateBeforeFilterChanged(params = {}) {
    const { filterInstance, additionalEventAttributes } = params;
    this.updateDependentFilters();
    return this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", additionalEventAttributes).then(() => {
        this.allColumnFilters.forEach((filterWrapper) => {
          if (!filterWrapper.filterPromise) {
            return;
          }
          filterWrapper.filterPromise.then((filter) => {
            if (filter && filter !== filterInstance && filter.onAnyFilterChanged) {
              filter.onAnyFilterChanged();
            }
          });
        });
        this.processingFilterChange = true;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = false;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    const allowShowChangeAfterFilter = this.gos.get("allowShowChangeAfterFilter") ?? false;
    return !allowShowChangeAfterFilter && this.processingFilterChange;
  }
  onNewRowsLoaded(source) {
    this.forEachColumnFilter((filter) => {
      filter.onNewRowsLoaded?.();
    }).then(() => this.updateFilterFlagInColumns(source, { afterDataChange: true })).then(() => this.updateActiveFilters());
  }
  createGetValue(filterColumn) {
    const { filterValueSvc, colModel } = this.beans;
    return (rowNode, column) => {
      const columnToUse = column ? colModel.getCol(column) : filterColumn;
      return columnToUse ? filterValueSvc.getValue(columnToUse, rowNode) : void 0;
    };
  }
  isFilterActive(column) {
    const { filter } = this.cachedFilter(column) ?? {};
    if (filter) {
      return filter.isFilterActive();
    }
    return this.getModelFromInitialState(column) != null;
  }
  getOrCreateFilterWrapper(column) {
    if (!column.isFilterAllowed()) {
      return null;
    }
    let filterWrapper = this.cachedFilter(column);
    if (!filterWrapper) {
      filterWrapper = this.createFilterWrapper(column);
      this.setColumnFilterWrapper(column, filterWrapper);
    }
    return filterWrapper;
  }
  cachedFilter(column) {
    return this.allColumnFilters.get(column.getColId());
  }
  getDefaultFilter(column) {
    let defaultFilter;
    const { gos, dataTypeSvc } = this.beans;
    if (_isSetFilterByDefault(gos)) {
      defaultFilter = "agSetColumnFilter";
    } else {
      const cellDataType = dataTypeSvc?.getBaseDataType(column);
      if (cellDataType === "number") {
        defaultFilter = "agNumberColumnFilter";
      } else if (cellDataType === "date" || cellDataType === "dateString") {
        defaultFilter = "agDateColumnFilter";
      } else {
        defaultFilter = "agTextColumnFilter";
      }
    }
    return defaultFilter;
  }
  getDefaultFloatingFilter(column) {
    let defaultFloatingFilterType;
    const { gos, dataTypeSvc } = this.beans;
    if (_isSetFilterByDefault(gos)) {
      defaultFloatingFilterType = "agSetColumnFloatingFilter";
    } else {
      const cellDataType = dataTypeSvc?.getBaseDataType(column);
      if (cellDataType === "number") {
        defaultFloatingFilterType = "agNumberColumnFloatingFilter";
      } else if (cellDataType === "date" || cellDataType === "dateString") {
        defaultFloatingFilterType = "agDateColumnFloatingFilter";
      } else {
        defaultFloatingFilterType = "agTextColumnFloatingFilter";
      }
    }
    return defaultFloatingFilterType;
  }
  createFilterInstance(column, filterWrapper) {
    const defaultFilter = this.getDefaultFilter(column);
    const colDef = column.getColDef();
    let filterInstance;
    const params = {
      ...this.createFilterParams(column, colDef),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(filterInstance, column)(),
      filterChangedCallback: (additionalEventAttributes) => this.filterChangedCallbackFactory(filterInstance, column)(additionalEventAttributes),
      doesRowPassOtherFilter: (node) => this.beans.filterManager?.doesRowPassOtherFilters(filterInstance, node) ?? true
    };
    const compDetails = _getFilterDetails(this.beans.userCompFactory, colDef, params, defaultFilter);
    if (!compDetails) {
      return { filterPromise: null, compDetails: null };
    }
    return {
      filterPromise: () => {
        const filterPromise = compDetails.newAgStackInstance();
        filterPromise.then((r) => {
          filterInstance = r;
          if (filterWrapper) {
            filterWrapper.filter = r ?? void 0;
          }
        });
        return filterPromise;
      },
      compDetails
    };
  }
  createFilterParams(column, colDef) {
    const params = this.gos.addGridCommonParams({
      column,
      colDef,
      rowModel: this.beans.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      getValue: this.createGetValue(column),
      doesRowPassOtherFilter: () => true
    });
    return params;
  }
  createFilterWrapper(column) {
    const filterWrapper = {
      column,
      filterPromise: null,
      compDetails: null
    };
    const { filterPromise, compDetails } = this.createFilterInstance(column, filterWrapper);
    filterWrapper.filterPromise = filterPromise?.() ?? null;
    filterWrapper.compDetails = compDetails;
    return filterWrapper;
  }
  onColumnsChanged() {
    const columns = [];
    const { colModel, filterManager } = this.beans;
    this.allColumnFilters.forEach((wrapper, colId) => {
      let currentColumn;
      if (wrapper.column.isPrimary()) {
        currentColumn = colModel.getColDefCol(colId);
      } else {
        currentColumn = colModel.getCol(colId);
      }
      if (currentColumn && currentColumn === wrapper.column) {
        return;
      }
      columns.push(wrapper.column);
      this.disposeFilterWrapper(wrapper, "columnChanged");
      this.disposeColumnListener(colId);
    });
    const allFiltersAreGroupFilters = columns.every(
      (column) => column.getColDef().filter === "agGroupColumnFilter"
    );
    if (columns.length > 0 && !allFiltersAreGroupFilters) {
      filterManager?.onFilterChanged({ columns, source: "api" });
    } else {
      this.updateDependentFilters();
    }
  }
  updateDependentFilters() {
    this.beans.autoColSvc?.getAutoCols()?.forEach((groupColumn) => {
      if (groupColumn.getColDef().filter === "agGroupColumnFilter") {
        this.getOrCreateFilterWrapper(groupColumn);
      }
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(column) {
    const isFilterAllowed = column.isFilterAllowed();
    if (!isFilterAllowed) {
      return false;
    }
    const { filter } = this.allColumnFilters.get(column.getColId()) ?? {};
    if (filter) {
      return typeof filter?.isFilterAllowed === "function" ? filter.isFilterAllowed() : true;
    }
    return true;
  }
  getFloatingFilterCompDetails(column, showParentFilter) {
    const parentFilterInstance = (callback) => {
      const filterComponent = this.getOrCreateFilterWrapper(column)?.filterPromise;
      if (filterComponent == null) {
        return;
      }
      filterComponent.then((instance) => {
        callback(_unwrapUserComp(instance));
      });
    };
    const colDef = column.getColDef();
    const filterParams = {
      ...this.createFilterParams(column, colDef),
      filterChangedCallback: () => parentFilterInstance(
        (filterInstance) => this.filterChangedCallbackFactory(filterInstance, column)()
      )
    };
    const { userCompFactory, frameworkOverrides } = this.beans;
    const finalFilterParams = _mergeFilterParamsWithApplicationProvidedParams(
      userCompFactory,
      colDef,
      filterParams
    );
    let defaultFloatingFilterType = _getDefaultFloatingFilterType(
      frameworkOverrides,
      colDef,
      () => this.getDefaultFloatingFilter(column)
    );
    if (defaultFloatingFilterType == null) {
      defaultFloatingFilterType = "agReadOnlyFloatingFilter";
    }
    const params = {
      column,
      filterParams: finalFilterParams,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(column),
      parentFilterInstance,
      showParentFilter
    };
    return _getFloatingFilterCompDetails(userCompFactory, colDef, params, defaultFloatingFilterType);
  }
  getCurrentFloatingFilterParentModel(column) {
    return this.getModelFromFilterWrapper(this.cachedFilter(column) ?? { column });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(column, source = "api") {
    const colId = column.getColId();
    const filterWrapper = this.allColumnFilters.get(colId);
    this.disposeColumnListener(colId);
    delete this.initialFilterModel[colId];
    if (filterWrapper) {
      this.disposeFilterWrapper(filterWrapper, source);
      this.beans.filterManager?.onFilterChanged({
        columns: [column],
        source: "api"
      });
    }
  }
  disposeColumnListener(colId) {
    const columnListener = this.allColumnListeners.get(colId);
    if (columnListener) {
      this.allColumnListeners.delete(colId);
      columnListener();
    }
  }
  disposeFilterWrapper(filterWrapper, source) {
    filterWrapper.filterPromise?.then((filter) => {
      this.destroyBean(filter);
      this.setColFilterActive(filterWrapper.column, false, "filterDestroyed");
      this.allColumnFilters.delete(filterWrapper.column.getColId());
      this.eventSvc.dispatchEvent({
        type: "filterDestroyed",
        source,
        column: filterWrapper.column
      });
    });
  }
  filterModifiedCallbackFactory(filter, column) {
    return () => {
      this.eventSvc.dispatchEvent({
        type: "filterModified",
        column,
        filterInstance: filter
      });
    };
  }
  filterChangedCallbackFactory(filter, column) {
    return (additionalEventAttributes) => {
      const source = additionalEventAttributes?.source ?? "columnFilter";
      const params = {
        filter,
        additionalEventAttributes,
        columns: [column],
        source
      };
      this.callOnFilterChangedOutsideRenderCycle(params);
    };
  }
  checkDestroyFilter(colId) {
    const filterWrapper = this.allColumnFilters.get(colId);
    if (!filterWrapper) {
      return;
    }
    const column = filterWrapper.column;
    const { compDetails } = column.isFilterAllowed() ? this.createFilterInstance(column) : { compDetails: null };
    if (this.areFilterCompsDifferent(filterWrapper.compDetails, compDetails)) {
      this.destroyFilter(column, "paramsUpdated");
      return;
    }
    const newFilterParams = column.getColDef().filterParams;
    if (!filterWrapper.filterPromise) {
      this.destroyFilter(column, "paramsUpdated");
      return;
    }
    filterWrapper.filterPromise.then((filter) => {
      const shouldRefreshFilter = filter?.refresh ? filter.refresh({
        ...this.createFilterParams(column, column.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(filter, column),
        filterChangedCallback: this.filterChangedCallbackFactory(filter, column),
        doesRowPassOtherFilter: (node) => this.beans.filterManager?.doesRowPassOtherFilters(filter, node) ?? true,
        ...newFilterParams
      }) : true;
      if (shouldRefreshFilter === false) {
        this.destroyFilter(column, "paramsUpdated");
      }
    });
  }
  setColumnFilterWrapper(column, filterWrapper) {
    const colId = column.getColId();
    this.allColumnFilters.set(colId, filterWrapper);
    this.allColumnListeners.set(
      colId,
      this.addManagedListeners(column, { colDefChanged: () => this.checkDestroyFilter(colId) })[0]
    );
  }
  areFilterCompsDifferent(oldCompDetails, newCompDetails) {
    if (!newCompDetails || !oldCompDetails) {
      return true;
    }
    const { componentClass: oldComponentClass } = oldCompDetails;
    const { componentClass: newComponentClass } = newCompDetails;
    const isSameComponentClass = oldComponentClass === newComponentClass || // react hooks returns new wrappers, so check nested render method
    oldComponentClass?.render && newComponentClass?.render && oldComponentClass.render === newComponentClass.render;
    return !isSameComponentClass;
  }
  hasFloatingFilters() {
    const gridColumns = this.beans.colModel.getCols();
    return gridColumns.some((col) => col.getColDef().floatingFilter);
  }
  getColumnFilterInstance(key) {
    return new Promise((resolve) => {
      this.getFilterInstanceImpl(key).then((filter) => {
        resolve(_unwrapUserComp(filter));
      });
    });
  }
  getFilterInstanceImpl(key) {
    const column = this.beans.colModel.getColDefCol(key);
    if (!column) {
      return AgPromise.resolve(void 0);
    }
    const filterPromise = this.getOrCreateFilterWrapper(column)?.filterPromise;
    return filterPromise ?? AgPromise.resolve(null);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model, source }) => this.setFilterModel(model, source));
    this.filterModelUpdateQueue = [];
    this.columnFilterModelUpdateQueue.forEach(({ key, model, resolve }) => {
      this.setColumnFilterModel(key, model).then(() => resolve());
    });
    this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(key) {
    const filterWrapper = this.getFilterWrapper(key);
    return filterWrapper ? this.getModelFromFilterWrapper(filterWrapper) : null;
  }
  setColumnFilterModel(key, model) {
    const { colModel, dataTypeSvc } = this.beans;
    if (dataTypeSvc?.isPendingInference) {
      let resolve = () => {
      };
      const promise = new Promise((res) => {
        resolve = res;
      });
      this.columnFilterModelUpdateQueue.push({ key, model, resolve });
      return promise;
    }
    const column = colModel.getColDefCol(key);
    const filterWrapper = column ? this.getOrCreateFilterWrapper(column) : null;
    const convertPromise = (promise) => {
      return new Promise((resolve) => {
        promise.then((result) => resolve(result));
      });
    };
    return filterWrapper ? convertPromise(setModelOnFilterWrapper(filterWrapper.filterPromise, model)) : Promise.resolve();
  }
  getFilterWrapper(key) {
    const column = this.beans.colModel.getColDefCol(key);
    return column ? this.cachedFilter(column) ?? null : null;
  }
  setColDefPropertiesForDataType(colDef, dataTypeDefinition, formatValue) {
    const usingSetFilter = _isSetFilterByDefault(this.gos);
    const translate = this.getLocaleTextFunc();
    const mergeFilterParams = (params) => {
      const { filterParams } = colDef;
      colDef.filterParams = typeof filterParams === "object" ? {
        ...filterParams,
        ...params
      } : params;
    };
    switch (dataTypeDefinition.baseDataType) {
      case "number": {
        if (usingSetFilter) {
          mergeFilterParams({
            comparator: setFilterNumberComparator
          });
        }
        break;
      }
      case "boolean": {
        if (usingSetFilter) {
          mergeFilterParams({
            valueFormatter: (params) => {
              if (!_exists(params.value)) {
                return translate("blanks", "(Blanks)");
              }
              return translate(String(params.value), params.value ? "True" : "False");
            }
          });
        } else {
          mergeFilterParams({
            maxNumConditions: 1,
            debounceMs: 0,
            filterOptions: [
              "empty",
              {
                displayKey: "true",
                displayName: "True",
                predicate: (_filterValues, cellValue) => cellValue,
                numberOfInputs: 0
              },
              {
                displayKey: "false",
                displayName: "False",
                predicate: (_filterValues, cellValue) => cellValue === false,
                numberOfInputs: 0
              }
            ]
          });
        }
        break;
      }
      case "date": {
        if (usingSetFilter) {
          mergeFilterParams({
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params);
              return _exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            },
            treeList: true,
            treeListFormatter: (pathKey, level) => {
              if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
              }
              return pathKey ?? translate("blanks", "(Blanks)");
            }
          });
        }
        break;
      }
      case "dateString": {
        const convertToDate = dataTypeDefinition.dateParser;
        if (usingSetFilter) {
          mergeFilterParams({
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params);
              return _exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            },
            treeList: true,
            treeListPathGetter: (value) => {
              const date = convertToDate(value ?? void 0);
              return date ? [String(date.getFullYear()), String(date.getMonth() + 1), String(date.getDate())] : null;
            },
            treeListFormatter: (pathKey, level) => {
              if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
              }
              return pathKey ?? translate("blanks", "(Blanks)");
            }
          });
        } else {
          mergeFilterParams({
            comparator: (filterDate, cellValue) => {
              const cellAsDate = convertToDate(cellValue);
              if (cellValue == null || cellAsDate < filterDate) {
                return -1;
              }
              if (cellAsDate > filterDate) {
                return 1;
              }
              return 0;
            }
          });
        }
        break;
      }
      case "object": {
        if (usingSetFilter) {
          mergeFilterParams({
            valueFormatter: (params) => {
              const valueFormatted = formatValue(params);
              return _exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
            }
          });
        } else {
          colDef.filterValueGetter = (params) => formatValue({
            column: params.column,
            node: params.node,
            value: this.beans.valueSvc.getValue(params.column, params.node)
          });
        }
        break;
      }
    }
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setColFilterActive(column, active, source, additionalEventAttributes) {
    if (column.filterActive !== active) {
      column.filterActive = active;
      column.dispatchColEvent("filterActiveChanged", source);
    }
    column.dispatchColEvent("filterChanged", source, additionalEventAttributes);
  }
  destroy() {
    super.destroy();
    this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "gridDestroyed"));
    this.allColumnListeners.clear();
  }
};
function setModelOnFilterWrapper(filterPromise, newModel) {
  if (!filterPromise) {
    return AgPromise.resolve();
  }
  return new AgPromise((resolve) => {
    filterPromise.then((filter) => {
      if (typeof filter.setModel !== "function") {
        _warn(65);
        resolve();
      }
      (filter.setModel(newModel) || AgPromise.resolve()).then(() => resolve());
    });
  });
}

// packages/ag-grid-community/src/filter/filterApi.ts
function isAnyFilterPresent(beans) {
  return !!beans.filterManager?.isAnyFilterPresent();
}
function onFilterChanged(beans, source = "api") {
  beans.filterManager?.onFilterChanged({ source });
}

// packages/ag-grid-community/src/filter/filterManager.ts
var FilterManager = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "filterManager";
    // when we're waiting for cell data types to be inferred, we need to defer filter model updates
    this.advFilterModelUpdateQueue = [];
  }
  wireBeans(beans) {
    this.quickFilter = beans.quickFilter;
    this.advancedFilter = beans.advancedFilter;
    this.colFilter = beans.colFilter;
  }
  postConstruct() {
    const refreshFiltersForAggregations = this.refreshFiltersForAggregations.bind(this);
    const updateAdvFilterColumns = this.updateAdvFilterColumns.bind(this);
    this.addManagedEventListeners({
      columnValueChanged: refreshFiltersForAggregations,
      columnPivotChanged: refreshFiltersForAggregations,
      columnPivotModeChanged: refreshFiltersForAggregations,
      newColumnsLoaded: updateAdvFilterColumns,
      columnVisible: updateAdvFilterColumns,
      advancedFilterEnabledChanged: ({ enabled }) => this.onAdvFilterEnabledChanged(enabled),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    });
    this.externalFilterPresent = this.isExternalFilterPresentCallback();
    this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    });
    this.updateAggFiltering();
    this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering();
      this.onFilterChanged();
    });
    if (this.quickFilter) {
      this.addManagedListeners(this.quickFilter, {
        quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
      });
    }
    const { gos } = this;
    this.alwaysPassFilter = gos.get("alwaysPassFilter");
    this.addManagedPropertyListener("alwaysPassFilter", () => {
      this.alwaysPassFilter = gos.get("alwaysPassFilter");
      this.onFilterChanged({ source: "api" });
    });
  }
  isExternalFilterPresentCallback() {
    const isFilterPresent = this.gos.getCallback("isExternalFilterPresent");
    return typeof isFilterPresent === "function" && isFilterPresent({});
  }
  doesExternalFilterPass(node) {
    const doesFilterPass = this.gos.get("doesExternalFilterPass");
    return typeof doesFilterPass === "function" && doesFilterPass(node);
  }
  setFilterModel(model, source = "api") {
    if (this.isAdvFilterEnabled()) {
      this.warnAdvFilters();
      return;
    }
    this.colFilter?.setFilterModel(model, source);
  }
  getFilterModel() {
    return this.colFilter?.getFilterModel() ?? {};
  }
  isColumnFilterPresent() {
    return !!this.colFilter?.isColumnFilterPresent();
  }
  isAggregateFilterPresent() {
    return !!this.colFilter?.isAggregateFilterPresent();
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.externalFilterPresent || this.isAdvFilterPresent();
  }
  isAnyFilterPresent() {
    return this.isChildFilterPresent() || this.isAggregateFilterPresent();
  }
  isAdvFilterPresent() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
  }
  onAdvFilterEnabledChanged(enabled) {
    if (enabled) {
      if (this.colFilter?.disableColumnFilters()) {
        this.onFilterChanged({ source: "advancedFilter" });
      }
    } else {
      if (this.advancedFilter?.isFilterPresent()) {
        this.advancedFilter.setModel(null);
        this.onFilterChanged({ source: "advancedFilter" });
      }
    }
  }
  isAdvFilterEnabled() {
    return !!this.advancedFilter?.isEnabled();
  }
  isAdvFilterHeaderActive() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
  }
  resetQuickFilterCache() {
    this.quickFilter?.resetCache();
  }
  refreshFiltersForAggregations() {
    const isAggFiltering = _getGroupAggFiltering(this.gos);
    if (isAggFiltering) {
      this.onFilterChanged();
    }
  }
  onFilterChanged(params = {}) {
    const { source, additionalEventAttributes, columns = [] } = params;
    this.externalFilterPresent = this.isExternalFilterPresentCallback();
    (this.colFilter ? this.colFilter.updateBeforeFilterChanged(params) : AgPromise.resolve()).then(() => {
      const filterChangedEvent = {
        source,
        type: "filterChanged",
        columns
      };
      if (additionalEventAttributes) {
        _mergeDeep(filterChangedEvent, additionalEventAttributes);
      }
      this.eventSvc.dispatchEvent(filterChangedEvent);
      this.colFilter?.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !!this.colFilter?.isSuppressFlashingCellsBecauseFiltering();
  }
  isQuickFilterPresent() {
    return !!this.quickFilter?.isFilterPresent();
  }
  updateAggFiltering() {
    this.aggFiltering = !!_getGroupAggFiltering(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.beans.colModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(filterToSkip, node) {
    return this.doesRowPassFilter({ rowNode: node, filterInstanceToSkip: filterToSkip });
  }
  doesRowPassAggregateFilters(params) {
    const { rowNode } = params;
    if (this.alwaysPassFilter?.(rowNode)) {
      return true;
    }
    if (this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) {
      return false;
    }
    if (this.isAggregateFilterPresent() && !this.colFilter.doAggregateFiltersPass(rowNode, params.filterInstanceToSkip)) {
      return false;
    }
    return true;
  }
  doesRowPassFilter(params) {
    const { rowNode } = params;
    if (this.alwaysPassFilter?.(rowNode)) {
      return true;
    }
    if (this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) {
      return false;
    }
    if (this.externalFilterPresent && !this.doesExternalFilterPass(rowNode)) {
      return false;
    }
    if (this.isColumnFilterPresent() && !this.colFilter.doColumnFiltersPass(rowNode, params.filterInstanceToSkip)) {
      return false;
    }
    if (this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(rowNode)) {
      return false;
    }
    return true;
  }
  isFilterActive(column) {
    return !!this.colFilter?.isFilterActive(column);
  }
  getOrCreateFilterWrapper(column) {
    return this.colFilter?.getOrCreateFilterWrapper(column) ?? null;
  }
  getDefaultFloatingFilter(column) {
    return this.colFilter.getDefaultFloatingFilter(column);
  }
  createFilterParams(column, colDef) {
    return this.colFilter.createFilterParams(column, colDef);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(column) {
    if (this.isAdvFilterEnabled()) {
      return false;
    }
    return !!this.colFilter?.isFilterAllowed(column);
  }
  getFloatingFilterCompDetails(column, showParentFilter) {
    return this.colFilter?.getFloatingFilterCompDetails(column, showParentFilter);
  }
  getCurrentFloatingFilterParentModel(column) {
    return this.colFilter?.getCurrentFloatingFilterParentModel(column);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(column, source = "api") {
    this.colFilter?.destroyFilter(column, source);
  }
  areFilterCompsDifferent(oldCompDetails, newCompDetails) {
    return !!this.colFilter?.areFilterCompsDifferent(oldCompDetails, newCompDetails);
  }
  getAdvFilterModel() {
    return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
  }
  setAdvFilterModel(expression) {
    if (!this.isAdvFilterEnabled()) {
      return;
    }
    if (this.beans.dataTypeSvc?.isPendingInference) {
      this.advFilterModelUpdateQueue.push(expression);
      return;
    }
    this.advancedFilter.setModel(expression ?? null);
    this.onFilterChanged({ source: "advancedFilter" });
  }
  toggleAdvFilterBuilder(show, source) {
    if (!this.isAdvFilterEnabled()) {
      return;
    }
    this.advancedFilter.getCtrl().toggleFilterBuilder({ source, force: show });
  }
  updateAdvFilterColumns() {
    if (!this.isAdvFilterEnabled()) {
      return;
    }
    if (this.advancedFilter.updateValidity()) {
      this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  hasFloatingFilters() {
    if (this.isAdvFilterEnabled()) {
      return false;
    }
    return !!this.colFilter?.hasFloatingFilters();
  }
  getColumnFilterInstance(key) {
    if (this.isAdvFilterEnabled()) {
      this.warnAdvFilters();
      return Promise.resolve(void 0);
    }
    return this.colFilter?.getColumnFilterInstance(key) ?? Promise.resolve(void 0);
  }
  warnAdvFilters() {
    _warn(68);
  }
  setupAdvFilterHeaderComp(eCompToInsertBefore) {
    this.advancedFilter?.getCtrl().setupHeaderComp(eCompToInsertBefore);
  }
  getHeaderRowCount() {
    return this.isAdvFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advFilterModelUpdateQueue.forEach((model) => this.setAdvFilterModel(model));
    this.advFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(key) {
    return this.colFilter?.getColumnFilterModel(key);
  }
  setColumnFilterModel(key, model) {
    if (this.isAdvFilterEnabled()) {
      this.warnAdvFilters();
      return Promise.resolve();
    }
    return this.colFilter?.setColumnFilterModel(key, model) ?? Promise.resolve();
  }
  setColDefPropertiesForDataType(colDef, dataTypeDefinition, formatValue) {
    this.colFilter?.setColDefPropertiesForDataType(colDef, dataTypeDefinition, formatValue);
  }
};

// packages/ag-grid-community/src/filter/filterMenuFactory.ts
var FilterMenuFactory = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "filterMenuFactory";
  }
  wireBeans(beans) {
    this.popupSvc = beans.popupSvc;
  }
  hideActiveMenu() {
    this.hidePopup?.();
  }
  showMenuAfterMouseEvent(column, mouseEvent, containerType) {
    this.showPopup(
      column,
      (eMenu) => {
        this.popupSvc?.positionPopupUnderMouseEvent({
          column,
          type: containerType,
          mouseEvent,
          ePopup: eMenu
        });
      },
      containerType,
      mouseEvent.target,
      _isLegacyMenuEnabled(this.gos)
    );
  }
  showMenuAfterButtonClick(column, eventSource, containerType) {
    let multiplier = -1;
    let alignSide = "left";
    const isLegacyMenuEnabled = _isLegacyMenuEnabled(this.gos);
    if (!isLegacyMenuEnabled && this.gos.get("enableRtl")) {
      multiplier = 1;
      alignSide = "right";
    }
    const nudgeX = isLegacyMenuEnabled ? void 0 : 4 * multiplier;
    const nudgeY = isLegacyMenuEnabled ? void 0 : 4;
    this.showPopup(
      column,
      (eMenu) => {
        this.popupSvc?.positionPopupByComponent({
          type: containerType,
          eventSource,
          ePopup: eMenu,
          nudgeX,
          nudgeY,
          alignSide,
          keepWithinBounds: true,
          position: "under",
          column
        });
      },
      containerType,
      eventSource,
      isLegacyMenuEnabled
    );
  }
  showPopup(column, positionCallback, containerType, eventSource, isLegacyMenuEnabled) {
    const comp = column ? this.createBean(new FilterWrapperComp(column, "COLUMN_MENU")) : void 0;
    this.activeMenu = comp;
    if (!comp?.hasFilter() || !column) {
      _error(57);
      return;
    }
    const eMenu = document.createElement("div");
    _setAriaRole(eMenu, "presentation");
    eMenu.classList.add("ag-menu");
    if (!isLegacyMenuEnabled) {
      eMenu.classList.add("ag-filter-menu");
    }
    [this.tabListener] = this.addManagedElementListeners(eMenu, {
      keydown: (e) => this.trapFocusWithin(e, eMenu)
    });
    eMenu.appendChild(comp?.getGui());
    let hidePopup;
    const afterGuiDetached = () => comp?.afterGuiDetached();
    const anchorToElement = _isColumnMenuAnchoringEnabled(this.gos) ? eventSource ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody : void 0;
    const closedCallback = (e) => {
      _setColMenuVisible(column, false, "contextMenu");
      const isKeyboardEvent = e instanceof KeyboardEvent;
      if (this.tabListener) {
        this.tabListener = this.tabListener();
      }
      if (isKeyboardEvent && eventSource && _isVisible(eventSource)) {
        const focusableEl = _findTabbableParent(eventSource);
        focusableEl?.focus({ preventScroll: true });
      }
      afterGuiDetached();
      this.destroyBean(this.activeMenu);
      this.dispatchVisibleChangedEvent(false, containerType, column);
    };
    const translate = this.getLocaleTextFunc();
    const ariaLabel = isLegacyMenuEnabled && containerType !== "columnFilter" ? translate("ariaLabelColumnMenu", "Column Menu") : translate("ariaLabelColumnFilter", "Column Filter");
    const addPopupRes = this.popupSvc?.addPopup({
      modal: true,
      eChild: eMenu,
      closeOnEsc: true,
      closedCallback,
      positionCallback: () => positionCallback(eMenu),
      anchorToElement,
      ariaLabel
    });
    if (addPopupRes) {
      this.hidePopup = hidePopup = addPopupRes.hideFunc;
    }
    comp.afterInit().then(() => {
      positionCallback(eMenu);
      comp.afterGuiAttached({ container: containerType, hidePopup });
    });
    _setColMenuVisible(column, true, "contextMenu");
    this.dispatchVisibleChangedEvent(true, containerType, column);
  }
  trapFocusWithin(e, menu) {
    if (e.key !== KeyCode.TAB || e.defaultPrevented || _findNextFocusableElement(this.beans, menu, false, e.shiftKey)) {
      return;
    }
    e.preventDefault();
    _focusInto(menu, e.shiftKey);
  }
  dispatchVisibleChangedEvent(visible, containerType, column) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible,
      switchingTab: false,
      key: containerType,
      column: column ?? null,
      columnGroup: null
    });
  }
  isMenuEnabled(column) {
    return column.isFilterAllowed() && (column.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu);
    super.destroy();
  }
};

// packages/ag-grid-community/src/filter/filterValueService.ts
var FilterValueService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "filterValueSvc";
  }
  getValue(column, rowNode) {
    if (!rowNode) {
      return;
    }
    const colDef = column.getColDef();
    const { filterValueGetter } = colDef;
    if (filterValueGetter) {
      return this.executeFilterValueGetter(filterValueGetter, rowNode.data, column, rowNode, colDef);
    }
    return this.beans.valueSvc.getValue(column, rowNode);
  }
  executeFilterValueGetter(valueGetter, data, column, node, colDef) {
    const { expressionSvc, valueSvc } = this.beans;
    const params = this.gos.addGridCommonParams({
      data,
      node,
      column,
      colDef,
      getValue: valueSvc.getValueCallback.bind(valueSvc, node)
    });
    if (typeof valueGetter === "function") {
      return valueGetter(params);
    }
    return expressionSvc?.evaluate(valueGetter, params);
  }
};

// packages/ag-grid-community/src/filter/floating/provided/readOnlyFloatingFilter.ts
var ReadOnlyFloatingFilter = class extends Component {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [AgInputTextFieldSelector]
    );
    this.eFloatingFilterText = RefPlaceholder;
  }
  init(params) {
    this.params = params;
    const displayName = this.beans.colNames.getDisplayNameForColumn(params.column, "header", true);
    this.eFloatingFilterText.setDisabled(true).setInputAriaLabel(`${displayName} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(parentModel) {
    if (parentModel == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((filterInstance) => {
      if (filterInstance.getModelAsString) {
        const modelAsString = filterInstance.getModelAsString(parentModel);
        this.eFloatingFilterText.setValue(modelAsString);
      }
    });
  }
  refresh(params) {
    this.init(params);
  }
};

// packages/ag-grid-community/src/filter/provided/optionsFactory.ts
var OptionsFactory = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(params, defaultOptions) {
    this.filterOptions = params.filterOptions || defaultOptions;
    this.mapCustomOptions();
    this.selectDefaultItem(params);
  }
  mapCustomOptions() {
    const { filterOptions } = this;
    if (!filterOptions) {
      return;
    }
    filterOptions.forEach((filterOption) => {
      if (typeof filterOption === "string") {
        return;
      }
      const requiredProperties = [["displayKey"], ["displayName"], ["predicate", "test"]];
      const propertyCheck = (keys) => {
        if (!keys.some((key) => filterOption[key] != null)) {
          _warn(72, { keys });
          return false;
        }
        return true;
      };
      if (!requiredProperties.every(propertyCheck)) {
        this.filterOptions = filterOptions.filter((v) => v === filterOption) || [];
        return;
      }
      this.customFilterOptions[filterOption.displayKey] = filterOption;
    });
  }
  selectDefaultItem(params) {
    const { filterOptions } = this;
    if (params.defaultOption) {
      this.defaultOption = params.defaultOption;
    } else if (filterOptions.length >= 1) {
      const firstFilterOption = filterOptions[0];
      if (typeof firstFilterOption === "string") {
        this.defaultOption = firstFilterOption;
      } else if (firstFilterOption.displayKey) {
        this.defaultOption = firstFilterOption.displayKey;
      } else {
        _warn(73);
      }
    } else {
      _warn(74);
    }
  }
  getCustomOption(name) {
    return this.customFilterOptions[name];
  }
};

// packages/ag-grid-community/src/filter/provided/simpleFilterUtils.ts
function removeItems(items, startPosition, deleteCount) {
  return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
}
function isBlank(cellValue) {
  return cellValue == null || typeof cellValue === "string" && cellValue.trim().length === 0;
}
function getDefaultJoinOperator(defaultJoinOperator) {
  return defaultJoinOperator === "AND" || defaultJoinOperator === "OR" ? defaultJoinOperator : "AND";
}
function evaluateCustomFilter(customFilterOption, values, cellValue) {
  if (customFilterOption == null) {
    return;
  }
  const { predicate } = customFilterOption;
  if (predicate != null && !values.some((v) => v == null)) {
    return predicate(values, cellValue);
  }
  return;
}
function validateAndUpdateConditions(conditions, maxNumConditions) {
  let numConditions = conditions.length;
  if (numConditions > maxNumConditions) {
    conditions.splice(maxNumConditions);
    _warn(78);
    numConditions = maxNumConditions;
  }
  return numConditions;
}

// packages/ag-grid-community/src/filter/provided/simpleFilter.ts
var SimpleFilter = class extends ProvidedFilter {
  constructor() {
    super(...arguments);
    this.eTypes = [];
    this.eJoinOperatorPanels = [];
    this.eJoinOperatorsAnd = [];
    this.eJoinOperatorsOr = [];
    this.eConditionBodies = [];
    this.listener = () => this.onUiChanged();
    this.lastUiCompletePosition = null;
    this.joinOperatorId = 0;
  }
  getNumberOfInputs(type) {
    const customOpts = this.optionsFactory.getCustomOption(type);
    if (customOpts) {
      const { numberOfInputs } = customOpts;
      return numberOfInputs != null ? numberOfInputs : 1;
    }
    const zeroInputTypes = ["empty", "notBlank", "blank"];
    if (type && zeroInputTypes.indexOf(type) >= 0) {
      return 0;
    } else if (type === "inRange") {
      return 2;
    }
    return 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(type, value) {
    this.setTypeFromFloatingFilter(type);
    this.setValueFromFloatingFilter(value);
    this.onUiChanged(true);
  }
  setTypeFromFloatingFilter(type) {
    this.eTypes.forEach((eType, position) => {
      const value = position === 0 ? type : this.optionsFactory.defaultOption;
      eType.setValue(value, true);
    });
  }
  getModelFromUi() {
    const conditions = this.getUiCompleteConditions();
    if (conditions.length === 0) {
      return null;
    }
    if (this.maxNumConditions > 1 && conditions.length > 1) {
      return {
        filterType: this.filterType,
        operator: this.getJoinOperator(),
        conditions
      };
    }
    return conditions[0];
  }
  getConditionTypes() {
    return this.eTypes.map((eType) => eType.getValue());
  }
  getConditionType(position) {
    return this.eTypes[position].getValue();
  }
  getJoinOperator() {
    const { eJoinOperatorsOr, defaultJoinOperator } = this;
    return eJoinOperatorsOr.length === 0 ? defaultJoinOperator : eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
  }
  areModelsEqual(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a && b || a && !b) {
      return false;
    }
    const aIsSimple = !a.operator;
    const bIsSimple = !b.operator;
    const oneSimpleOneCombined = !aIsSimple && bIsSimple || aIsSimple && !bIsSimple;
    if (oneSimpleOneCombined) {
      return false;
    }
    let res;
    if (aIsSimple) {
      const aSimple = a;
      const bSimple = b;
      res = this.areSimpleModelsEqual(aSimple, bSimple);
    } else {
      const aCombined = a;
      const bCombined = b;
      res = aCombined.operator === bCombined.operator && _areEqual(
        aCombined.conditions,
        bCombined.conditions,
        (aModel, bModel) => this.areSimpleModelsEqual(aModel, bModel)
      );
    }
    return res;
  }
  shouldRefresh(newParams) {
    const model = this.getModel();
    const conditions = model ? model.conditions ?? [model] : null;
    const newOptionsList = newParams.filterOptions?.map((option) => typeof option === "string" ? option : option.displayKey) ?? this.getDefaultFilterOptions();
    const allConditionsExistInNewOptionsList = !conditions || conditions.every((condition) => newOptionsList.find((option) => option === condition.type) !== void 0);
    if (!allConditionsExistInNewOptionsList) {
      return false;
    }
    if (typeof newParams.maxNumConditions === "number" && conditions && conditions.length > newParams.maxNumConditions) {
      return false;
    }
    return true;
  }
  refresh(newParams) {
    if (!this.shouldRefresh(newParams)) {
      return false;
    }
    const parentRefreshed = super.refresh(newParams);
    if (!parentRefreshed) {
      return false;
    }
    this.setParams(newParams);
    this.removeConditionsAndOperators(0);
    this.createOption();
    this.setModel(this.getModel());
    return true;
  }
  setModelIntoUi(model) {
    const isCombined = model.operator;
    if (isCombined) {
      const combinedModel = model;
      let conditions = combinedModel.conditions;
      if (conditions == null) {
        conditions = [];
        _warn(77);
      }
      const numConditions = validateAndUpdateConditions(conditions, this.maxNumConditions);
      const numPrevConditions = this.getNumConditions();
      if (numConditions < numPrevConditions) {
        this.removeConditionsAndOperators(numConditions);
      } else if (numConditions > numPrevConditions) {
        for (let i = numPrevConditions; i < numConditions; i++) {
          this.createJoinOperatorPanel();
          this.createOption();
        }
      }
      const orChecked = combinedModel.operator === "OR";
      this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd) => eJoinOperatorAnd.setValue(!orChecked, true));
      this.eJoinOperatorsOr.forEach((eJoinOperatorOr) => eJoinOperatorOr.setValue(orChecked, true));
      conditions.forEach((condition, position) => {
        this.eTypes[position].setValue(condition.type, true);
        this.setConditionIntoUi(condition, position);
      });
    } else {
      const simpleModel = model;
      if (this.getNumConditions() > 1) {
        this.removeConditionsAndOperators(1);
      }
      this.eTypes[0].setValue(simpleModel.type, true);
      this.setConditionIntoUi(simpleModel, 0);
    }
    this.lastUiCompletePosition = this.getNumConditions() - 1;
    this.createMissingConditionsAndOperators();
    this.onUiChanged();
    return AgPromise.resolve();
  }
  doesFilterPass(params) {
    const model = this.getModel();
    if (model == null) {
      return true;
    }
    const { operator } = model;
    const models = [];
    if (operator) {
      const combinedModel = model;
      models.push(...combinedModel.conditions ?? []);
    } else {
      models.push(model);
    }
    const combineFunction = operator && operator === "OR" ? "some" : "every";
    return models[combineFunction]((m) => this.individualConditionPasses(params, m));
  }
  setParams(params) {
    super.setParams(params);
    this.setNumConditions(params);
    this.defaultJoinOperator = getDefaultJoinOperator(params.defaultJoinOperator);
    this.filterPlaceholder = params.filterPlaceholder;
    this.optionsFactory = new OptionsFactory();
    this.optionsFactory.init(params, this.getDefaultFilterOptions());
    this.createFilterListOptions();
    this.createOption();
    this.createMissingConditionsAndOperators();
    if (this.isReadOnly()) {
      this.eFilterBody.setAttribute("tabindex", "-1");
    }
  }
  setNumConditions(params) {
    let maxNumConditions = params.maxNumConditions ?? 2;
    if (maxNumConditions < 1) {
      _warn(79);
      maxNumConditions = 1;
    }
    this.maxNumConditions = maxNumConditions;
    let numAlwaysVisibleConditions = params.numAlwaysVisibleConditions ?? 1;
    if (numAlwaysVisibleConditions < 1) {
      _warn(80);
      numAlwaysVisibleConditions = 1;
    }
    if (numAlwaysVisibleConditions > maxNumConditions) {
      _warn(81);
      numAlwaysVisibleConditions = maxNumConditions;
    }
    this.numAlwaysVisibleConditions = numAlwaysVisibleConditions;
  }
  createOption() {
    const eType = this.createManagedBean(new AgSelect());
    this.eTypes.push(eType);
    eType.addCssClass("ag-filter-select");
    this.eFilterBody.appendChild(eType.getGui());
    const eConditionBody = this.createValueElement();
    this.eConditionBodies.push(eConditionBody);
    this.eFilterBody.appendChild(eConditionBody);
    this.putOptionsIntoDropdown(eType);
    this.resetType(eType);
    const position = this.getNumConditions() - 1;
    this.forEachPositionInput(position, (element) => this.resetInput(element));
    this.addChangedListeners(eType, position);
  }
  createJoinOperatorPanel() {
    const eJoinOperatorPanel = document.createElement("div");
    this.eJoinOperatorPanels.push(eJoinOperatorPanel);
    eJoinOperatorPanel.classList.add("ag-filter-condition");
    const eJoinOperatorAnd = this.createJoinOperator(this.eJoinOperatorsAnd, eJoinOperatorPanel, "and");
    const eJoinOperatorOr = this.createJoinOperator(this.eJoinOperatorsOr, eJoinOperatorPanel, "or");
    this.eFilterBody.appendChild(eJoinOperatorPanel);
    const index = this.eJoinOperatorPanels.length - 1;
    const uniqueGroupId = this.joinOperatorId++;
    this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
    this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
    if (!this.isReadOnly()) {
      eJoinOperatorAnd.onValueChange(this.listener);
      eJoinOperatorOr.onValueChange(this.listener);
    }
  }
  createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
    const eJoinOperator = this.createManagedBean(new AgRadioButton());
    eJoinOperators.push(eJoinOperator);
    const baseClass = "ag-filter-condition-operator";
    eJoinOperator.addCssClass(baseClass);
    eJoinOperator.addCssClass(`${baseClass}-${andOr}`);
    eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
    return eJoinOperator;
  }
  createFilterListOptions() {
    this.filterListOptions = this.optionsFactory.filterOptions.map(
      (option) => typeof option === "string" ? this.createBoilerplateListOption(option) : this.createCustomListOption(option)
    );
  }
  putOptionsIntoDropdown(eType) {
    const { filterListOptions } = this;
    filterListOptions.forEach((listOption) => {
      eType.addOption(listOption);
    });
    eType.setDisabled(filterListOptions.length <= 1);
  }
  createBoilerplateListOption(option) {
    return { value: option, text: this.translate(option) };
  }
  createCustomListOption(option) {
    const { displayKey } = option;
    const customOption = this.optionsFactory.getCustomOption(option.displayKey);
    return {
      value: displayKey,
      text: customOption ? this.getLocaleTextFunc()(customOption.displayKey, customOption.displayName) : this.translate(displayKey)
    };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const joinOperator = this.getJoinOperator();
    this.updateNumConditions();
    this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
  }
  updateNumConditions() {
    let lastUiCompletePosition = -1;
    let areAllConditionsUiComplete = true;
    for (let position = 0; position < this.getNumConditions(); position++) {
      if (this.isConditionUiComplete(position)) {
        lastUiCompletePosition = position;
      } else {
        areAllConditionsUiComplete = false;
      }
    }
    if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
      this.createJoinOperatorPanel();
      this.createOption();
    } else {
      const activePosition = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (lastUiCompletePosition < activePosition) {
        this.removeConditionsAndOperators(activePosition + 1);
        const removeStartPosition = lastUiCompletePosition + 1;
        const numConditionsToRemove = activePosition - removeStartPosition;
        if (numConditionsToRemove > 0) {
          this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
        }
        this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = lastUiCompletePosition;
  }
  updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
    this.eTypes.forEach((eType, position) => {
      const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
      eType.setDisabled(disabled || this.filterListOptions.length <= 1);
      if (position === 1) {
        _setDisabled(this.eJoinOperatorPanels[0], disabled);
        this.eJoinOperatorsAnd[0].setDisabled(disabled);
        this.eJoinOperatorsOr[0].setDisabled(disabled);
      }
    });
    this.eConditionBodies.forEach((element, index) => {
      _setDisplayed(element, this.isConditionBodyVisible(index));
    });
    const orChecked = (joinOperator ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd) => {
      eJoinOperatorAnd.setValue(!orChecked, true);
    });
    this.eJoinOperatorsOr.forEach((eJoinOperatorOr) => {
      eJoinOperatorOr.setValue(orChecked, true);
    });
    this.forEachInput((element, index, position, numberOfInputs) => {
      this.setElementDisplayed(element, index < numberOfInputs);
      this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
    });
    this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
    return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(startPosition, deleteCount) {
    if (startPosition >= this.getNumConditions()) {
      return;
    }
    const { eTypes, eConditionBodies, eJoinOperatorPanels, eJoinOperatorsAnd, eJoinOperatorsOr } = this;
    this.removeComponents(eTypes, startPosition, deleteCount);
    this.removeElements(eConditionBodies, startPosition, deleteCount);
    this.removeValueElements(startPosition, deleteCount);
    const joinOperatorIndex = Math.max(startPosition - 1, 0);
    this.removeElements(eJoinOperatorPanels, joinOperatorIndex, deleteCount);
    this.removeComponents(eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
    this.removeComponents(eJoinOperatorsOr, joinOperatorIndex, deleteCount);
  }
  removeElements(elements, startPosition, deleteCount) {
    const removedElements = removeItems(elements, startPosition, deleteCount);
    removedElements.forEach((element) => _removeFromParent(element));
  }
  removeComponents(components, startPosition, deleteCount) {
    const removedComponents = removeItems(components, startPosition, deleteCount);
    removedComponents.forEach((comp) => {
      _removeFromParent(comp.getGui());
      this.destroyBean(comp);
    });
  }
  afterGuiAttached(params) {
    super.afterGuiAttached(params);
    this.resetPlaceholder();
    if (!params?.suppressFocus) {
      const { eFilterBody, eTypes } = this;
      let elementToFocus;
      if (!this.isReadOnly()) {
        const firstInput = this.getInputs(0)[0];
        if (firstInput instanceof AgAbstractInputField && this.isConditionBodyVisible(0)) {
          elementToFocus = firstInput.getInputElement();
        } else {
          elementToFocus = eTypes[0]?.getFocusableElement();
        }
      }
      (elementToFocus ?? eFilterBody).focus({ preventScroll: true });
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const appliedModel = this.getModel();
    this.resetUiToActiveModel(appliedModel);
    let lastUiCompletePosition = -1;
    let updatedLastUiCompletePosition = -1;
    let conditionsRemoved = false;
    const joinOperator = this.getJoinOperator();
    for (let position = this.getNumConditions() - 1; position >= 0; position--) {
      if (this.isConditionUiComplete(position)) {
        if (lastUiCompletePosition === -1) {
          lastUiCompletePosition = position;
          updatedLastUiCompletePosition = position;
        }
      } else {
        const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
        const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
        if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
          this.removeConditionsAndOperators(position, 1);
          conditionsRemoved = true;
          if (positionBeforeLastUiCompletePosition) {
            updatedLastUiCompletePosition--;
          }
        }
      }
    }
    let shouldUpdateConditionStatusesAndValues = false;
    if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
      this.createMissingConditionsAndOperators();
      shouldUpdateConditionStatusesAndValues = true;
    }
    if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
      this.createJoinOperatorPanel();
      this.createOption();
      shouldUpdateConditionStatusesAndValues = true;
    }
    if (shouldUpdateConditionStatusesAndValues) {
      this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
    }
    if (conditionsRemoved) {
      this.updateJoinOperatorsDisabled();
    }
    this.lastUiCompletePosition = updatedLastUiCompletePosition;
  }
  getPlaceholderText(defaultPlaceholder, position) {
    let placeholder = this.translate(defaultPlaceholder);
    if (typeof this.filterPlaceholder === "function") {
      const filterOptionKey = this.eTypes[position].getValue();
      const filterOption = this.translate(filterOptionKey);
      placeholder = this.filterPlaceholder({
        filterOptionKey,
        filterOption,
        placeholder
      });
    } else if (typeof this.filterPlaceholder === "string") {
      placeholder = this.filterPlaceholder;
    }
    return placeholder;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const globalTranslate = this.getLocaleTextFunc();
    this.forEachInput((element, index, position, numberOfInputs) => {
      if (!(element instanceof AgAbstractInputField)) {
        return;
      }
      const placeholder = index === 0 && numberOfInputs > 1 ? "inRangeStart" : index === 0 ? "filterOoo" : "inRangeEnd";
      const ariaLabel = index === 0 && numberOfInputs > 1 ? globalTranslate("ariaFilterFromValue", "Filter from value") : index === 0 ? globalTranslate("ariaFilterValue", "Filter Value") : globalTranslate("ariaFilterToValue", "Filter to Value");
      element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
      element.setInputAriaLabel(ariaLabel);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(element, value, fromFloatingFilter) {
    if (element instanceof AgAbstractInputField) {
      element.setValue(value != null ? String(value) : null, true);
    }
  }
  setElementDisplayed(element, displayed) {
    if (element instanceof Component) {
      _setDisplayed(element.getGui(), displayed);
    }
  }
  setElementDisabled(element, disabled) {
    if (element instanceof Component) {
      _setDisabled(element.getGui(), disabled);
    }
  }
  attachElementOnChange(element, listener) {
    if (element instanceof AgAbstractInputField) {
      element.onValueChange(listener);
    }
  }
  forEachInput(cb) {
    this.getConditionTypes().forEach((type, position) => {
      this.forEachPositionTypeInput(position, type, cb);
    });
  }
  forEachPositionInput(position, cb) {
    const type = this.getConditionType(position);
    this.forEachPositionTypeInput(position, type, cb);
  }
  forEachPositionTypeInput(position, type, cb) {
    const numberOfInputs = this.getNumberOfInputs(type);
    const inputs = this.getInputs(position);
    for (let index = 0; index < inputs.length; index++) {
      const input = inputs[index];
      if (input != null) {
        cb(input, index, position, numberOfInputs);
      }
    }
  }
  isConditionDisabled(position, lastUiCompletePosition) {
    if (this.isReadOnly()) {
      return true;
    }
    if (position === 0) {
      return false;
    }
    return position > lastUiCompletePosition + 1;
  }
  isConditionBodyVisible(position) {
    const type = this.getConditionType(position);
    const numberOfInputs = this.getNumberOfInputs(type);
    return numberOfInputs > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(position) {
    if (position >= this.getNumConditions()) {
      return false;
    }
    const type = this.getConditionType(position);
    if (type === "empty") {
      return false;
    }
    if (this.getValues(position).some((v) => v == null)) {
      return false;
    }
    return true;
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const conditions = [];
    for (let position = 0; position < this.getNumConditions(); position++) {
      if (this.isConditionUiComplete(position)) {
        conditions.push(this.createCondition(position));
      }
    }
    return conditions;
  }
  createMissingConditionsAndOperators() {
    if (this.isReadOnly()) {
      return;
    }
    for (let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++) {
      this.createJoinOperatorPanel();
      this.createOption();
    }
  }
  resetUiToDefaults(silent) {
    this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
    this.eTypes.forEach((eType) => this.resetType(eType));
    this.eJoinOperatorsAnd.forEach(
      (eJoinOperatorAnd, index) => this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index)
    );
    this.eJoinOperatorsOr.forEach(
      (eJoinOperatorOr, index) => this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index)
    );
    this.joinOperatorId++;
    this.forEachInput((element) => this.resetInput(element));
    this.resetPlaceholder();
    this.createMissingConditionsAndOperators();
    this.lastUiCompletePosition = null;
    if (!silent) {
      this.onUiChanged();
    }
    return AgPromise.resolve();
  }
  resetType(eType) {
    const translate = this.getLocaleTextFunc();
    const filteringLabel = translate("ariaFilteringOperator", "Filtering operator");
    eType.setValue(this.optionsFactory.defaultOption, true).setAriaLabel(filteringLabel).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
    this.resetJoinOperator(
      eJoinOperatorAnd,
      index,
      this.defaultJoinOperator === "AND",
      this.translate("andCondition"),
      uniqueGroupId
    );
  }
  resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
    this.resetJoinOperator(
      eJoinOperatorOr,
      index,
      this.defaultJoinOperator === "OR",
      this.translate("orCondition"),
      uniqueGroupId
    );
  }
  resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
    this.updateJoinOperatorDisabled(
      eJoinOperator.setValue(value, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`).setLabel(label),
      index
    );
  }
  updateJoinOperatorsDisabled() {
    const updater = (eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index);
    this.eJoinOperatorsAnd.forEach(updater);
    this.eJoinOperatorsOr.forEach(updater);
  }
  updateJoinOperatorDisabled(eJoinOperator, index) {
    eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
  }
  resetInput(element) {
    this.setElementValue(element, null);
    this.setElementDisabled(element, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(model, position) {
    const values = this.mapValuesFromModel(model);
    this.forEachInput((element, index, elPosition) => {
      if (elPosition !== position) {
        return;
      }
      this.setElementValue(element, values[index] != null ? values[index] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(value) {
    this.forEachInput((element, index, position) => {
      this.setElementValue(element, index === 0 && position === 0 ? value : null, true);
    });
  }
  addChangedListeners(eType, position) {
    if (this.isReadOnly()) {
      return;
    }
    eType.onValueChange(this.listener);
    this.forEachPositionInput(position, (element) => {
      this.attachElementOnChange(element, this.listener);
    });
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(params, filterModel) {
    const cellValue = this.getCellValue(params.node);
    const values = this.mapValuesFromModel(filterModel);
    const customFilterOption = this.optionsFactory.getCustomOption(filterModel.type);
    const customFilterResult = evaluateCustomFilter(customFilterOption, values, cellValue);
    if (customFilterResult != null) {
      return customFilterResult;
    }
    if (cellValue == null) {
      return this.evaluateNullValue(filterModel.type);
    }
    return this.evaluateNonNullValue(values, cellValue, filterModel, params);
  }
  hasInvalidInputs() {
    return false;
  }
};

// packages/ag-grid-community/src/filter/provided/scalarFilter.ts
var ScalarFilter = class extends SimpleFilter {
  setParams(params) {
    super.setParams(params);
    this.scalarFilterParams = params;
  }
  evaluateNullValue(filterType) {
    const {
      includeBlanksInEquals,
      includeBlanksInNotEqual,
      includeBlanksInGreaterThan,
      includeBlanksInLessThan,
      includeBlanksInRange
    } = this.scalarFilterParams;
    switch (filterType) {
      case "equals":
        if (includeBlanksInEquals) {
          return true;
        }
        break;
      case "notEqual":
        if (includeBlanksInNotEqual) {
          return true;
        }
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (includeBlanksInGreaterThan) {
          return true;
        }
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (includeBlanksInLessThan) {
          return true;
        }
        break;
      case "inRange":
        if (includeBlanksInRange) {
          return true;
        }
        break;
      case "blank":
        return true;
      case "notBlank":
        return false;
    }
    return false;
  }
  evaluateNonNullValue(values, cellValue, filterModel) {
    const comparator = this.comparator();
    const compareResult = values[0] != null ? comparator(values[0], cellValue) : 0;
    switch (filterModel.type) {
      case "equals":
        return compareResult === 0;
      case "notEqual":
        return compareResult !== 0;
      case "greaterThan":
        return compareResult > 0;
      case "greaterThanOrEqual":
        return compareResult >= 0;
      case "lessThan":
        return compareResult < 0;
      case "lessThanOrEqual":
        return compareResult <= 0;
      case "inRange": {
        const compareToResult = comparator(values[1], cellValue);
        return this.scalarFilterParams.inRangeInclusive ? compareResult >= 0 && compareToResult <= 0 : compareResult > 0 && compareToResult < 0;
      }
      case "blank":
        return isBlank(cellValue);
      case "notBlank":
        return !isBlank(cellValue);
      default:
        _warn(76, { filterModelType: filterModel.type });
        return true;
    }
  }
};

// packages/ag-grid-community/src/filter/provided/date/dateCompWrapper.ts
var DateCompWrapper = class {
  constructor(context, userCompFactory, dateComponentParams, eParent, onReady) {
    this.alive = true;
    this.context = context;
    this.eParent = eParent;
    const compDetails = _getDateCompDetails(userCompFactory, dateComponentParams);
    if (!compDetails) {
      return;
    }
    compDetails.newAgStackInstance().then((dateComp) => {
      if (!this.alive) {
        context.destroyBean(dateComp);
        return;
      }
      this.dateComp = dateComp;
      if (!dateComp) {
        return;
      }
      eParent.appendChild(dateComp.getGui());
      dateComp?.afterGuiAttached?.();
      const { tempValue, disabled } = this;
      if (tempValue) {
        dateComp.setDate(tempValue);
      }
      if (disabled != null) {
        dateComp.setDisabled?.(disabled);
      }
      onReady?.(this);
    });
  }
  destroy() {
    this.alive = false;
    this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(value) {
    const dateComp = this.dateComp;
    if (dateComp) {
      dateComp.setDate(value);
    } else {
      this.tempValue = value;
    }
  }
  setDisabled(disabled) {
    const dateComp = this.dateComp;
    if (dateComp) {
      dateComp.setDisabled?.(disabled);
    } else {
      this.disabled = disabled;
    }
  }
  setDisplayed(displayed) {
    _setDisplayed(this.eParent, displayed);
  }
  setInputPlaceholder(placeholder) {
    this.dateComp?.setInputPlaceholder?.(placeholder);
  }
  setInputAriaLabel(label) {
    this.dateComp?.setInputAriaLabel?.(label);
  }
  afterGuiAttached(params) {
    this.dateComp?.afterGuiAttached?.(params);
  }
  updateParams(params) {
    this.dateComp?.refresh?.(params);
  }
};

// packages/ag-grid-community/src/filter/provided/date/dateFilterConstants.ts
var DEFAULT_DATE_FILTER_OPTIONS = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
];

// packages/ag-grid-community/src/filter/provided/simpleFilterModelFormatter.ts
var SimpleFilterModelFormatter = class {
  constructor(getLocaleTextFunc, optionsFactory, valueFormatter) {
    this.getLocaleTextFunc = getLocaleTextFunc;
    this.optionsFactory = optionsFactory;
    this.valueFormatter = valueFormatter;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(model) {
    if (!model) {
      return null;
    }
    const isCombined = model.operator != null;
    const translate = this.getLocaleTextFunc();
    if (isCombined) {
      const combinedModel = model;
      const conditions = combinedModel.conditions ?? [];
      const customOptions = conditions.map((condition) => this.getModelAsString(condition));
      const joinOperatorTranslateKey = combinedModel.operator === "AND" ? "andCondition" : "orCondition";
      return customOptions.join(
        ` ${translate(joinOperatorTranslateKey, FILTER_LOCALE_TEXT[joinOperatorTranslateKey])} `
      );
    } else if (model.type === "blank" || model.type === "notBlank") {
      return translate(model.type, model.type);
    } else {
      const condition = model;
      const customOption = this.optionsFactory.getCustomOption(condition.type);
      const { displayKey, displayName, numberOfInputs } = customOption || {};
      if (displayKey && displayName && numberOfInputs === 0) {
        translate(displayKey, displayName);
        return displayName;
      }
      return this.conditionToString(condition, customOption);
    }
  }
  updateParams(params) {
    this.optionsFactory = params.optionsFactory;
  }
  formatValue(value) {
    const valueFormatter = this.valueFormatter;
    return valueFormatter ? valueFormatter(value ?? null) ?? "" : String(value);
  }
};

// packages/ag-grid-community/src/filter/provided/date/dateFilterModelFormatter.ts
var DateFilterModelFormatter = class extends SimpleFilterModelFormatter {
  constructor(dateFilterParams, getLocaleTextFunc, optionsFactory) {
    super(getLocaleTextFunc, optionsFactory);
    this.dateFilterParams = dateFilterParams;
  }
  conditionToString(condition, options) {
    const { type } = condition;
    const { numberOfInputs } = options || {};
    const isRange = type == "inRange" || numberOfInputs === 2;
    const dateFrom = _parseDateTimeFromString(condition.dateFrom);
    const dateTo = _parseDateTimeFromString(condition.dateTo);
    const format = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (isRange) {
      const formattedFrom = dateFrom !== null ? _dateToFormattedString(dateFrom, format) : "null";
      const formattedTo = dateTo !== null ? _dateToFormattedString(dateTo, format) : "null";
      return `${formattedFrom}-${formattedTo}`;
    }
    if (dateFrom != null) {
      return _dateToFormattedString(dateFrom, format);
    }
    return `${type}`;
  }
  updateParams(params) {
    super.updateParams(params);
    this.dateFilterParams = params.dateFilterParams;
  }
};

// packages/ag-grid-community/src/filter/provided/date/dateFilter.ts
var DEFAULT_MIN_YEAR = 1e3;
var DEFAULT_MAX_YEAR = Infinity;
var DateFilter = class extends ScalarFilter {
  constructor() {
    super("dateFilter");
    this.eConditionPanelsFrom = [];
    this.eConditionPanelsTo = [];
    this.dateConditionFromComps = [];
    this.dateConditionToComps = [];
    this.minValidYear = DEFAULT_MIN_YEAR;
    this.maxValidYear = DEFAULT_MAX_YEAR;
    this.minValidDate = null;
    this.maxValidDate = null;
    this.filterType = "date";
  }
  afterGuiAttached(params) {
    super.afterGuiAttached(params);
    this.dateConditionFromComps[0].afterGuiAttached(params);
  }
  mapValuesFromModel(filterModel) {
    const { dateFrom, dateTo, type } = filterModel || {};
    return [
      dateFrom && _parseDateTimeFromString(dateFrom) || null,
      dateTo && _parseDateTimeFromString(dateTo) || null
    ].slice(0, this.getNumberOfInputs(type));
  }
  comparator() {
    return this.dateFilterParams.comparator ?? defaultDateComparator;
  }
  setParams(params) {
    this.dateFilterParams = params;
    super.setParams(params);
    const yearParser = (param, fallback) => {
      if (params[param] != null) {
        if (!isNaN(params[param])) {
          return params[param] == null ? fallback : Number(params[param]);
        } else {
          _warn(82, { param });
        }
      }
      return fallback;
    };
    this.minValidYear = yearParser("minValidYear", DEFAULT_MIN_YEAR);
    this.maxValidYear = yearParser("maxValidYear", DEFAULT_MAX_YEAR);
    if (this.minValidYear > this.maxValidYear) {
      _warn(83);
    }
    this.minValidDate = params.minValidDate ? params.minValidDate instanceof Date ? params.minValidDate : _parseDateTimeFromString(params.minValidDate) : null;
    this.maxValidDate = params.maxValidDate ? params.maxValidDate instanceof Date ? params.maxValidDate : _parseDateTimeFromString(params.maxValidDate) : null;
    if (this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate) {
      _warn(84);
    }
    this.filterModelFormatter = new DateFilterModelFormatter(
      this.dateFilterParams,
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  createDateCompWrapper(element) {
    const { userCompFactory, context } = this.beans;
    const dateCompWrapper = new DateCompWrapper(
      context,
      userCompFactory,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams,
        location: "filter"
      },
      element
    );
    this.addDestroyFunc(() => dateCompWrapper.destroy());
    return dateCompWrapper;
  }
  setElementValue(element, value) {
    element.setDate(value);
  }
  setElementDisplayed(element, displayed) {
    element.setDisplayed(displayed);
  }
  setElementDisabled(element, disabled) {
    element.setDisabled(disabled);
  }
  getDefaultFilterOptions() {
    return DEFAULT_DATE_FILTER_OPTIONS;
  }
  createValueElement() {
    const eDocument = _getDocument(this.beans);
    const eCondition = eDocument.createElement("div");
    eCondition.classList.add("ag-filter-body");
    this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, "from");
    this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, "to");
    return eCondition;
  }
  createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
    const eDocument = _getDocument(this.beans);
    const eConditionPanel = eDocument.createElement("div");
    eConditionPanel.classList.add(`ag-filter-${fromTo}`);
    eConditionPanel.classList.add(`ag-filter-date-${fromTo}`);
    eConditionPanels.push(eConditionPanel);
    eCondition.appendChild(eConditionPanel);
    dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
  }
  removeValueElements(startPosition, deleteCount) {
    this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
    this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
    removeItems(this.eConditionPanelsFrom, startPosition, deleteCount);
    removeItems(this.eConditionPanelsTo, startPosition, deleteCount);
  }
  removeDateComps(components, startPosition, deleteCount) {
    const removedComponents = removeItems(components, startPosition, deleteCount);
    removedComponents.forEach((comp) => comp.destroy());
  }
  isValidDateValue(value) {
    if (value === null) {
      return false;
    }
    const { minValidDate, maxValidDate, minValidYear, maxValidYear } = this;
    if (minValidDate) {
      if (value < minValidDate) {
        return false;
      }
    } else {
      if (value.getUTCFullYear() < minValidYear) {
        return false;
      }
    }
    if (maxValidDate) {
      if (value > maxValidDate) {
        return false;
      }
    } else {
      if (value.getUTCFullYear() > maxValidYear) {
        return false;
      }
    }
    return true;
  }
  isConditionUiComplete(position) {
    if (!super.isConditionUiComplete(position)) {
      return false;
    }
    let valid = true;
    this.forEachInput((element, index, elPosition, numberOfInputs) => {
      if (elPosition !== position || !valid || index >= numberOfInputs) {
        return;
      }
      valid = valid && this.isValidDateValue(element.getDate());
    });
    return valid;
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type;
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {};
    const values = this.getValues(position);
    if (values.length > 0) {
      model.dateFrom = _serialiseDate(values[0]);
    }
    if (values.length > 1) {
      model.dateTo = _serialiseDate(values[1]);
    }
    return {
      dateFrom: null,
      dateTo: null,
      filterType: this.filterType,
      type,
      ...model
    };
  }
  resetPlaceholder() {
    const globalTranslate = this.getLocaleTextFunc();
    const placeholder = this.translate("dateFormatOoo");
    const ariaLabel = globalTranslate("ariaFilterValue", "Filter Value");
    this.forEachInput((element) => {
      element.setInputPlaceholder(placeholder);
      element.setInputAriaLabel(ariaLabel);
    });
  }
  getInputs(position) {
    const { dateConditionFromComps, dateConditionToComps } = this;
    if (position >= dateConditionFromComps.length) {
      return [null, null];
    }
    return [dateConditionFromComps[position], dateConditionToComps[position]];
  }
  getValues(position) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        result.push(element.getDate());
      }
    });
    return result;
  }
  translate(key) {
    if (key === "lessThan") {
      return super.translate("before");
    }
    if (key === "greaterThan") {
      return super.translate("after");
    }
    return super.translate(key);
  }
  getModelAsString(model) {
    return this.filterModelFormatter.getModelAsString(model) ?? "";
  }
};
function defaultDateComparator(filterDate, cellValue) {
  const cellAsDate = cellValue;
  if (cellValue == null || cellAsDate < filterDate) {
    return -1;
  }
  if (cellAsDate > filterDate) {
    return 1;
  }
  return 0;
}

// packages/ag-grid-community/src/filter/floating/provided/simpleFloatingFilter.ts
var SimpleFloatingFilter = class extends Component {
  constructor() {
    super(...arguments);
    this.defaultDebounceMs = 0;
  }
  setLastTypeFromModel(model) {
    if (!model) {
      this.lastType = this.optionsFactory.defaultOption;
      return;
    }
    const isCombined = model.operator;
    let condition;
    if (isCombined) {
      const combinedModel = model;
      condition = combinedModel.conditions[0];
    } else {
      condition = model;
    }
    this.lastType = condition.type;
  }
  canWeEditAfterModelFromParentFilter(model) {
    if (!model) {
      return this.isTypeEditable(this.lastType);
    }
    const isCombined = model.operator;
    if (isCombined) {
      return false;
    }
    const simpleModel = model;
    return this.isTypeEditable(simpleModel.type);
  }
  init(params) {
    this.setSimpleParams(params, false);
  }
  setSimpleParams(params, update = true) {
    const optionsFactory = new OptionsFactory();
    this.optionsFactory = optionsFactory;
    optionsFactory.init(params.filterParams, this.getDefaultOptions());
    const defaultOption = optionsFactory.defaultOption;
    if (!update) {
      this.lastType = defaultOption;
    }
    this.readOnly = !!params.filterParams.readOnly;
    const editable = this.isTypeEditable(defaultOption);
    this.setEditable(editable);
  }
  refresh(params) {
    this.setSimpleParams(params);
  }
  hasSingleInput(filterType) {
    const numberOfInputs = this.optionsFactory.getCustomOption(filterType)?.numberOfInputs;
    return numberOfInputs == null || numberOfInputs == 1;
  }
  isTypeEditable(type) {
    const uneditableTypes = ["inRange", "empty", "blank", "notBlank"];
    return !!type && !this.readOnly && this.hasSingleInput(type) && uneditableTypes.indexOf(type) < 0;
  }
  getAriaLabel(params) {
    const displayName = this.beans.colNames.getDisplayNameForColumn(params.column, "header", true);
    return `${displayName} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`;
  }
};

// packages/ag-grid-community/src/filter/provided/date/dateFloatingFilter.ts
var DateFloatingFilter = class extends SimpleFloatingFilter {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
      [AgInputTextFieldSelector]
    );
    this.eReadOnlyText = RefPlaceholder;
    this.eDateWrapper = RefPlaceholder;
  }
  getDefaultOptions() {
    return DEFAULT_DATE_FILTER_OPTIONS;
  }
  init(params) {
    super.init(params);
    this.params = params;
    this.filterParams = params.filterParams;
    this.createDateComponent();
    this.filterModelFormatter = new DateFilterModelFormatter(
      this.filterParams,
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
    const translate = this.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate("ariaDateFilterInput", "Date Filter Input"));
  }
  refresh(params) {
    super.refresh(params);
    this.params = params;
    this.filterParams = params.filterParams;
    const dateParams = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(dateParams);
    this.filterModelFormatter.updateParams({
      optionsFactory: this.optionsFactory,
      dateFilterParams: this.filterParams
    });
    this.updateCompOnModelChange(params.currentParentModel());
  }
  updateCompOnModelChange(model) {
    const allowEditing = !this.readOnly && this.canWeEditAfterModelFromParentFilter(model);
    this.setEditable(allowEditing);
    if (allowEditing) {
      const dateModel = model ? _parseDateTimeFromString(model.dateFrom) : null;
      this.dateComp.setDate(dateModel);
      this.eReadOnlyText.setValue("");
    } else {
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
      this.dateComp.setDate(null);
    }
  }
  setEditable(editable) {
    _setDisplayed(this.eDateWrapper, editable);
    _setDisplayed(this.eReadOnlyText.getGui(), !editable);
  }
  onParentModelChanged(model, event) {
    if (event?.afterFloatingFilter || event?.afterDataChange) {
      return;
    }
    super.setLastTypeFromModel(model);
    this.updateCompOnModelChange(model);
  }
  onDateChanged() {
    const filterValueDate = this.dateComp.getDate();
    const filterValueText = _serialiseDate(filterValueDate);
    this.params.parentFilterInstance((filterInstance) => {
      if (filterInstance) {
        const date = _parseDateTimeFromString(filterValueText);
        filterInstance.onFloatingFilterChanged(this.lastType || null, date);
      }
    });
  }
  getDateComponentParams() {
    const { filterParams, column } = this.params;
    const debounceMs = getDebounceMs(filterParams, this.defaultDebounceMs);
    return {
      onDateChanged: _debounce(this, this.onDateChanged.bind(this), debounceMs),
      filterParams: column.getColDef().filterParams,
      location: "floatingFilter"
    };
  }
  createDateComponent() {
    const {
      beans: { context, userCompFactory },
      eDateWrapper
    } = this;
    this.dateComp = new DateCompWrapper(
      context,
      userCompFactory,
      this.getDateComponentParams(),
      eDateWrapper,
      (dateComp) => {
        dateComp.setInputAriaLabel(this.getAriaLabel(this.params));
      }
    );
    this.addDestroyFunc(() => this.dateComp.destroy());
  }
};

// packages/ag-grid-community/src/filter/provided/date/defaultDateComponent.ts
var DefaultDateComponent = class extends Component {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
      [AgInputTextFieldSelector]
    );
    this.eDateInput = RefPlaceholder;
    this.isApply = false;
    this.applyOnFocusOut = false;
  }
  init(params) {
    this.params = params;
    this.setParams(params);
    const inputElement = this.eDateInput.getInputElement();
    this.addManagedListeners(inputElement, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        if (this.eDateInput.isDisabled() || this.usingSafariDatePicker) {
          return;
        }
        inputElement.focus({ preventScroll: true });
      },
      input: this.handleInput.bind(this, false),
      change: this.handleInput.bind(this, true),
      focusout: this.handleFocusOut.bind(this)
    });
  }
  handleInput(isChange, e) {
    if (e.target !== _getActiveDomElement(this.beans)) {
      return;
    }
    if (this.eDateInput.isDisabled()) {
      return;
    }
    if (this.isApply) {
      this.applyOnFocusOut = !isChange;
      if (isChange) {
        this.params.onDateChanged();
      }
      return;
    }
    if (!isChange) {
      this.params.onDateChanged();
    }
  }
  handleFocusOut() {
    if (this.applyOnFocusOut) {
      this.applyOnFocusOut = false;
      this.params.onDateChanged();
    }
  }
  setParams(params) {
    const inputElement = this.eDateInput.getInputElement();
    const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
    this.usingSafariDatePicker = shouldUseBrowserDatePicker && _isBrowserSafari();
    inputElement.type = shouldUseBrowserDatePicker ? "date" : "text";
    const { minValidYear, maxValidYear, minValidDate, maxValidDate, buttons } = params.filterParams || {};
    if (minValidDate && minValidYear) {
      _warn(85);
    }
    if (maxValidDate && maxValidYear) {
      _warn(86);
    }
    if (minValidDate && maxValidDate) {
      const [parsedMinValidDate, parsedMaxValidDate] = [minValidDate, maxValidDate].map(
        (v) => v instanceof Date ? v : _parseDateTimeFromString(v)
      );
      if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate.getTime() > parsedMaxValidDate.getTime()) {
        _warn(87);
      }
    }
    if (minValidDate) {
      if (minValidDate instanceof Date) {
        inputElement.min = _dateToFormattedString(minValidDate);
      } else {
        inputElement.min = minValidDate;
      }
    } else {
      if (minValidYear) {
        inputElement.min = `${minValidYear}-01-01`;
      }
    }
    if (maxValidDate) {
      if (maxValidDate instanceof Date) {
        inputElement.max = _dateToFormattedString(maxValidDate);
      } else {
        inputElement.max = maxValidDate;
      }
    } else {
      if (maxValidYear) {
        inputElement.max = `${maxValidYear}-12-31`;
      }
    }
    this.isApply = params.location === "floatingFilter" && !!buttons?.includes("apply");
  }
  refresh(params) {
    this.params = params;
    this.setParams(params);
  }
  getDate() {
    return _parseDateTimeFromString(this.eDateInput.getValue());
  }
  setDate(date) {
    this.eDateInput.setValue(_serialiseDate(date, false));
  }
  setInputPlaceholder(placeholder) {
    this.eDateInput.setInputPlaceholder(placeholder);
  }
  setInputAriaLabel(ariaLabel) {
    this.eDateInput.setAriaLabel(ariaLabel);
  }
  setDisabled(disabled) {
    this.eDateInput.setDisabled(disabled);
  }
  afterGuiAttached(params) {
    if (!params || !params.suppressFocus) {
      this.eDateInput.getInputElement().focus({ preventScroll: true });
    }
  }
  shouldUseBrowserDatePicker(params) {
    return params?.filterParams?.browserDatePicker ?? true;
  }
};

// packages/ag-grid-community/src/filter/provided/number/numberFilterConstants.ts
var DEFAULT_NUMBER_FILTER_OPTIONS = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
];

// packages/ag-grid-community/src/filter/provided/number/numberFilterModelFormatter.ts
var NumberFilterModelFormatter = class extends SimpleFilterModelFormatter {
  conditionToString(condition, options) {
    const { numberOfInputs } = options || {};
    const { filter, filterTo, type } = condition;
    const isRange = type == "inRange" || numberOfInputs === 2;
    const formatValue = this.formatValue.bind(this);
    if (isRange) {
      return `${formatValue(filter)}-${formatValue(filterTo)}`;
    }
    if (filter != null) {
      return formatValue(filter);
    }
    return `${type}`;
  }
};

// packages/ag-grid-community/src/filter/provided/number/numberFilterUtils.ts
function getAllowedCharPattern(filterParams) {
  const { allowedCharPattern } = filterParams ?? {};
  return allowedCharPattern ?? null;
}

// packages/ag-grid-community/src/filter/provided/number/numberFilter.ts
var NumberFilter = class extends ScalarFilter {
  constructor() {
    super("numberFilter");
    this.eValuesFrom = [];
    this.eValuesTo = [];
    this.filterType = "number";
    this.defaultDebounceMs = 500;
  }
  refresh(params) {
    if (this.numberFilterParams.allowedCharPattern !== params.allowedCharPattern) {
      return false;
    }
    return super.refresh(params);
  }
  mapValuesFromModel(filterModel) {
    const { filter, filterTo, type } = filterModel || {};
    return [this.processValue(filter), this.processValue(filterTo)].slice(0, this.getNumberOfInputs(type));
  }
  comparator() {
    return (left, right) => {
      if (left === right) {
        return 0;
      }
      return left < right ? 1 : -1;
    };
  }
  setParams(params) {
    this.numberFilterParams = params;
    super.setParams(params);
    this.filterModelFormatter = new NumberFilterModelFormatter(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory,
      this.numberFilterParams.numberFormatter
    );
  }
  getDefaultFilterOptions() {
    return DEFAULT_NUMBER_FILTER_OPTIONS;
  }
  setElementValue(element, value, fromFloatingFilter) {
    const { numberFormatter } = this.numberFilterParams;
    const valueToSet = !fromFloatingFilter && numberFormatter ? numberFormatter(value ?? null) : value;
    super.setElementValue(element, valueToSet);
  }
  createValueElement() {
    const allowedCharPattern = getAllowedCharPattern(this.numberFilterParams);
    const eCondition = document.createElement("div");
    eCondition.classList.add("ag-filter-body");
    _setAriaRole(eCondition, "presentation");
    this.createFromToElement(eCondition, this.eValuesFrom, "from", allowedCharPattern);
    this.createFromToElement(eCondition, this.eValuesTo, "to", allowedCharPattern);
    return eCondition;
  }
  createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
    const eValue = this.createManagedBean(
      allowedCharPattern ? new AgInputTextField({ allowedCharPattern }) : new AgInputNumberField()
    );
    eValue.addCssClass(`ag-filter-${fromTo}`);
    eValue.addCssClass("ag-filter-filter");
    eValues.push(eValue);
    eCondition.appendChild(eValue.getGui());
  }
  removeValueElements(startPosition, deleteCount) {
    const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
    removeComps(this.eValuesFrom);
    removeComps(this.eValuesTo);
  }
  getValues(position) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        result.push(this.processValue(this.stringToFloat(element.getValue())));
      }
    });
    return result;
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
  }
  processValue(value) {
    if (value == null) {
      return null;
    }
    return isNaN(value) ? null : value;
  }
  stringToFloat(value) {
    if (typeof value === "number") {
      return value;
    }
    let filterText = _makeNull(value);
    if (filterText != null && filterText.trim() === "") {
      filterText = null;
    }
    const numberParser = this.numberFilterParams.numberParser;
    if (numberParser) {
      return numberParser(filterText);
    }
    return filterText == null || filterText.trim() === "-" ? null : parseFloat(filterText);
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {
      filterType: this.filterType,
      type
    };
    const values = this.getValues(position);
    if (values.length > 0) {
      model.filter = values[0];
    }
    if (values.length > 1) {
      model.filterTo = values[1];
    }
    return model;
  }
  getInputs(position) {
    const { eValuesFrom, eValuesTo } = this;
    if (position >= eValuesFrom.length) {
      return [null, null];
    }
    return [eValuesFrom[position], eValuesTo[position]];
  }
  getModelAsString(model) {
    return this.filterModelFormatter.getModelAsString(model) ?? "";
  }
  hasInvalidInputs() {
    let invalidInputs = false;
    this.forEachInput((element) => {
      if (!element.getInputElement().validity.valid) {
        invalidInputs = true;
        return;
      }
    });
    return invalidInputs;
  }
};

// packages/ag-grid-community/src/filter/floating/provided/floatingFilterTextInputService.ts
var FloatingFilterTextInputService = class extends BeanStub {
  constructor(params) {
    super();
    this.params = params;
    this.eInput = RefPlaceholder;
    this.onValueChanged = () => {
    };
  }
  setupGui(parentElement) {
    this.eInput = this.createManagedBean(new AgInputTextField(this.params?.config));
    const eInput = this.eInput.getGui();
    parentElement.appendChild(eInput);
    const listener = (e) => this.onValueChanged(e);
    this.addManagedListeners(eInput, {
      input: listener,
      keydown: listener
    });
  }
  setEditable(editable) {
    this.eInput.setDisabled(!editable);
  }
  getValue() {
    return this.eInput.getValue();
  }
  setValue(value, silent) {
    this.eInput.setValue(value, silent);
  }
  setValueChangedListener(listener) {
    this.onValueChanged = listener;
  }
  setParams({ ariaLabel, autoComplete }) {
    const { eInput } = this;
    eInput.setInputAriaLabel(ariaLabel);
    if (autoComplete !== void 0) {
      eInput.setAutoComplete(autoComplete);
    }
  }
};

// packages/ag-grid-community/src/filter/provided/text/textFilterUtils.ts
function trimInputForFilter(value) {
  const trimmedInput = value?.trim();
  return trimmedInput === "" ? value : trimmedInput;
}

// packages/ag-grid-community/src/filter/floating/provided/textInputFloatingFilter.ts
var TextInputFloatingFilter = class extends SimpleFloatingFilter {
  constructor() {
    super(...arguments);
    this.eFloatingFilterInputContainer = RefPlaceholder;
    this.defaultDebounceMs = 500;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  onParentModelChanged(model, event) {
    if (event?.afterFloatingFilter || event?.afterDataChange) {
      return;
    }
    this.setLastTypeFromModel(model);
    this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
    this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(model));
  }
  init(params) {
    this.setupFloatingFilterInputService(params);
    super.init(params);
    this.setTextInputParams(params);
  }
  setupFloatingFilterInputService(params) {
    this.inputSvc = this.createFloatingFilterInputService(params);
    this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(params) {
    this.params = params;
    const autoComplete = params.browserAutoComplete ?? false;
    const { inputSvc, defaultDebounceMs, readOnly } = this;
    inputSvc.setParams({
      ariaLabel: this.getAriaLabel(params),
      autoComplete
    });
    this.applyActive = isUseApplyButton(params.filterParams);
    if (!readOnly) {
      const debounceMs = getDebounceMs(params.filterParams, defaultDebounceMs);
      const toDebounce = _debounce(
        this,
        this.syncUpWithParentFilter.bind(this),
        debounceMs
      );
      inputSvc.setValueChangedListener(toDebounce);
    }
  }
  refresh(params) {
    super.refresh(params);
    this.setTextInputParams(params);
  }
  recreateFloatingFilterInputService(params) {
    const { inputSvc } = this;
    const value = inputSvc.getValue();
    _clearElement(this.eFloatingFilterInputContainer);
    this.destroyBean(inputSvc);
    this.setupFloatingFilterInputService(params);
    inputSvc.setValue(value, true);
  }
  syncUpWithParentFilter(e) {
    const isEnterKey = e.key === KeyCode.ENTER;
    if (this.applyActive && !isEnterKey) {
      return;
    }
    const { inputSvc, params } = this;
    let value = inputSvc.getValue();
    if (params.filterParams.trimInput) {
      value = trimInputForFilter(value);
      inputSvc.setValue(value, true);
    }
    params.parentFilterInstance((filterInstance) => {
      filterInstance?.onFloatingFilterChanged(this.lastType || null, value || null);
    });
  }
  setEditable(editable) {
    this.inputSvc.setEditable(editable);
  }
};

// packages/ag-grid-community/src/filter/provided/number/numberFloatingFilter.ts
var FloatingFilterNumberInputService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.onValueChanged = () => {
    };
    this.numberInputActive = true;
  }
  setupGui(parentElement) {
    this.eNumberInput = this.createManagedBean(new AgInputNumberField());
    this.eTextInput = this.createManagedBean(new AgInputTextField());
    this.eTextInput.setDisabled(true);
    const eNumberInput = this.eNumberInput.getGui();
    const eTextInput = this.eTextInput.getGui();
    parentElement.appendChild(eNumberInput);
    parentElement.appendChild(eTextInput);
    this.setupListeners(eNumberInput, (e) => this.onValueChanged(e));
    this.setupListeners(eTextInput, (e) => this.onValueChanged(e));
  }
  setEditable(editable) {
    this.numberInputActive = editable;
    this.eNumberInput.setDisplayed(this.numberInputActive);
    this.eTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(autoComplete) {
    this.eNumberInput.setAutoComplete(autoComplete);
    this.eTextInput.setAutoComplete(autoComplete);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(value, silent) {
    this.getActiveInputElement().setValue(value, silent);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eNumberInput : this.eTextInput;
  }
  setValueChangedListener(listener) {
    this.onValueChanged = listener;
  }
  setupListeners(element, listener) {
    this.addManagedListeners(element, {
      input: listener,
      keydown: listener
    });
  }
  setParams(params) {
    this.setAriaLabel(params.ariaLabel);
    if (params.autoComplete !== void 0) {
      this.setAutoComplete(params.autoComplete);
    }
  }
  setAriaLabel(ariaLabel) {
    this.eNumberInput.setInputAriaLabel(ariaLabel);
    this.eTextInput.setInputAriaLabel(ariaLabel);
  }
};
var NumberFloatingFilter = class extends TextInputFloatingFilter {
  init(params) {
    super.init(params);
    this.filterModelFormatter = new NumberFilterModelFormatter(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory,
      params.filterParams?.numberFormatter
    );
  }
  refresh(params) {
    const allowedCharPattern = getAllowedCharPattern(params.filterParams);
    if (allowedCharPattern !== this.allowedCharPattern) {
      this.recreateFloatingFilterInputService(params);
    }
    super.refresh(params);
    this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultOptions() {
    return DEFAULT_NUMBER_FILTER_OPTIONS;
  }
  createFloatingFilterInputService(params) {
    this.allowedCharPattern = getAllowedCharPattern(params.filterParams);
    if (this.allowedCharPattern) {
      return this.createManagedBean(
        new FloatingFilterTextInputService({
          config: { allowedCharPattern: this.allowedCharPattern }
        })
      );
    }
    return this.createManagedBean(new FloatingFilterNumberInputService());
  }
};

// packages/ag-grid-community/src/filter/provided/text/textFilterConstants.ts
var DEFAULT_TEXT_FILTER_OPTIONS = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
];

// packages/ag-grid-community/src/filter/provided/text/textFilterModelFormatter.ts
var TextFilterModelFormatter = class extends SimpleFilterModelFormatter {
  conditionToString(condition, options) {
    const { numberOfInputs } = options || {};
    const { filter, filterTo, type } = condition;
    const isRange = type == "inRange" || numberOfInputs === 2;
    if (isRange) {
      return `${filter}-${filterTo}`;
    }
    if (filter != null) {
      return `${filter}`;
    }
    return `${type}`;
  }
};

// packages/ag-grid-community/src/filter/provided/text/textFilter.ts
var TextFilter = class extends SimpleFilter {
  constructor() {
    super("textFilter");
    this.filterType = "text";
    this.defaultFormatter = (from) => from;
    this.defaultLowercaseFormatter = (from) => from == null ? null : from.toString().toLowerCase();
    this.defaultMatcher = ({ filterOption, value, filterText }) => {
      if (filterText == null) {
        return false;
      }
      switch (filterOption) {
        case "contains":
          return value.indexOf(filterText) >= 0;
        case "notContains":
          return value.indexOf(filterText) < 0;
        case "equals":
          return value === filterText;
        case "notEqual":
          return value != filterText;
        case "startsWith":
          return value.indexOf(filterText) === 0;
        case "endsWith": {
          const index = value.lastIndexOf(filterText);
          return index >= 0 && index === value.length - filterText.length;
        }
        default:
          return false;
      }
    };
    this.eValuesFrom = [];
    this.eValuesTo = [];
    this.defaultDebounceMs = 500;
  }
  setParams(params) {
    this.textFilterParams = params;
    super.setParams(params);
    this.matcher = params.textMatcher || this.defaultMatcher;
    this.formatter = params.textFormatter || (params.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter);
    this.filterModelFormatter = new TextFilterModelFormatter(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  createCondition(position) {
    const type = this.getConditionType(position);
    const model = {
      filterType: this.filterType,
      type
    };
    const values = this.getValuesWithSideEffects(position, true);
    if (values.length > 0) {
      model.filter = values[0];
    }
    if (values.length > 1) {
      model.filterTo = values[1];
    }
    return model;
  }
  areSimpleModelsEqual(aSimple, bSimple) {
    return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
  }
  getInputs(position) {
    const { eValuesFrom, eValuesTo } = this;
    if (position >= eValuesFrom.length) {
      return [null, null];
    }
    return [eValuesFrom[position], eValuesTo[position]];
  }
  getValues(position) {
    return this.getValuesWithSideEffects(position, false);
  }
  getValuesWithSideEffects(position, applySideEffects) {
    const result = [];
    this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
      if (index < numberOfInputs) {
        let value = _makeNull(element.getValue());
        if (applySideEffects && this.textFilterParams.trimInput) {
          value = trimInputForFilter(value) ?? null;
          element.setValue(value, true);
        }
        result.push(value);
      }
    });
    return result;
  }
  getDefaultFilterOptions() {
    return DEFAULT_TEXT_FILTER_OPTIONS;
  }
  createValueElement() {
    const eCondition = document.createElement("div");
    eCondition.classList.add("ag-filter-body");
    _setAriaRole(eCondition, "presentation");
    this.createFromToElement(eCondition, this.eValuesFrom, "from");
    this.createFromToElement(eCondition, this.eValuesTo, "to");
    return eCondition;
  }
  createFromToElement(eCondition, eValues, fromTo) {
    const eValue = this.createManagedBean(new AgInputTextField());
    eValue.addCssClass(`ag-filter-${fromTo}`);
    eValue.addCssClass("ag-filter-filter");
    eValues.push(eValue);
    eCondition.appendChild(eValue.getGui());
  }
  removeValueElements(startPosition, deleteCount) {
    const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
    removeComps(this.eValuesFrom);
    removeComps(this.eValuesTo);
  }
  mapValuesFromModel(filterModel) {
    const { filter, filterTo, type } = filterModel || {};
    return [filter || null, filterTo || null].slice(0, this.getNumberOfInputs(type));
  }
  evaluateNullValue(filterType) {
    const filterTypesAllowNulls = ["notEqual", "notContains", "blank"];
    return filterType ? filterTypesAllowNulls.indexOf(filterType) >= 0 : false;
  }
  evaluateNonNullValue(values, cellValue, filterModel, params) {
    const formattedValues = values.map((v) => this.formatter(v)) || [];
    const cellValueFormatted = this.formatter(cellValue);
    const { api, colDef, column, context, textFormatter } = this.textFilterParams;
    if (filterModel.type === "blank") {
      return isBlank(cellValue);
    } else if (filterModel.type === "notBlank") {
      return !isBlank(cellValue);
    }
    const matcherParams = {
      api,
      colDef,
      column,
      context,
      node: params.node,
      data: params.data,
      filterOption: filterModel.type,
      value: cellValueFormatted,
      textFormatter
    };
    return formattedValues.some((v) => this.matcher({ ...matcherParams, filterText: v }));
  }
  getModelAsString(model) {
    return this.filterModelFormatter.getModelAsString(model) ?? "";
  }
};

// packages/ag-grid-community/src/filter/provided/text/textFloatingFilter.ts
var TextFloatingFilter = class extends TextInputFloatingFilter {
  init(params) {
    super.init(params);
    this.filterModelFormatter = new TextFilterModelFormatter(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  refresh(params) {
    super.refresh(params);
    this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultOptions() {
    return DEFAULT_TEXT_FILTER_OPTIONS;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new FloatingFilterTextInputService());
  }
};

// packages/ag-grid-community/src/filter/quickFilterApi.ts
function isQuickFilterPresent(beans) {
  return !!beans.filterManager?.isQuickFilterPresent();
}
function getQuickFilter(beans) {
  return beans.gos.get("quickFilterText");
}
function resetQuickFilter(beans) {
  beans.filterManager?.resetQuickFilterCache();
}

// packages/ag-grid-community/src/filter/quickFilterService.ts
var QuickFilterService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "quickFilter";
    this.quickFilter = null;
    this.quickFilterParts = null;
  }
  postConstruct() {
    const resetListener = this.resetCache.bind(this);
    const gos = this.gos;
    this.addManagedEventListeners({
      columnPivotModeChanged: resetListener,
      newColumnsLoaded: resetListener,
      columnRowGroupChanged: resetListener,
      columnVisible: () => {
        if (!gos.get("includeHiddenColumnsInQuickFilter")) {
          this.resetCache();
        }
      }
    });
    this.addManagedPropertyListener("quickFilterText", (e) => this.setFilter(e.currentValue));
    this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onColumnConfigChanged()
    );
    this.quickFilter = this.parseFilter(gos.get("quickFilterText"));
    this.parser = gos.get("quickFilterParser");
    this.matcher = gos.get("quickFilterMatcher");
    this.setFilterParts();
    this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setParserAndMatcher());
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshCols() {
    const { autoColSvc, colModel, gos, pivotResultCols } = this.beans;
    const pivotMode = colModel.isPivotMode();
    const groupAutoCols = autoColSvc?.getAutoCols();
    const providedCols = colModel.getColDefCols();
    let columnsForQuickFilter = (pivotMode && !gos.get("applyQuickFilterBeforePivotOrAgg") ? pivotResultCols?.getPivotResultCols()?.list : providedCols) ?? [];
    if (groupAutoCols) {
      columnsForQuickFilter = columnsForQuickFilter.concat(groupAutoCols);
    }
    this.colsToUse = gos.get("includeHiddenColumnsInQuickFilter") ? columnsForQuickFilter : columnsForQuickFilter.filter((col) => col.isVisible() || col.isRowGroupActive());
  }
  isFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPass(node) {
    const usingCache = this.gos.get("cacheQuickFilter");
    if (this.matcher) {
      return this.doesRowPassMatcher(usingCache, node);
    }
    return this.quickFilterParts.every(
      (part) => usingCache ? this.doesRowPassCache(node, part) : this.doesRowPassNoCache(node, part)
    );
  }
  resetCache() {
    this.beans.rowModel.forEachNode((node) => node.quickFilterAggregateText = null);
  }
  setFilterParts() {
    const { quickFilter, parser } = this;
    if (quickFilter) {
      this.quickFilterParts = parser ? parser(quickFilter) : quickFilter.split(" ");
    } else {
      this.quickFilterParts = null;
    }
  }
  parseFilter(newFilter) {
    if (!_exists(newFilter)) {
      return null;
    }
    return newFilter.toUpperCase();
  }
  setFilter(newFilter) {
    if (newFilter != null && typeof newFilter !== "string") {
      _warn(70, { newFilter });
      return;
    }
    const parsedFilter = this.parseFilter(newFilter);
    if (this.quickFilter !== parsedFilter) {
      this.quickFilter = parsedFilter;
      this.setFilterParts();
      this.dispatchLocalEvent({ type: "quickFilterChanged" });
    }
  }
  setParserAndMatcher() {
    const parser = this.gos.get("quickFilterParser");
    const matcher = this.gos.get("quickFilterMatcher");
    const hasChanged = parser !== this.parser || matcher !== this.matcher;
    this.parser = parser;
    this.matcher = matcher;
    if (hasChanged) {
      this.setFilterParts();
      this.dispatchLocalEvent({ type: "quickFilterChanged" });
    }
  }
  onColumnConfigChanged() {
    this.refreshCols();
    this.resetCache();
    if (this.isFilterPresent()) {
      this.dispatchLocalEvent({ type: "quickFilterChanged" });
    }
  }
  doesRowPassNoCache(node, filterPart) {
    return this.colsToUse.some((column) => {
      const part = this.getTextForColumn(column, node);
      return _exists(part) && part.indexOf(filterPart) >= 0;
    });
  }
  doesRowPassCache(node, filterPart) {
    this.checkGenerateAggText(node);
    return node.quickFilterAggregateText.indexOf(filterPart) >= 0;
  }
  doesRowPassMatcher(usingCache, node) {
    let quickFilterAggregateText;
    if (usingCache) {
      this.checkGenerateAggText(node);
      quickFilterAggregateText = node.quickFilterAggregateText;
    } else {
      quickFilterAggregateText = this.getAggText(node);
    }
    const { quickFilterParts, matcher } = this;
    return matcher(quickFilterParts, quickFilterAggregateText);
  }
  checkGenerateAggText(node) {
    if (!node.quickFilterAggregateText) {
      node.quickFilterAggregateText = this.getAggText(node);
    }
  }
  getTextForColumn(column, node) {
    let value = this.beans.filterValueSvc.getValue(column, node);
    const colDef = column.getColDef();
    if (colDef.getQuickFilterText) {
      const params = this.gos.addGridCommonParams({
        value,
        node,
        data: node.data,
        column,
        colDef
      });
      value = colDef.getQuickFilterText(params);
    }
    return _exists(value) ? value.toString().toUpperCase() : null;
  }
  getAggText(node) {
    const stringParts = [];
    this.colsToUse.forEach((column) => {
      const part = this.getTextForColumn(column, node);
      if (_exists(part)) {
        stringParts.push(part);
      }
    });
    return stringParts.join("\n");
  }
};

// packages/ag-grid-community/src/filter/filterModule.ts
var ClientSideRowModelFilterModule = {
  moduleName: "ClientSideRowModelFilter",
  version: VERSION,
  rowModels: ["clientSide"],
  beans: [FilterStage]
};
var FilterCoreModule = {
  moduleName: "FilterCore",
  version: VERSION,
  beans: [FilterManager],
  apiFunctions: {
    isAnyFilterPresent,
    onFilterChanged
  },
  css: [columnFiltersCSS],
  dependsOn: [ClientSideRowModelFilterModule]
};
var FilterValueModule = {
  moduleName: "FilterValue",
  version: VERSION,
  beans: [FilterValueService]
};
var ColumnFilterModule = {
  moduleName: "ColumnFilter",
  version: VERSION,
  beans: [ColumnFilterService, FilterMenuFactory],
  dynamicBeans: { headerFilterCellCtrl: HeaderFilterCellCtrl },
  icons: {
    // open filter button - header, floating filter, menu
    filter: "filter",
    // filter is applied - header (legacy column menu), filter tool panel
    filterActive: "filter"
  },
  apiFunctions: {
    isColumnFilterPresent,
    getColumnFilterInstance,
    destroyFilter,
    setFilterModel,
    getFilterModel,
    getColumnFilterModel,
    setColumnFilterModel,
    showColumnFilter
  },
  dependsOn: [FilterCoreModule, PopupModule, FilterValueModule, SharedMenuModule]
};
var CustomFilterModule = {
  moduleName: "CustomFilter",
  version: VERSION,
  userComponents: { agReadOnlyFloatingFilter: ReadOnlyFloatingFilter },
  dependsOn: [ColumnFilterModule]
};
var TextFilterModule = {
  moduleName: "TextFilter",
  version: VERSION,
  dependsOn: [ColumnFilterModule],
  userComponents: {
    agTextColumnFilter: TextFilter,
    agTextColumnFloatingFilter: TextFloatingFilter
  }
};
var NumberFilterModule = {
  moduleName: "NumberFilter",
  version: VERSION,
  dependsOn: [ColumnFilterModule],
  userComponents: {
    agNumberColumnFilter: NumberFilter,
    agNumberColumnFloatingFilter: NumberFloatingFilter
  }
};
var DateFilterModule = {
  moduleName: "DateFilter",
  version: VERSION,
  dependsOn: [ColumnFilterModule],
  userComponents: {
    agDateColumnFilter: DateFilter,
    agDateInput: DefaultDateComponent,
    agDateColumnFloatingFilter: DateFloatingFilter
  }
};
var QuickFilterModule = {
  moduleName: "QuickFilter",
  version: VERSION,
  rowModels: ["clientSide"],
  beans: [QuickFilterService],
  apiFunctions: {
    isQuickFilterPresent,
    getQuickFilter,
    resetQuickFilter
  },
  dependsOn: [FilterCoreModule, FilterValueModule]
};
var ExternalFilterModule = {
  moduleName: "ExternalFilter",
  version: VERSION,
  dependsOn: [FilterCoreModule]
};

// packages/ag-grid-community/src/undoRedo/undoRedoStack.ts
var UndoRedoAction = class {
  constructor(cellValueChanges) {
    this.cellValueChanges = cellValueChanges;
  }
};
var RangeUndoRedoAction = class extends UndoRedoAction {
  constructor(cellValueChanges, initialRange, finalRange, ranges) {
    super(cellValueChanges);
    this.initialRange = initialRange;
    this.finalRange = finalRange;
    this.ranges = ranges;
  }
};
var DEFAULT_STACK_SIZE = 10;
var UndoRedoStack = class {
  constructor(maxStackSize) {
    this.actionStack = [];
    this.maxStackSize = maxStackSize ? maxStackSize : DEFAULT_STACK_SIZE;
    this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(item) {
    const shouldAddActions = item.cellValueChanges && item.cellValueChanges.length > 0;
    if (!shouldAddActions) {
      return;
    }
    if (this.actionStack.length === this.maxStackSize) {
      this.actionStack.shift();
    }
    this.actionStack.push(item);
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
};

// packages/ag-grid-community/src/undoRedo/undoRedoService.ts
var UndoRedoService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "undoRedo";
    this.cellValueChanges = [];
    this.activeCellEdit = null;
    this.activeRowEdit = null;
    this.isPasting = false;
    this.isRangeInAction = false;
    this.onCellValueChanged = (event) => {
      const eventCell = { column: event.column, rowIndex: event.rowIndex, rowPinned: event.rowPinned };
      const isCellEditing = this.activeCellEdit !== null && _areCellsEqual(this.activeCellEdit, eventCell);
      const isRowEditing = this.activeRowEdit !== null && _isSameRow(this.activeRowEdit, eventCell);
      const shouldCaptureAction = isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction;
      if (!shouldCaptureAction) {
        return;
      }
      const { rowPinned, rowIndex, column, oldValue, value } = event;
      const cellValueChange = {
        rowPinned,
        rowIndex,
        columnId: column.getColId(),
        newValue: value,
        oldValue
      };
      this.cellValueChanges.push(cellValueChange);
    };
    this.clearStacks = () => {
      this.undoStack.clear();
      this.redoStack.clear();
    };
  }
  postConstruct() {
    const { gos, ctrlsSvc } = this.beans;
    if (!gos.get("undoRedoCellEditing")) {
      return;
    }
    const undoRedoLimit = gos.get("undoRedoCellEditingLimit");
    if (undoRedoLimit <= 0) {
      return;
    }
    this.undoStack = new UndoRedoStack(undoRedoLimit);
    this.redoStack = new UndoRedoStack(undoRedoLimit);
    this.addListeners();
    const listener = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (e) => {
        if (!e.keepUndoRedoStack) {
          this.clearStacks();
        }
      },
      columnPivotModeChanged: listener,
      newColumnsLoaded: listener,
      columnGroupOpened: listener,
      columnRowGroupChanged: listener,
      columnMoved: listener,
      columnPinned: listener,
      columnVisible: listener,
      rowDragEnd: listener
    });
    ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack?.getCurrentStackSize() ?? 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack?.getCurrentStackSize() ?? 0;
  }
  undo(source) {
    const { eventSvc, undoStack, redoStack } = this;
    eventSvc.dispatchEvent({
      type: "undoStarted",
      source
    });
    const operationPerformed = this.undoRedo(undoStack, redoStack, "initialRange", "oldValue", "undo");
    eventSvc.dispatchEvent({
      type: "undoEnded",
      source,
      operationPerformed
    });
  }
  redo(source) {
    const { eventSvc, undoStack, redoStack } = this;
    eventSvc.dispatchEvent({
      type: "redoStarted",
      source
    });
    const operationPerformed = this.undoRedo(redoStack, undoStack, "finalRange", "newValue", "redo");
    eventSvc.dispatchEvent({
      type: "redoEnded",
      source,
      operationPerformed
    });
  }
  undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
    if (!undoRedoStack) {
      return false;
    }
    const undoRedoAction = undoRedoStack.pop();
    if (!undoRedoAction || !undoRedoAction.cellValueChanges) {
      return false;
    }
    this.processAction(
      undoRedoAction,
      (cellValueChange) => cellValueChange[cellValueChangeProperty],
      source
    );
    if (undoRedoAction instanceof RangeUndoRedoAction) {
      this.processRange(undoRedoAction.ranges || [undoRedoAction[rangeProperty]]);
    } else {
      this.processCell(undoRedoAction.cellValueChanges);
    }
    opposingUndoRedoStack.push(undoRedoAction);
    return true;
  }
  processAction(action, valueExtractor, source) {
    action.cellValueChanges.forEach((cellValueChange) => {
      const { rowIndex, rowPinned, columnId } = cellValueChange;
      const rowPosition = { rowIndex, rowPinned };
      const currentRow = _getRowNode(this.beans, rowPosition);
      if (!currentRow.displayed) {
        return;
      }
      currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
    });
  }
  processRange(ranges) {
    let lastFocusedCell;
    const rangeSvc = this.beans.rangeSvc;
    rangeSvc.removeAllCellRanges(true);
    ranges.forEach((range, idx) => {
      if (!range) {
        return;
      }
      const startRow = range.startRow;
      const endRow = range.endRow;
      if (idx === ranges.length - 1) {
        lastFocusedCell = {
          rowPinned: startRow.rowPinned,
          rowIndex: startRow.rowIndex,
          columnId: range.startColumn.getColId()
        };
        this.setLastFocusedCell(lastFocusedCell);
      }
      const cellRangeParams = {
        rowStartIndex: startRow.rowIndex,
        rowStartPinned: startRow.rowPinned,
        rowEndIndex: endRow.rowIndex,
        rowEndPinned: endRow.rowPinned,
        columnStart: range.startColumn,
        columns: range.columns
      };
      rangeSvc.addCellRange(cellRangeParams);
    });
  }
  processCell(cellValueChanges) {
    const cellValueChange = cellValueChanges[0];
    const { rowIndex, rowPinned } = cellValueChange;
    const rowPosition = { rowIndex, rowPinned };
    const row = _getRowNode(this.beans, rowPosition);
    const lastFocusedCell = {
      rowPinned: cellValueChange.rowPinned,
      rowIndex: row.rowIndex,
      columnId: cellValueChange.columnId
    };
    this.setLastFocusedCell(lastFocusedCell);
  }
  setLastFocusedCell(lastFocusedCell) {
    const { rowIndex, columnId, rowPinned } = lastFocusedCell;
    const { colModel, focusSvc, rangeSvc } = this.beans;
    const column = colModel.getCol(columnId);
    if (!column) {
      return;
    }
    const { scrollFeature } = this.gridBodyCtrl;
    scrollFeature.ensureIndexVisible(rowIndex);
    scrollFeature.ensureColumnVisible(column);
    const cellPosition = { rowIndex, column, rowPinned };
    focusSvc.setFocusedCell({ ...cellPosition, forceBrowserFocus: true });
    rangeSvc?.setRangeToCell(cellPosition);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const action = new UndoRedoAction(this.cellValueChanges);
        this.pushActionsToUndoStack(action);
        this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        this.activeCellEdit = null;
        const shouldPushAction = e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction;
        if (shouldPushAction) {
          const action = new UndoRedoAction(this.cellValueChanges);
          this.pushActionsToUndoStack(action);
        }
      },
      pasteStart: () => {
        this.isPasting = true;
      },
      pasteEnd: () => {
        const action = new UndoRedoAction(this.cellValueChanges);
        this.pushActionsToUndoStack(action);
        this.isPasting = false;
      },
      fillStart: () => {
        this.isRangeInAction = true;
      },
      fillEnd: (event) => {
        const action = new RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
        this.pushActionsToUndoStack(action);
        this.isRangeInAction = false;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = true;
      },
      keyShortcutChangedCellEnd: () => {
        let action;
        const { rangeSvc, gos } = this.beans;
        if (rangeSvc && _isCellSelectionEnabled(gos)) {
          action = new RangeUndoRedoAction(this.cellValueChanges, void 0, void 0, [
            ...rangeSvc.getCellRanges()
          ]);
        } else {
          action = new UndoRedoAction(this.cellValueChanges);
        }
        this.pushActionsToUndoStack(action);
        this.isRangeInAction = false;
      }
    });
  }
  pushActionsToUndoStack(action) {
    this.undoStack.push(action);
    this.cellValueChanges = [];
    this.redoStack.clear();
  }
};

// packages/ag-grid-community/src/edit/cell-editing.css-GENERATED.ts
var cellEditingCSS = (
  /*css*/
  `.ag-cell-inline-editing{border:var(--ag-cell-editing-border)!important;border-radius:var(--ag-border-radius);box-shadow:var(--ag-cell-editing-shadow);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-wrapper,:where(.ag-cell-editor) .ag-input-field-input,:where(.ag-cell-editor) .ag-wrapper{height:100%;line-height:normal;width:100%}}:where(.ag-popup-editor) .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{height:auto;padding:var(--ag-cell-horizontal-padding)}:where(.ag-rtl .ag-large-text-input) textarea{resize:none}:where(.ag-ltr) .ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-checkbox-edit{padding-right:var(--ag-cell-horizontal-padding)}`
);

// packages/ag-grid-community/src/edit/cellEditors/checkboxCellEditor.ts
var CheckboxCellEditor = class extends PopupComponent {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [AgCheckboxSelector]
    );
    this.eCheckbox = RefPlaceholder;
  }
  init(params) {
    this.params = params;
    const isSelected = params.value ?? void 0;
    const eCheckbox = this.eCheckbox;
    eCheckbox.setValue(isSelected);
    const inputEl = eCheckbox.getInputElement();
    inputEl.setAttribute("tabindex", "-1");
    this.setAriaLabel(isSelected);
    this.addManagedListeners(eCheckbox, {
      fieldValueChanged: (event) => this.setAriaLabel(event.selected)
    });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    if (this.params.cellStartedEdit) {
      this.focusIn();
    }
  }
  isPopup() {
    return false;
  }
  setAriaLabel(isSelected) {
    const translate = this.getLocaleTextFunc();
    const stateName = _getAriaCheckboxStateName(translate, isSelected);
    const ariaLabel = translate("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${ariaLabel} (${stateName})`);
  }
};

// packages/ag-grid-community/src/edit/cellEditors/simpleCellEditor.ts
var SimpleCellEditor = class extends PopupComponent {
  constructor(cellEditorInput) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${cellEditorInput.getTemplate()}
            </div>`,
      cellEditorInput.getAgComponents()
    );
    this.cellEditorInput = cellEditorInput;
    this.eInput = RefPlaceholder;
  }
  init(params) {
    this.params = params;
    const { cellStartedEdit, eventKey, suppressPreventDefault } = params;
    const eInput = this.eInput;
    this.cellEditorInput.init(eInput, params);
    let startValue;
    let shouldSetStartValue = true;
    if (cellStartedEdit) {
      this.focusAfterAttached = true;
      if (eventKey === KeyCode.BACKSPACE || eventKey === KeyCode.DELETE) {
        startValue = "";
      } else if (eventKey && eventKey.length === 1) {
        if (suppressPreventDefault) {
          shouldSetStartValue = false;
        } else {
          startValue = eventKey;
        }
      } else {
        startValue = this.cellEditorInput.getStartValue();
        if (eventKey !== KeyCode.F2) {
          this.highlightAllOnFocus = true;
        }
      }
    } else {
      this.focusAfterAttached = false;
      startValue = this.cellEditorInput.getStartValue();
    }
    if (shouldSetStartValue && startValue != null) {
      eInput.setStartValue(startValue);
    }
    this.addManagedElementListeners(eInput.getGui(), {
      keydown: (event) => {
        const { key } = event;
        if (key === KeyCode.PAGE_UP || key === KeyCode.PAGE_DOWN) {
          event.preventDefault();
        }
      }
    });
  }
  afterGuiAttached() {
    const translate = this.getLocaleTextFunc();
    const eInput = this.eInput;
    eInput.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
    if (!this.focusAfterAttached) {
      return;
    }
    if (!_isBrowserSafari()) {
      eInput.getFocusableElement().focus();
    }
    const inputEl = eInput.getInputElement();
    if (this.highlightAllOnFocus) {
      inputEl.select();
    } else {
      this.cellEditorInput.setCaret?.();
    }
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const eInput = this.eInput;
    const focusEl = eInput.getFocusableElement();
    const inputEl = eInput.getInputElement();
    focusEl.focus();
    inputEl.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return false;
  }
};

// packages/ag-grid-community/src/edit/cellEditors/dateCellEditor.ts
var DateCellEditorInput = class {
  getTemplate() {
    return (
      /* html */
      `<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>`
    );
  }
  getAgComponents() {
    return [AgInputDateFieldSelector];
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    const { min, max, step } = params;
    if (min != null) {
      eInput.setMin(min);
    }
    if (max != null) {
      eInput.setMax(max);
    }
    if (step != null) {
      eInput.setStep(step);
    }
  }
  getValue() {
    const { eInput, params } = this;
    const value = eInput.getDate();
    if (!_exists(value) && !_exists(params.value)) {
      return params.value;
    }
    return value ?? null;
  }
  getStartValue() {
    const { value } = this.params;
    if (!(value instanceof Date)) {
      return void 0;
    }
    return _serialiseDate(value, false);
  }
};
var DateCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new DateCellEditorInput());
  }
};

// packages/ag-grid-community/src/edit/cellEditors/dateStringCellEditor.ts
var DateStringCellEditorInput = class {
  constructor(getDataTypeService) {
    this.getDataTypeService = getDataTypeService;
  }
  getTemplate() {
    return (
      /* html */
      `<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>`
    );
  }
  getAgComponents() {
    return [AgInputDateFieldSelector];
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    const { min, max, step } = params;
    if (min != null) {
      eInput.setMin(min);
    }
    if (max != null) {
      eInput.setMax(max);
    }
    if (step != null) {
      eInput.setStep(step);
    }
  }
  getValue() {
    const { params, eInput } = this;
    const value = this.formatDate(eInput.getDate());
    if (!_exists(value) && !_exists(params.value)) {
      return params.value;
    }
    return params.parseValue(value ?? "");
  }
  getStartValue() {
    return _serialiseDate(this.parseDate(this.params.value ?? void 0) ?? null, false);
  }
  parseDate(value) {
    const dataTypeSvc = this.getDataTypeService();
    return dataTypeSvc ? dataTypeSvc.getDateParserFunction(this.params.column)(value) : _parseDateTimeFromString(value) ?? void 0;
  }
  formatDate(value) {
    const dataTypeSvc = this.getDataTypeService();
    return dataTypeSvc ? dataTypeSvc.getDateFormatterFunction(this.params.column)(value) : _serialiseDate(value ?? null, false) ?? void 0;
  }
};
var DateStringCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new DateStringCellEditorInput(() => this.beans.dataTypeSvc));
  }
};

// packages/ag-grid-community/src/edit/cellEditors/largeTextCellEditor.ts
var LargeTextCellEditor = class extends PopupComponent {
  constructor() {
    super(
      /* html */
      `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
      [AgInputTextAreaSelector]
    );
    this.eTextArea = RefPlaceholder;
  }
  init(params) {
    this.params = params;
    this.focusAfterAttached = params.cellStartedEdit;
    this.eTextArea.setMaxLength(params.maxLength || 200).setCols(params.cols || 60).setRows(params.rows || 10);
    if (params.value != null) {
      this.eTextArea.setValue(params.value.toString(), true);
    }
    this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
    this.activateTabIndex();
  }
  onKeyDown(event) {
    const key = event.key;
    if (key === KeyCode.LEFT || key === KeyCode.UP || key === KeyCode.RIGHT || key === KeyCode.DOWN || event.shiftKey && key === KeyCode.ENTER) {
      event.stopPropagation();
    }
  }
  afterGuiAttached() {
    const translate = this.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
    if (this.focusAfterAttached) {
      this.eTextArea.getFocusableElement().focus();
    }
  }
  getValue() {
    const value = this.eTextArea.getValue();
    const params = this.params;
    if (!_exists(value) && !_exists(params.value)) {
      return params.value;
    }
    return params.parseValue(value);
  }
};

// packages/ag-grid-community/src/edit/cellEditors/numberCellEditor.ts
var NumberCellEditorInput = class {
  getTemplate() {
    return (
      /* html */
      `<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>`
    );
  }
  getAgComponents() {
    return [AgInputNumberFieldSelector];
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    const { max, min, precision, step } = params;
    if (max != null) {
      eInput.setMax(max);
    }
    if (min != null) {
      eInput.setMin(min);
    }
    if (precision != null) {
      eInput.setPrecision(precision);
    }
    if (step != null) {
      eInput.setStep(step);
    }
    const inputEl = eInput.getInputElement();
    if (params.preventStepping) {
      eInput.addManagedElementListeners(inputEl, { keydown: this.preventStepping });
    } else if (params.showStepperButtons) {
      inputEl.classList.add("ag-number-field-input-stepper");
    }
  }
  preventStepping(e) {
    if (e.key === KeyCode.UP || e.key === KeyCode.DOWN) {
      e.preventDefault();
    }
  }
  getValue() {
    const { eInput, params } = this;
    const value = eInput.getValue();
    if (!_exists(value) && !_exists(params.value)) {
      return params.value;
    }
    let parsedValue = params.parseValue(value);
    if (parsedValue == null) {
      return parsedValue;
    }
    if (typeof parsedValue === "string") {
      if (parsedValue === "") {
        return null;
      }
      parsedValue = Number(parsedValue);
    }
    return isNaN(parsedValue) ? null : parsedValue;
  }
  getStartValue() {
    return this.params.value;
  }
  setCaret() {
    if (_isBrowserSafari()) {
      this.eInput.getInputElement().focus({ preventScroll: true });
    }
  }
};
var NumberCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new NumberCellEditorInput());
  }
};

// packages/ag-grid-community/src/edit/cellEditors/selectCellEditor.ts
var SelectCellEditor = class extends PopupComponent {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
      [AgSelectSelector]
    );
    this.eSelect = RefPlaceholder;
    this.startedByEnter = false;
  }
  wireBeans(beans) {
    this.valueSvc = beans.valueSvc;
  }
  init(params) {
    this.focusAfterAttached = params.cellStartedEdit;
    const { eSelect, valueSvc, gos } = this;
    const { values, value, eventKey } = params;
    if (_missing(values)) {
      _warn(58);
      return;
    }
    this.startedByEnter = eventKey != null ? eventKey === KeyCode.ENTER : false;
    let hasValue = false;
    values.forEach((currentValue) => {
      const option = { value: currentValue };
      const valueFormatted = valueSvc.formatValue(params.column, null, currentValue);
      const valueFormattedExits = valueFormatted !== null && valueFormatted !== void 0;
      option.text = valueFormattedExits ? valueFormatted : currentValue;
      eSelect.addOption(option);
      hasValue = hasValue || value === currentValue;
    });
    if (hasValue) {
      eSelect.setValue(params.value, true);
    } else if (params.values.length) {
      eSelect.setValue(params.values[0], true);
    }
    const { valueListGap, valueListMaxWidth, valueListMaxHeight } = params;
    if (valueListGap != null) {
      eSelect.setPickerGap(valueListGap);
    }
    if (valueListMaxHeight != null) {
      eSelect.setPickerMaxHeight(valueListMaxHeight);
    }
    if (valueListMaxWidth != null) {
      eSelect.setPickerMaxWidth(valueListMaxWidth);
    }
    if (gos.get("editType") !== "fullRow") {
      this.addManagedListeners(this.eSelect, { selectedItem: () => params.stopEditing() });
    }
  }
  afterGuiAttached() {
    if (this.focusAfterAttached) {
      this.eSelect.getFocusableElement().focus();
    }
    if (this.startedByEnter) {
      setTimeout(() => {
        if (this.isAlive()) {
          this.eSelect.showPicker();
        }
      });
    }
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return false;
  }
};

// packages/ag-grid-community/src/edit/cellEditors/textCellEditor.ts
var TextCellEditorInput = class {
  getTemplate() {
    return (
      /* html */
      `<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>`
    );
  }
  getAgComponents() {
    return [AgInputTextFieldSelector];
  }
  init(eInput, params) {
    this.eInput = eInput;
    this.params = params;
    const maxLength = params.maxLength;
    if (maxLength != null) {
      eInput.setMaxLength(maxLength);
    }
  }
  getValue() {
    const { eInput, params } = this;
    const value = eInput.getValue();
    if (!_exists(value) && !_exists(params.value)) {
      return params.value;
    }
    return params.parseValue(value);
  }
  getStartValue() {
    const params = this.params;
    const formatValue = params.useFormatter || params.column.getColDef().refData;
    return formatValue ? params.formatValue(params.value) : params.value;
  }
  setCaret() {
    const eInput = this.eInput;
    const value = eInput.getValue();
    const len = _exists(value) && value.length || 0;
    if (len) {
      eInput.getInputElement().setSelectionRange(len, len);
    }
  }
};
var TextCellEditor = class extends SimpleCellEditor {
  constructor() {
    super(new TextCellEditorInput());
  }
};

// packages/ag-grid-community/src/api/scrollApi.ts
function getVerticalPixelRange(beans) {
  return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
function getHorizontalPixelRange(beans) {
  return beans.ctrlsSvc.getScrollFeature().getHScrollPosition();
}
function ensureColumnVisible(beans, key, position = "auto") {
  beans.frameworkOverrides.wrapIncoming(
    () => beans.ctrlsSvc.getScrollFeature().ensureColumnVisible(key, position),
    "ensureVisible"
  );
}
function ensureIndexVisible(beans, index, position) {
  beans.frameworkOverrides.wrapIncoming(
    () => beans.ctrlsSvc.getScrollFeature().ensureIndexVisible(index, position),
    "ensureVisible"
  );
}
function ensureNodeVisible(beans, nodeSelector, position = null) {
  beans.frameworkOverrides.wrapIncoming(
    () => beans.ctrlsSvc.getScrollFeature().ensureNodeVisible(nodeSelector, position),
    "ensureVisible"
  );
}

// packages/ag-grid-community/src/edit/editApi.ts
function undoCellEditing(beans) {
  beans.undoRedo?.undo("api");
}
function redoCellEditing(beans) {
  beans.undoRedo?.redo("api");
}
function getCellEditorInstances(beans, params = {}) {
  const res = [];
  beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
    const cellEditor = cellCtrl.comp?.getCellEditor();
    if (cellEditor) {
      res.push(_unwrapUserComp(cellEditor));
    }
  });
  return res;
}
function getEditingCells(beans) {
  const res = [];
  beans.rowRenderer.getAllCellCtrls().forEach((cellCtrl) => {
    if (cellCtrl.editing) {
      const { cellPosition } = cellCtrl;
      res.push(cellPosition);
    }
  });
  return res;
}
function stopEditing(beans, cancel = false) {
  beans.editSvc?.stopAllEditing(cancel);
}
function startEditingCell(beans, params) {
  const column = beans.colModel.getCol(params.colKey);
  if (!column) {
    _warn(12, { colKey: params.colKey });
    return;
  }
  const cellPosition = {
    rowIndex: params.rowIndex,
    rowPinned: params.rowPinned || null,
    column
  };
  const notPinned = params.rowPinned == null;
  if (notPinned) {
    ensureIndexVisible(beans, params.rowIndex);
  }
  ensureColumnVisible(beans, params.colKey);
  const cell = _getCellByPosition(beans, cellPosition);
  if (!cell) {
    return;
  }
  const { focusSvc, gos, editSvc } = beans;
  const isFocusWithinCell = () => {
    const activeElement = _getActiveDomElement(beans);
    const eCell = cell.eGui;
    return activeElement !== eCell && !!eCell?.contains(activeElement);
  };
  const forceBrowserFocus = gos.get("stopEditingWhenCellsLoseFocus") && isFocusWithinCell();
  if (forceBrowserFocus || !focusSvc.isCellFocused(cellPosition)) {
    focusSvc.setFocusedCell({
      ...cellPosition,
      forceBrowserFocus,
      preventScrollOnBrowserFocus: true
    });
  }
  editSvc?.startRowOrCellEdit(cell, params.key);
}
function getCurrentUndoSize(beans) {
  return beans.undoRedo?.getCurrentUndoStackSize() ?? 0;
}
function getCurrentRedoSize(beans) {
  return beans.undoRedo?.getCurrentRedoStackSize() ?? 0;
}

// packages/ag-grid-community/src/edit/cellEditors/popupEditorWrapper.ts
var PopupEditorWrapper = class extends PopupComponent {
  constructor(params) {
    super(
      /* html */
      `<div class="ag-popup-editor" tabindex="-1"/>`
    );
    this.params = params;
  }
  postConstruct() {
    _setDomData(this.gos, this.getGui(), "popupEditorWrapper", true);
    this.addKeyDownListener();
  }
  addKeyDownListener() {
    const eGui = this.getGui();
    const params = this.params;
    const listener = (event) => {
      if (!_isUserSuppressingKeyboardEvent(this.gos, event, params.node, params.column, true)) {
        params.onKeyDown(event);
      }
    };
    this.addManagedElementListeners(eGui, { keydown: listener });
  }
};

// packages/ag-grid-community/src/edit/editService.ts
var EditService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "editSvc";
  }
  startEditing(cellCtrl, key = null, cellStartedEdit = false, event = null) {
    if (!cellCtrl.isCellEditable() || cellCtrl.editing) {
      return true;
    }
    if (!cellCtrl.comp) {
      cellCtrl.onCompAttachedFuncs.push(() => {
        this.startEditing(cellCtrl, key, cellStartedEdit, event);
      });
      return true;
    }
    const editorParams = this.createCellEditorParams(cellCtrl, key, cellStartedEdit);
    const colDef = cellCtrl.column.getColDef();
    const compDetails = _getCellEditorDetails(this.beans.userCompFactory, colDef, editorParams);
    const popup = compDetails?.popupFromSelector != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
    const position = compDetails?.popupPositionFromSelector != null ? compDetails.popupPositionFromSelector : colDef.cellEditorPopupPosition;
    setEditing(cellCtrl, true, compDetails);
    cellCtrl.comp.setEditDetails(compDetails, popup, position, this.gos.get("reactiveCustomComponents"));
    this.eventSvc.dispatchEvent(cellCtrl.createEvent(event, "cellEditingStarted"));
    return !compDetails?.params?.suppressPreventDefault;
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(cellCtrl, cancel = false) {
    cellCtrl.onEditorAttachedFuncs = [];
    if (!cellCtrl.editing) {
      return false;
    }
    const { comp: cellComp, column, rowNode } = cellCtrl;
    const { newValue, newValueExists } = takeValueFromCellEditor(cancel, cellComp);
    const oldValue = this.beans.valueSvc.getValueForDisplay(column, rowNode);
    let valueChanged = false;
    if (newValueExists) {
      valueChanged = saveNewValue(cellCtrl, oldValue, newValue, rowNode, column);
    }
    setEditing(cellCtrl, false, void 0);
    cellComp.setEditDetails();
    cellCtrl.updateAndFormatValue(false);
    cellCtrl.refreshCell({ forceRefresh: true, suppressFlash: true });
    this.eventSvc.dispatchEvent({
      ...cellCtrl.createEvent(null, "cellEditingStopped"),
      oldValue,
      newValue,
      valueChanged
    });
    return valueChanged;
  }
  handleColDefChanged(cellCtrl) {
    const cellEditor = cellCtrl.comp?.getCellEditor();
    if (cellEditor?.refresh) {
      const { eventKey, cellStartedEdit } = cellCtrl.editCompDetails.params;
      const editorParams = this.createCellEditorParams(cellCtrl, eventKey, cellStartedEdit);
      const colDef = cellCtrl.column.getColDef();
      const compDetails = _getCellEditorDetails(this.beans.userCompFactory, colDef, editorParams);
      cellEditor.refresh(compDetails.params);
    }
  }
  setFocusOutOnEditor(cellCtrl) {
    if (!cellCtrl.editing) {
      return;
    }
    const cellEditor = cellCtrl.comp.getCellEditor();
    if (cellEditor && cellEditor.focusOut) {
      cellEditor.focusOut();
    }
  }
  setFocusInOnEditor(cellCtrl) {
    if (!cellCtrl.editing) {
      return;
    }
    const cellComp = cellCtrl.comp;
    const cellEditor = cellComp.getCellEditor();
    if (cellEditor?.focusIn) {
      cellEditor.focusIn();
    } else {
      cellCtrl.focusCell(true);
      cellCtrl.onEditorAttachedFuncs.push(() => cellComp.getCellEditor()?.focusIn?.());
    }
  }
  stopEditingAndFocus(cellCtrl, suppressNavigateAfterEdit = false, shiftKey = false) {
    this.stopRowOrCellEdit(cellCtrl);
    cellCtrl.focusCell(true);
    if (!suppressNavigateAfterEdit) {
      this.navigateAfterEdit(shiftKey, cellCtrl.cellPosition);
    }
  }
  createPopupEditorWrapper(params) {
    return new PopupEditorWrapper(params);
  }
  stopAllEditing(cancel = false) {
    this.beans.rowRenderer.getAllRowCtrls().forEach((rowCtrl) => this.stopRowEditing(rowCtrl, cancel));
  }
  stopRowEditing(rowCtrl, cancel = false) {
    if (rowCtrl.stoppingRowEdit) {
      return;
    }
    const cellControls = rowCtrl.getAllCellCtrls();
    const isRowEdit = rowCtrl.editing;
    rowCtrl.stoppingRowEdit = true;
    let fireRowEditEvent = false;
    for (const ctrl of cellControls) {
      const valueChanged = ctrl.stopEditing(cancel);
      if (isRowEdit && !cancel && !fireRowEditEvent && valueChanged) {
        fireRowEditEvent = true;
      }
    }
    if (fireRowEditEvent) {
      this.eventSvc.dispatchEvent(rowCtrl.createRowEvent("rowValueChanged"));
    }
    if (isRowEdit) {
      this.beans.rowEditSvc?.setEditing(rowCtrl, false);
    }
    rowCtrl.stoppingRowEdit = false;
  }
  addStopEditingWhenGridLosesFocus(viewports) {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus")) {
      return;
    }
    const focusOutListener = (event) => {
      const elementWithFocus = event.relatedTarget;
      if (_getTabIndex(elementWithFocus) === null) {
        this.stopAllEditing();
        return;
      }
      let clickInsideGrid = (
        // see if click came from inside the viewports
        viewports.some((viewport) => viewport.contains(elementWithFocus)) && // and also that it's not from a detail grid
        _isElementInThisGrid(this.gos, elementWithFocus)
      );
      if (!clickInsideGrid) {
        const popupSvc = this.beans.popupSvc;
        clickInsideGrid = !!popupSvc && (popupSvc.getActivePopups().some((popup) => popup.contains(elementWithFocus)) || popupSvc.isElementWithinCustomPopup(elementWithFocus));
      }
      if (!clickInsideGrid) {
        this.stopAllEditing();
      }
    };
    viewports.forEach((viewport) => this.addManagedElementListeners(viewport, { focusout: focusOutListener }));
  }
  setInlineEditingCss(rowCtrl) {
    const editing = rowCtrl.editing || rowCtrl.getAllCellCtrls().some((cellCtrl) => cellCtrl.editing);
    rowCtrl.forEachGui(void 0, (gui) => {
      gui.rowComp.addOrRemoveCssClass("ag-row-inline-editing", editing);
      gui.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !editing);
    });
  }
  isCellEditable(column, rowNode) {
    if (rowNode.group) {
      if (this.gos.get("treeData")) {
        if (!rowNode.data && !this.gos.get("enableGroupEdit")) {
          return false;
        }
      } else {
        if (!this.gos.get("enableGroupEdit")) {
          return false;
        }
      }
    }
    return column.isColumnFunc(rowNode, column.colDef.editable);
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(cellCtrl, key, event = null) {
    if (!cellCtrl.comp) {
      cellCtrl.onCompAttachedFuncs.push(() => {
        this.startRowOrCellEdit(cellCtrl, key, event);
      });
      return true;
    }
    if (this.gos.get("editType") === "fullRow") {
      return this.beans.rowEditSvc?.startEditing(cellCtrl.rowCtrl, key, cellCtrl) ?? true;
    } else {
      return this.startEditing(cellCtrl, key, true, event);
    }
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(cellCtrl, cancel = false) {
    if (this.gos.get("editType") === "fullRow") {
      this.stopRowEditing(cellCtrl.rowCtrl, cancel);
    } else {
      this.stopEditing(cellCtrl, cancel);
    }
  }
  createCellEditorParams(cellCtrl, key, cellStartedEdit) {
    const {
      column,
      rowNode,
      eGui,
      cellPosition: { rowIndex }
    } = cellCtrl;
    const { valueSvc, gos } = this.beans;
    return gos.addGridCommonParams({
      value: valueSvc.getValueForDisplay(column, rowNode),
      eventKey: key,
      column,
      colDef: column.getColDef(),
      rowIndex,
      node: rowNode,
      data: rowNode.data,
      cellStartedEdit,
      onKeyDown: cellCtrl.onKeyDown.bind(cellCtrl),
      stopEditing: cellCtrl.stopEditingAndFocus.bind(cellCtrl),
      eGridCell: eGui,
      parseValue: (newValue) => valueSvc.parseValue(column, rowNode, newValue, cellCtrl.value),
      formatValue: cellCtrl.formatValue.bind(cellCtrl)
    });
  }
  navigateAfterEdit(shiftKey, cellPosition) {
    const enterNavigatesVerticallyAfterEdit = this.gos.get("enterNavigatesVerticallyAfterEdit");
    if (enterNavigatesVerticallyAfterEdit) {
      const key = shiftKey ? KeyCode.UP : KeyCode.DOWN;
      this.beans.navigation?.navigateToNextCell(null, key, cellPosition, false);
    }
  }
};
function setEditing(cellCtrl, editing, compDetails) {
  cellCtrl.editCompDetails = compDetails;
  if (cellCtrl.editing === editing) {
    return;
  }
  cellCtrl.editing = editing;
}
function takeValueFromCellEditor(cancel, cellComp) {
  const noValueResult = { newValueExists: false };
  if (cancel) {
    return noValueResult;
  }
  const cellEditor = cellComp.getCellEditor();
  if (!cellEditor) {
    return noValueResult;
  }
  const userWantsToCancel = cellEditor.isCancelAfterEnd && cellEditor.isCancelAfterEnd();
  if (userWantsToCancel) {
    return noValueResult;
  }
  const newValue = cellEditor.getValue();
  return {
    newValue,
    newValueExists: true
  };
}
function saveNewValue(cellCtrl, oldValue, newValue, rowNode, column) {
  if (newValue === oldValue) {
    return false;
  }
  cellCtrl.suppressRefreshCell = true;
  const valueChanged = rowNode.setDataValue(column, newValue, "edit");
  cellCtrl.suppressRefreshCell = false;
  return valueChanged;
}

// packages/ag-grid-community/src/edit/rowEditService.ts
var RowEditService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowEditSvc";
  }
  startEditing(rowCtrl, key = null, sourceRenderedCell = null, event = null) {
    if (rowCtrl.editing) {
      return true;
    }
    let preventDefault = true;
    let atLeastOneEditing = false;
    const { editSvc } = this.beans;
    rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
      const cellStartedEdit = cellCtrl === sourceRenderedCell;
      if (cellStartedEdit) {
        preventDefault = editSvc?.startEditing(cellCtrl, key, cellStartedEdit, event) ?? true;
      } else {
        editSvc?.startEditing(cellCtrl, null, cellStartedEdit, event);
      }
      atLeastOneEditing || (atLeastOneEditing = cellCtrl.editing);
    });
    if (atLeastOneEditing) {
      this.setEditing(rowCtrl, true);
    }
    return preventDefault;
  }
  setEditing(rowCtrl, value) {
    rowCtrl.editing = value;
    rowCtrl.forEachGui(void 0, (gui) => gui.rowComp.addOrRemoveCssClass("ag-row-editing", value));
    const event = value ? rowCtrl.createRowEvent("rowEditingStarted") : rowCtrl.createRowEvent("rowEditingStopped");
    this.eventSvc.dispatchEvent(event);
  }
};

// packages/ag-grid-community/src/edit/editModule.ts
var EditCoreModule = {
  moduleName: "EditCore",
  version: VERSION,
  beans: [EditService, RowEditService],
  apiFunctions: {
    getCellEditorInstances,
    getEditingCells,
    stopEditing,
    startEditingCell
  },
  dependsOn: [PopupModule],
  css: [cellEditingCSS]
};
var UndoRedoEditModule = {
  moduleName: "UndoRedoEdit",
  version: VERSION,
  beans: [UndoRedoService],
  apiFunctions: {
    undoCellEditing,
    redoCellEditing,
    getCurrentUndoSize,
    getCurrentRedoSize
  },
  dependsOn: [EditCoreModule]
};
var TextEditorModule = {
  moduleName: "TextEditor",
  version: VERSION,
  userComponents: { agCellEditor: TextCellEditor, agTextCellEditor: TextCellEditor },
  dependsOn: [EditCoreModule]
};
var NumberEditorModule = {
  moduleName: "NumberEditor",
  version: VERSION,
  userComponents: {
    agNumberCellEditor: {
      classImp: NumberCellEditor,
      params: {
        suppressPreventDefault: true
      }
    }
  },
  dependsOn: [EditCoreModule]
};
var DateEditorModule = {
  moduleName: "DateEditor",
  version: VERSION,
  userComponents: {
    agDateCellEditor: DateCellEditor,
    agDateStringCellEditor: DateStringCellEditor
  },
  dependsOn: [EditCoreModule]
};
var CheckboxEditorModule = {
  moduleName: "CheckboxEditor",
  version: VERSION,
  userComponents: {
    agCheckboxCellEditor: CheckboxCellEditor
  },
  dependsOn: [EditCoreModule]
};
var SelectEditorModule = {
  moduleName: "SelectEditor",
  version: VERSION,
  userComponents: { agSelectCellEditor: SelectCellEditor },
  dependsOn: [EditCoreModule]
};
var LargeTextEditorModule = {
  moduleName: "LargeTextEditor",
  version: VERSION,
  userComponents: { agLargeTextCellEditor: LargeTextCellEditor },
  dependsOn: [EditCoreModule]
};
var CustomEditorModule = {
  moduleName: "CustomEditor",
  version: VERSION,
  dependsOn: [EditCoreModule]
};

// packages/ag-grid-community/src/selection/rowSelectionApi.ts
function setNodesSelected(beans, params) {
  const allNodesValid = params.nodes.every((node) => {
    if (node.rowPinned) {
      _warn(59);
      return false;
    }
    if (node.id === void 0) {
      _warn(60);
      return false;
    }
    return true;
  });
  if (!allNodesValid) {
    return;
  }
  const { nodes, source, newValue } = params;
  const nodesAsRowNode = nodes;
  beans.selectionSvc?.setNodesSelected({ nodes: nodesAsRowNode, source: source ?? "api", newValue });
}
function selectAll(beans, selectAll2, source = "apiSelectAll") {
  beans.selectionSvc?.selectAllRowNodes({ source, selectAll: selectAll2 });
}
function deselectAll(beans, selectAll2, source = "apiSelectAll") {
  beans.selectionSvc?.deselectAllRowNodes({ source, selectAll: selectAll2 });
}
function selectAllFiltered(beans, source = "apiSelectAllFiltered") {
  beans.selectionSvc?.selectAllRowNodes({ source, selectAll: "filtered" });
}
function deselectAllFiltered(beans, source = "apiSelectAllFiltered") {
  beans.selectionSvc?.deselectAllRowNodes({ source, selectAll: "filtered" });
}
function selectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
  beans.selectionSvc?.selectAllRowNodes({ source, selectAll: "currentPage" });
}
function deselectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
  beans.selectionSvc?.deselectAllRowNodes({ source, selectAll: "currentPage" });
}
function getSelectedNodes(beans) {
  return beans.selectionSvc?.getSelectedNodes() ?? [];
}
function getSelectedRows(beans) {
  return beans.selectionSvc?.getSelectedRows() ?? [];
}

// packages/ag-grid-community/src/selection/selectionService.ts
var SelectionService = class extends BaseSelectionService {
  constructor() {
    super(...arguments);
    this.beanName = "selectionSvc";
    this.selectedNodes = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    super.postConstruct();
    const { gos } = this;
    this.mode = _getRowSelectionMode(gos);
    this.groupSelectsDescendants = _getGroupSelectsDescendants(gos);
    this.groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
    this.addManagedPropertyListeners(["groupSelectsChildren", "groupSelectsFiltered", "rowSelection"], () => {
      const groupSelectsDescendants = _getGroupSelectsDescendants(gos);
      const selectionMode = _getRowSelectionMode(gos);
      const groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
      if (groupSelectsDescendants !== this.groupSelectsDescendants || groupSelectsFiltered !== this.groupSelectsFiltered || selectionMode !== this.mode) {
        this.deselectAllRowNodes({ source: "api" });
        this.groupSelectsDescendants = groupSelectsDescendants;
        this.groupSelectsFiltered = groupSelectsFiltered;
        this.mode = selectionMode;
      }
    });
    this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
  }
  destroy() {
    super.destroy();
    this.resetNodes();
  }
  handleSelectionEvent(event, rowNode, source) {
    if (this.isRowSelectionBlocked(rowNode))
      return 0;
    const selection = this.inferNodeSelections(rowNode, event.shiftKey, event.metaKey || event.ctrlKey, source);
    if (selection == null) {
      return 0;
    }
    if ("select" in selection) {
      if (selection.reset) {
        this.resetNodes();
      } else {
        this.selectRange(selection.deselect, false, source);
      }
      return this.selectRange(selection.select, true, source);
    } else {
      return this.setNodesSelected({
        nodes: [selection.node],
        newValue: selection.newValue,
        clearSelection: selection.clearSelection,
        event,
        source
      });
    }
  }
  setNodesSelected({
    newValue,
    clearSelection,
    suppressFinishActions,
    nodes,
    event,
    source
  }) {
    if (!_isRowSelection(this.gos) && newValue) {
      _warn(132);
      return 0;
    }
    if (nodes.length === 0)
      return 0;
    if (nodes.length > 1 && !this.isMultiSelect()) {
      _warn(130);
      return 0;
    }
    let updatedCount = 0;
    for (let i = 0; i < nodes.length; i++) {
      const rowNode = nodes[i];
      const node = rowNode.footer ? rowNode.sibling : rowNode;
      const skipThisNode = this.groupSelectsFiltered && node.group;
      if (node.rowPinned) {
        _warn(59);
        continue;
      }
      if (node.id === void 0) {
        _warn(60);
        continue;
      }
      if (!skipThisNode) {
        const thisNodeWasSelected = this.selectRowNode(node, newValue, event, source);
        if (thisNodeWasSelected) {
          updatedCount++;
        }
      }
      if (this.groupSelectsDescendants && node.childrenAfterGroup?.length) {
        updatedCount += this.selectChildren(node, newValue, source);
      }
    }
    if (!suppressFinishActions) {
      const clearOtherNodes = newValue && (clearSelection || !this.isMultiSelect());
      if (clearOtherNodes) {
        updatedCount += this.clearOtherNodes(nodes[0], source);
      }
      if (updatedCount > 0) {
        this.updateGroupsFromChildrenSelections(source);
        this.dispatchSelectionChanged(source);
      }
    }
    return updatedCount;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(nodesToSelect, value, source) {
    let updatedCount = 0;
    nodesToSelect.forEach((rowNode) => {
      if (rowNode.group && this.groupSelectsDescendants) {
        return;
      }
      const nodeWasSelected = this.selectRowNode(rowNode, value, void 0, source);
      if (nodeWasSelected) {
        updatedCount++;
      }
    });
    if (updatedCount > 0) {
      this.updateGroupsFromChildrenSelections(source);
      this.dispatchSelectionChanged(source);
    }
    return updatedCount;
  }
  selectChildren(node, newValue, source) {
    const children = this.groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
    if (!children) {
      return 0;
    }
    return this.setNodesSelected({
      newValue,
      clearSelection: false,
      suppressFinishActions: true,
      source,
      nodes: children
    });
  }
  getSelectedNodes() {
    return Array.from(this.selectedNodes.values());
  }
  getSelectedRows() {
    const selectedRows = [];
    this.selectedNodes.forEach((rowNode) => selectedRows.push(rowNode.data));
    return selectedRows;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(predicate) {
    const newSelectedNodes = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((rowNode, key) => {
      if (predicate(rowNode)) {
        newSelectedNodes.set(key, rowNode);
      }
    });
    this.selectedNodes = newSelectedNodes;
  }
  updateGroupsFromChildrenSelections(source, changedPath) {
    if (!this.groupSelectsDescendants) {
      return false;
    }
    const { gos, rowModel } = this.beans;
    if (!_isClientSideRowModel(gos, rowModel)) {
      return false;
    }
    const rootNode = rowModel.rootNode;
    if (!rootNode) {
      return false;
    }
    if (!changedPath) {
      changedPath = new ChangedPath(true, rootNode);
      changedPath.active = false;
    }
    let selectionChanged = false;
    changedPath.forEachChangedNodeDepthFirst((rowNode) => {
      if (rowNode !== rootNode) {
        const selected = this.calculateSelectedFromChildren(rowNode);
        selectionChanged = this.selectRowNode(rowNode, selected === null ? false : selected, void 0, source) || selectionChanged;
      }
    });
    return selectionChanged;
  }
  clearOtherNodes(rowNodeToKeepSelected, source) {
    const groupsToRefresh = /* @__PURE__ */ new Map();
    let updatedCount = 0;
    this.selectedNodes.forEach((otherRowNode) => {
      if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
        const rowNode = this.selectedNodes.get(otherRowNode.id);
        updatedCount += this.setNodesSelected({
          nodes: [rowNode],
          newValue: false,
          clearSelection: false,
          suppressFinishActions: true,
          source
        });
        if (this.groupSelectsDescendants && otherRowNode.parent) {
          groupsToRefresh.set(otherRowNode.parent.id, otherRowNode.parent);
        }
      }
    });
    groupsToRefresh.forEach((group) => {
      const selected = this.calculateSelectedFromChildren(group);
      this.selectRowNode(group, selected === null ? false : selected, void 0, source);
    });
    return updatedCount;
  }
  onRowSelected(event) {
    const rowNode = event.node;
    if (this.groupSelectsDescendants && rowNode.group) {
      return;
    }
    if (rowNode.isSelected()) {
      this.selectedNodes.set(rowNode.id, rowNode);
    } else {
      this.selectedNodes.delete(rowNode.id);
    }
  }
  syncInRowNode(rowNode, oldNode) {
    this.syncInOldRowNode(rowNode, oldNode);
    this.syncInNewRowNode(rowNode);
  }
  createDaemonNode(rowNode) {
    if (!rowNode.id) {
      return void 0;
    }
    const oldNode = new RowNode(this.beans);
    oldNode.id = rowNode.id;
    oldNode.data = rowNode.data;
    oldNode.__daemon = true;
    oldNode.__selected = rowNode.__selected;
    oldNode.level = rowNode.level;
    return oldNode;
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(rowNode, oldNode) {
    if (oldNode && rowNode.id !== oldNode.id) {
      const oldNodeSelected = this.selectedNodes.get(oldNode.id) == rowNode;
      if (oldNodeSelected) {
        this.selectedNodes.set(oldNode.id, oldNode);
      }
    }
  }
  syncInNewRowNode(rowNode) {
    if (this.selectedNodes.has(rowNode.id)) {
      rowNode.__selected = true;
      this.selectedNodes.set(rowNode.id, rowNode);
    } else {
      rowNode.__selected = false;
    }
  }
  reset(source) {
    const selectionCount = this.getSelectionCount();
    this.resetNodes();
    if (selectionCount) {
      this.dispatchSelectionChanged(source);
    }
  }
  resetNodes() {
    this.selectedNodes.forEach((node) => {
      this.selectRowNode(node, false);
    });
    this.selectedNodes.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    const { gos, rowModel } = this.beans;
    if (!_isClientSideRowModel(gos, rowModel)) {
      return;
    }
    const topLevelNodes = rowModel.getTopLevelNodes();
    if (topLevelNodes === null) {
      return;
    }
    const result = [];
    function traverse(nodes) {
      for (let i = 0, l = nodes.length; i < l; i++) {
        const node = nodes[i];
        if (node.isSelected()) {
          result.push(node);
        } else {
          if (node.group && node.childrenAfterGroup) {
            traverse(node.childrenAfterGroup);
          }
        }
      }
    }
    traverse(topLevelNodes);
    return result;
  }
  isEmpty() {
    return this.getSelectionCount() === 0;
  }
  deselectAllRowNodes(params) {
    const callback = (rowNode) => this.selectRowNode(rowNode.footer ? rowNode.sibling : rowNode, false, void 0, source);
    const rowModelClientSide = _isClientSideRowModel(this.gos);
    const { source, selectAll: selectAll2 } = params;
    if (selectAll2 === "currentPage" || selectAll2 === "filtered") {
      if (!rowModelClientSide) {
        _error(102);
        return;
      }
      this.getNodesToSelect(selectAll2).forEach(callback);
    } else {
      this.selectedNodes.forEach(callback);
      this.reset(source);
    }
    if (rowModelClientSide && this.groupSelectsDescendants) {
      this.updateGroupsFromChildrenSelections(source);
    }
    this.dispatchSelectionChanged(source);
  }
  getSelectedCounts(selectAll2) {
    let selectedCount = 0;
    let notSelectedCount = 0;
    const callback = (node) => {
      if (this.groupSelectsDescendants && node.group) {
        return;
      }
      if (node.isSelected()) {
        selectedCount++;
      } else if (!node.selectable) {
      } else {
        notSelectedCount++;
      }
    };
    this.getNodesToSelect(selectAll2).forEach(callback);
    return { selectedCount, notSelectedCount };
  }
  getSelectAllState(selectAll2) {
    const { selectedCount, notSelectedCount } = this.getSelectedCounts(selectAll2);
    if (selectedCount === 0 && notSelectedCount === 0) {
      return false;
    }
    if (selectedCount > 0 && notSelectedCount > 0) {
      return null;
    }
    return selectedCount > 0;
  }
  hasNodesToSelect(selectAll2) {
    return this.getNodesToSelect(selectAll2).filter((node) => node.selectable).length > 0;
  }
  /**
   * @param selectAll See `MultiRowSelectionOptions.selectAll`
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(selectAll2) {
    if (!this.canSelectAll()) {
      return [];
    }
    const nodes = [];
    if (selectAll2 === "currentPage") {
      this.forEachNodeOnPage((node) => {
        if (!node.group) {
          nodes.push(node);
          return;
        }
        if (!node.expanded && !node.footer) {
          const recursivelyAddChildren = (child) => {
            nodes.push(child);
            if (child.childrenAfterFilter?.length) {
              child.childrenAfterFilter.forEach(recursivelyAddChildren);
            }
          };
          recursivelyAddChildren(node);
          return;
        }
        if (!this.groupSelectsDescendants) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    const clientSideRowModel = this.beans.rowModel;
    if (selectAll2 === "filtered") {
      clientSideRowModel.forEachNodeAfterFilter((node) => {
        nodes.push(node);
      });
      return nodes;
    }
    clientSideRowModel.forEachNode((node) => {
      nodes.push(node);
    });
    return nodes;
  }
  forEachNodeOnPage(callback) {
    const { pageBounds, rowModel } = this.beans;
    const firstRow = pageBounds.getFirstRow();
    const lastRow = pageBounds.getLastRow();
    for (let i = firstRow; i <= lastRow; i++) {
      const node = rowModel.getRow(i);
      if (node) {
        callback(node);
      }
    }
  }
  selectAllRowNodes(params) {
    const { gos } = this;
    if (!_isRowSelection(gos)) {
      _warn(132);
      return;
    }
    if (_isUsingNewRowSelectionAPI(gos) && !_isMultiRowSelection(gos)) {
      _warn(130);
      return;
    }
    if (!this.canSelectAll()) {
      return;
    }
    const { source, selectAll: selectAll2 } = params;
    this.getNodesToSelect(selectAll2).forEach((rowNode) => {
      this.selectRowNode(rowNode.footer ? rowNode.sibling : rowNode, true, void 0, source);
    });
    if (_isClientSideRowModel(gos) && this.groupSelectsDescendants) {
      this.updateGroupsFromChildrenSelections(source);
    }
    this.dispatchSelectionChanged(source);
  }
  getSelectionState() {
    const selectedIds = [];
    this.selectedNodes.forEach((node) => {
      if (node?.id) {
        selectedIds.push(node.id);
      }
    });
    return selectedIds.length ? selectedIds : null;
  }
  setSelectionState(state, source) {
    if (!Array.isArray(state)) {
      _error(103);
      return;
    }
    const rowIds = new Set(state);
    const nodes = [];
    this.beans.rowModel.forEachNode((node) => {
      if (rowIds.has(node.id)) {
        nodes.push(node);
      }
    });
    this.setNodesSelected({
      newValue: true,
      nodes,
      source
    });
  }
  canSelectAll() {
    const { gos, rowModel } = this.beans;
    if (!_isClientSideRowModel(gos)) {
      _error(100, { rowModelType: rowModel.getType() });
      return false;
    }
    return true;
  }
  /**
   * Updates the selectable state for a node by invoking isRowSelectable callback.
   * If the node is not selectable, it will be deselected.
   *
   * Callers:
   *  - property isRowSelectable changed
   *  - after grouping / treeData via `updateSelectableAfterGrouping`
   */
  updateSelectable(changedPath) {
    const { gos, rowModel } = this.beans;
    if (!_isRowSelection(gos)) {
      return;
    }
    const source = "selectableChanged";
    const skipLeafNodes = changedPath !== void 0;
    const isCSRMGroupSelectsDescendants = _isClientSideRowModel(gos) && this.groupSelectsDescendants;
    const nodesToDeselect = [];
    const nodeCallback = (node) => {
      if (skipLeafNodes && !node.group) {
        return;
      }
      if (isCSRMGroupSelectsDescendants && node.group) {
        const hasSelectableChild = node.childrenAfterGroup?.some((rowNode) => rowNode.selectable) ?? false;
        this.setRowSelectable(node, hasSelectableChild, true);
        return;
      }
      const rowSelectable = this.updateRowSelectable(node, true);
      if (!rowSelectable && node.isSelected()) {
        nodesToDeselect.push(node);
      }
    };
    if (isCSRMGroupSelectsDescendants) {
      if (changedPath === void 0) {
        const rootNode = rowModel.rootNode;
        changedPath = rootNode ? new ChangedPath(false, rootNode) : void 0;
      }
      changedPath?.forEachChangedNodeDepthFirst(nodeCallback, !skipLeafNodes, !skipLeafNodes);
    } else {
      rowModel.forEachNode(nodeCallback);
    }
    if (nodesToDeselect.length) {
      this.setNodesSelected({
        nodes: nodesToDeselect,
        newValue: false,
        source
      });
    }
    if (!skipLeafNodes && isCSRMGroupSelectsDescendants) {
      this.updateGroupsFromChildrenSelections?.(source);
    }
  }
  // only called by CSRM
  updateSelectableAfterGrouping(changedPath) {
    this.updateSelectable(changedPath);
    if (this.groupSelectsDescendants) {
      const selectionChanged = this.updateGroupsFromChildrenSelections?.("rowGroupChanged", changedPath);
      if (selectionChanged) {
        this.eventSvc.dispatchEvent({
          type: "selectionChanged",
          source: "rowGroupChanged"
        });
      }
    }
  }
};

// packages/ag-grid-community/src/selection/rowSelectionModule.ts
var SharedRowSelectionModule = {
  moduleName: "SharedRowSelection",
  version: VERSION,
  beans: [SelectionColService],
  apiFunctions: {
    setNodesSelected,
    selectAll,
    deselectAll,
    selectAllFiltered,
    deselectAllFiltered,
    selectAllOnCurrentPage,
    deselectAllOnCurrentPage,
    getSelectedNodes,
    getSelectedRows
  }
};
var RowSelectionModule = {
  moduleName: "RowSelection",
  version: VERSION,
  rowModels: ["clientSide", "infinite", "viewport"],
  beans: [SelectionService],
  dependsOn: [SharedRowSelectionModule]
};

// packages/ag-grid-community/src/api/csrmSsrmSharedApi.ts
function expandAll(beans) {
  beans.expansionSvc?.expandAll(true);
}
function collapseAll(beans) {
  beans.expansionSvc?.expandAll(false);
}
function onRowHeightChanged(beans) {
  const clientSideRowModel = _getClientSideRowModel(beans);
  const serverSideRowModel = _getServerSideRowModel(beans);
  if (clientSideRowModel) {
    clientSideRowModel.onRowHeightChanged();
  } else if (serverSideRowModel) {
    serverSideRowModel.onRowHeightChanged();
  }
}

// packages/ag-grid-community/src/api/ssrmInfiniteSharedApi.ts
function setRowCount(beans, rowCount, maxRowFound) {
  const serverSideRowModel = _getServerSideRowModel(beans);
  if (serverSideRowModel) {
    if (beans.rowGroupColsSvc?.columns.length === 0) {
      if (rowCount < 0) {
        _error(238);
        return;
      }
      serverSideRowModel.setRowCount(rowCount, maxRowFound);
      return;
    }
    _error(28);
    return;
  }
  const infiniteRowModel = _getInfiniteRowModel(beans);
  if (infiniteRowModel) {
    infiniteRowModel.setRowCount(rowCount, maxRowFound);
    return;
  }
}
function getCacheBlockState(beans) {
  if (_isServerSideRowModel(beans.gos)) {
    const ssrm = beans.rowModel;
    return ssrm.getBlockStates();
  }
  return beans.rowNodeBlockLoader?.getBlockState() ?? {};
}
function isLastRowIndexKnown(beans) {
  return beans.rowModel.isLastRowIndexKnown();
}

// packages/ag-grid-community/src/api/sharedApiModule.ts
var CsrmSsrmSharedApiModule = {
  moduleName: "CsrmSsrmSharedApi",
  version: VERSION,
  apiFunctions: {
    expandAll,
    collapseAll,
    onRowHeightChanged
  }
};
var SsrmInfiniteSharedApiModule = {
  moduleName: "SsrmInfiniteSharedApi",
  version: VERSION,
  apiFunctions: {
    setRowCount,
    getCacheBlockState,
    isLastRowIndexKnown
  }
};

// packages/ag-grid-community/src/alignedGrids/alignedGridsService.ts
var AlignedGridsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "alignedGridsSvc";
    // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master
    // while processing a master event) we mark this if consuming an event, and if we are, then
    // we don't fire back any events.
    this.consuming = false;
  }
  getAlignedGridApis() {
    let alignedGrids = this.gos.get("alignedGrids") ?? [];
    const isCallbackConfig = typeof alignedGrids === "function";
    if (typeof alignedGrids === "function") {
      alignedGrids = alignedGrids();
    }
    const apis = alignedGrids.map((alignedGrid) => {
      if (!alignedGrid) {
        _error(18);
        if (!isCallbackConfig) {
          _error(20);
        }
        return;
      }
      if (this.isGridApi(alignedGrid)) {
        return alignedGrid;
      }
      const refOrComp = alignedGrid;
      if ("current" in refOrComp) {
        return refOrComp.current?.api;
      }
      if (!refOrComp.api) {
        _error(19);
      }
      return refOrComp.api;
    }).filter((api) => !!api && !api.isDestroyed());
    return apis;
  }
  isGridApi(ref) {
    return !!ref && !!ref.dispatchEvent;
  }
  postConstruct() {
    const fireColumnEvent = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: fireColumnEvent,
      columnVisible: fireColumnEvent,
      columnPinned: fireColumnEvent,
      columnGroupOpened: fireColumnEvent,
      columnResized: fireColumnEvent,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event }) => this.onColumnEvent(event),
      alignedGridScroll: ({ event }) => this.onScrollEvent(event)
    });
  }
  // common logic across all the fire methods
  fireEvent(event) {
    if (this.consuming) {
      return;
    }
    this.getAlignedGridApis().forEach((api) => {
      if (api.isDestroyed()) {
        return;
      }
      api.dispatchEvent(event);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(callback) {
    this.consuming = true;
    callback();
    this.consuming = false;
  }
  fireColumnEvent(columnEvent) {
    this.fireEvent({
      type: "alignedGridColumn",
      event: columnEvent
    });
  }
  fireScrollEvent(scrollEvent) {
    if (scrollEvent.direction !== "horizontal") {
      return;
    }
    this.fireEvent({
      type: "alignedGridScroll",
      event: scrollEvent
    });
  }
  onScrollEvent(event) {
    this.onEvent(() => {
      this.beans.ctrlsSvc.getScrollFeature().setHorizontalScrollPosition(event.left, true);
    });
  }
  extractDataFromEvent(event, func) {
    const result = [];
    if (event.columns) {
      event.columns.forEach((column) => {
        result.push(func(column));
      });
    } else if (event.column) {
      result.push(func(event.column));
    }
    return result;
  }
  getMasterColumns(event) {
    return this.extractDataFromEvent(event, (col) => col);
  }
  getColumnIds(event) {
    return this.extractDataFromEvent(event, (col) => col.getColId());
  }
  onColumnEvent(event) {
    this.onEvent(() => {
      switch (event.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          this.processColumnEvent(event);
          break;
        }
        case "columnGroupOpened": {
          this.processGroupOpenedEvent(event);
          break;
        }
        case "columnPivotChanged":
          _warn(21);
          break;
      }
    });
  }
  processGroupOpenedEvent(groupOpenedEvent) {
    const { colGroupSvc } = this.beans;
    if (!colGroupSvc) {
      return;
    }
    groupOpenedEvent.columnGroups.forEach((masterGroup) => {
      let otherColumnGroup = null;
      if (masterGroup) {
        otherColumnGroup = colGroupSvc.getProvidedColGroup(masterGroup.getGroupId());
      }
      if (masterGroup && !otherColumnGroup) {
        return;
      }
      colGroupSvc.setColumnGroupOpened(otherColumnGroup, masterGroup.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(colEvent) {
    const masterColumn = colEvent.column;
    let otherColumn = null;
    const beans = this.beans;
    const { colResize, ctrlsSvc, colModel } = beans;
    if (masterColumn) {
      otherColumn = colModel.getColDefCol(masterColumn.getColId());
    }
    if (masterColumn && !otherColumn) {
      return;
    }
    const masterColumns = this.getMasterColumns(colEvent);
    switch (colEvent.type) {
      case "columnMoved":
        {
          const srcColState = colEvent.api.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId }));
          _applyColumnState(beans, { state: destColState, applyOrder: true }, "alignedGridChanged");
        }
        break;
      case "columnVisible":
        {
          const srcColState = colEvent.api.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId, hide: s.hide }));
          _applyColumnState(beans, { state: destColState }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const srcColState = colEvent.api.getColumnState();
          const destColState = srcColState.map((s) => ({ colId: s.colId, pinned: s.pinned }));
          _applyColumnState(beans, { state: destColState }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const resizedEvent = colEvent;
        const columnWidths = {};
        masterColumns.forEach((column) => {
          columnWidths[column.getId()] = { key: column.getColId(), newWidth: column.getActualWidth() };
        });
        resizedEvent.flexColumns?.forEach((col) => {
          if (columnWidths[col.getId()]) {
            delete columnWidths[col.getId()];
          }
        });
        colResize?.setColumnWidths(
          Object.values(columnWidths),
          false,
          resizedEvent.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const gridBodyCon = ctrlsSvc.getGridBodyCtrl();
    const isVerticalScrollShowing = gridBodyCon.isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((api) => {
      api.setGridOption("alwaysShowVerticalScroll", isVerticalScrollShowing);
    });
  }
};

// packages/ag-grid-community/src/alignedGrids/alignedGridsModule.ts
var AlignedGridsModule = {
  moduleName: "AlignedGrids",
  version: VERSION,
  beans: [AlignedGridsService]
};

// packages/ag-grid-community/src/clientSideRowModel/clientSideNodeManager.ts
var ClientSideNodeManager = class extends AbstractClientSideNodeManager {
  constructor() {
    super(...arguments);
    this.beanName = "csrmNodeSvc";
  }
};

// packages/ag-grid-community/src/clientSideRowModel/changedRowNodes.ts
var ChangedRowNodes = class {
  constructor() {
    this.removals = /* @__PURE__ */ new Set();
    this.updates = /* @__PURE__ */ new Map();
  }
  /** Marks a row as removed. Order of operations is: remove, update, add */
  remove(node) {
    this.removals.add(node);
    this.updates.delete(node);
  }
  /** Marks a row as updated. Order of operations is: remove, update, add */
  update(node) {
    const updates = this.updates;
    if (!updates.has(node)) {
      this.removals.delete(node);
      this.updates.set(node, false);
    }
  }
  /** Marks a row as added. Order of operation is: remove, update, add */
  add(node) {
    this.removals.delete(node);
    this.updates.set(node, true);
  }
};

// packages/ag-grid-community/src/clientSideRowModel/sortStage.ts
function updateChildIndexes(rowNode) {
  if (_missing(rowNode.childrenAfterSort)) {
    return;
  }
  const listToSort = rowNode.childrenAfterSort;
  for (let i = 0; i < listToSort.length; i++) {
    const child = listToSort[i];
    const firstChild = i === 0;
    const lastChild = i === rowNode.childrenAfterSort.length - 1;
    child.setFirstChild(firstChild);
    if (child.lastChild !== lastChild) {
      child.lastChild = lastChild;
      child.dispatchRowEvent("lastChildChanged");
    }
    if (child.childIndex !== i) {
      child.childIndex = i;
      child.dispatchRowEvent("childIndexChanged");
    }
  }
}
function updateRowNodeAfterSort(rowNode) {
  if (rowNode.sibling) {
    rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
  }
  updateChildIndexes(rowNode);
}
var SortStage = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "sortStage";
    this.refreshProps = /* @__PURE__ */ new Set(["postSortRows", "groupDisplayType", "accentedSort"]);
    this.step = "sort";
  }
  execute(params) {
    const beans = this.beans;
    const sortOptions = beans.sortSvc.getSortOptions();
    const sortActive = _exists(sortOptions) && sortOptions.length > 0;
    const deltaSort = sortActive && !!params.changedRowNodes && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort");
    const sortContainsGroupColumns = sortOptions.some(({ column }) => {
      const isSortingCoupled = _isColumnsSortingCoupledToGroup(beans.gos);
      if (isSortingCoupled) {
        return column.isPrimary() && column.isRowGroupActive();
      }
      return !!column.getColDef().showRowGroup;
    });
    this.sort(
      beans,
      sortOptions,
      sortActive,
      deltaSort,
      params.changedRowNodes,
      params.changedPath,
      sortContainsGroupColumns
    );
  }
  sort(beans, sortOptions, sortActive, useDeltaSort, changedRowNodes, changedPath, sortContainsGroupColumns) {
    const { gos, colModel, rowGroupColsSvc, groupHideOpenParentsSvc, rowNodeSorter } = beans;
    const groupMaintainOrder = gos.get("groupMaintainOrder");
    const groupColumnsPresent = colModel.getCols().some((c) => c.isRowGroupActive());
    const isPivotMode = colModel.isPivotMode();
    const postSortFunc = gos.getCallback("postSortRows");
    const callback = (rowNode) => {
      groupHideOpenParentsSvc?.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);
      const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
      const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
      let newChildrenAfterSort;
      if (skipSortingGroups) {
        const nextGroup = rowGroupColsSvc?.columns?.[rowNode.level + 1];
        const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;
        const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
        if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {
          const indexedOrders = {};
          rowNode.childrenAfterSort.forEach((node, idx) => {
            indexedOrders[node.id] = idx;
          });
          childrenToBeSorted.sort(
            (row1, row2) => (indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0)
          );
        }
        newChildrenAfterSort = childrenToBeSorted;
      } else if (!sortActive || skipSortingPivotLeafs) {
        newChildrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
      } else if (useDeltaSort && changedRowNodes) {
        newChildrenAfterSort = doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions);
      } else {
        newChildrenAfterSort = rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
      }
      rowNode.childrenAfterSort = newChildrenAfterSort;
      updateRowNodeAfterSort(rowNode);
      if (postSortFunc) {
        const params = { nodes: rowNode.childrenAfterSort };
        postSortFunc(params);
      }
    };
    changedPath?.forEachChangedNodeDepthFirst(callback);
  }
};
function doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions) {
  const unsortedRows = rowNode.childrenAfterAggFilter;
  const oldSortedRows = rowNode.childrenAfterSort;
  if (!oldSortedRows) {
    return rowNodeSorter.doFullSort(unsortedRows, sortOptions);
  }
  const untouchedRows = /* @__PURE__ */ new Set();
  const touchedRows = [];
  const updates = changedRowNodes.updates;
  for (let i = 0, len = unsortedRows.length; i < len; ++i) {
    const row = unsortedRows[i];
    if (updates.has(row) || changedPath && !changedPath.canSkip(row)) {
      touchedRows.push({
        currentPos: touchedRows.length,
        rowNode: row
      });
    } else {
      untouchedRows.add(row.id);
    }
  }
  const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRows.has(child.id)).map((rowNode2, currentPos) => ({ currentPos, rowNode: rowNode2 }));
  touchedRows.sort((a, b) => rowNodeSorter.compareRowNodes(sortOptions, a, b));
  return mergeSortedArrays(rowNodeSorter, sortOptions, touchedRows, sortedUntouchedRows);
}
function mergeSortedArrays(rowNodeSorter, sortOptions, arr1, arr2) {
  const res = [];
  let i = 0;
  let j = 0;
  const arr1Length = arr1.length;
  const arr2Length = arr2.length;
  while (i < arr1Length && j < arr2Length) {
    const a = arr1[i];
    const b = arr2[j];
    const compareResult = rowNodeSorter.compareRowNodes(sortOptions, a, b);
    let chosen;
    if (compareResult < 0) {
      chosen = a;
      ++i;
    } else {
      chosen = b;
      ++j;
    }
    res.push(chosen.rowNode);
  }
  while (i < arr1Length) {
    res.push(arr1[i++].rowNode);
  }
  while (j < arr2Length) {
    res.push(arr2[j++].rowNode);
  }
  return res;
}

// packages/ag-grid-community/src/clientSideRowModel/clientSideRowModel.ts
var ClientSideRowModel = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowModel";
    this.onRowHeightChanged_debounced = _debounce(this, this.onRowHeightChanged.bind(this), 100);
    // top most node of the tree. the children are the user provided data.
    this.rootNode = null;
    this.rowsToDisplay = [];
    /** Has the start method been called */
    this.started = false;
    /** E.g. data has been set into the node manager already */
    this.shouldSkipSettingDataOnStart = false;
    /**
     * This is to prevent refresh model being called when it's already being called.
     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,
     * which then triggers the listener here that calls refresh model again but at the filter stage
     * (which is about to be run by the original call).
     */
    this.isRefreshingModel = false;
    this.rowNodesCountReady = false;
    this.rowCountReady = false;
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
    this.valueCache = beans.valueCache;
    this.filterStage = beans.filterStage;
    this.sortStage = beans.sortStage;
    this.flattenStage = beans.flattenStage;
    this.groupStage = beans.groupStage;
    this.aggStage = beans.aggStage;
    this.pivotStage = beans.pivotStage;
    this.filterAggStage = beans.filterAggStage;
  }
  postConstruct() {
    this.orderedStages = [
      this.groupStage,
      this.filterStage,
      this.pivotStage,
      this.aggStage,
      this.sortStage,
      this.filterAggStage,
      this.flattenStage
    ].filter((stage) => !!stage);
    const refreshEverythingFunc = this.refreshModel.bind(this, { step: "group" });
    const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: true,
      keepRenderedRows: true,
      // we want animations cos sorting or filtering could be applied
      animate: !this.gos.get("suppressAnimationFrame")
    });
    this.addManagedEventListeners({
      newColumnsLoaded: refreshEverythingAfterColsChangedFunc,
      columnRowGroupChanged: refreshEverythingFunc,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, { step: "pivot" }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: refreshEverythingFunc,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    });
    this.addPropertyListeners();
    this.rootNode = new RowNode(this.beans);
    this.initRowManager();
  }
  initRowManager() {
    const { gos, beans, nodeManager: oldNodeManager } = this;
    const treeData = gos.get("treeData");
    const childrenField = gos.get("treeDataChildrenField");
    const isTree = childrenField || treeData;
    let nodeManager;
    if (isTree) {
      nodeManager = childrenField ? beans.csrmChildrenTreeNodeSvc : beans.csrmPathTreeNodeSvc;
    }
    if (!nodeManager) {
      nodeManager = beans.csrmNodeSvc;
    }
    if (oldNodeManager !== nodeManager) {
      oldNodeManager?.deactivate();
      this.nodeManager = nodeManager;
    }
    nodeManager.activate(this.rootNode);
  }
  addPropertyListeners() {
    const allProps = [
      "treeData",
      "treeDataChildrenField",
      ...this.orderedStages.flatMap(({ refreshProps }) => [...refreshProps])
    ];
    this.addManagedPropertyListeners(allProps, (params) => {
      const properties = params.changeSet?.properties;
      if (properties) {
        this.onPropChange(properties);
      }
    });
    this.addManagedPropertyListener("rowData", () => this.onPropChange(["rowData"]));
    this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.started = true;
    if (this.shouldSkipSettingDataOnStart) {
      this.refreshModel({
        step: "group",
        newData: true,
        rowDataUpdated: true
      });
    } else {
      this.setInitialData();
    }
  }
  setInitialData() {
    const rowData = this.gos.get("rowData");
    if (rowData) {
      this.shouldSkipSettingDataOnStart = true;
      this.onPropChange(["rowData"]);
    }
  }
  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
    let atLeastOneChange;
    let res = false;
    do {
      atLeastOneChange = false;
      const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
      const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
      const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
      const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
      for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
        const rowNode = this.getRow(rowIndex);
        if (rowNode.rowHeightEstimated) {
          const rowHeight = _getRowHeightForNode(this.beans, rowNode);
          rowNode.setRowHeight(rowHeight.height);
          atLeastOneChange = true;
          res = true;
        }
      }
      if (atLeastOneChange) {
        this.setRowTopAndRowIndex();
      }
    } while (atLeastOneChange);
    return res;
  }
  onPropChange(properties) {
    if (!this.rootNode) {
      return;
    }
    const gos = this.gos;
    const changedProps = new Set(properties);
    const params = {
      step: "nothing",
      changedProps
    };
    const rowDataChanged = changedProps.has("rowData");
    const treeDataChanged = changedProps.has("treeData");
    const treeDataChildrenFieldChanged = changedProps.has("treeDataChildrenField");
    const reset = treeDataChildrenFieldChanged || treeDataChanged && !gos.get("treeDataChildrenField");
    let newRowData;
    if (treeDataChanged) {
      params.step = "group";
    }
    if (reset || rowDataChanged) {
      newRowData = gos.get("rowData");
      if (newRowData != null && !Array.isArray(newRowData)) {
        newRowData = null;
        _warn(1);
      }
    }
    if (reset) {
      if (!rowDataChanged) {
        newRowData = this.nodeManager?.extractRowData() ?? newRowData;
      }
      this.initRowManager();
    }
    if (newRowData) {
      const immutable = !reset && this.started && !this.isEmpty() && newRowData.length > 0 && gos.exists("getRowId") && // this property is a backwards compatibility property, for those who want
      // the old behaviour of Row IDs but NOT Immutable Data.
      !gos.get("resetRowDataOnUpdate");
      if (immutable) {
        params.keepRenderedRows = true;
        params.animate = !this.gos.get("suppressAnimationFrame");
        params.changedRowNodes = new ChangedRowNodes();
        this.nodeManager.setImmutableRowData(params, newRowData);
      } else {
        params.step = "group";
        params.rowDataUpdated = true;
        params.newData = true;
        this.beans.selectionSvc?.reset("rowDataChanged");
        this.rowNodesCountReady = true;
        this.nodeManager.setNewRowData(newRowData);
      }
    }
    if (params.step === "nothing") {
      for (const { refreshProps, step } of this.orderedStages) {
        if (properties.some((prop) => refreshProps.has(prop))) {
          params.step = step;
          break;
        }
      }
    }
    if (params.step !== "nothing") {
      this.refreshModel(params);
    }
  }
  setRowTopAndRowIndex() {
    const { beans } = this;
    const defaultRowHeight = beans.environment.getDefaultRowHeight();
    let nextRowTop = 0;
    const displayedRowsMapped = /* @__PURE__ */ new Set();
    const allowEstimate = _isDomLayout(this.gos, "normal");
    const rowsToDisplay = this.rowsToDisplay;
    for (let i = 0, len = rowsToDisplay.length; i < len; ++i) {
      const rowNode = rowsToDisplay[i];
      if (rowNode.id != null) {
        displayedRowsMapped.add(rowNode.id);
      }
      if (rowNode.rowHeight == null) {
        const rowHeight = _getRowHeightForNode(beans, rowNode, allowEstimate, defaultRowHeight);
        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
      }
      rowNode.setRowTop(nextRowTop);
      rowNode.setRowIndex(i);
      nextRowTop += rowNode.rowHeight;
    }
    return displayedRowsMapped;
  }
  clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
    const changedPathActive = changedPath.active;
    const clearIfNotDisplayed = (rowNode) => {
      if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {
        rowNode.clearRowTopAndRowIndex();
      }
    };
    const recurse = (rowNode) => {
      if (rowNode === null) {
        return;
      }
      clearIfNotDisplayed(rowNode);
      clearIfNotDisplayed(rowNode.detailNode);
      clearIfNotDisplayed(rowNode.sibling);
      if (rowNode.hasChildren()) {
        if (rowNode.childrenAfterGroup) {
          const isRootNode = rowNode.level == -1;
          const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;
          if (!skipChildren) {
            rowNode.childrenAfterGroup.forEach(recurse);
          }
        }
      }
    };
    recurse(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(rowNodes, pixel, increment = 0) {
    const indexAtPixelNow = this.getRowIndexAtPixel(pixel);
    const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);
    const animate = !this.gos.get("suppressAnimationFrame");
    if (rowNodeAtPixelNow === rowNodes[0]) {
      return false;
    }
    const allLeafChildren = this.rootNode?.allLeafChildren;
    if (!allLeafChildren) {
      return false;
    }
    rowNodes.forEach((rowNode) => {
      _removeFromArray(allLeafChildren, rowNode);
    });
    rowNodes.forEach((rowNode, idx) => {
      allLeafChildren.splice(Math.max(indexAtPixelNow + increment, 0) + idx, 0, rowNode);
    });
    rowNodes.forEach((rowNode, index) => {
      rowNode.sourceRowIndex = index;
    });
    this.refreshModel({
      step: "group",
      keepRenderedRows: true,
      animate,
      rowNodesOrderChanged: true
      // We assume the order changed and we don't need to check if it really did
    });
    return true;
  }
  highlightRowAtPixel(rowNode, pixel) {
    const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;
    const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;
    if (!rowNodeAtPixelNow || !rowNode || pixel == null) {
      this.clearHighlightedRow();
      return;
    }
    const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);
    const isSamePosition = this.isHighlightingCurrentPosition(rowNode, rowNodeAtPixelNow, highlight);
    const isDifferentNode = this.lastHighlightedRow != null && this.lastHighlightedRow !== rowNodeAtPixelNow;
    if (isSamePosition || isDifferentNode) {
      this.clearHighlightedRow();
      if (isSamePosition) {
        return;
      }
    }
    this.setRowNodeHighlighted(rowNodeAtPixelNow, highlight);
    this.lastHighlightedRow = rowNodeAtPixelNow;
  }
  setRowNodeHighlighted(rowNode, highlighted) {
    if (rowNode.highlighted !== highlighted) {
      rowNode.highlighted = highlighted;
      rowNode.dispatchRowEvent("rowHighlightChanged");
    }
  }
  getHighlightPosition(pixel, rowNode) {
    if (!rowNode) {
      const index = this.getRowIndexAtPixel(pixel);
      rowNode = this.getRow(index || 0);
      if (!rowNode) {
        return "Below";
      }
    }
    const { rowTop, rowHeight } = rowNode;
    return pixel - rowTop < rowHeight / 2 ? "Above" : "Below";
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isHighlightingCurrentPosition(movingRowNode, hoveredRowNode, highlightPosition) {
    if (movingRowNode === hoveredRowNode) {
      return true;
    }
    const diff = highlightPosition === "Above" ? -1 : 1;
    if (this.getRow(hoveredRowNode.rowIndex + diff) === movingRowNode) {
      return true;
    }
    return false;
  }
  clearHighlightedRow() {
    if (this.lastHighlightedRow) {
      this.setRowNodeHighlighted(this.lastHighlightedRow, null);
      this.lastHighlightedRow = null;
    }
  }
  isLastRowIndexKnown() {
    return true;
  }
  getRowCount() {
    if (this.rowsToDisplay) {
      return this.rowsToDisplay.length;
    }
    return 0;
  }
  /**
   * Returns the number of rows with level === 1
   */
  getTopLevelRowCount() {
    const rootNode = this.rootNode;
    if (!rootNode) {
      return 0;
    }
    if (this.rowsToDisplay.length === 0) {
      return 0;
    }
    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === rootNode;
    if (showingRootNode) {
      return 1;
    }
    const filteredChildren = rootNode.childrenAfterAggFilter;
    const totalFooterInc = rootNode.sibling ? 1 : 0;
    return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;
  }
  /**
   * Get the row display index by the top level index
   * top level index is the index of rows with level === 1
   */
  getTopLevelRowDisplayedIndex(topLevelIndex) {
    const { rootNode, rowsToDisplay } = this;
    const showingRootNode = !rootNode || !rowsToDisplay.length || rowsToDisplay[0] === rootNode;
    if (showingRootNode) {
      return topLevelIndex;
    }
    const { childrenAfterSort } = rootNode;
    const getDefaultIndex = (adjustedIndex) => {
      let rowNode = childrenAfterSort[adjustedIndex];
      if (this.gos.get("groupHideOpenParents")) {
        while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {
          rowNode = rowNode.childrenAfterSort[0];
        }
      }
      return rowNode.rowIndex;
    };
    const { footerSvc } = this.beans;
    if (footerSvc) {
      return footerSvc.getTopDisplayIndex(rowsToDisplay, topLevelIndex, childrenAfterSort, getDefaultIndex);
    } else {
      return getDefaultIndex(topLevelIndex);
    }
  }
  getRowBounds(index) {
    const rowNode = this.rowsToDisplay[index];
    if (rowNode) {
      return {
        rowTop: rowNode.rowTop,
        rowHeight: rowNode.rowHeight
      };
    }
    return null;
  }
  onRowGroupOpened() {
    const animate = _isAnimateRows(this.gos);
    this.refreshModel({ step: "map", keepRenderedRows: true, animate });
  }
  onFilterChanged(event) {
    if (event.afterDataChange) {
      return;
    }
    const animate = _isAnimateRows(this.gos);
    const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());
    const step = primaryOrQuickFilterChanged ? "filter" : "filter_aggregates";
    this.refreshModel({ step, keepRenderedRows: true, animate });
  }
  onSortChanged() {
    const animate = _isAnimateRows(this.gos);
    this.refreshModel({
      step: "sort",
      keepRenderedRows: true,
      animate
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.refreshModel({ step: this.colModel.isPivotActive() ? "pivot" : "aggregate" });
  }
  createChangePath(rowNodeTransactions) {
    const noTransactions = !rowNodeTransactions?.length;
    const changedPath = new ChangedPath(false, this.rootNode);
    if (noTransactions) {
      changedPath.active = false;
    }
    return changedPath;
  }
  isSuppressModelUpdateAfterUpdateTransaction(params) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction")) {
      return false;
    }
    const rowNodeTransactions = params.rowNodeTransactions;
    if (!rowNodeTransactions) {
      return false;
    }
    const transWithAddsOrDeletes = rowNodeTransactions.some(
      (tx) => tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0
    );
    const transactionsContainUpdatesOnly = !transWithAddsOrDeletes;
    return transactionsContainUpdatesOnly;
  }
  refreshModel(params) {
    if (!this.rootNode) {
      return;
    }
    const rowNodeTransactions = params.rowNodeTransactions;
    const changedPath = params.changedPath ?? (params.changedPath = this.createChangePath(rowNodeTransactions));
    this.nodeManager.refreshModel?.(params);
    this.eventSvc.dispatchEvent({ type: "beforeRefreshModel", params });
    if (!this.started) {
      return;
    }
    if (params.rowDataUpdated) {
      this.eventSvc.dispatchEvent({ type: "rowDataUpdated" });
    }
    if (this.isRefreshingModel || this.colModel.changeEventsDispatching || this.isSuppressModelUpdateAfterUpdateTransaction(params)) {
      return;
    }
    this.isRefreshingModel = true;
    switch (params.step) {
      case "group": {
        this.doRowGrouping(
          params.rowNodeTransactions,
          params.changedRowNodes,
          changedPath,
          !!params.rowNodesOrderChanged,
          !!params.afterColumnsChanged
        );
      }
      case "filter":
        this.doFilter(changedPath);
      case "pivot":
        this.doPivot(changedPath);
      case "aggregate":
        this.doAggregate(changedPath);
      case "filter_aggregates":
        this.doFilterAggregates(changedPath);
      case "sort":
        this.doSort(params.changedRowNodes, changedPath);
      case "map":
        this.doRowsToDisplay();
    }
    const displayedNodesMapped = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
    this.isRefreshingModel = false;
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: params.animate,
      keepRenderedRows: params.keepRenderedRows,
      newData: params.newData,
      newPage: false,
      keepUndoRedoStack: params.keepUndoRedoStack
    });
  }
  isEmpty() {
    return !this.rootNode?.allLeafChildren?.length || !this.colModel?.ready;
  }
  isRowsToRender() {
    return this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(firstInRange, lastInRange) {
    let started = false;
    let finished = false;
    const result = [];
    const groupsSelectChildren = _getGroupSelectsDescendants(this.gos);
    this.forEachNodeAfterFilterAndSort((rowNode) => {
      if (finished) {
        return;
      }
      if (started) {
        if (rowNode === lastInRange || rowNode === firstInRange) {
          finished = true;
          if (rowNode.group && groupsSelectChildren) {
            result.push(...rowNode.allLeafChildren);
            return;
          }
        }
      }
      if (!started) {
        if (rowNode !== lastInRange && rowNode !== firstInRange) {
          return;
        }
        started = true;
      }
      const includeThisNode = !rowNode.group || !groupsSelectChildren;
      if (includeThisNode) {
        result.push(rowNode);
        return;
      }
    });
    return result;
  }
  getTopLevelNodes() {
    return this.rootNode?.childrenAfterGroup ?? null;
  }
  getRow(index) {
    return this.rowsToDisplay[index];
  }
  isRowPresent(rowNode) {
    return this.rowsToDisplay.indexOf(rowNode) >= 0;
  }
  getRowIndexAtPixel(pixelToMatch) {
    const rowsToDisplay = this.rowsToDisplay;
    if (this.isEmpty() || rowsToDisplay.length === 0) {
      return -1;
    }
    let bottomPointer = 0;
    let topPointer = rowsToDisplay.length - 1;
    if (pixelToMatch <= 0) {
      return 0;
    }
    const lastNode = _last(rowsToDisplay);
    if (lastNode.rowTop <= pixelToMatch) {
      return rowsToDisplay.length - 1;
    }
    let oldBottomPointer = -1;
    let oldTopPointer = -1;
    while (true) {
      const midPointer = Math.floor((bottomPointer + topPointer) / 2);
      const currentRowNode = rowsToDisplay[midPointer];
      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
        return midPointer;
      }
      if (currentRowNode.rowTop < pixelToMatch) {
        bottomPointer = midPointer + 1;
      } else if (currentRowNode.rowTop > pixelToMatch) {
        topPointer = midPointer - 1;
      }
      const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;
      if (caughtInInfiniteLoop) {
        return midPointer;
      }
      oldBottomPointer = bottomPointer;
      oldTopPointer = topPointer;
    }
  }
  isRowInPixel(rowNode, pixelToMatch) {
    const topPixel = rowNode.rowTop;
    const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
    const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
    return pixelInRow;
  }
  forEachLeafNode(callback) {
    this.rootNode?.allLeafChildren?.forEach((rowNode, index) => callback(rowNode, index));
  }
  forEachNode(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode?.childrenAfterGroup || []],
      callback,
      recursionType: 0 /* Normal */,
      index: 0,
      includeFooterNodes
    });
  }
  forEachNodeAfterFilter(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode?.childrenAfterAggFilter || []],
      callback,
      recursionType: 1 /* AfterFilter */,
      index: 0,
      includeFooterNodes
    });
  }
  forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode?.childrenAfterSort || []],
      callback,
      recursionType: 2 /* AfterFilterAndSort */,
      index: 0,
      includeFooterNodes
    });
  }
  forEachPivotNode(callback, includeFooterNodes = false) {
    const rootNode = this.rootNode;
    if (rootNode) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [rootNode],
        callback,
        recursionType: 3 /* PivotNodes */,
        index: 0,
        includeFooterNodes
      });
    }
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(params) {
    const { nodes, callback, recursionType, includeFooterNodes } = params;
    let { index } = params;
    const { footerSvc } = this.beans;
    footerSvc?.addNodes(params, nodes, callback, includeFooterNodes, this.rootNode, "top");
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      callback(node, index++);
      if (node.hasChildren() && !node.footer) {
        let nodeChildren = null;
        switch (recursionType) {
          case 0 /* Normal */:
            nodeChildren = node.childrenAfterGroup;
            break;
          case 1 /* AfterFilter */:
            nodeChildren = node.childrenAfterAggFilter;
            break;
          case 2 /* AfterFilterAndSort */:
            nodeChildren = node.childrenAfterSort;
            break;
          case 3 /* PivotNodes */:
            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
            break;
        }
        if (nodeChildren) {
          index = this.recursivelyWalkNodesAndCallback({
            nodes: [...nodeChildren],
            callback,
            recursionType,
            index,
            includeFooterNodes
          });
        }
      }
    }
    footerSvc?.addNodes(params, nodes, callback, includeFooterNodes, this.rootNode, "bottom");
    return index;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(changedPath) {
    const rootNode = this.rootNode;
    if (rootNode) {
      this.aggStage?.execute({ rowNode: rootNode, changedPath });
    }
  }
  doFilterAggregates(changedPath) {
    const rootNode = this.rootNode;
    if (this.filterAggStage) {
      this.filterAggStage.execute({ rowNode: rootNode, changedPath });
    } else {
      rootNode.childrenAfterAggFilter = rootNode.childrenAfterFilter;
    }
  }
  doSort(changedRowNodes, changedPath) {
    const { groupHideOpenParentsSvc } = this.beans;
    if (this.sortStage) {
      this.sortStage.execute({
        rowNode: this.rootNode,
        changedRowNodes,
        changedPath
      });
    } else {
      changedPath.forEachChangedNodeDepthFirst((rowNode) => {
        groupHideOpenParentsSvc?.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);
        rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
        updateRowNodeAfterSort(rowNode);
      });
    }
    groupHideOpenParentsSvc?.updateGroupDataForHideOpenParents(changedPath);
  }
  doRowGrouping(rowNodeTransactions, changedRowNodes, changedPath, rowNodesOrderChanged, afterColumnsChanged) {
    const treeData = this.nodeManager.treeData;
    const rootNode = this.rootNode;
    if (!treeData) {
      const groupStage = this.groupStage;
      if (groupStage) {
        groupStage.execute({
          rowNode: rootNode,
          changedPath,
          changedRowNodes,
          rowNodeTransactions,
          rowNodesOrderChanged,
          afterColumnsChanged
        });
      } else {
        const sibling = rootNode.sibling;
        rootNode.childrenAfterGroup = rootNode.allLeafChildren;
        if (sibling) {
          sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
        }
        rootNode.updateHasChildren();
      }
    }
    if (this.rowNodesCountReady) {
      this.rowCountReady = true;
      this.eventSvc.dispatchEventOnce({ type: "rowCountReady" });
    }
  }
  doFilter(changedPath) {
    if (this.filterStage) {
      this.filterStage.execute({ rowNode: this.rootNode, changedPath });
    } else {
      changedPath.forEachChangedNodeDepthFirst((rowNode) => {
        rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
        updateRowNodeAfterFilter(rowNode);
      }, true);
    }
  }
  doPivot(changedPath) {
    this.pivotStage?.execute({ rowNode: this.rootNode, changedPath });
  }
  getRowNode(id) {
    const idIsGroup = typeof id == "string" && id.indexOf(ROW_ID_PREFIX_ROW_GROUP) == 0;
    if (idIsGroup) {
      let res = void 0;
      this.forEachNode((node) => {
        if (node.id === id) {
          res = node;
        }
      });
      return res;
    }
    return this.nodeManager.getRowNode(id);
  }
  batchUpdateRowData(rowDataTransaction, callback) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const waitMillis = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        if (this.isAlive()) {
          this.executeBatchUpdateRowData();
        }
      }, waitMillis);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction, callback });
  }
  flushAsyncTransactions() {
    if (this.applyAsyncTransactionsTimeout != null) {
      clearTimeout(this.applyAsyncTransactionsTimeout);
      this.executeBatchUpdateRowData();
    }
  }
  executeBatchUpdateRowData() {
    this.valueCache?.onDataChanged();
    const callbackFuncsBound = [];
    const rowNodeTrans = [];
    const changedRowNodes = new ChangedRowNodes();
    let orderChanged = false;
    this.rowDataTransactionBatch?.forEach((tranItem) => {
      this.rowNodesCountReady = true;
      const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(
        tranItem.rowDataTransaction,
        changedRowNodes
      );
      if (rowsInserted) {
        orderChanged = true;
      }
      rowNodeTrans.push(rowNodeTransaction);
      if (tranItem.callback) {
        callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTransaction));
      }
    });
    this.commitTransactions(rowNodeTrans, orderChanged, changedRowNodes);
    if (callbackFuncsBound.length > 0) {
      window.setTimeout(() => {
        callbackFuncsBound.forEach((func) => func());
      }, 0);
    }
    if (rowNodeTrans.length > 0) {
      this.eventSvc.dispatchEvent({
        type: "asyncTransactionsFlushed",
        results: rowNodeTrans
      });
    }
    this.rowDataTransactionBatch = null;
    this.applyAsyncTransactionsTimeout = void 0;
  }
  /**
   * Used to apply transaction changes.
   * Called by gridApi & rowDragFeature
   */
  updateRowData(rowDataTran) {
    this.valueCache?.onDataChanged();
    this.rowNodesCountReady = true;
    const changedRowNodes = new ChangedRowNodes();
    const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(rowDataTran, changedRowNodes);
    this.commitTransactions([rowNodeTransaction], rowsInserted, changedRowNodes);
    return rowNodeTransaction;
  }
  /**
   * Common to:
   * - executeBatchUpdateRowData (batch transactions)
   * - updateRowData (single transaction)
   * - setImmutableRowData (generated transaction)
   *
   * @param rowNodeTrans - the transactions to apply
   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
   */
  commitTransactions(rowNodeTransactions, rowNodesOrderChanged, changedRowNodes) {
    this.refreshModel({
      step: "group",
      rowDataUpdated: true,
      rowNodeTransactions,
      rowNodesOrderChanged,
      keepRenderedRows: true,
      animate: !this.gos.get("suppressAnimationFrame"),
      changedRowNodes,
      changedPath: this.createChangePath(rowNodeTransactions)
    });
  }
  doRowsToDisplay() {
    const { flattenStage, rootNode } = this;
    let rowsToDisplay;
    if (flattenStage) {
      rowsToDisplay = flattenStage.execute({ rowNode: rootNode });
    } else {
      rowsToDisplay = rootNode?.childrenAfterSort ?? [];
      for (const row of rowsToDisplay) {
        row.setUiLevel(0);
      }
    }
    this.rowsToDisplay = rowsToDisplay;
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: true,
      keepUndoRedoStack: true
    });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const rootNode = this.rootNode;
    if (!rootNode) {
      return;
    }
    const atLeastOne = this.resetRowHeightsForAllRowNodes();
    rootNode.setRowHeight(rootNode.rowHeight, true);
    if (rootNode.sibling) {
      rootNode.sibling.setRowHeight(rootNode.sibling.rowHeight, true);
    }
    if (atLeastOne) {
      this.onRowHeightChanged();
    }
  }
  resetRowHeightsForAllRowNodes() {
    let atLeastOne = false;
    this.forEachNode((rowNode) => {
      rowNode.setRowHeight(rowNode.rowHeight, true);
      const detailNode = rowNode.detailNode;
      if (detailNode) {
        detailNode.setRowHeight(detailNode.rowHeight, true);
      }
      if (rowNode.sibling) {
        rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);
      }
      atLeastOne = true;
    });
    return atLeastOne;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      if (this.beans.rowAutoHeight?.active) {
        return;
      }
      this.resetRowHeights();
    }
  }
  onGridReady() {
    if (!this.started) {
      this.setInitialData();
    }
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy();
    this.clearHighlightedRow();
    this.started = false;
    this.rootNode = null;
    this.nodeManager = null;
    this.rowDataTransactionBatch = null;
    this.lastHighlightedRow = null;
    this.orderedStages = _EmptyArray;
    this.rowsToDisplay = _EmptyArray;
  }
};

// packages/ag-grid-community/src/clientSideRowModel/clientSideRowModelApi.ts
function onGroupExpandedOrCollapsed(beans) {
  beans.expansionSvc?.onGroupExpandedOrCollapsed();
}
function refreshClientSideRowModel(beans, step) {
  const clientSideRowModel = _getClientSideRowModel(beans);
  if (clientSideRowModel) {
    if (!step || step === "everything") {
      step = "group";
    }
    clientSideRowModel.refreshModel({
      step,
      keepRenderedRows: true,
      animate: !beans.gos.get("suppressAnimationFrame")
    });
  }
}
function isRowDataEmpty(beans) {
  return _getClientSideRowModel(beans)?.isEmpty() ?? true;
}
function forEachLeafNode(beans, callback) {
  _getClientSideRowModel(beans)?.forEachLeafNode(callback);
}
function forEachNodeAfterFilter(beans, callback) {
  _getClientSideRowModel(beans)?.forEachNodeAfterFilter(callback);
}
function forEachNodeAfterFilterAndSort(beans, callback) {
  _getClientSideRowModel(beans)?.forEachNodeAfterFilterAndSort(callback);
}
function resetRowHeights(beans) {
  if (beans.rowAutoHeight?.active) {
    _warn(3);
    return;
  }
  _getClientSideRowModel(beans)?.resetRowHeights();
}
function applyTransaction(beans, rowDataTransaction) {
  return beans.frameworkOverrides.wrapIncoming(
    () => _getClientSideRowModel(beans)?.updateRowData(rowDataTransaction)
  );
}
function applyTransactionAsync(beans, rowDataTransaction, callback) {
  beans.frameworkOverrides.wrapIncoming(
    () => _getClientSideRowModel(beans)?.batchUpdateRowData(rowDataTransaction, callback)
  );
}
function flushAsyncTransactions(beans) {
  beans.frameworkOverrides.wrapIncoming(() => _getClientSideRowModel(beans)?.flushAsyncTransactions());
}
function getBestCostNodeSelection(beans) {
  return beans.selectionSvc?.getBestCostNodeSelection();
}

// packages/ag-grid-community/src/clientSideRowModel/clientSideRowModelModule.ts
var ClientSideRowModelModule = {
  moduleName: "ClientSideRowModel",
  version: VERSION,
  rowModels: ["clientSide"],
  beans: [ClientSideNodeManager, ClientSideRowModel, SortStage],
  dependsOn: [SortModule]
};
var ClientSideRowModelApiModule = {
  moduleName: "ClientSideRowModelApi",
  version: VERSION,
  rowModels: ["clientSide"],
  apiFunctions: {
    onGroupExpandedOrCollapsed,
    refreshClientSideRowModel,
    isRowDataEmpty,
    forEachLeafNode,
    forEachNodeAfterFilter,
    forEachNodeAfterFilterAndSort,
    resetRowHeights,
    applyTransaction,
    applyTransactionAsync,
    flushAsyncTransactions,
    getBestCostNodeSelection
  },
  dependsOn: [CsrmSsrmSharedApiModule]
};

// packages/ag-grid-community/src/export/gridSerializer.ts
var GridSerializer = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "gridSerializer";
  }
  wireBeans(beans) {
    this.visibleCols = beans.visibleCols;
    this.colModel = beans.colModel;
    this.rowModel = beans.rowModel;
    this.pinnedRowModel = beans.pinnedRowModel;
  }
  serialize(gridSerializingSession, params = {}) {
    const { allColumns, columnKeys, skipRowGroups } = params;
    const columnsToExport = this.getColumnsToExport(
      allColumns,
      skipRowGroups,
      columnKeys
    );
    return [
      // first pass, put in the header names of the cols
      this.prepareSession(columnsToExport),
      this.prependContent(params),
      this.exportColumnGroups(params, columnsToExport),
      this.exportHeaders(params, columnsToExport),
      this.processPinnedTopRows(params, columnsToExport),
      this.processRows(params, columnsToExport),
      this.processPinnedBottomRows(params, columnsToExport),
      this.appendContent(params)
    ].reduce((composed, f) => f(composed), gridSerializingSession).parse();
  }
  processRow(gridSerializingSession, params, columnsToExport, node) {
    const rowSkipper = params.shouldRowBeSkipped || (() => false);
    const isClipboardExport = params.rowPositions != null;
    const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
    const hideOpenParents = this.gos.get("groupHideOpenParents") && !isExplicitExportSelection;
    const isLeafNode = this.colModel.isPivotMode() ? node.leafGroup : !node.group;
    const isFooter = !!node.footer;
    const shouldSkipCurrentGroup = node.allChildrenCount === 1 && node.childrenAfterGroup?.length === 1 && _canSkipShowingRowGroup(this.gos, node);
    if (!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents) || params.onlySelected && !node.isSelected() || params.skipPinnedTop && node.rowPinned === "top" || params.skipPinnedBottom && node.rowPinned === "bottom") {
      return;
    }
    const nodeIsRootNode = node.level === -1;
    if (nodeIsRootNode && !isLeafNode && !isFooter) {
      return;
    }
    const shouldRowBeSkipped = rowSkipper(this.gos.addGridCommonParams({ node }));
    if (shouldRowBeSkipped) {
      return;
    }
    const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
    columnsToExport.forEach((column, index) => {
      rowAccumulator.onColumn(column, index, node);
    });
    if (params.getCustomContentBelowRow) {
      const content = params.getCustomContentBelowRow(this.gos.addGridCommonParams({ node }));
      if (content) {
        gridSerializingSession.addCustomContent(content);
      }
    }
  }
  appendContent(params) {
    return (gridSerializingSession) => {
      const appendContent = params.appendContent;
      if (appendContent) {
        gridSerializingSession.addCustomContent(appendContent);
      }
      return gridSerializingSession;
    };
  }
  prependContent(params) {
    return (gridSerializingSession) => {
      const prependContent = params.prependContent;
      if (prependContent) {
        gridSerializingSession.addCustomContent(prependContent);
      }
      return gridSerializingSession;
    };
  }
  prepareSession(columnsToExport) {
    return (gridSerializingSession) => {
      gridSerializingSession.prepare(columnsToExport);
      return gridSerializingSession;
    };
  }
  exportColumnGroups(params, columnsToExport) {
    return (gridSerializingSession) => {
      if (!params.skipColumnGroupHeaders) {
        const idCreator = new GroupInstanceIdCreator();
        const { colGroupSvc } = this.beans;
        const displayedGroups = colGroupSvc ? colGroupSvc.createColumnGroups({
          columns: columnsToExport,
          idCreator,
          pinned: null,
          isStandaloneStructure: true
        }) : columnsToExport;
        this.recursivelyAddHeaderGroups(
          displayedGroups,
          gridSerializingSession,
          params.processGroupHeaderCallback
        );
      }
      return gridSerializingSession;
    };
  }
  exportHeaders(params, columnsToExport) {
    return (gridSerializingSession) => {
      if (!params.skipColumnHeaders) {
        const gridRowIterator = gridSerializingSession.onNewHeaderRow();
        columnsToExport.forEach((column, index) => {
          gridRowIterator.onColumn(column, index, void 0);
        });
      }
      return gridSerializingSession;
    };
  }
  processPinnedTopRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned === "top").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel?.getPinnedTopRow(position.rowIndex)).forEach(processRow);
      } else {
        this.pinnedRowModel?.forEachPinnedRow("top", processRow);
      }
      return gridSerializingSession;
    };
  }
  processRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const rowModel = this.rowModel;
      const usingCsrm = _isClientSideRowModel(this.gos, rowModel);
      const usingSsrm = _isServerSideRowModel(this.gos, rowModel);
      const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      const { exportedRows = "filteredAndSorted" } = params;
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned == null).sort((a, b) => a.rowIndex - b.rowIndex).map((position) => rowModel.getRow(position.rowIndex)).forEach(processRow);
        return gridSerializingSession;
      }
      if (this.colModel.isPivotMode()) {
        if (usingCsrm) {
          rowModel.forEachPivotNode(processRow, true);
        } else if (usingSsrm) {
          rowModel.forEachNodeAfterFilterAndSort(processRow, true);
        } else {
          rowModel.forEachNode(processRow);
        }
        return gridSerializingSession;
      }
      if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
        const selectedNodes = this.beans.selectionSvc?.getSelectedNodes() ?? [];
        this.replicateSortedOrder(selectedNodes);
        selectedNodes.forEach(processRow);
      } else {
        if (exportedRows === "all") {
          rowModel.forEachNode(processRow);
        } else if (usingCsrm || usingSsrm) {
          rowModel.forEachNodeAfterFilterAndSort(processRow, true);
        } else {
          rowModel.forEachNode(processRow);
        }
      }
      return gridSerializingSession;
    };
  }
  replicateSortedOrder(rows) {
    const { sortSvc, rowNodeSorter } = this.beans;
    if (!sortSvc || !rowNodeSorter) {
      return;
    }
    const sortOptions = sortSvc.getSortOptions();
    const compareNodes = (rowA, rowB) => {
      if (rowA.rowIndex != null && rowB.rowIndex != null) {
        return rowA.rowIndex - rowB.rowIndex;
      }
      if (rowA.level === rowB.level) {
        if (rowA.parent?.id === rowB.parent?.id) {
          return rowNodeSorter.compareRowNodes(
            sortOptions,
            {
              rowNode: rowA,
              currentPos: rowA.rowIndex ?? -1
            },
            {
              rowNode: rowB,
              currentPos: rowB.rowIndex ?? -1
            }
          );
        }
        return compareNodes(rowA.parent, rowB.parent);
      }
      if (rowA.level > rowB.level) {
        return compareNodes(rowA.parent, rowB);
      }
      return compareNodes(rowA, rowB.parent);
    };
    rows.sort(compareNodes);
  }
  processPinnedBottomRows(params, columnsToExport) {
    return (gridSerializingSession) => {
      const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
      if (params.rowPositions) {
        params.rowPositions.filter((position) => position.rowPinned === "bottom").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel?.getPinnedBottomRow(position.rowIndex)).forEach(processRow);
      } else {
        this.pinnedRowModel?.forEachPinnedRow("bottom", processRow);
      }
      return gridSerializingSession;
    };
  }
  getColumnsToExport(allColumns = false, skipRowGroups = false, columnKeys) {
    const { colModel, gos, visibleCols } = this;
    const isPivotMode = colModel.isPivotMode();
    if (columnKeys && columnKeys.length) {
      return colModel.getColsForKeys(columnKeys);
    }
    const isTreeData = gos.get("treeData");
    let columnsToExport = [];
    if (allColumns && !isPivotMode) {
      columnsToExport = colModel.getCols();
    } else {
      columnsToExport = visibleCols.allCols;
    }
    columnsToExport = columnsToExport.filter(
      (column) => !isColumnSelectionCol(column) && (skipRowGroups && !isTreeData ? !isColumnGroupAutoCol(column) : true)
    );
    return columnsToExport;
  }
  recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
    const directChildrenHeaderGroups = [];
    displayedGroups.forEach((columnGroupChild) => {
      const columnGroup = columnGroupChild;
      if (!columnGroup.getChildren) {
        return;
      }
      columnGroup.getChildren().forEach((it) => directChildrenHeaderGroups.push(it));
    });
    if (displayedGroups.length > 0 && isColumnGroup2(displayedGroups[0])) {
      this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
    }
    if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
      this.recursivelyAddHeaderGroups(
        directChildrenHeaderGroups,
        gridSerializingSession,
        processGroupHeaderCallback
      );
    }
  }
  doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
    const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
    let columnIndex = 0;
    displayedGroups.forEach((columnGroupChild) => {
      const columnGroup = columnGroupChild;
      let name;
      if (processGroupHeaderCallback) {
        name = processGroupHeaderCallback(
          this.gos.addGridCommonParams({
            columnGroup
          })
        );
      } else {
        name = this.beans.colNames.getDisplayNameForColumnGroup(columnGroup, "header");
      }
      const collapsibleGroupRanges = columnGroup.getLeafColumns().reduce((collapsibleGroups, currentColumn, currentIdx, arr) => {
        let lastGroup = _last(collapsibleGroups);
        const groupShow = currentColumn.getColumnGroupShow() === "open";
        if (!groupShow) {
          if (lastGroup && lastGroup[1] == null) {
            lastGroup[1] = currentIdx - 1;
          }
        } else if (!lastGroup || lastGroup[1] != null) {
          lastGroup = [currentIdx];
          collapsibleGroups.push(lastGroup);
        }
        if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) {
          lastGroup[1] = currentIdx;
        }
        return collapsibleGroups;
      }, []);
      gridRowIterator.onColumn(
        columnGroup,
        name || "",
        columnIndex++,
        columnGroup.getLeafColumns().length - 1,
        collapsibleGroupRanges
      );
    });
  }
};

// packages/ag-grid-community/src/export/exportModule.ts
var SharedExportModule = {
  moduleName: "SharedExport",
  version: VERSION,
  beans: [GridSerializer]
};

// packages/ag-grid-community/src/csvExport/csvSerializingSession.ts
var LINE_SEPARATOR = "\r\n";
var CsvSerializingSession = class extends BaseGridSerializingSession {
  constructor(config) {
    super(config);
    this.isFirstLine = true;
    this.result = "";
    const { suppressQuotes, columnSeparator } = config;
    this.suppressQuotes = suppressQuotes;
    this.columnSeparator = columnSeparator;
  }
  addCustomContent(content) {
    if (!content) {
      return;
    }
    if (typeof content === "string") {
      if (!/^\s*\n/.test(content)) {
        this.beginNewLine();
      }
      content = content.replace(/\r?\n/g, LINE_SEPARATOR);
      this.result += content;
    } else {
      content.forEach((row) => {
        this.beginNewLine();
        row.forEach((cell, index) => {
          if (index !== 0) {
            this.result += this.columnSeparator;
          }
          this.result += this.putInQuotes(cell.data.value || "");
          if (cell.mergeAcross) {
            this.appendEmptyCells(cell.mergeAcross);
          }
        });
      });
    }
  }
  onNewHeaderGroupingRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    this.result += this.putInQuotes(header);
    this.appendEmptyCells(span);
  }
  appendEmptyCells(count) {
    for (let i = 1; i <= count; i++) {
      this.result += this.columnSeparator + this.putInQuotes("");
    }
  }
  onNewHeaderRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(column, index) {
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    this.result += this.putInQuotes(this.extractHeaderValue(column));
  }
  onNewBodyRow() {
    this.beginNewLine();
    return {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(column, index, node) {
    if (index != 0) {
      this.result += this.columnSeparator;
    }
    const rowCellValue = this.extractRowCellValue(column, index, index, "csv", node);
    this.result += this.putInQuotes(rowCellValue.valueFormatted ?? rowCellValue.value);
  }
  putInQuotes(value) {
    if (this.suppressQuotes) {
      return value;
    }
    if (value === null || value === void 0) {
      return '""';
    }
    let stringValue;
    if (typeof value === "string") {
      stringValue = value;
    } else if (typeof value.toString === "function") {
      stringValue = value.toString();
    } else {
      _warn(53);
      stringValue = "";
    }
    const valueEscaped = stringValue.replace(/"/g, '""');
    return '"' + valueEscaped + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    if (!this.isFirstLine) {
      this.result += LINE_SEPARATOR;
    }
    this.isFirstLine = false;
  }
};

// packages/ag-grid-community/src/csvExport/csvCreator.ts
var CsvCreator = class extends BaseCreator {
  constructor() {
    super(...arguments);
    this.beanName = "csvCreator";
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
    this.colNames = beans.colNames;
    this.rowGroupColsSvc = beans.rowGroupColsSvc;
    this.valueSvc = beans.valueSvc;
  }
  getMergedParams(params) {
    const baseParams3 = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, baseParams3, params);
  }
  export(userParams) {
    if (this.isExportSuppressed()) {
      _warn(51);
      return;
    }
    const mergedParams = this.getMergedParams(userParams);
    const data = this.getData(mergedParams);
    const packagedFile = new Blob(["\uFEFF", data], { type: "text/plain" });
    const fileName = typeof mergedParams.fileName === "function" ? mergedParams.fileName(this.gos.getGridCommonParams()) : mergedParams.fileName;
    _downloadFile(this.getFileName(fileName), packagedFile);
  }
  exportDataAsCsv(params) {
    this.export(params);
  }
  getDataAsCsv(params, skipDefaultParams = false) {
    const mergedParams = skipDefaultParams ? Object.assign({}, params) : this.getMergedParams(params);
    return this.getData(mergedParams);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(params) {
    const { colModel, colNames, rowGroupColsSvc, valueSvc, gos } = this;
    const {
      processCellCallback,
      processHeaderCallback,
      processGroupHeaderCallback,
      processRowGroupCallback,
      suppressQuotes,
      columnSeparator
    } = params;
    return new CsvSerializingSession({
      colModel,
      colNames,
      valueSvc,
      gos,
      processCellCallback: processCellCallback || void 0,
      processHeaderCallback: processHeaderCallback || void 0,
      processGroupHeaderCallback: processGroupHeaderCallback || void 0,
      processRowGroupCallback: processRowGroupCallback || void 0,
      suppressQuotes: suppressQuotes || false,
      columnSeparator: columnSeparator || ",",
      rowGroupColsSvc
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};

// packages/ag-grid-community/src/csvExport/csvExportApi.ts
function getDataAsCsv(beans, params) {
  return beans.csvCreator?.getDataAsCsv(params);
}
function exportDataAsCsv(beans, params) {
  beans.csvCreator?.exportDataAsCsv(params);
}

// packages/ag-grid-community/src/csvExport/csvExportModule.ts
var CsvExportModule = {
  moduleName: "CsvExport",
  version: VERSION,
  beans: [CsvCreator],
  apiFunctions: {
    getDataAsCsv,
    exportDataAsCsv
  },
  dependsOn: [SharedExportModule]
};

// packages/ag-grid-community/src/infiniteRowModel/infiniteBlock.ts
var InfiniteBlock = class extends BeanStub {
  constructor(id, parentCache, params) {
    super();
    this.id = id;
    this.parentCache = parentCache;
    this.params = params;
    this.state = "needsLoading";
    this.version = 0;
    this.startRow = id * params.blockSize;
    this.endRow = this.startRow + params.blockSize;
  }
  load() {
    this.state = "loading";
    this.loadFromDatasource();
  }
  setStateWaitingToLoad() {
    this.version++;
    this.state = "needsLoading";
  }
  pageLoadFailed(version) {
    const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
    if (requestMostRecentAndLive) {
      this.state = "failed";
    }
    this.dispatchLocalEvent({ type: "loadComplete" });
  }
  pageLoaded(version, rows, lastRow) {
    this.successCommon(version, { rowData: rows, rowCount: lastRow });
  }
  isRequestMostRecentAndLive(version) {
    const thisIsMostRecentRequest = version === this.version;
    const weAreNotDestroyed = this.isAlive();
    return thisIsMostRecentRequest && weAreNotDestroyed;
  }
  successCommon(version, params) {
    this.dispatchLocalEvent({ type: "loadComplete" });
    const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
    if (requestMostRecentAndLive) {
      this.state = "loaded";
      this.processServerResult(params);
    }
  }
  postConstruct() {
    this.rowNodes = [];
    const {
      params: { blockSize, rowHeight },
      startRow,
      beans,
      rowNodes
    } = this;
    for (let i = 0; i < blockSize; i++) {
      const rowIndex = startRow + i;
      const rowNode = new RowNode(beans);
      rowNode.setRowHeight(rowHeight);
      rowNode.uiLevel = 0;
      rowNode.setRowIndex(rowIndex);
      rowNode.setRowTop(rowHeight * rowIndex);
      rowNodes.push(rowNode);
    }
  }
  getBlockStateJson() {
    const { id, startRow, endRow, state: pageStatus } = this;
    return {
      id: "" + id,
      state: {
        blockNumber: id,
        startRow,
        endRow,
        pageStatus
      }
    };
  }
  setDataAndId(rowNode, data, index) {
    if (_exists(data)) {
      rowNode.setDataAndId(data, index.toString());
    } else {
      rowNode.setDataAndId(void 0, void 0);
    }
  }
  loadFromDatasource() {
    const params = this.createLoadParams();
    if (_missing(this.params.datasource.getRows)) {
      _warn(90);
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(params);
    }, 0);
  }
  createLoadParams() {
    const {
      startRow,
      endRow,
      version,
      params: { sortModel, filterModel },
      gos
    } = this;
    const params = {
      startRow,
      endRow,
      successCallback: this.pageLoaded.bind(this, version),
      failCallback: this.pageLoadFailed.bind(this, version),
      sortModel,
      filterModel,
      context: gos.getGridCommonParams().context
    };
    return params;
  }
  forEachNode(callback, sequence, rowCount) {
    this.rowNodes.forEach((rowNode, index) => {
      const rowIndex = this.startRow + index;
      if (rowIndex < rowCount) {
        callback(rowNode, sequence.value++);
      }
    });
  }
  getRow(rowIndex, dontTouchLastAccessed = false) {
    if (!dontTouchLastAccessed) {
      this.lastAccessed = this.params.lastAccessedSequence.value++;
    }
    const localIndex = rowIndex - this.startRow;
    return this.rowNodes[localIndex];
  }
  processServerResult(params) {
    const { rowNodes, beans } = this;
    rowNodes.forEach((rowNode, index) => {
      const data = params.rowData ? params.rowData[index] : void 0;
      if (!rowNode.id && rowNode.alreadyRendered && data) {
        rowNodes[index] = new RowNode(beans);
        rowNodes[index].setRowIndex(rowNode.rowIndex);
        rowNodes[index].setRowTop(rowNode.rowTop);
        rowNodes[index].setRowHeight(rowNode.rowHeight);
        rowNode.clearRowTopAndRowIndex();
      }
      this.setDataAndId(rowNodes[index], data, this.startRow + index);
    });
    const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;
    this.parentCache.pageLoaded(this, finalRowCount);
  }
  destroy() {
    this.rowNodes.forEach((rowNode) => {
      rowNode.clearRowTopAndRowIndex();
    });
    super.destroy();
  }
};

// packages/ag-grid-community/src/infiniteRowModel/infiniteCache.ts
var MAX_EMPTY_BLOCKS_TO_KEEP = 2;
var InfiniteCache = class extends BeanStub {
  constructor(params) {
    super();
    this.params = params;
    this.lastRowIndexKnown = false;
    this.blocks = {};
    this.blockCount = 0;
    this.rowCount = params.initialRowCount;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(rowIndex, dontCreatePage = false) {
    const blockId = Math.floor(rowIndex / this.params.blockSize);
    let block = this.blocks[blockId];
    if (!block) {
      if (dontCreatePage) {
        return void 0;
      }
      block = this.createBlock(blockId);
    }
    return block.getRow(rowIndex);
  }
  createBlock(blockNumber) {
    const params = this.params;
    const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, params));
    this.blocks[newBlock.id] = newBlock;
    this.blockCount++;
    this.purgeBlocksIfNeeded(newBlock);
    params.rowNodeBlockLoader.addBlock(newBlock);
    return newBlock;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    const nothingToRefresh = this.blockCount == 0;
    if (nothingToRefresh) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());
    this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));
    super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(block, lastRow) {
    if (!this.isAlive()) {
      return;
    }
    _logIfDebug(this.gos, `InfiniteCache - onPageLoaded: page = ${block.id}, lastRow = ${lastRow}`);
    this.checkRowCount(block, lastRow);
    this.onCacheUpdated();
  }
  purgeBlocksIfNeeded(blockToExclude) {
    const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);
    const lastAccessedComparator = (a, b) => b.lastAccessed - a.lastAccessed;
    blocksForPurging.sort(lastAccessedComparator);
    const maxBlocksProvided = this.params.maxBlocksInCache > 0;
    const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;
    const emptyBlocksToKeep = MAX_EMPTY_BLOCKS_TO_KEEP - 1;
    blocksForPurging.forEach((block, index) => {
      const purgeBecauseBlockEmpty = block.state === "needsLoading" && index >= emptyBlocksToKeep;
      const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;
      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {
        if (this.isBlockCurrentlyDisplayed(block)) {
          return;
        }
        if (this.isBlockFocused(block)) {
          return;
        }
        this.removeBlockFromCache(block);
      }
    });
  }
  isBlockFocused(block) {
    const focusedCell = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
    if (!focusedCell) {
      return false;
    }
    if (focusedCell.rowPinned != null) {
      return false;
    }
    const { startRow, endRow } = block;
    const hasFocus = focusedCell.rowIndex >= startRow && focusedCell.rowIndex < endRow;
    return hasFocus;
  }
  isBlockCurrentlyDisplayed(block) {
    const { startRow, endRow } = block;
    return this.beans.rowRenderer.isRangeInRenderedViewport(startRow, endRow - 1);
  }
  removeBlockFromCache(blockToRemove) {
    if (!blockToRemove) {
      return;
    }
    this.destroyBlock(blockToRemove);
  }
  checkRowCount(block, lastRow) {
    if (typeof lastRow === "number" && lastRow >= 0) {
      this.rowCount = lastRow;
      this.lastRowIndexKnown = true;
    } else if (!this.lastRowIndexKnown) {
      const { blockSize, overflowSize } = this.params;
      const lastRowIndex = (block.id + 1) * blockSize;
      const lastRowIndexPlusOverflow = lastRowIndex + overflowSize;
      if (this.rowCount < lastRowIndexPlusOverflow) {
        this.rowCount = lastRowIndexPlusOverflow;
      }
    }
  }
  setRowCount(rowCount, lastRowIndexKnown) {
    this.rowCount = rowCount;
    if (_exists(lastRowIndexKnown)) {
      this.lastRowIndexKnown = lastRowIndexKnown;
    }
    if (!this.lastRowIndexKnown) {
      if (this.rowCount % this.params.blockSize === 0) {
        this.rowCount++;
      }
    }
    this.onCacheUpdated();
  }
  forEachNodeDeep(callback) {
    const sequence = { value: 0 };
    this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));
  }
  getBlocksInOrder() {
    const blockComparator = (a, b) => a.id - b.id;
    const blocks = Object.values(this.blocks).sort(blockComparator);
    return blocks;
  }
  destroyBlock(block) {
    delete this.blocks[block.id];
    this.destroyBean(block);
    this.blockCount--;
    this.params.rowNodeBlockLoader.removeBlock(block);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      this.eventSvc.dispatchEvent({
        type: "storeUpdated"
      });
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const blocksToDestroy = [];
    this.getBlocksInOrder().forEach((block) => {
      const startRow = block.id * this.params.blockSize;
      if (startRow >= this.rowCount) {
        blocksToDestroy.push(block);
      }
    });
    if (blocksToDestroy.length > 0) {
      blocksToDestroy.forEach((block) => this.destroyBlock(block));
    }
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));
    this.lastRowIndexKnown = false;
    if (this.rowCount === 0) {
      this.rowCount = this.params.initialRowCount;
    }
    this.onCacheUpdated();
  }
  getRowNodesInRange(firstInRange, lastInRange) {
    const result = [];
    let lastBlockId = -1;
    let inActiveRange = false;
    const numberSequence = { value: 0 };
    let foundGapInSelection = false;
    this.getBlocksInOrder().forEach((block) => {
      if (foundGapInSelection) {
        return;
      }
      if (inActiveRange && lastBlockId + 1 !== block.id) {
        foundGapInSelection = true;
        return;
      }
      lastBlockId = block.id;
      block.forEachNode(
        (rowNode) => {
          const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
          if (inActiveRange || hitFirstOrLast) {
            result.push(rowNode);
          }
          if (hitFirstOrLast) {
            inActiveRange = !inActiveRange;
          }
        },
        numberSequence,
        this.rowCount
      );
    });
    const invalidRange = foundGapInSelection || inActiveRange;
    return invalidRange ? [] : result;
  }
};

// packages/ag-grid-community/src/infiniteRowModel/infiniteRowModel.ts
var InfiniteRowModel = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowModel";
  }
  getRowBounds(index) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * index
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return false;
  }
  postConstruct() {
    if (this.gos.get("rowModelType") !== "infinite") {
      return;
    }
    this.rowHeight = _getRowHeightAsNumber(this.beans);
    this.addEventListeners();
    this.addDestroyFunc(() => this.destroyCache());
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource();
    super.destroy();
  }
  destroyDatasource() {
    if (this.datasource) {
      this.destroyBean(this.datasource);
      this.beans.rowRenderer.datasourceChanged();
      this.datasource = null;
    }
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.reset.bind(this),
      sortChanged: this.reset.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.dispatchModelUpdatedEvent.bind(this)
    });
    this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource")));
    this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache());
    this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = _getRowHeightAsNumber(this.beans);
      this.cacheParams.rowHeight = this.rowHeight;
      this.updateRowHeights();
    });
  }
  onColumnEverything() {
    let resetRequired;
    if (this.cacheParams) {
      resetRequired = !_jsonEquals(this.cacheParams.sortModel, this.beans.sortSvc?.getSortModel() ?? []);
    } else {
      resetRequired = true;
    }
    if (resetRequired) {
      this.reset();
    }
  }
  getType() {
    return "infinite";
  }
  setDatasource(datasource) {
    this.destroyDatasource();
    this.datasource = datasource;
    if (datasource) {
      this.reset();
    }
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(firstInRange, lastInRange) {
    return this.infiniteCache?.getRowNodesInRange(firstInRange, lastInRange) ?? [];
  }
  reset() {
    if (!this.datasource) {
      return;
    }
    const getRowIdFunc = _getRowIdCallback(this.gos);
    const userGeneratingIds = getRowIdFunc != null;
    if (!userGeneratingIds) {
      this.beans.selectionSvc?.reset("rowDataChanged");
    }
    this.resetCache();
  }
  dispatchModelUpdatedEvent() {
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: false,
      newPageSize: false,
      newData: false,
      keepRenderedRows: true,
      animate: false
    });
  }
  resetCache() {
    this.destroyCache();
    const beans = this.beans;
    const { filterManager, sortSvc, rowNodeBlockLoader, eventSvc, gos } = beans;
    this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: filterManager?.getFilterModel() ?? {},
      sortModel: sortSvc?.getSortModel() ?? [],
      rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: gos.get("infiniteInitialRowCount"),
      maxBlocksInCache: gos.get("maxBlocksInCache"),
      rowHeight: _getRowHeightAsNumber(beans),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: gos.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: gos.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: { value: 0 }
    };
    this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));
    eventSvc.dispatchEventOnce({
      type: "rowCountReady"
    });
    this.dispatchModelUpdatedEvent();
  }
  updateRowHeights() {
    this.forEachNode((node) => {
      node.setRowHeight(this.rowHeight);
      node.setRowTop(this.rowHeight * node.rowIndex);
    });
    this.dispatchModelUpdatedEvent();
  }
  destroyCache() {
    this.infiniteCache = this.destroyBean(this.infiniteCache);
  }
  getRow(rowIndex) {
    const infiniteCache = this.infiniteCache;
    if (!infiniteCache) {
      return void 0;
    }
    if (rowIndex >= infiniteCache.getRowCount()) {
      return void 0;
    }
    return infiniteCache.getRow(rowIndex);
  }
  getRowNode(id) {
    let result;
    this.forEachNode((rowNode) => {
      if (rowNode.id === id) {
        result = rowNode;
      }
    });
    return result;
  }
  forEachNode(callback) {
    this.infiniteCache?.forEachNodeDeep(callback);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(topLevelIndex) {
    return topLevelIndex;
  }
  getRowIndexAtPixel(pixel) {
    if (this.rowHeight !== 0) {
      const rowIndexForPixel = Math.floor(pixel / this.rowHeight);
      const lastRowIndex = this.getRowCount() - 1;
      if (rowIndexForPixel > lastRowIndex) {
        return lastRowIndex;
      }
      return rowIndexForPixel;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(rowNode) {
    return !!this.getRowNode(rowNode.id);
  }
  refreshCache() {
    this.infiniteCache?.refreshCache();
  }
  purgeCache() {
    this.infiniteCache?.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache?.isLastRowIndexKnown() ?? false;
  }
  setRowCount(rowCount, lastRowIndexKnown) {
    this.infiniteCache?.setRowCount(rowCount, lastRowIndexKnown);
  }
};

// packages/ag-grid-community/src/infiniteRowModel/infiniteRowModelApi.ts
function refreshInfiniteCache(beans) {
  _getInfiniteRowModel(beans)?.refreshCache();
}
function purgeInfiniteCache(beans) {
  _getInfiniteRowModel(beans)?.purgeCache();
}
function getInfiniteRowCount(beans) {
  return _getInfiniteRowModel(beans)?.getRowCount();
}

// packages/ag-grid-community/src/infiniteRowModel/rowNodeBlockLoader.ts
var RowNodeBlockLoader = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowNodeBlockLoader";
    this.activeBlockLoadsCount = 0;
    this.blocks = [];
    this.active = true;
  }
  postConstruct() {
    this.maxConcurrentRequests = _getMaxConcurrentDatasourceRequests(this.gos);
    const blockLoadDebounceMillis = this.gos.get("blockLoadDebounceMillis");
    if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) {
      this.checkBlockToLoadDebounce = _debounce(
        this,
        this.performCheckBlocksToLoad.bind(this),
        blockLoadDebounceMillis
      );
    }
  }
  addBlock(block) {
    this.blocks.push(block);
    block.addEventListener("loadComplete", this.loadComplete.bind(this));
    this.checkBlockToLoad();
  }
  removeBlock(block) {
    _removeFromArray(this.blocks, block);
  }
  destroy() {
    super.destroy();
    this.active = false;
  }
  loadComplete() {
    this.activeBlockLoadsCount--;
    this.checkBlockToLoad();
  }
  checkBlockToLoad() {
    if (this.checkBlockToLoadDebounce) {
      this.checkBlockToLoadDebounce();
    } else {
      this.performCheckBlocksToLoad();
    }
  }
  performCheckBlocksToLoad() {
    if (!this.active) {
      return;
    }
    this.printCacheStatus();
    if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      _logIfDebug(this.gos, `RowNodeBlockLoader - checkBlockToLoad: max loads exceeded`);
      return;
    }
    const loadAvailability = this.maxConcurrentRequests != null ? this.maxConcurrentRequests - this.activeBlockLoadsCount : 1;
    const blocksToLoad = this.blocks.filter((block) => block.state === "needsLoading").slice(0, loadAvailability);
    this.activeBlockLoadsCount += blocksToLoad.length;
    blocksToLoad.forEach((block) => block.load());
    this.printCacheStatus();
  }
  getBlockState() {
    const result = {};
    this.blocks.forEach((block) => {
      const { id, state } = block.getBlockStateJson();
      result[id] = state;
    });
    return result;
  }
  printCacheStatus() {
    _logIfDebug(
      this.gos,
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
};

// packages/ag-grid-community/src/infiniteRowModel/infiniteRowModelModule.ts
var InfiniteRowModelModule = {
  moduleName: "InfiniteRowModel",
  version: VERSION,
  rowModels: ["infinite"],
  apiFunctions: {
    refreshInfiniteCache,
    purgeInfiniteCache,
    getInfiniteRowCount
  },
  beans: [InfiniteRowModel, RowNodeBlockLoader],
  dependsOn: [SsrmInfiniteSharedApiModule]
};

// packages/ag-grid-community/src/rendering/cellRenderers/animateShowChangeCellRenderer.ts
var ARROW_UP = "\u2191";
var ARROW_DOWN = "\u2193";
var AnimateShowChangeCellRenderer = class extends Component {
  constructor() {
    super();
    this.refreshCount = 0;
    const template = document.createElement("span");
    const delta = document.createElement("span");
    delta.setAttribute("class", "ag-value-change-delta");
    const value = document.createElement("span");
    value.setAttribute("class", "ag-value-change-value");
    template.appendChild(delta);
    template.appendChild(value);
    this.setTemplateFromElement(template);
  }
  init(params) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value");
    this.eDelta = this.queryForHtmlElement(".ag-value-change-delta");
    this.refresh(params, true);
  }
  showDelta(params, delta) {
    const absDelta = Math.abs(delta);
    const valueFormatted = params.formatValue(absDelta);
    const valueToUse = _exists(valueFormatted) ? valueFormatted : absDelta;
    const deltaUp = delta >= 0;
    const eDelta = this.eDelta;
    if (deltaUp) {
      eDelta.textContent = ARROW_UP + valueToUse;
    } else {
      eDelta.textContent = ARROW_DOWN + valueToUse;
    }
    eDelta.classList.toggle("ag-value-change-delta-up", deltaUp);
    eDelta.classList.toggle("ag-value-change-delta-down", !deltaUp);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const refreshCountCopy = this.refreshCount;
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        if (refreshCountCopy === this.refreshCount) {
          this.hideDeltaValue();
        }
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight");
    _clearElement(this.eDelta);
  }
  refresh(params, isInitialRender = false) {
    const { value, valueFormatted } = params;
    const { eValue, lastValue, beans } = this;
    if (value === lastValue) {
      return false;
    }
    if (_exists(valueFormatted)) {
      eValue.textContent = valueFormatted;
    } else if (_exists(value)) {
      eValue.textContent = value;
    } else {
      _clearElement(eValue);
    }
    if (beans.filterManager?.isSuppressFlashingCellsBecauseFiltering()) {
      return false;
    }
    if (typeof value === "number" && typeof lastValue === "number") {
      const delta = value - lastValue;
      this.showDelta(params, delta);
    }
    if (lastValue) {
      eValue.classList.add("ag-value-change-value-highlight");
    }
    if (!isInitialRender) {
      this.setTimerToRemoveDelta();
    }
    this.lastValue = value;
    return true;
  }
};

// packages/ag-grid-community/src/rendering/cellRenderers/animateSlideCellRenderer.css-GENERATED.ts
var animateSlideCellRendererCSS = (
  /*css*/
  `.ag-value-slide-out{opacity:1}:where(.ag-ltr) .ag-value-slide-out{margin-right:5px;transition:opacity 3s,margin-right 3s}:where(.ag-rtl) .ag-value-slide-out{margin-left:5px;transition:opacity 3s,margin-left 3s}:where(.ag-ltr,.ag-rtl) .ag-value-slide-out{transition-timing-function:linear}.ag-value-slide-out-end{opacity:0}:where(.ag-ltr) .ag-value-slide-out-end{margin-right:10px}:where(.ag-rtl) .ag-value-slide-out-end{margin-left:10px}`
);

// packages/ag-grid-community/src/rendering/cellRenderers/animateSlideCellRenderer.ts
var AnimateSlideCellRenderer = class extends Component {
  constructor() {
    super();
    this.refreshCount = 0;
    const template = document.createElement("span");
    const slide = document.createElement("span");
    slide.setAttribute("class", "ag-value-slide-current");
    template.appendChild(slide);
    this.setTemplateFromElement(template);
    this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
    this.registerCSS(animateSlideCellRendererCSS);
  }
  init(params) {
    this.refresh(params, true);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const refreshCountCopy = this.refreshCount;
    if (this.ePrevious) {
      this.getGui().removeChild(this.ePrevious);
    }
    const { beans, eCurrent } = this;
    const prevElement = _getDocument(beans).createElement("span");
    prevElement.setAttribute("class", "ag-value-slide-previous ag-value-slide-out");
    this.ePrevious = prevElement;
    prevElement.textContent = eCurrent.textContent;
    this.getGui().insertBefore(prevElement, eCurrent);
    beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        if (refreshCountCopy !== this.refreshCount) {
          return;
        }
        this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50);
      window.setTimeout(() => {
        if (refreshCountCopy !== this.refreshCount) {
          return;
        }
        this.getGui().removeChild(this.ePrevious);
        this.ePrevious = null;
      }, 3e3);
    });
  }
  refresh(params, isInitialRender = false) {
    let value = params.value;
    if (_missing(value)) {
      value = "";
    }
    if (value === this.lastValue) {
      return false;
    }
    if (this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering()) {
      return false;
    }
    if (!isInitialRender) {
      this.addSlideAnimation();
    }
    this.lastValue = value;
    const eCurrent = this.eCurrent;
    if (_exists(params.valueFormatted)) {
      eCurrent.textContent = params.valueFormatted;
    } else if (_exists(params.value)) {
      eCurrent.textContent = value;
    } else {
      _clearElement(eCurrent);
    }
    return true;
  }
};

// packages/ag-grid-community/src/rendering/cell/cellFlashService.ts
var CellFlashService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "cellFlashSvc";
  }
  onFlashCells(cellCtrl, event) {
    if (!cellCtrl.comp) {
      return;
    }
    const cellId = _createCellId(cellCtrl.cellPosition);
    const shouldFlash = event.cells[cellId];
    if (shouldFlash) {
      this.animateCell(cellCtrl, "highlight");
    }
  }
  flashCell(cellCtrl, delays) {
    this.animateCell(cellCtrl, "data-changed", delays?.flashDuration, delays?.fadeDuration);
  }
  animateCell(cellCtrl, cssName, flashDuration, fadeDuration) {
    const cellComp = cellCtrl.comp;
    if (!cellComp) {
      return;
    }
    const { gos } = this;
    if (!flashDuration) {
      flashDuration = gos.get("cellFlashDuration");
    }
    if (flashDuration === 0) {
      return;
    }
    if (!_exists(fadeDuration)) {
      fadeDuration = gos.get("cellFadeDuration");
    }
    const fullName = `ag-cell-${cssName}`;
    const animationFullName = `ag-cell-${cssName}-animation`;
    cellComp.addOrRemoveCssClass(fullName, true);
    cellComp.addOrRemoveCssClass(animationFullName, false);
    const { eGui } = cellCtrl;
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        if (!cellCtrl.isAlive()) {
          return;
        }
        cellComp.addOrRemoveCssClass(fullName, false);
        cellComp.addOrRemoveCssClass(animationFullName, true);
        eGui.style.transition = `background-color ${fadeDuration}ms`;
        window.setTimeout(() => {
          if (!cellCtrl.isAlive()) {
            return;
          }
          cellComp.addOrRemoveCssClass(animationFullName, false);
          eGui.style.transition = "";
        }, fadeDuration);
      }, flashDuration);
    });
  }
};

// packages/ag-grid-community/src/rendering/cell/highlightChangesApi.ts
function flashCells(beans, params = {}) {
  const { cellFlashSvc } = beans;
  if (!cellFlashSvc) {
    return;
  }
  beans.frameworkOverrides.wrapIncoming(() => {
    beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => cellFlashSvc.flashCell(cellCtrl, params));
  });
}

// packages/ag-grid-community/src/rendering/cell/highlightChangesModule.ts
var HighlightChangesModule = {
  moduleName: "HighlightChanges",
  version: VERSION,
  beans: [CellFlashService],
  userComponents: {
    agAnimateShowChangeCellRenderer: AnimateShowChangeCellRenderer,
    agAnimateSlideCellRenderer: AnimateSlideCellRenderer
  },
  apiFunctions: {
    flashCells
  }
};

// packages/ag-grid-community/src/misc/state/stateApi.ts
function getState(beans) {
  return beans.stateSvc?.getState() ?? {};
}

// packages/ag-grid-community/src/misc/state/stateModelMigration.ts
function migrateGridStateModel(state) {
  state = { ...state };
  if (!state.version) {
    state.version = "32.1.0";
  }
  switch (state.version) {
    case "32.1.0":
      state = migrateV32_1(state);
  }
  return state;
}
function migrateV32_1(state) {
  state.cellSelection = jsonGet(state, "rangeSelection");
  return state;
}
function jsonGet(json, key) {
  if (json && typeof json === "object") {
    return json[key];
  }
}

// packages/ag-grid-community/src/misc/state/stateService.ts
var StateService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "stateSvc";
    this.updateRowGroupExpansionStateTimer = 0;
    this.suppressEvents = true;
    this.queuedUpdateSources = /* @__PURE__ */ new Set();
    this.dispatchStateUpdateEventDebounced = _debounce(this, () => this.dispatchQueuedStateUpdateEvents(), 0);
    // If user is doing a manual expand all node by node, we don't want to process one at a time.
    // EVENT_ROW_GROUP_OPENED is already async, so no impact of making the state async here.
    this.onRowGroupOpenedDebounced = _debounce(
      this,
      () => {
        this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
      },
      0
    );
    // similar to row expansion, want to debounce. However, selection is synchronous, so need to mark as stale in case `getState` is called.
    this.onRowSelectedDebounced = _debounce(
      this,
      () => {
        this.staleStateKeys.delete("rowSelection");
        this.updateCachedState("rowSelection", this.getRowSelectionState());
      },
      0
    );
    this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  postConstruct() {
    this.isClientSideRowModel = _isClientSideRowModel(this.gos);
    this.cachedState = this.getInitialState();
    this.setCachedStateValue("version", VERSION);
    const suppressEventsAndDispatchInitEvent = this.suppressEventsAndDispatchInitEvent.bind(this);
    this.beans.ctrlsSvc.whenReady(
      this,
      () => suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady())
    );
    const [newColumnsLoadedDestroyFunc, rowCountReadyDestroyFunc, firstDataRenderedDestroyFunc] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source }) => {
        if (source === "gridInitializing") {
          newColumnsLoadedDestroyFunc();
          suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised());
        }
      },
      rowCountReady: () => {
        rowCountReadyDestroyFunc?.();
        suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
      },
      firstDataRendered: () => {
        firstDataRenderedDestroyFunc?.();
        suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
      }
    });
  }
  destroy() {
    super.destroy();
    clearTimeout(this.updateRowGroupExpansionStateTimer);
    this.queuedUpdateSources.clear();
  }
  getInitialState() {
    return migrateGridStateModel(this.gos.get("initialState") ?? {});
  }
  getState() {
    if (this.staleStateKeys.size) {
      this.refreshStaleState();
    }
    return this.cachedState;
  }
  setupStateOnGridReady() {
    const stateUpdater = () => this.updateCachedState("sideBar", this.getSideBarState());
    stateUpdater();
    this.addManagedEventListeners({
      toolPanelVisibleChanged: stateUpdater,
      sideBarUpdated: stateUpdater
    });
  }
  setupStateOnColumnsInitialised() {
    const initialState = this.getInitialState();
    this.setColumnState(initialState);
    this.setColumnGroupState(initialState);
    this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]);
    this.updateCachedState("columnGroup", this.getColumnGroupState());
    const onUpdate = (state) => () => this.updateColumnState([state]);
    this.addManagedEventListeners({
      columnValueChanged: onUpdate("aggregation"),
      columnMoved: onUpdate("columnOrder"),
      columnPinned: onUpdate("columnPinning"),
      columnResized: onUpdate("columnSizing"),
      columnVisible: onUpdate("columnVisibility"),
      columnPivotChanged: onUpdate("pivot"),
      columnPivotModeChanged: onUpdate("pivot"),
      columnRowGroupChanged: onUpdate("rowGroup"),
      sortChanged: onUpdate("sort"),
      newColumnsLoaded: () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "rowGroup",
        "sort"
      ]),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setupStateOnRowCountReady() {
    const {
      filter: filterState,
      rowGroupExpansion: rowGroupExpansionState,
      rowSelection: rowSelectionState,
      pagination: paginationState
    } = this.getInitialState();
    if (filterState) {
      this.setFilterState(filterState);
    }
    if (rowGroupExpansionState) {
      this.setRowGroupExpansionState(rowGroupExpansionState);
    }
    if (rowSelectionState) {
      this.setRowSelectionState(rowSelectionState);
    }
    if (paginationState) {
      this.setPaginationState(paginationState);
    }
    const updateCachedState = this.updateCachedState.bind(this);
    updateCachedState("filter", this.getFilterState());
    updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
    updateCachedState("rowSelection", this.getRowSelectionState());
    updateCachedState("pagination", this.getPaginationState());
    const updateRowGroupExpansionState = () => {
      this.updateRowGroupExpansionStateTimer = 0;
      updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
    };
    this.addManagedEventListeners({
      filterChanged: () => updateCachedState("filter", this.getFilterState()),
      rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
      expandOrCollapseAll: updateRowGroupExpansionState,
      // `groupDefaultExpanded` updates expansion state without an expansion event
      columnRowGroupChanged: updateRowGroupExpansionState,
      rowDataUpdated: () => {
        if (this.gos.get("groupDefaultExpanded") !== 0) {
          this.updateRowGroupExpansionStateTimer || (this.updateRowGroupExpansionStateTimer = setTimeout(updateRowGroupExpansionState));
        }
      },
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection");
        this.onRowSelectedDebounced();
      },
      paginationChanged: (event) => {
        if (event.newPage || event.newPageSize) {
          updateCachedState("pagination", this.getPaginationState());
        }
      }
    });
  }
  setupStateOnFirstDataRendered() {
    const {
      scroll: scrollState,
      cellSelection: cellSelectionState,
      focusedCell: focusedCellState,
      columnOrder: columnOrderState
    } = this.getInitialState();
    if (focusedCellState) {
      this.setFocusedCellState(focusedCellState);
    }
    if (cellSelectionState) {
      this.setCellSelectionState(cellSelectionState);
    }
    if (scrollState) {
      this.setScrollState(scrollState);
    }
    this.setColumnPivotState(!!columnOrderState?.orderedColIds);
    const updateCachedState = this.updateCachedState.bind(this);
    updateCachedState("sideBar", this.getSideBarState());
    updateCachedState("focusedCell", this.getFocusedCellState());
    const cellSelection = this.getRangeSelectionState();
    updateCachedState("rangeSelection", cellSelection);
    updateCachedState("cellSelection", cellSelection);
    updateCachedState("scroll", this.getScrollState());
    this.addManagedEventListeners({
      cellFocused: () => updateCachedState("focusedCell", this.getFocusedCellState()),
      cellSelectionChanged: (event) => {
        if (event.finished) {
          const cellSelection2 = this.getRangeSelectionState();
          updateCachedState("rangeSelection", cellSelection2);
          updateCachedState("cellSelection", cellSelection2);
        }
      },
      bodyScrollEnd: () => updateCachedState("scroll", this.getScrollState())
    });
  }
  getColumnState() {
    const beans = this.beans;
    const pivotMode = beans.colModel.isPivotMode();
    const sortColumns = [];
    const groupColIds = [];
    const aggregationColumns = [];
    const pivotColIds = [];
    const leftColIds = [];
    const rightColIds = [];
    const hiddenColIds = [];
    const columnSizes = [];
    const columns = [];
    let defaultSortIndex = 0;
    const columnState = _getColumnState(beans);
    for (let i = 0; i < columnState.length; i++) {
      const {
        colId,
        sort,
        sortIndex,
        rowGroup,
        rowGroupIndex,
        aggFunc,
        pivot,
        pivotIndex,
        pinned,
        hide,
        width,
        flex
      } = columnState[i];
      columns.push(colId);
      if (sort) {
        sortColumns[sortIndex ?? defaultSortIndex++] = { colId, sort };
      }
      if (rowGroup) {
        groupColIds[rowGroupIndex ?? 0] = colId;
      }
      if (typeof aggFunc === "string") {
        aggregationColumns.push({ colId, aggFunc });
      }
      if (pivot) {
        pivotColIds[pivotIndex ?? 0] = colId;
      }
      if (pinned) {
        (pinned === "right" ? rightColIds : leftColIds).push(colId);
      }
      if (hide) {
        hiddenColIds.push(colId);
      }
      if (flex || width) {
        columnSizes.push({ colId, flex: flex ?? void 0, width });
      }
    }
    return {
      sort: sortColumns.length ? { sortModel: sortColumns } : void 0,
      rowGroup: groupColIds.length ? { groupColIds } : void 0,
      aggregation: aggregationColumns.length ? { aggregationModel: aggregationColumns } : void 0,
      pivot: pivotColIds.length || pivotMode ? { pivotMode, pivotColIds } : void 0,
      columnPinning: leftColIds.length || rightColIds.length ? { leftColIds, rightColIds } : void 0,
      columnVisibility: hiddenColIds.length ? { hiddenColIds } : void 0,
      columnSizing: columnSizes.length ? { columnSizingModel: columnSizes } : void 0,
      columnOrder: columns.length ? { orderedColIds: columns } : void 0
    };
  }
  setColumnState(initialState) {
    const {
      sort: sortState,
      rowGroup: groupState,
      aggregation: aggregationState,
      pivot: pivotState,
      columnPinning: columnPinningState,
      columnVisibility: columnVisibilityState,
      columnSizing: columnSizingState,
      columnOrder: columnOrderState,
      partialColumnState
    } = initialState;
    const columnStateMap = {};
    const getColumnState2 = (colId) => {
      let columnState = columnStateMap[colId];
      if (columnState) {
        return columnState;
      }
      columnState = { colId };
      columnStateMap[colId] = columnState;
      return columnState;
    };
    const defaultState = partialColumnState ? {} : {
      sort: null,
      sortIndex: null,
      rowGroup: null,
      rowGroupIndex: null,
      aggFunc: null,
      pivot: null,
      pivotIndex: null,
      pinned: null,
      hide: null,
      flex: null
    };
    if (sortState) {
      sortState.sortModel.forEach(({ colId, sort }, sortIndex) => {
        const columnState = getColumnState2(colId);
        columnState.sort = sort;
        columnState.sortIndex = sortIndex;
      });
      defaultState.sort = null;
      defaultState.sortIndex = null;
    }
    if (groupState) {
      groupState.groupColIds.forEach((colId, rowGroupIndex) => {
        const columnState = getColumnState2(colId);
        columnState.rowGroup = true;
        columnState.rowGroupIndex = rowGroupIndex;
      });
      defaultState.rowGroup = null;
      defaultState.rowGroupIndex = null;
    }
    if (aggregationState) {
      aggregationState.aggregationModel.forEach(({ colId, aggFunc }) => {
        getColumnState2(colId).aggFunc = aggFunc;
      });
      defaultState.aggFunc = null;
    }
    if (pivotState) {
      pivotState.pivotColIds.forEach((colId, pivotIndex) => {
        const columnState = getColumnState2(colId);
        columnState.pivot = true;
        columnState.pivotIndex = pivotIndex;
      });
      this.gos.updateGridOptions({
        options: { pivotMode: pivotState.pivotMode },
        source: "gridInitializing"
      });
      defaultState.pivot = null;
      defaultState.pivotIndex = null;
    }
    if (columnPinningState) {
      columnPinningState.leftColIds.forEach((colId) => {
        getColumnState2(colId).pinned = "left";
      });
      columnPinningState.rightColIds.forEach((colId) => {
        getColumnState2(colId).pinned = "right";
      });
      defaultState.pinned = null;
    }
    if (columnVisibilityState) {
      columnVisibilityState.hiddenColIds.forEach((colId) => {
        getColumnState2(colId).hide = true;
      });
      defaultState.hide = null;
    }
    if (columnSizingState) {
      columnSizingState.columnSizingModel.forEach(({ colId, flex, width }) => {
        const columnState = getColumnState2(colId);
        columnState.flex = flex ?? null;
        columnState.width = width;
      });
      defaultState.flex = null;
    }
    const columns = columnOrderState?.orderedColIds;
    const applyOrder = !!columns?.length;
    const columnStates = applyOrder ? columns.map((colId) => getColumnState2(colId)) : Object.values(columnStateMap);
    if (columnStates.length) {
      this.columnStates = columnStates;
      _applyColumnState(
        this.beans,
        {
          state: columnStates,
          applyOrder,
          defaultState
        },
        "gridInitializing"
      );
    }
  }
  setColumnPivotState(applyOrder) {
    const columnStates = this.columnStates;
    this.columnStates = void 0;
    const columnGroupStates = this.columnGroupStates;
    this.columnGroupStates = void 0;
    const beans = this.beans;
    const { pivotResultCols, colGroupSvc } = beans;
    if (!pivotResultCols?.isPivotResultColsPresent()) {
      return;
    }
    if (columnStates) {
      const secondaryColumnStates = [];
      for (const columnState of columnStates) {
        if (pivotResultCols.getPivotResultCol(columnState.colId)) {
          secondaryColumnStates.push(columnState);
        }
      }
      _applyColumnState(
        beans,
        {
          state: secondaryColumnStates,
          applyOrder
        },
        "gridInitializing"
      );
    }
    if (columnGroupStates) {
      colGroupSvc?.setColumnGroupState(columnGroupStates, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const colGroupSvc = this.beans.colGroupSvc;
    if (!colGroupSvc) {
      return void 0;
    }
    const columnGroupState = colGroupSvc.getColumnGroupState();
    const openColumnGroups = [];
    columnGroupState.forEach(({ groupId, open }) => {
      if (open) {
        openColumnGroups.push(groupId);
      }
    });
    return openColumnGroups.length ? { openColumnGroupIds: openColumnGroups } : void 0;
  }
  setColumnGroupState(initialState) {
    const colGroupSvc = this.beans.colGroupSvc;
    if (!Object.prototype.hasOwnProperty.call(initialState, "columnGroup") || !colGroupSvc) {
      return;
    }
    const openColumnGroups = new Set(initialState.columnGroup?.openColumnGroupIds);
    const existingColumnGroupState = colGroupSvc.getColumnGroupState();
    const stateItems = existingColumnGroupState.map(({ groupId }) => {
      const open = openColumnGroups.has(groupId);
      if (open) {
        openColumnGroups.delete(groupId);
      }
      return {
        groupId,
        open
      };
    });
    openColumnGroups.forEach((groupId) => {
      stateItems.push({
        groupId,
        open: true
      });
    });
    if (stateItems.length) {
      this.columnGroupStates = stateItems;
    }
    colGroupSvc.setColumnGroupState(stateItems, "gridInitializing");
  }
  getFilterState() {
    const filterManager = this.beans.filterManager;
    let filterModel = filterManager?.getFilterModel();
    if (filterModel && Object.keys(filterModel).length === 0) {
      filterModel = void 0;
    }
    const advancedFilterModel = filterManager?.getAdvFilterModel() ?? void 0;
    return filterModel || advancedFilterModel ? { filterModel, advancedFilterModel } : void 0;
  }
  setFilterState(filterState) {
    const filterManager = this.beans.filterManager;
    const { filterModel, advancedFilterModel } = filterState ?? {};
    if (filterModel) {
      filterManager?.setFilterModel(filterModel, "columnFilter");
    }
    if (advancedFilterModel) {
      filterManager?.setAdvFilterModel(advancedFilterModel);
    }
  }
  getRangeSelectionState() {
    const cellRanges = this.beans.rangeSvc?.getCellRanges().map((cellRange) => {
      const { id, type, startRow, endRow, columns, startColumn } = cellRange;
      return {
        id,
        type,
        startRow,
        endRow,
        colIds: columns.map((column) => column.getColId()),
        startColId: startColumn.getColId()
      };
    });
    return cellRanges?.length ? { cellRanges } : void 0;
  }
  setCellSelectionState(cellSelectionState) {
    const { gos, rangeSvc, colModel, visibleCols } = this.beans;
    if (!_isCellSelectionEnabled(gos) || !rangeSvc) {
      return;
    }
    const cellRanges = [];
    cellSelectionState.cellRanges.forEach((cellRange) => {
      const columns = [];
      cellRange.colIds.forEach((colId) => {
        const column = colModel.getCol(colId);
        if (column) {
          columns.push(column);
        }
      });
      if (!columns.length) {
        return;
      }
      let startColumn = colModel.getCol(cellRange.startColId);
      if (!startColumn) {
        const allColumns = visibleCols.allCols;
        const columnSet = new Set(columns);
        startColumn = allColumns.find((column) => columnSet.has(column));
      }
      cellRanges.push({
        ...cellRange,
        columns,
        startColumn
      });
    });
    rangeSvc.setCellRanges(cellRanges);
  }
  getScrollState() {
    if (!this.isClientSideRowModel) {
      return void 0;
    }
    const scrollFeature = this.beans.ctrlsSvc.getScrollFeature();
    const { left } = scrollFeature?.getHScrollPosition() ?? { left: 0 };
    const { top } = scrollFeature?.getVScrollPosition() ?? { top: 0 };
    return top || left ? {
      top,
      left
    } : void 0;
  }
  setScrollState(scrollState) {
    if (!this.isClientSideRowModel) {
      return;
    }
    const { top, left } = scrollState;
    const { frameworkOverrides, rowRenderer, animationFrameSvc, ctrlsSvc } = this.beans;
    frameworkOverrides.wrapIncoming(() => {
      ctrlsSvc.get("center").setCenterViewportScrollLeft(left);
      ctrlsSvc.getScrollFeature()?.setVerticalScrollPosition(top);
      rowRenderer.redraw({ afterScroll: true });
      animationFrameSvc?.flushAllFrames();
    });
  }
  getSideBarState() {
    return this.beans.sideBar?.comp?.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel) {
      return void 0;
    }
    const focusedCell = this.beans.focusSvc.getFocusedCell();
    if (focusedCell) {
      const { column, rowIndex, rowPinned } = focusedCell;
      return {
        colId: column.getColId(),
        rowIndex,
        rowPinned
      };
    }
    return void 0;
  }
  setFocusedCellState(focusedCellState) {
    if (!this.isClientSideRowModel) {
      return;
    }
    const { colId, rowIndex, rowPinned } = focusedCellState;
    const { focusSvc, colModel } = this.beans;
    focusSvc.setFocusedCell({
      column: colModel.getCol(colId),
      rowIndex,
      rowPinned,
      forceBrowserFocus: true,
      preventScrollOnBrowserFocus: true
    });
  }
  getPaginationState() {
    const { pagination, gos } = this.beans;
    if (!pagination) {
      return void 0;
    }
    const page = pagination.getCurrentPage();
    const pageSize = !gos.get("paginationAutoPageSize") ? pagination.getPageSize() : void 0;
    if (!page && !pageSize) {
      return;
    }
    return { page, pageSize };
  }
  setPaginationState(paginationState) {
    const { pagination, gos } = this.beans;
    if (!pagination) {
      return;
    }
    if (paginationState.pageSize && !gos.get("paginationAutoPageSize")) {
      pagination.setPageSize(paginationState.pageSize, "initialState");
    }
    if (typeof paginationState.page === "number") {
      pagination.setPage(paginationState.page);
    }
  }
  getRowSelectionState() {
    const selectionSvc = this.beans.selectionSvc;
    if (!selectionSvc) {
      return void 0;
    }
    const selectionState = selectionSvc.getSelectionState();
    const noSelections = !selectionState || !Array.isArray(selectionState) && (selectionState.selectAll === false || selectionState.selectAllChildren === false) && !selectionState?.toggledNodes?.length;
    return noSelections ? void 0 : selectionState;
  }
  setRowSelectionState(rowSelectionState) {
    this.beans.selectionSvc?.setSelectionState(rowSelectionState, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const { expansionSvc, rowModel } = this.beans;
    if (!expansionSvc) {
      return void 0;
    }
    const expandedRowGroups = [];
    rowModel.forEachNode(({ expanded, id }) => {
      if (expanded && id) {
        expandedRowGroups.push(id);
      }
    });
    return expandedRowGroups.length ? {
      expandedRowGroupIds: expandedRowGroups
    } : void 0;
  }
  setRowGroupExpansionState(rowGroupExpansionState) {
    this.beans.expansionSvc?.expandRows(rowGroupExpansionState.expandedRowGroupIds);
  }
  updateColumnState(features) {
    const newColumnState = this.getColumnState();
    let hasChanged = false;
    const cachedState = this.cachedState;
    Object.entries(newColumnState).forEach(([key, value]) => {
      if (!_jsonEquals(value, cachedState[key])) {
        hasChanged = true;
      }
    });
    this.cachedState = {
      ...cachedState,
      ...newColumnState
    };
    if (hasChanged) {
      this.dispatchStateUpdateEvent(features);
    }
  }
  updateCachedState(key, value) {
    const existingValue = this.cachedState[key];
    this.setCachedStateValue(key, value);
    if (!_jsonEquals(value, existingValue)) {
      this.dispatchStateUpdateEvent([key]);
    }
  }
  setCachedStateValue(key, value) {
    this.cachedState = {
      ...this.cachedState,
      [key]: value
    };
  }
  refreshStaleState() {
    const staleStateKeys = this.staleStateKeys;
    staleStateKeys.forEach((key) => {
      switch (key) {
        case "rowSelection":
          this.setCachedStateValue(key, this.getRowSelectionState());
          break;
      }
    });
    staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(sources) {
    if (this.suppressEvents) {
      return;
    }
    sources.forEach((source) => this.queuedUpdateSources.add(source));
    this.dispatchStateUpdateEventDebounced();
  }
  dispatchQueuedStateUpdateEvents() {
    const queuedUpdateSources = this.queuedUpdateSources;
    const sources = Array.from(queuedUpdateSources);
    queuedUpdateSources.clear();
    this.eventSvc.dispatchEvent({
      type: "stateUpdated",
      sources,
      state: this.cachedState
    });
  }
  suppressEventsAndDispatchInitEvent(updateFunc) {
    this.suppressEvents = true;
    const colAnimation = this.beans.colAnimation;
    colAnimation?.setSuppressAnimation(true);
    updateFunc();
    setTimeout(() => {
      this.suppressEvents = false;
      this.queuedUpdateSources.clear();
      if (!this.isAlive()) {
        return;
      }
      colAnimation?.setSuppressAnimation(false);
      this.dispatchStateUpdateEvent(["gridInitializing"]);
    });
  }
};

// packages/ag-grid-community/src/misc/state/stateModule.ts
var GridStateModule = {
  moduleName: "GridState",
  version: VERSION,
  beans: [StateService],
  apiFunctions: {
    getState
  }
};

// packages/ag-grid-community/src/pagination/paginationApi.ts
function paginationIsLastPageFound(beans) {
  return beans.rowModel.isLastRowIndexKnown();
}
function paginationGetPageSize(beans) {
  return beans.pagination?.getPageSize() ?? 100;
}
function paginationGetCurrentPage(beans) {
  return beans.pagination?.getCurrentPage() ?? 0;
}
function paginationGetTotalPages(beans) {
  return beans.pagination?.getTotalPages() ?? 1;
}
function paginationGetRowCount(beans) {
  return beans.pagination ? beans.pagination.getMasterRowCount() : beans.rowModel.getRowCount();
}
function paginationGoToNextPage(beans) {
  beans.pagination?.goToNextPage();
}
function paginationGoToPreviousPage(beans) {
  beans.pagination?.goToPreviousPage();
}
function paginationGoToFirstPage(beans) {
  beans.pagination?.goToFirstPage();
}
function paginationGoToLastPage(beans) {
  beans.pagination?.goToLastPage();
}
function paginationGoToPage(beans, page) {
  beans.pagination?.goToPage(page);
}

// packages/ag-grid-community/src/pagination/paginationAutoPageSizeService.ts
var PaginationAutoPageSizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "paginationAutoPageSizeSvc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.centerRowsCtrl = p.center;
      const listener = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: listener,
        scrollVisibilityChanged: listener
      });
      this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this));
      this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    if (this.notActive()) {
      this.beans.pagination.unsetAutoCalculatedPageSize();
    } else {
      this.checkPageSize();
    }
  }
  checkPageSize() {
    if (this.notActive()) {
      return;
    }
    const bodyHeight = this.centerRowsCtrl.viewportSizeFeature.getBodyHeight();
    if (bodyHeight > 0) {
      const beans = this.beans;
      const update = () => {
        const rowHeight = Math.max(_getRowHeightAsNumber(beans), 1);
        const newPageSize = Math.floor(bodyHeight / rowHeight);
        beans.pagination.setPageSize(newPageSize, "autoCalculated");
      };
      if (!this.isBodyRendered) {
        update();
        this.isBodyRendered = true;
      } else {
        _debounce(this, update, 50)();
      }
    } else {
      this.isBodyRendered = false;
    }
  }
};

// packages/ag-grid-community/src/pagination/pageSizeSelector/pageSizeSelectorComp.ts
var paginationPageSizeSelector = "paginationPageSizeSelector";
var PageSizeSelectorComp = class extends Component {
  constructor() {
    super(
      /* html */
      `<span class="ag-paging-page-size"></span>`
    );
    this.hasEmptyOption = false;
    this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp) {
        return;
      }
      const newValue = this.selectPageSizeComp.getValue();
      if (!newValue) {
        return;
      }
      const paginationPageSize = Number(newValue);
      if (isNaN(paginationPageSize) || paginationPageSize < 1 || paginationPageSize === this.pagination.getPageSize()) {
        return;
      }
      this.pagination.setPageSize(paginationPageSize, "pageSizeSelector");
      if (this.hasEmptyOption) {
        this.toggleSelectDisplay(true);
      }
      this.selectPageSizeComp.getFocusableElement().focus();
    };
  }
  wireBeans(beans) {
    this.pagination = beans.pagination;
  }
  postConstruct() {
    this.addManagedPropertyListener(paginationPageSizeSelector, () => {
      this.onPageSizeSelectorValuesChange();
    });
    this.addManagedEventListeners({ paginationChanged: (event) => this.handlePaginationChanged(event) });
  }
  handlePaginationChanged(paginationChangedEvent) {
    if (!this.selectPageSizeComp || !paginationChangedEvent?.newPageSize) {
      return;
    }
    const paginationPageSize = this.pagination.getPageSize();
    if (this.getPageSizeSelectorValues().includes(paginationPageSize)) {
      this.selectPageSizeComp.setValue(paginationPageSize.toString());
    } else {
      if (this.hasEmptyOption) {
        this.selectPageSizeComp.setValue("");
      } else {
        this.toggleSelectDisplay(true);
      }
    }
  }
  toggleSelectDisplay(show) {
    if (this.selectPageSizeComp && !show) {
      this.reset();
    }
    if (!show) {
      return;
    }
    this.reloadPageSizesSelector();
    if (!this.selectPageSizeComp) {
      return;
    }
  }
  reset() {
    _clearElement(this.getGui());
    if (!this.selectPageSizeComp) {
      return;
    }
    this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp);
  }
  onPageSizeSelectorValuesChange() {
    if (!this.selectPageSizeComp) {
      return;
    }
    if (this.shouldShowPageSizeSelector()) {
      this.reloadPageSizesSelector();
    }
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get(paginationPageSizeSelector) !== false;
  }
  reloadPageSizesSelector() {
    const pageSizeOptions = this.getPageSizeSelectorValues();
    const paginationPageSizeOption = this.pagination.getPageSize();
    const shouldAddAndSelectEmptyOption = !paginationPageSizeOption || !pageSizeOptions.includes(paginationPageSizeOption);
    if (shouldAddAndSelectEmptyOption) {
      const pageSizeSet = this.gos.exists("paginationPageSize");
      const pageSizesSet = this.gos.get(paginationPageSizeSelector) !== true;
      _warn(94, { pageSizeSet, pageSizesSet, pageSizeOptions, paginationPageSizeOption });
      if (!pageSizesSet) {
        _warn(95, { paginationPageSizeOption, paginationPageSizeSelector });
      }
      pageSizeOptions.unshift("");
    }
    const value = String(shouldAddAndSelectEmptyOption ? "" : paginationPageSizeOption);
    if (this.selectPageSizeComp) {
      if (!_areEqual(this.pageSizeOptions, pageSizeOptions)) {
        this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(pageSizeOptions));
        this.pageSizeOptions = pageSizeOptions;
      }
      this.selectPageSizeComp.setValue(value, true);
    } else {
      this.createPageSizeSelectorComp(pageSizeOptions, value);
    }
    this.hasEmptyOption = shouldAddAndSelectEmptyOption;
  }
  createPageSizeSelectOptions(pageSizeOptions) {
    return pageSizeOptions.map((value) => ({
      value: String(value)
    }));
  }
  createPageSizeSelectorComp(pageSizeOptions, value) {
    const localeTextFunc = this.getLocaleTextFunc();
    const localisedLabel = localeTextFunc("pageSizeSelectorLabel", "Page Size:");
    const localisedAriaLabel = localeTextFunc("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new AgSelect()).addOptions(this.createPageSizeSelectOptions(pageSizeOptions)).setValue(value).setAriaLabel(localisedAriaLabel).setLabel(localisedLabel).onValueChange(() => this.handlePageSizeItemSelected());
    this.appendChild(this.selectPageSizeComp);
  }
  getPageSizeSelectorValues() {
    const defaultValues = [20, 50, 100];
    const paginationPageSizeSelectorValues = this.gos.get(paginationPageSizeSelector);
    if (!Array.isArray(paginationPageSizeSelectorValues) || !paginationPageSizeSelectorValues?.length) {
      return defaultValues;
    }
    return [...paginationPageSizeSelectorValues].sort((a, b) => a - b);
  }
  destroy() {
    this.toggleSelectDisplay(false);
    super.destroy();
  }
};
var PageSizeSelectorSelector = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: PageSizeSelectorComp
};

// packages/ag-grid-community/src/pagination/paginationComp.css-GENERATED.ts
var paginationCompCSS = (
  /*css*/
  `.ag-paging-panel{align-items:center;border-top:var(--ag-footer-row-border);display:flex;gap:calc(var(--ag-spacing)*4);height:max(var(--ag-row-height),22px);justify-content:flex-end;padding:0 var(--ag-cell-horizontal-padding)}:where(.ag-paging-page-size) .ag-wrapper{min-width:50px}.ag-paging-page-summary-panel{align-items:center;display:flex;gap:var(--ag-cell-widget-spacing);.ag-disabled &{pointer-events:none}}.ag-paging-button{cursor:pointer;position:relative;&.ag-disabled{cursor:default;opacity:.5}}.ag-paging-number,.ag-paging-row-summary-panel-number{font-weight:500}`
);

// packages/ag-grid-community/src/pagination/paginationComp.ts
var PaginationComp = class extends TabGuardComp {
  constructor() {
    super();
    this.btFirst = RefPlaceholder;
    this.btPrevious = RefPlaceholder;
    this.btNext = RefPlaceholder;
    this.btLast = RefPlaceholder;
    this.lbRecordCount = RefPlaceholder;
    this.lbFirstRowOnPage = RefPlaceholder;
    this.lbLastRowOnPage = RefPlaceholder;
    this.lbCurrent = RefPlaceholder;
    this.lbTotal = RefPlaceholder;
    this.pageSizeComp = RefPlaceholder;
    this.previousAndFirstButtonsDisabled = false;
    this.nextButtonDisabled = false;
    this.lastButtonDisabled = false;
    this.areListenersSetup = false;
    this.allowFocusInnerElement = false;
    this.registerCSS(paginationCompCSS);
  }
  wireBeans(beans) {
    this.rowModel = beans.rowModel;
    this.pagination = beans.pagination;
    this.ariaAnnounce = beans.ariaAnnounce;
  }
  postConstruct() {
    const isRtl = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [PageSizeSelectorSelector]);
    const { btFirst, btPrevious, btNext, btLast } = this;
    this.activateTabIndex([btFirst, btPrevious, btNext, btLast]);
    btFirst.insertAdjacentElement("afterbegin", _createIconNoSpan(isRtl ? "last" : "first", this.beans));
    btPrevious.insertAdjacentElement("afterbegin", _createIconNoSpan(isRtl ? "next" : "previous", this.beans));
    btNext.insertAdjacentElement("afterbegin", _createIconNoSpan(isRtl ? "previous" : "next", this.beans));
    btLast.insertAdjacentElement("afterbegin", _createIconNoSpan(isRtl ? "first" : "last", this.beans));
    this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this));
    this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this));
    this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    );
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
    this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (fromBottom) => {
        if (this.allowFocusInnerElement) {
          this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(fromBottom);
        } else {
          _focusGridInnerElement(this.beans, fromBottom);
        }
      },
      forceFocusOutWhenTabGuardsAreEmpty: true
    });
    this.onPaginationChanged();
  }
  setAllowFocus(allowFocus) {
    this.allowFocusInnerElement = allowFocus;
  }
  onPaginationChanged() {
    const isPaging = this.gos.get("pagination");
    const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(paginationPanelEnabled);
    if (!paginationPanelEnabled) {
      return;
    }
    this.setupListeners();
    this.enableOrDisableButtons();
    this.updateLabels();
    this.onPageSizeRelatedOptionsChange();
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    if (!this.areListenersSetup) {
      this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) });
      [
        { el: this.btFirst, fn: this.onBtFirst.bind(this) },
        { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
        { el: this.btNext, fn: this.onBtNext.bind(this) },
        { el: this.btLast, fn: this.onBtLast.bind(this) }
      ].forEach((item) => {
        const { el, fn } = item;
        this.addManagedListeners(el, {
          click: fn,
          keydown: (e) => {
            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
              e.preventDefault();
              fn();
            }
          }
        });
      });
      _addFocusableContainerListener(this.beans, this, this.getGui());
      this.areListenersSetup = true;
    }
  }
  onBtFirst() {
    if (!this.previousAndFirstButtonsDisabled) {
      this.pagination.goToFirstPage();
    }
  }
  formatNumber(value) {
    const userFunc = this.gos.getCallback("paginationNumberFormatter");
    if (userFunc) {
      const params = { value };
      return userFunc(params);
    }
    return _formatNumberCommas(value, this.getLocaleTextFunc.bind(this));
  }
  getTemplate() {
    const localeTextFunc = this.getLocaleTextFunc();
    const strPage = localeTextFunc("page", "Page");
    const strTo = localeTextFunc("to", "to");
    const strOf = localeTextFunc("of", "of");
    const strFirst = localeTextFunc("firstPage", "First Page");
    const strPrevious = localeTextFunc("previousPage", "Previous Page");
    const strNext = localeTextFunc("nextPage", "Next Page");
    const strLast = localeTextFunc("lastPage", "Last Page");
    const compId = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${compId}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel">
                    <span id="ag-${compId}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-to">${strTo}</span>
                    <span id="ag-${compId}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-of">${strOf}</span>
                    <span id="ag-${compId}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${strFirst}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${strPrevious}"></div>
                    <span class="ag-paging-description">
                        <span id="ag-${compId}-start-page">${strPage}</span>
                        <span id="ag-${compId}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${compId}-of-page">${strOf}</span>
                        <span id="ag-${compId}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${strNext}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${strLast}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    if (!this.nextButtonDisabled) {
      this.pagination.goToNextPage();
    }
  }
  onBtPrevious() {
    if (!this.previousAndFirstButtonsDisabled) {
      this.pagination.goToPreviousPage();
    }
  }
  onBtLast() {
    if (!this.lastButtonDisabled) {
      this.pagination.goToLastPage();
    }
  }
  enableOrDisableButtons() {
    const currentPage = this.pagination.getCurrentPage();
    const maxRowFound = this.rowModel.isLastRowIndexKnown();
    const totalPages = this.pagination.getTotalPages();
    this.previousAndFirstButtonsDisabled = currentPage === 0;
    this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled);
    this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const zeroPagesToDisplay = this.isZeroPagesToDisplay();
    const onLastPage = currentPage === totalPages - 1;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.lastButtonDisabled = !maxRowFound || zeroPagesToDisplay || currentPage === totalPages - 1;
    this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled);
    this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(button, disabled) {
    _setAriaDisabled(button, disabled);
    button.classList.toggle("ag-disabled", disabled);
  }
  isZeroPagesToDisplay() {
    const maxRowFound = this.rowModel.isLastRowIndexKnown();
    const totalPages = this.pagination.getTotalPages();
    return maxRowFound && totalPages === 0;
  }
  updateLabels() {
    const lastPageFound = this.rowModel.isLastRowIndexKnown();
    const totalPages = this.pagination.getTotalPages();
    const masterRowCount = this.pagination.getMasterRowCount();
    const rowCount = lastPageFound ? masterRowCount : null;
    if (rowCount === 1) {
      const firstRow = this.rowModel.getRow(0);
      const hiddenGroupRow = firstRow && firstRow.group && !(firstRow.groupData || firstRow.aggData);
      if (hiddenGroupRow) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    const currentPage = this.pagination.getCurrentPage();
    const pageSize = this.pagination.getPageSize();
    let startRow;
    let endRow;
    if (this.isZeroPagesToDisplay()) {
      startRow = endRow = 0;
    } else {
      startRow = pageSize * currentPage + 1;
      endRow = startRow + pageSize - 1;
      if (lastPageFound && endRow > rowCount) {
        endRow = rowCount;
      }
    }
    const theoreticalEndRow = startRow + pageSize - 1;
    const isLoadingPageSize = !lastPageFound && masterRowCount < theoreticalEndRow;
    const lbFirstRowOnPage = this.formatNumber(startRow);
    this.lbFirstRowOnPage.textContent = lbFirstRowOnPage;
    let lbLastRowOnPage;
    const localeTextFunc = this.getLocaleTextFunc();
    if (isLoadingPageSize) {
      lbLastRowOnPage = localeTextFunc("pageLastRowUnknown", "?");
    } else {
      lbLastRowOnPage = this.formatNumber(endRow);
    }
    this.lbLastRowOnPage.textContent = lbLastRowOnPage;
    const pagesExist = totalPages > 0;
    const toDisplay = pagesExist ? currentPage + 1 : 0;
    const lbCurrent = this.formatNumber(toDisplay);
    this.lbCurrent.textContent = lbCurrent;
    let lbTotal;
    let lbRecordCount;
    if (lastPageFound) {
      lbTotal = this.formatNumber(totalPages);
      lbRecordCount = this.formatNumber(rowCount);
    } else {
      const moreText = localeTextFunc("more", "more");
      lbTotal = moreText;
      lbRecordCount = moreText;
    }
    this.lbTotal.textContent = lbTotal;
    this.lbRecordCount.textContent = lbRecordCount;
    this.announceAriaStatus(lbFirstRowOnPage, lbLastRowOnPage, lbRecordCount, lbCurrent, lbTotal);
  }
  announceAriaStatus(lbFirstRowOnPage, lbLastRowOnPage, lbRecordCount, lbCurrent, lbTotal) {
    const localeTextFunc = this.getLocaleTextFunc();
    const strPage = localeTextFunc("page", "Page");
    const strTo = localeTextFunc("to", "to");
    const strOf = localeTextFunc("of", "of");
    const ariaRowStatus = `${lbFirstRowOnPage} ${strTo} ${lbLastRowOnPage} ${strOf} ${lbRecordCount}`;
    const ariaPageStatus = `${strPage} ${lbCurrent} ${strOf} ${lbTotal}`;
    if (ariaRowStatus !== this.ariaRowStatus) {
      this.ariaRowStatus = ariaRowStatus;
      this.ariaAnnounce?.announceValue(ariaRowStatus, "paginationRow");
    }
    if (ariaPageStatus !== this.ariaPageStatus) {
      this.ariaPageStatus = ariaPageStatus;
      this.ariaAnnounce?.announceValue(ariaPageStatus, "paginationPage");
    }
  }
  setTotalLabelsToZero() {
    const strZero = this.formatNumber(0);
    this.lbFirstRowOnPage.textContent = strZero;
    this.lbCurrent.textContent = strZero;
    this.lbLastRowOnPage.textContent = strZero;
    this.lbTotal.textContent = strZero;
    this.lbRecordCount.textContent = strZero;
    this.announceAriaStatus(strZero, strZero, strZero, strZero, strZero);
  }
};
var PaginationSelector = {
  selector: "AG-PAGINATION",
  component: PaginationComp
};

// packages/ag-grid-community/src/pagination/paginationService.ts
var PaginationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pagination";
    this.currentPage = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = 0;
    this.masterRowCount = 0;
  }
  postConstruct() {
    const gos = this.gos;
    this.active = gos.get("pagination");
    this.pageSizeFromGridOptions = gos.get("paginationPageSize");
    this.paginateChildRows = this.isPaginateChildRows();
    this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this));
    this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return PaginationSelector;
  }
  isPaginateChildRows() {
    const gos = this.gos;
    const shouldPaginate = gos.get("groupHideParentOfSingleChild") || // following two properties deprecated v32.3.0
    gos.get("groupRemoveSingleChildren") || gos.get("groupRemoveLowestSingleChildren");
    if (shouldPaginate) {
      return true;
    }
    return gos.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination");
    this.calculatePages();
    this.dispatchPaginationChangedEvent({ keepRenderedRows: true });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(page) {
    const currentPage = this.currentPage;
    if (!this.active || currentPage === page || typeof currentPage !== "number") {
      return;
    }
    this.currentPage = page;
    this.calculatePages();
    this.dispatchPaginationChangedEvent({ newPage: true });
  }
  isRowPresent(rowNode) {
    const nodeIsInPage = rowNode.rowIndex >= this.topDisplayedRowIndex && rowNode.rowIndex <= this.bottomDisplayedRowIndex;
    return nodeIsInPage;
  }
  getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  goToPageWithIndex(index) {
    if (!this.active) {
      return;
    }
    const pageNumber = this.getPageForIndex(index);
    this.goToPage(pageNumber);
  }
  isRowInPage(row) {
    if (!this.active) {
      return true;
    }
    const rowPage = this.getPageForIndex(row.rowIndex);
    return rowPage === this.currentPage;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const rowCount = this.beans.rowModel.getRowCount();
    const lastPage = Math.floor(rowCount / this.pageSize);
    this.goToPage(lastPage);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(page) {
    this.currentPage = page;
  }
  get pageSize() {
    if (_exists(this.pageSizeAutoCalculated) && this.gos.get("paginationAutoPageSize")) {
      return this.pageSizeAutoCalculated;
    }
    if (_exists(this.pageSizeFromPageSizeSelector)) {
      return this.pageSizeFromPageSizeSelector;
    }
    if (_exists(this.pageSizeFromInitialState)) {
      return this.pageSizeFromInitialState;
    }
    if (_exists(this.pageSizeFromGridOptions)) {
      return this.pageSizeFromGridOptions;
    }
    return this.defaultPageSize;
  }
  calculatePages() {
    if (this.active) {
      if (this.paginateChildRows) {
        this.calculatePagesAllRows();
      } else {
        this.calculatePagesMasterRowsOnly();
      }
    } else {
      this.calculatedPagesNotActive();
    }
    this.beans.pageBounds.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0) {
      return;
    }
    const oldPageSize = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0;
    if (this.pageSize === oldPageSize) {
      return;
    }
    this.calculatePages();
    this.dispatchPaginationChangedEvent({ newPageSize: true });
  }
  setPageSize(size, source) {
    const currentSize = this.pageSize;
    switch (source) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = size;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = size;
        if (this.currentPage !== 0) {
          this.goToFirstPage();
        }
        break;
      case "initialState":
        this.pageSizeFromInitialState = size;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = size;
        this.pageSizeFromInitialState = void 0;
        this.pageSizeFromPageSizeSelector = void 0;
        if (this.currentPage !== 0) {
          this.goToFirstPage();
        }
        break;
    }
    if (currentSize !== this.pageSize) {
      this.calculatePages();
      this.dispatchPaginationChangedEvent({ newPageSize: true, keepRenderedRows: true });
    }
  }
  setZeroRows() {
    this.masterRowCount = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = -1;
    this.currentPage = 0;
    this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    const totalPages = this.totalPages;
    if (this.currentPage >= totalPages) {
      this.currentPage = totalPages - 1;
    }
    const currentPage = this.currentPage;
    if (!isFinite(currentPage) || isNaN(currentPage) || currentPage < 0) {
      this.currentPage = 0;
    }
  }
  calculatePagesMasterRowsOnly() {
    const rowModel = this.beans.rowModel;
    const masterRowCount = rowModel.getTopLevelRowCount();
    this.masterRowCount = masterRowCount;
    if (masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const pageSize = this.pageSize;
    const masterLastRowIndex = masterRowCount - 1;
    this.totalPages = Math.floor(masterLastRowIndex / pageSize) + 1;
    this.adjustCurrentPageIfInvalid();
    const currentPage = this.currentPage;
    const masterPageStartIndex = pageSize * currentPage;
    let masterPageEndIndex = pageSize * (currentPage + 1) - 1;
    if (masterPageEndIndex > masterLastRowIndex) {
      masterPageEndIndex = masterLastRowIndex;
    }
    this.topDisplayedRowIndex = rowModel.getTopLevelRowDisplayedIndex(masterPageStartIndex);
    if (masterPageEndIndex === masterLastRowIndex) {
      this.bottomDisplayedRowIndex = rowModel.getRowCount() - 1;
    } else {
      const firstIndexNotToShow = rowModel.getTopLevelRowDisplayedIndex(masterPageEndIndex + 1);
      this.bottomDisplayedRowIndex = firstIndexNotToShow - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    const masterRowCount = this.beans.rowModel.getRowCount();
    this.masterRowCount = masterRowCount;
    if (masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const { pageSize, currentPage } = this;
    const maxRowIndex = masterRowCount - 1;
    this.totalPages = Math.floor(maxRowIndex / pageSize) + 1;
    this.adjustCurrentPageIfInvalid();
    this.topDisplayedRowIndex = pageSize * currentPage;
    this.bottomDisplayedRowIndex = pageSize * (currentPage + 1) - 1;
    if (this.bottomDisplayedRowIndex > maxRowIndex) {
      this.bottomDisplayedRowIndex = maxRowIndex;
    }
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated");
    this.totalPages = 1;
    this.currentPage = 0;
    this.topDisplayedRowIndex = 0;
    this.bottomDisplayedRowIndex = this.beans.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(params) {
    const { keepRenderedRows = false, newPage = false, newPageSize = false } = params;
    this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: false,
      newData: false,
      newPage,
      newPageSize,
      keepRenderedRows
    });
  }
};

// packages/ag-grid-community/src/pagination/paginationModule.ts
var PaginationModule = {
  moduleName: "Pagination",
  version: VERSION,
  beans: [PaginationService, PaginationAutoPageSizeService],
  icons: {
    // "go to first" button in pagination controls
    first: "first",
    // "go to previous" button in pagination controls
    previous: "previous",
    // "go to next" button in pagination controls
    next: "next",
    // "go to last" button in pagination controls
    last: "last"
  },
  apiFunctions: {
    paginationIsLastPageFound,
    paginationGetPageSize,
    paginationGetCurrentPage,
    paginationGetTotalPages,
    paginationGetRowCount,
    paginationGoToNextPage,
    paginationGoToPreviousPage,
    paginationGoToFirstPage,
    paginationGoToLastPage,
    paginationGoToPage
  },
  dependsOn: [PopupModule]
};

// packages/ag-grid-community/src/api/rowApi.ts
function redrawRows(beans, params = {}) {
  const rowNodes = params ? params.rowNodes : void 0;
  beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.redrawRows(rowNodes));
}
function setRowNodeExpanded(beans, rowNode, expanded, expandParents, forceSync) {
  if (rowNode) {
    if (expandParents && rowNode.parent && rowNode.parent.level !== -1) {
      setRowNodeExpanded(beans, rowNode.parent, expanded, expandParents, forceSync);
    }
    rowNode.setExpanded(expanded, void 0, forceSync);
  }
}
function getRowNode(beans, id) {
  return beans.rowModel.getRowNode(id);
}
function addRenderedRowListener(beans, eventName, rowIndex, callback) {
  beans.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
}
function getRenderedNodes(beans) {
  return beans.rowRenderer.getRenderedNodes();
}
function forEachNode(beans, callback, includeFooterNodes) {
  beans.rowModel.forEachNode(callback, includeFooterNodes);
}
function getFirstDisplayedRowIndex(beans) {
  return beans.rowRenderer.firstRenderedRow;
}
function getLastDisplayedRowIndex(beans) {
  return beans.rowRenderer.lastRenderedRow;
}
function getDisplayedRowAtIndex(beans, index) {
  return beans.rowModel.getRow(index);
}
function getDisplayedRowCount(beans) {
  return beans.rowModel.getRowCount();
}

// packages/ag-grid-community/src/api/apiModule.ts
var RowApiModule = {
  moduleName: "RowApi",
  version: VERSION,
  apiFunctions: {
    redrawRows,
    setRowNodeExpanded,
    getRowNode,
    addRenderedRowListener,
    getRenderedNodes,
    forEachNode,
    getFirstDisplayedRowIndex,
    getLastDisplayedRowIndex,
    getDisplayedRowAtIndex,
    getDisplayedRowCount
  }
};
var ScrollApiModule = {
  moduleName: "ScrollApi",
  version: VERSION,
  apiFunctions: {
    getVerticalPixelRange,
    getHorizontalPixelRange,
    ensureColumnVisible,
    ensureIndexVisible,
    ensureNodeVisible
  }
};

// packages/ag-grid-community/src/rendering/renderApi.ts
function setGridAriaProperty(beans, property, value) {
  if (!property) {
    return;
  }
  const eGrid = beans.ctrlsSvc.getGridBodyCtrl().eGridBody;
  const ariaProperty = `aria-${property}`;
  if (value === null) {
    eGrid.removeAttribute(ariaProperty);
  } else {
    eGrid.setAttribute(ariaProperty, value);
  }
}
function refreshCells(beans, params = {}) {
  beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.refreshCells(params));
}
function refreshHeader(beans) {
  beans.frameworkOverrides.wrapIncoming(
    () => beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((c) => c.refresh())
  );
}
function isAnimationFrameQueueEmpty(beans) {
  return beans.animationFrameSvc?.isQueueEmpty() ?? true;
}
function flushAllAnimationFrames(beans) {
  beans.animationFrameSvc?.flushAllFrames();
}
function getSizesForCurrentTheme(beans) {
  return {
    rowHeight: _getRowHeightAsNumber(beans),
    headerHeight: getHeaderHeight(beans)
  };
}
function getCellRendererInstances(beans, params = {}) {
  const cellRenderers = [];
  beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
    const cellRenderer = cellCtrl.getCellRenderer();
    if (cellRenderer != null) {
      cellRenderers.push(_unwrapUserComp(cellRenderer));
    }
  });
  if (params.columns?.length) {
    return cellRenderers;
  }
  const fullWidthRenderers = [];
  const rowIdMap = mapRowNodes(params.rowNodes);
  beans.rowRenderer.getAllRowCtrls().forEach((rowCtrl) => {
    if (rowIdMap && !isRowInMap(rowCtrl.rowNode, rowIdMap)) {
      return;
    }
    if (!rowCtrl.isFullWidth()) {
      return;
    }
    const renderers = rowCtrl.getFullWidthCellRenderers();
    for (let i = 0; i < renderers.length; i++) {
      const renderer = renderers[i];
      if (renderer != null) {
        fullWidthRenderers.push(_unwrapUserComp(renderer));
      }
    }
  });
  return [...fullWidthRenderers, ...cellRenderers];
}

// packages/ag-grid-community/src/rendering/renderModule.ts
var RenderApiModule = {
  moduleName: "RenderApi",
  version: VERSION,
  apiFunctions: {
    setGridAriaProperty,
    refreshCells,
    refreshHeader,
    isAnimationFrameQueueEmpty,
    flushAllAnimationFrames,
    getSizesForCurrentTheme,
    getCellRendererInstances
  }
};

// packages/ag-grid-community/src/columnAutosize/columnAutosizeApi.ts
function sizeColumnsToFit(beans, paramsOrGridWidth) {
  if (typeof paramsOrGridWidth === "number") {
    beans.colAutosize?.sizeColumnsToFit(paramsOrGridWidth, "api");
  } else {
    beans.colAutosize?.sizeColumnsToFitGridBody(paramsOrGridWidth);
  }
}
function autoSizeColumns(beans, keys, skipHeader) {
  beans.colAutosize?.autoSizeCols({ colKeys: keys, skipHeader, source: "api" });
}
function autoSizeAllColumns(beans, skipHeader) {
  beans.colAutosize?.autoSizeAllColumns("api", skipHeader);
}

// packages/ag-grid-community/src/columnAutosize/columnAutosizeService.ts
var ColumnAutosizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colAutosize";
    this.timesDelayed = 0;
    // when we're waiting for cell data types to be inferred, we need to defer column resizing
    this.shouldQueueResizeOperations = false;
    this.resizeOperationQueue = [];
  }
  postConstruct() {
    this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  autoSizeCols(params) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeCols(params));
      return;
    }
    const { colKeys, skipHeader, skipHeaderGroups, stopAtGroup, source = "api" } = params;
    const { animationFrameSvc, renderStatus, colModel, autoWidthCalc, visibleCols } = this.beans;
    animationFrameSvc?.flushAllFrames();
    if (this.timesDelayed < 5 && renderStatus && !renderStatus.areHeaderCellsRendered()) {
      this.timesDelayed++;
      setTimeout(() => {
        if (this.isAlive()) {
          this.autoSizeCols(params);
        }
      });
      return;
    }
    this.timesDelayed = 0;
    const columnsAutosized = [];
    let changesThisTimeAround = -1;
    const shouldSkipHeader = skipHeader != null ? skipHeader : this.gos.get("skipHeaderOnAutoSize");
    const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
    while (changesThisTimeAround !== 0) {
      changesThisTimeAround = 0;
      const updatedColumns = [];
      colKeys.forEach((key) => {
        if (!key) {
          return;
        }
        const column = colModel.getCol(key);
        if (!column) {
          return;
        }
        if (columnsAutosized.indexOf(column) >= 0) {
          return;
        }
        const preferredWidth = autoWidthCalc.getPreferredWidthForColumn(column, shouldSkipHeader);
        if (preferredWidth > 0) {
          const newWidth = normaliseColumnWidth(column, preferredWidth);
          column.setActualWidth(newWidth, source);
          columnsAutosized.push(column);
          changesThisTimeAround++;
        }
        updatedColumns.push(column);
      });
      if (!updatedColumns.length) {
        continue;
      }
      visibleCols.refresh(source);
    }
    if (!shouldSkipHeaderGroups) {
      this.autoSizeColumnGroupsByColumns(colKeys, source, stopAtGroup);
    }
    dispatchColumnResizedEvent(this.eventSvc, columnsAutosized, true, "autosizeColumns");
  }
  autoSizeColumn(key, source, skipHeader) {
    if (key) {
      this.autoSizeCols({ colKeys: [key], skipHeader, skipHeaderGroups: true, source });
    }
  }
  autoSizeColumnGroupsByColumns(keys, source, stopAtGroup) {
    const { colModel, ctrlsSvc } = this.beans;
    const columnGroups = /* @__PURE__ */ new Set();
    const columns = colModel.getColsForKeys(keys);
    columns.forEach((col) => {
      let parent = col.getParent();
      while (parent && parent != stopAtGroup) {
        if (!parent.isPadding()) {
          columnGroups.add(parent);
        }
        parent = parent.getParent();
      }
    });
    let headerGroupCtrl;
    const resizedColumns = [];
    for (const columnGroup of columnGroups) {
      for (const headerContainerCtrl of ctrlsSvc.getHeaderRowContainerCtrls()) {
        headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
        if (headerGroupCtrl) {
          break;
        }
      }
      if (headerGroupCtrl) {
        headerGroupCtrl.resizeLeafColumnsToFit(source);
      }
    }
    return resizedColumns;
  }
  autoSizeAllColumns(source, skipHeader) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeAllColumns(source, skipHeader));
      return;
    }
    const allDisplayedColumns = this.beans.visibleCols.allCols;
    this.autoSizeCols({ colKeys: allDisplayedColumns, skipHeader, source });
  }
  addColumnAutosize(element, column) {
    const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
    const autoSizeColListener = () => {
      this.autoSizeColumn(column, "uiColumnResized", skipHeaderOnAutoSize);
    };
    element.addEventListener("dblclick", autoSizeColListener);
    const touchListener = new TouchListener(element);
    touchListener.addEventListener("doubleTap", autoSizeColListener);
    return () => {
      element.removeEventListener("dblclick", autoSizeColListener);
      touchListener.removeEventListener("doubleTap", autoSizeColListener);
      touchListener.destroy();
    };
  }
  addColumnGroupResize(element, columnGroup, callback) {
    const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
    const listener = () => {
      const keys = [];
      const leafCols = columnGroup.getDisplayedLeafColumns();
      leafCols.forEach((column) => {
        if (!column.getColDef().suppressAutoSize) {
          keys.push(column.getColId());
        }
      });
      if (keys.length > 0) {
        this.autoSizeCols({
          colKeys: keys,
          skipHeader: skipHeaderOnAutoSize,
          stopAtGroup: columnGroup,
          source: "uiColumnResized"
        });
      }
      callback();
    };
    element.addEventListener("dblclick", listener);
    return () => element.removeEventListener("dblclick", listener);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFitGridBody(params, nextTimeout) {
    if (!this.isAlive()) {
      return;
    }
    const { ctrlsSvc, scrollVisibleSvc } = this.beans;
    const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
    const removeScrollWidth = gridBodyCtrl.isVerticalScrollShowing();
    const scrollWidthToRemove = removeScrollWidth ? scrollVisibleSvc.getScrollbarWidth() : 0;
    const bodyViewportWidth = _getInnerWidth(gridBodyCtrl.eGridBody);
    const availableWidth = bodyViewportWidth - scrollWidthToRemove;
    if (availableWidth > 0) {
      this.sizeColumnsToFit(availableWidth, "sizeColumnsToFit", false, params);
      return;
    }
    if (nextTimeout === void 0) {
      window.setTimeout(() => {
        this.sizeColumnsToFitGridBody(params, 100);
      }, 0);
    } else if (nextTimeout === 100) {
      window.setTimeout(() => {
        this.sizeColumnsToFitGridBody(params, 500);
      }, 100);
    } else if (nextTimeout === 500) {
      window.setTimeout(() => {
        this.sizeColumnsToFitGridBody(params, -1);
      }, 500);
    } else {
      _warn(29);
    }
  }
  // called from api
  sizeColumnsToFit(gridWidth, source = "sizeColumnsToFit", silent, params) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.sizeColumnsToFit(gridWidth, source, silent, params));
      return;
    }
    const limitsMap = {};
    if (params) {
      params?.columnLimits?.forEach(({ key, ...dimensions }) => {
        limitsMap[typeof key === "string" ? key : key.getColId()] = dimensions;
      });
    }
    const allDisplayedColumns = this.beans.visibleCols.allCols;
    const doColumnsAlreadyFit = gridWidth === getWidthOfColsInList(allDisplayedColumns);
    if (gridWidth <= 0 || !allDisplayedColumns.length || doColumnsAlreadyFit) {
      return;
    }
    const colsToSpread = [];
    const colsToNotSpread = [];
    allDisplayedColumns.forEach((column) => {
      if (column.getColDef().suppressSizeToFit === true) {
        colsToNotSpread.push(column);
      } else {
        colsToSpread.push(column);
      }
    });
    const colsToDispatchEventFor = colsToSpread.slice(0);
    let finishedResizing = false;
    const moveToNotSpread = (column) => {
      _removeFromArray(colsToSpread, column);
      colsToNotSpread.push(column);
    };
    colsToSpread.forEach((column) => {
      column.resetActualWidth(source);
      const widthOverride = limitsMap?.[column.getId()];
      const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
      const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
      const colWidth = column.getActualWidth();
      if (typeof minOverride === "number" && colWidth < minOverride) {
        column.setActualWidth(minOverride, source, true);
      } else if (typeof maxOverride === "number" && colWidth > maxOverride) {
        column.setActualWidth(maxOverride, source, true);
      }
    });
    while (!finishedResizing) {
      finishedResizing = true;
      const availablePixels = gridWidth - getWidthOfColsInList(colsToNotSpread);
      if (availablePixels <= 0) {
        colsToSpread.forEach((column) => {
          const widthOverride = limitsMap?.[column.getId()]?.minWidth ?? params?.defaultMinWidth;
          if (typeof widthOverride === "number") {
            column.setActualWidth(widthOverride, source, true);
            return;
          }
          column.setActualWidth(column.minWidth, source);
        });
      } else {
        const scale = availablePixels / getWidthOfColsInList(colsToSpread);
        let pixelsForLastCol = availablePixels;
        for (let i = colsToSpread.length - 1; i >= 0; i--) {
          const column = colsToSpread[i];
          const widthOverride = limitsMap?.[column.getId()];
          const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
          const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
          const colMinWidth = column.getMinWidth();
          const colMaxWidth = column.getMaxWidth();
          const minWidth = typeof minOverride === "number" && minOverride > colMinWidth ? minOverride : colMinWidth;
          const maxWidth = typeof maxOverride === "number" && maxOverride < colMaxWidth ? maxOverride : colMaxWidth;
          let newWidth = Math.round(column.getActualWidth() * scale);
          if (newWidth < minWidth) {
            newWidth = minWidth;
            moveToNotSpread(column);
            finishedResizing = false;
          } else if (newWidth > maxWidth) {
            newWidth = maxWidth;
            moveToNotSpread(column);
            finishedResizing = false;
          } else if (i === 0) {
            newWidth = pixelsForLastCol;
          }
          column.setActualWidth(newWidth, source, true);
          pixelsForLastCol -= newWidth;
        }
      }
    }
    colsToDispatchEventFor.forEach((col) => {
      col.fireColumnWidthChangedEvent(source);
    });
    const visibleCols = this.beans.visibleCols;
    visibleCols.setLeftValues(source);
    visibleCols.updateBodyWidths();
    if (silent) {
      return;
    }
    dispatchColumnResizedEvent(this.eventSvc, colsToDispatchEventFor, true, source);
  }
  applyAutosizeStrategy() {
    const autoSizeStrategy = this.gos.get("autoSizeStrategy");
    if (!autoSizeStrategy) {
      return;
    }
    const { type } = autoSizeStrategy;
    setTimeout(() => {
      if (type === "fitGridWidth") {
        const { columnLimits: propColumnLimits, defaultMinWidth, defaultMaxWidth } = autoSizeStrategy;
        const columnLimits = propColumnLimits?.map(({ colId: key, minWidth, maxWidth }) => ({
          key,
          minWidth,
          maxWidth
        }));
        this.sizeColumnsToFitGridBody({
          defaultMinWidth,
          defaultMaxWidth,
          columnLimits
        });
      } else if (type === "fitProvidedWidth") {
        this.sizeColumnsToFit(autoSizeStrategy.width, "sizeColumnsToFit");
      }
    });
  }
  onFirstDataRendered() {
    const autoSizeStrategy = this.gos.get("autoSizeStrategy");
    if (autoSizeStrategy?.type !== "fitCellContents") {
      return;
    }
    const { colIds: columns, skipHeader } = autoSizeStrategy;
    setTimeout(() => {
      if (columns) {
        this.autoSizeCols({
          colKeys: columns,
          skipHeader,
          source: "autosizeColumns"
        });
      } else {
        this.autoSizeAllColumns("autosizeColumns", skipHeader);
      }
    });
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = false;
    this.resizeOperationQueue.forEach((resizeOperation) => resizeOperation());
    this.resizeOperationQueue = [];
  }
  pushResizeOperation(func) {
    this.resizeOperationQueue.push(func);
  }
  destroy() {
    this.resizeOperationQueue.length = 0;
    super.destroy();
  }
};
function normaliseColumnWidth(column, newWidth) {
  const minWidth = column.getMinWidth();
  if (newWidth < minWidth) {
    newWidth = minWidth;
  }
  const maxWidth = column.getMaxWidth();
  if (column.isGreaterThanMax(newWidth)) {
    newWidth = maxWidth;
  }
  return newWidth;
}

// packages/ag-grid-community/src/columnAutosize/columnAutosizeModule.ts
var ColumnAutoSizeModule = {
  moduleName: "ColumnAutoSize",
  version: VERSION,
  beans: [ColumnAutosizeService],
  apiFunctions: {
    sizeColumnsToFit,
    autoSizeColumns,
    autoSizeAllColumns
  },
  dependsOn: [AutoWidthModule]
};

// packages/ag-grid-community/src/pinnedRowModel/pinnedRowApi.ts
function getPinnedTopRowCount(beans) {
  return beans.pinnedRowModel?.getPinnedTopRowCount() ?? 0;
}
function getPinnedBottomRowCount(beans) {
  return beans.pinnedRowModel?.getPinnedBottomRowCount() ?? 0;
}
function getPinnedTopRow(beans, index) {
  return beans.pinnedRowModel?.getPinnedTopRow(index);
}
function getPinnedBottomRow(beans, index) {
  return beans.pinnedRowModel?.getPinnedBottomRow(index);
}

// packages/ag-grid-community/src/pinnedRowModel/pinnedRowModel.ts
var PinnedRowModel = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pinnedRowModel";
    this.nextId = 0;
    this.pinnedTopRows = { cache: {}, order: [] };
    this.pinnedBottomRows = { cache: {}, order: [] };
  }
  postConstruct() {
    const gos = this.gos;
    this.setPinnedRowData(gos.get("pinnedTopRowData"), "top");
    this.setPinnedRowData(gos.get("pinnedBottomRowData"), "bottom");
    this.addManagedPropertyListener("pinnedTopRowData", (e) => this.setPinnedRowData(e.currentValue, "top"));
    this.addManagedPropertyListener("pinnedBottomRowData", (e) => this.setPinnedRowData(e.currentValue, "bottom"));
    this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(floating) {
    return this.getCache(floating).order.length === 0;
  }
  isRowsToRender(floating) {
    return !this.isEmpty(floating);
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const estimateRowHeight = (rowNode) => {
        rowNode.setRowHeight(rowNode.rowHeight, true);
      };
      forEach(this.pinnedBottomRows, estimateRowHeight);
      forEach(this.pinnedTopRows, estimateRowHeight);
    }
  }
  ensureRowHeightsValid() {
    let anyChange = false;
    let rowTop = 0;
    const updateRowHeight = (rowNode) => {
      if (rowNode.rowHeightEstimated) {
        const rowHeight = _getRowHeightForNode(this.beans, rowNode);
        rowNode.setRowTop(rowTop);
        rowNode.setRowHeight(rowHeight.height);
        rowTop += rowHeight.height;
        anyChange = true;
      }
    };
    forEach(this.pinnedBottomRows, updateRowHeight);
    rowTop = 0;
    forEach(this.pinnedTopRows, updateRowHeight);
    this.eventSvc.dispatchEvent({
      type: "pinnedHeightChanged"
    });
    return anyChange;
  }
  setPinnedRowData(rowData, floating) {
    this.updateNodesFromRowData(rowData, floating);
    this.eventSvc.dispatchEvent({
      type: "pinnedRowDataChanged"
    });
  }
  /**
   * Updates existing RowNode instances and creates new ones if necessary
   *
   * Setting data as `undefined` will clear row nodes
   */
  updateNodesFromRowData(allData, floating) {
    const nodes = this.getCache(floating);
    if (allData === void 0) {
      nodes.order.length = 0;
      nodes.cache = {};
      return;
    }
    const getRowId = _getRowIdCallback(this.gos);
    const idPrefix = floating === "top" ? ROW_ID_PREFIX_TOP_PINNED : ROW_ID_PREFIX_BOTTOM_PINNED;
    const nodesToRemove = new Set(nodes.order);
    const newOrder = [];
    const dataIds = /* @__PURE__ */ new Set();
    let nextRowTop = 0;
    let i = -1;
    for (const data of allData) {
      const id = getRowId?.({ data, level: 0, rowPinned: floating }) ?? idPrefix + this.nextId++;
      if (dataIds.has(id)) {
        _warn(96, { id, data });
        continue;
      }
      i++;
      dataIds.add(id);
      newOrder.push(id);
      const existingNode = getById(nodes, id);
      if (existingNode !== void 0) {
        if (existingNode.data !== data) {
          existingNode.setData(data);
        }
        nextRowTop += this.setRowTopAndRowIndex(existingNode, nextRowTop, i);
        nodesToRemove.delete(id);
      } else {
        const rowNode = new RowNode(this.beans);
        rowNode.id = id;
        rowNode.data = data;
        rowNode.rowPinned = floating;
        nextRowTop += this.setRowTopAndRowIndex(rowNode, nextRowTop, i);
        nodes.cache[id] = rowNode;
        nodes.order.push(id);
      }
    }
    nodesToRemove.forEach((id) => {
      getById(nodes, id)?.clearRowTopAndRowIndex();
      delete nodes.cache[id];
    });
    nodes.order = newOrder;
  }
  setRowTopAndRowIndex(rowNode, rowTop, rowIndex) {
    rowNode.setRowTop(rowTop);
    rowNode.setRowHeight(_getRowHeightForNode(this.beans, rowNode).height);
    rowNode.setRowIndex(rowIndex);
    return rowNode.rowHeight;
  }
  getPinnedTopTotalHeight() {
    return getTotalHeight(this.pinnedTopRows);
  }
  getPinnedBottomTotalHeight() {
    return getTotalHeight(this.pinnedBottomRows);
  }
  getPinnedTopRowCount() {
    return getSize(this.pinnedTopRows);
  }
  getPinnedBottomRowCount() {
    return getSize(this.pinnedBottomRows);
  }
  getPinnedTopRow(index) {
    return getByIndex(this.pinnedTopRows, index);
  }
  getPinnedBottomRow(index) {
    return getByIndex(this.pinnedBottomRows, index);
  }
  getPinnedRowById(id, floating) {
    return getById(this.getCache(floating), id);
  }
  forEachPinnedRow(floating, callback) {
    return forEach(this.getCache(floating), callback);
  }
  getCache(floating) {
    return floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
  }
};
function getTotalHeight(rowNodes) {
  const size = getSize(rowNodes);
  if (size === 0) {
    return 0;
  }
  const node = getByIndex(rowNodes, size - 1);
  if (node === void 0) {
    return 0;
  }
  return node.rowTop + node.rowHeight;
}
function getById(cache, id) {
  return cache.cache[id];
}
function getByIndex(cache, i) {
  return getById(cache, cache.order[i]);
}
function forEach(cache, callback) {
  cache.order.forEach((id, index) => {
    const node = getById(cache, id);
    node && callback(node, index);
  });
}
function getSize(cache) {
  return cache.order.length;
}

// packages/ag-grid-community/src/pinnedRowModel/pinnedRowModule.ts
var PinnedRowModule = {
  moduleName: "PinnedRow",
  version: VERSION,
  beans: [PinnedRowModel],
  apiFunctions: {
    getPinnedTopRowCount,
    getPinnedBottomRowCount,
    getPinnedTopRow,
    getPinnedBottomRow
  }
};

// packages/ag-grid-community/src/styling/cellCustomStyleFeature.ts
var CellCustomStyleFeature = class extends BeanStub {
  constructor(cellCtrl, beans) {
    super();
    this.cellCtrl = cellCtrl;
    this.staticClasses = [];
    this.beans = beans;
    this.column = cellCtrl.column;
  }
  setComp(comp) {
    this.cellComp = comp;
    this.applyUserStyles();
    this.applyCellClassRules();
    this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const { column, cellComp } = this;
    const colDef = column.colDef;
    const cellClassRules = colDef.cellClassRules;
    const cellClassParams = this.getCellClassParams(column, colDef);
    processClassRules(
      this.beans.expressionSvc,
      // if current was previous, skip
      cellClassRules === this.cellClassRules ? void 0 : this.cellClassRules,
      cellClassRules,
      cellClassParams,
      (className) => cellComp.addOrRemoveCssClass(className, true),
      (className) => cellComp.addOrRemoveCssClass(className, false)
    );
    this.cellClassRules = cellClassRules;
  }
  applyUserStyles() {
    const column = this.column;
    const colDef = column.colDef;
    const cellStyle = colDef.cellStyle;
    if (!cellStyle) {
      return;
    }
    let styles;
    if (typeof cellStyle === "function") {
      const cellStyleParams = this.getCellClassParams(column, colDef);
      styles = cellStyle(cellStyleParams);
    } else {
      styles = cellStyle;
    }
    if (styles) {
      this.cellComp.setUserStyles(styles);
    }
  }
  applyClassesFromColDef() {
    const { column, cellComp } = this;
    const colDef = column.colDef;
    const cellClassParams = this.getCellClassParams(column, colDef);
    this.staticClasses.forEach((className) => cellComp.addOrRemoveCssClass(className, false));
    const newStaticClasses = this.beans.cellStyles.getStaticCellClasses(colDef, cellClassParams);
    this.staticClasses = newStaticClasses;
    newStaticClasses.forEach((className) => cellComp.addOrRemoveCssClass(className, true));
  }
  getCellClassParams(column, colDef) {
    const { value, rowNode } = this.cellCtrl;
    return this.beans.gos.addGridCommonParams({
      value,
      data: rowNode.data,
      node: rowNode,
      colDef,
      column,
      rowIndex: rowNode.rowIndex
    });
  }
};

// packages/ag-grid-community/src/styling/cellStyleService.ts
var CellStyleService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "cellStyles";
  }
  processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
    processClassRules(
      this.beans.expressionSvc,
      void 0,
      colDef.cellClassRules,
      params,
      onApplicableClass,
      onNotApplicableClass
    );
    this.processStaticCellClasses(colDef, params, onApplicableClass);
  }
  getStaticCellClasses(colDef, params) {
    const { cellClass } = colDef;
    if (!cellClass) {
      return [];
    }
    let classOrClasses;
    if (typeof cellClass === "function") {
      const cellClassFunc = cellClass;
      classOrClasses = cellClassFunc(params);
    } else {
      classOrClasses = cellClass;
    }
    if (typeof classOrClasses === "string") {
      classOrClasses = [classOrClasses];
    }
    return classOrClasses || [];
  }
  createCellCustomStyleFeature(ctrl, beans) {
    return new CellCustomStyleFeature(ctrl, beans);
  }
  processStaticCellClasses(colDef, params, onApplicableClass) {
    const classOrClasses = this.getStaticCellClasses(colDef, params);
    classOrClasses.forEach((cssClassItem) => {
      onApplicableClass(cssClassItem);
    });
  }
};

// packages/ag-grid-community/src/styling/stylingModule.ts
var CellStyleModule = {
  moduleName: "CellStyle",
  version: VERSION,
  beans: [CellStyleService]
};
var RowStyleModule = {
  moduleName: "RowStyle",
  version: VERSION,
  beans: [RowStyleService]
};

// packages/ag-grid-community/src/columns/columnHover/columnHoverApi.ts
function isColumnHovered(beans, column) {
  return !!beans.colHover?.isHovered(column);
}

// packages/ag-grid-community/src/columns/columnHover/hoverFeature.ts
var HoverFeature = class extends BeanStub {
  constructor(columns, element) {
    super();
    this.columns = columns;
    this.element = element;
  }
  postConstruct() {
    if (this.gos.get("columnHoverHighlight")) {
      const colHover = this.beans.colHover;
      this.addManagedListeners(this.element, {
        mouseout: colHover.clearMouseOver.bind(colHover),
        mouseover: colHover.setMouseOver.bind(colHover, this.columns)
      });
    }
  }
};

// packages/ag-grid-community/src/columns/columnHover/columnHoverService.ts
var CSS_COLUMN_HOVER = "ag-column-hover";
var ColumnHoverService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colHover";
  }
  setMouseOver(columns) {
    this.updateState(columns);
  }
  clearMouseOver() {
    this.updateState(null);
  }
  isHovered(column) {
    const selectedColumns = this.selectedColumns;
    return !!selectedColumns && selectedColumns.indexOf(column) >= 0;
  }
  addHeaderColumnHoverListener(compBean, comp, column) {
    const listener = () => {
      if (!this.gos.get("columnHoverHighlight")) {
        return;
      }
      const isHovered = this.isHovered(column);
      comp.addOrRemoveCssClass("ag-column-hover", isHovered);
    };
    compBean.addManagedEventListeners({ columnHoverChanged: listener });
    listener();
  }
  onCellColumnHover(column, cellComp) {
    if (!cellComp) {
      return;
    }
    if (!this.gos.get("columnHoverHighlight")) {
      return;
    }
    const isHovered = this.isHovered(column);
    cellComp.addOrRemoveCssClass(CSS_COLUMN_HOVER, isHovered);
  }
  addHeaderFilterColumnHoverListener(compBean, comp, column, eGui) {
    this.createHoverFeature(compBean, [column], eGui);
    const listener = () => {
      if (!this.gos.get("columnHoverHighlight")) {
        return;
      }
      const hovered = this.isHovered(column);
      comp.addOrRemoveCssClass("ag-column-hover", hovered);
    };
    compBean.addManagedEventListeners({ columnHoverChanged: listener });
    listener();
  }
  createHoverFeature(compBean, columns, eGui) {
    compBean.createManagedBean(new HoverFeature(columns, eGui));
  }
  updateState(columns) {
    this.selectedColumns = columns;
    this.eventSvc.dispatchEvent({
      type: "columnHoverChanged"
    });
  }
};

// packages/ag-grid-community/src/columns/columnHover/columnHoverModule.ts
var ColumnHoverModule = {
  moduleName: "ColumnHover",
  version: VERSION,
  beans: [ColumnHoverService],
  apiFunctions: {
    isColumnHovered
  }
};

// packages/ag-grid-community/src/misc/apiEvents/apiEventService.ts
var ApiEventService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "apiEventSvc";
    this.syncListeners = /* @__PURE__ */ new Map();
    this.asyncListeners = /* @__PURE__ */ new Map();
    this.syncGlobalListeners = /* @__PURE__ */ new Set();
    this.globalListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.wrapSvc = this.beans.frameworkOverrides.createGlobalEventListenerWrapper?.();
  }
  addEventListener(eventType, userListener) {
    const listener = this.wrapSvc?.wrap(userListener) ?? userListener;
    const async = !ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType);
    const listeners = async ? this.asyncListeners : this.syncListeners;
    if (!listeners.has(eventType)) {
      listeners.set(eventType, /* @__PURE__ */ new Set());
    }
    listeners.get(eventType).add(listener);
    this.eventSvc.addEventListener(eventType, listener, async);
  }
  removeEventListener(eventType, userListener) {
    const listener = this.wrapSvc?.unwrap(userListener) ?? userListener;
    const asyncListeners = this.asyncListeners.get(eventType);
    const hasAsync = !!asyncListeners?.delete(listener);
    if (!hasAsync) {
      this.syncListeners.get(eventType)?.delete(listener);
    }
    this.eventSvc.removeEventListener(eventType, listener, hasAsync);
  }
  addGlobalListener(userListener) {
    const listener = this.wrapSvc?.wrapGlobal(userListener) ?? userListener;
    const syncListener = (eventType, event) => {
      if (ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
        listener(eventType, event);
      }
    };
    const asyncListener = (eventType, event) => {
      if (!ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
        listener(eventType, event);
      }
    };
    this.globalListenerPairs.set(userListener, { syncListener, asyncListener });
    const eventSvc = this.eventSvc;
    eventSvc.addGlobalListener(syncListener, false);
    eventSvc.addGlobalListener(asyncListener, true);
  }
  removeGlobalListener(userListener) {
    const { eventSvc, wrapSvc, globalListenerPairs } = this;
    const listener = wrapSvc?.unwrapGlobal(userListener) ?? userListener;
    const hasAsync = globalListenerPairs.has(listener);
    if (hasAsync) {
      const { syncListener, asyncListener } = globalListenerPairs.get(listener);
      eventSvc.removeGlobalListener(syncListener, false);
      eventSvc.removeGlobalListener(asyncListener, true);
      globalListenerPairs.delete(userListener);
    } else {
      this.syncGlobalListeners.delete(listener);
      eventSvc.removeGlobalListener(listener, false);
    }
  }
  destroyEventListeners(map, async) {
    map.forEach((listeners, eventType) => {
      listeners.forEach((listener) => this.eventSvc.removeEventListener(eventType, listener, async));
      listeners.clear();
    });
    map.clear();
  }
  destroyGlobalListeners(set, async) {
    set.forEach((listener) => this.eventSvc.removeGlobalListener(listener, async));
    set.clear();
  }
  destroy() {
    super.destroy();
    this.destroyEventListeners(this.syncListeners, false);
    this.destroyEventListeners(this.asyncListeners, true);
    this.destroyGlobalListeners(this.syncGlobalListeners, false);
    const { globalListenerPairs, eventSvc } = this;
    globalListenerPairs.forEach(({ syncListener, asyncListener }) => {
      eventSvc.removeGlobalListener(syncListener, false);
      eventSvc.removeGlobalListener(asyncListener, true);
    });
    globalListenerPairs.clear();
  }
};

// packages/ag-grid-community/src/misc/apiEvents/eventApi.ts
function addEventListener(beans, eventType, listener) {
  beans.apiEventSvc?.addEventListener(eventType, listener);
}
function removeEventListener(beans, eventType, listener) {
  beans.apiEventSvc?.removeEventListener(eventType, listener);
}
function addGlobalListener(beans, listener) {
  beans.apiEventSvc?.addGlobalListener(listener);
}
function removeGlobalListener(beans, listener) {
  beans.apiEventSvc?.removeGlobalListener(listener);
}

// packages/ag-grid-community/src/misc/apiEvents/apiEventModule.ts
var EventApiModule = {
  moduleName: "EventApi",
  version: VERSION,
  apiFunctions: {
    addEventListener,
    addGlobalListener,
    removeEventListener,
    removeGlobalListener
  },
  beans: [ApiEventService]
};

// packages/ag-grid-community/src/tooltip/tooltip.css-GENERATED.ts
var tooltipCSS = (
  /*css*/
  `.ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);white-space:normal}.ag-tooltip,.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:where(:not(.ag-tooltip-interactive)),.ag-tooltip:where(:not(.ag-tooltip-interactive)){pointer-events:none}.ag-tooltip-animate{transition:opacity 1s;&:where(.ag-tooltip-hiding){opacity:0}}`
);

// packages/ag-grid-community/src/tooltip/tooltipService.ts
var TooltipService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "tooltipSvc";
  }
  setupHeaderTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
    if (existingTooltipFeature) {
      ctrl.destroyBean(existingTooltipFeature);
    }
    const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(this.gos);
    const { column, eGui } = ctrl;
    const colDef = column.getColDef();
    if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colDef.headerComponent) {
      shouldDisplayTooltip = _shouldDisplayTooltip(
        () => eGui.querySelector(".ag-header-cell-text")
      );
    }
    const tooltipCtrl = {
      getColumn: () => column,
      getColDef: () => column.getColDef(),
      getGui: () => eGui,
      getLocation: () => "header",
      getTooltipValue: () => {
        if (value != null) {
          return value;
        }
        const res = column.getColDef().headerTooltip;
        return res;
      },
      shouldDisplayTooltip
    };
    let tooltipFeature = this.createTooltipFeature(tooltipCtrl);
    if (tooltipFeature) {
      tooltipFeature = ctrl.createBean(tooltipFeature);
      ctrl.setRefreshFunction("tooltip", () => tooltipFeature.refreshTooltip());
    }
    return tooltipFeature;
  }
  setupHeaderGroupTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
    if (existingTooltipFeature) {
      ctrl.destroyBean(existingTooltipFeature);
    }
    const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(this.gos);
    const { column, eGui } = ctrl;
    const colGroupDef = column.getColGroupDef();
    if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colGroupDef?.headerGroupComponent) {
      shouldDisplayTooltip = _shouldDisplayTooltip(
        () => eGui.querySelector(".ag-header-group-text")
      );
    }
    const tooltipCtrl = {
      getColumn: () => column,
      getGui: () => eGui,
      getLocation: () => "headerGroup",
      getTooltipValue: () => value ?? (colGroupDef && colGroupDef.headerTooltip),
      shouldDisplayTooltip
    };
    if (colGroupDef) {
      tooltipCtrl.getColDef = () => colGroupDef;
    }
    const tooltipFeature = this.createTooltipFeature(tooltipCtrl);
    return tooltipFeature ? ctrl.createBean(tooltipFeature) : tooltipFeature;
  }
  enableCellTooltipFeature(ctrl, value, shouldDisplayTooltip) {
    const { column, rowNode } = ctrl;
    const getTooltipValue = () => {
      const colDef = column.getColDef();
      const data = rowNode.data;
      if (colDef.tooltipField && _exists(data)) {
        return _getValueUsingField(data, colDef.tooltipField, column.isTooltipFieldContainsDots());
      }
      const valueGetter = colDef.tooltipValueGetter;
      if (valueGetter) {
        return valueGetter(
          this.gos.addGridCommonParams({
            location: "cell",
            colDef: column.getColDef(),
            column,
            rowIndex: ctrl.cellPosition.rowIndex,
            node: rowNode,
            data: rowNode.data,
            value: ctrl.value,
            valueFormatted: ctrl.valueFormatted
          })
        );
      }
      return null;
    };
    const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(this.gos);
    if (!shouldDisplayTooltip && isTooltipWhenTruncated && !ctrl.isCellRenderer()) {
      shouldDisplayTooltip = _shouldDisplayTooltip(() => {
        const { eGui } = ctrl;
        return eGui.children.length === 0 ? eGui : eGui.querySelector(".ag-cell-value");
      });
    }
    const tooltipCtrl = {
      getColumn: () => column,
      getColDef: () => column.getColDef(),
      getRowIndex: () => ctrl.cellPosition.rowIndex,
      getRowNode: () => rowNode,
      getGui: () => ctrl.eGui,
      getLocation: () => "cell",
      getTooltipValue: value != null ? () => value : getTooltipValue,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => ctrl.valueFormatted,
      shouldDisplayTooltip
    };
    return this.createTooltipFeature(tooltipCtrl, this.beans);
  }
  refreshRowTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
    const tooltipParams = {
      getGui: () => ctrl.getFullWidthElement(),
      getTooltipValue: () => value,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip
    };
    const beans = this.beans;
    const context = beans.context;
    if (existingTooltipFeature) {
      ctrl.destroyBean(existingTooltipFeature, context);
    }
    const tooltipFeature = this.createTooltipFeature(tooltipParams, beans);
    return ctrl.createBean(tooltipFeature, context);
  }
  initCol(column) {
    const { colDef } = column;
    column.tooltipEnabled = _exists(colDef.tooltipField) || _exists(colDef.tooltipValueGetter) || _exists(colDef.tooltipComponent);
  }
  createTooltipFeature(tooltipCtrl, beans) {
    return this.beans.registry.createDynamicBean("tooltipFeature", false, tooltipCtrl, beans);
  }
};

// packages/ag-grid-community/src/tooltip/tooltipModule.ts
var TooltipModule = {
  moduleName: "Tooltip",
  version: VERSION,
  beans: [TooltipService],
  dynamicBeans: {
    tooltipFeature: TooltipFeature
  },
  userComponents: {
    agTooltipComponent: TooltipComponent2
  },
  dependsOn: [PopupModule],
  css: [tooltipCSS]
};

// packages/ag-grid-community/src/misc/locale/localeModule.ts
var LocaleModule = {
  moduleName: "Locale",
  version: VERSION,
  beans: [LocaleService]
};

// packages/ag-grid-community/src/rendering/row/rowAutoHeightService.ts
var RowAutoHeightService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowAutoHeight";
    this.wasEverActive = false;
  }
  setRowAutoHeight(rowNode, cellHeight, column) {
    if (!rowNode.__autoHeights) {
      rowNode.__autoHeights = {};
    }
    rowNode.__autoHeights[column.getId()] = cellHeight;
    if (cellHeight != null) {
      if (rowNode.__checkAutoHeightsDebounced == null) {
        rowNode.__checkAutoHeightsDebounced = _debounce(this, this.doCheckAutoHeights.bind(this, rowNode), 1);
      }
      rowNode.__checkAutoHeightsDebounced();
    }
  }
  checkAutoHeights(rowNode) {
    if (this.wasEverActive) {
      this.doCheckAutoHeights(rowNode);
    }
  }
  doCheckAutoHeights(rowNode) {
    const autoHeights = rowNode.__autoHeights;
    if (autoHeights == null) {
      return;
    }
    let notAllPresent = false;
    let nonePresent = true;
    let newRowHeight = 0;
    const { visibleCols, colModel, colViewport, rowModel } = this.beans;
    const displayedAutoHeightCols = visibleCols.autoHeightCols;
    displayedAutoHeightCols.forEach((col) => {
      let cellHeight = autoHeights[col.getId()];
      if (cellHeight == null) {
        if (colModel.colSpanActive) {
          let activeColsForRow = [];
          switch (col.getPinned()) {
            case "left":
              activeColsForRow = visibleCols.getLeftColsForRow(rowNode);
              break;
            case "right":
              activeColsForRow = visibleCols.getRightColsForRow(rowNode);
              break;
            case null:
              activeColsForRow = colViewport.getColsWithinViewport(rowNode);
              break;
          }
          if (activeColsForRow.includes(col)) {
            notAllPresent = true;
            return;
          }
          cellHeight = -1;
        } else {
          notAllPresent = true;
          return;
        }
      } else {
        nonePresent = false;
      }
      if (cellHeight > newRowHeight) {
        newRowHeight = cellHeight;
      }
    });
    if (notAllPresent) {
      return;
    }
    if (nonePresent || newRowHeight < 10) {
      newRowHeight = _getRowHeightForNode(this.beans, rowNode).height;
    }
    if (newRowHeight == rowNode.rowHeight) {
      return;
    }
    rowNode.setRowHeight(newRowHeight);
    rowModel.onRowHeightChangedDebounced?.();
  }
  setupCellAutoHeight(cellCtrl, eCellWrapper, compBean) {
    const eParentCell = eCellWrapper.parentElement;
    const { rowNode, column } = cellCtrl;
    const beans = this.beans;
    const minRowHeight = _getRowHeightForNode(beans, rowNode).height;
    const measureHeight = (timesCalled) => {
      if (cellCtrl.editing) {
        return;
      }
      if (!cellCtrl.isAlive() || !compBean.isAlive()) {
        return;
      }
      const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = _getElementSize(eParentCell);
      const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
      const wrapperHeight = eCellWrapper.offsetHeight;
      const autoHeight = wrapperHeight + extraHeight;
      if (timesCalled < 5) {
        const doc = _getDocument(beans);
        const notYetInDom = !doc || !doc.contains(eCellWrapper);
        const possiblyNoContentYet = autoHeight == 0;
        if (notYetInDom || possiblyNoContentYet) {
          window.setTimeout(() => measureHeight(timesCalled + 1), 0);
          return;
        }
      }
      const newHeight = Math.max(autoHeight, minRowHeight);
      this.setRowAutoHeight(rowNode, newHeight, column);
    };
    const listener = () => measureHeight(0);
    listener();
    const destroyResizeObserver = _observeResize(beans, eCellWrapper, listener);
    compBean.addDestroyFunc(() => {
      destroyResizeObserver();
      this.setRowAutoHeight(rowNode, void 0, column);
    });
  }
  setAutoHeightActive(cols) {
    this.active = cols.list.some((col) => col.isVisible() && col.isAutoHeight());
    if (this.active) {
      this.wasEverActive = true;
    }
  }
};

// packages/ag-grid-community/src/rendering/row/rowAutoHeightModule.ts
var RowAutoHeightModule = {
  moduleName: "RowAutoHeight",
  version: VERSION,
  beans: [RowAutoHeightService]
};

// packages/ag-grid-community/src/allCommunityModule.ts
var AllCommunityModule = {
  moduleName: "AllCommunity",
  version: VERSION,
  dependsOn: [
    ClientSideRowModelModule,
    CsvExportModule,
    InfiniteRowModelModule,
    ValidationModule,
    TextEditorModule,
    NumberEditorModule,
    DateEditorModule,
    CheckboxEditorModule,
    SelectEditorModule,
    LargeTextEditorModule,
    CustomEditorModule,
    UndoRedoEditModule,
    TextFilterModule,
    NumberFilterModule,
    DateFilterModule,
    CustomFilterModule,
    QuickFilterModule,
    ExternalFilterModule,
    GridStateModule,
    AlignedGridsModule,
    PaginationModule,
    ColumnApiModule,
    RowApiModule,
    ScrollApiModule,
    RenderApiModule,
    ColumnAutoSizeModule,
    RowDragModule,
    PinnedRowModule,
    RowSelectionModule,
    ValueCacheModule,
    CellStyleModule,
    ColumnHoverModule,
    RowStyleModule,
    EventApiModule,
    CellApiModule,
    HighlightChangesModule,
    TooltipModule,
    LocaleModule,
    RowAutoHeightModule,
    DragAndDropModule,
    ClientSideRowModelApiModule
  ]
};
//# sourceMappingURL=main.cjs.js.map


/***/ }),

/***/ 5608:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: function() { return /* binding */ __addDisposableResource; },
/* harmony export */   __assign: function() { return /* binding */ __assign; },
/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },
/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },
/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },
/* harmony export */   __await: function() { return /* binding */ __await; },
/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },
/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },
/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },
/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },
/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },
/* harmony export */   __decorate: function() { return /* binding */ __decorate; },
/* harmony export */   __disposeResources: function() { return /* binding */ __disposeResources; },
/* harmony export */   __esDecorate: function() { return /* binding */ __esDecorate; },
/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },
/* harmony export */   __extends: function() { return /* binding */ __extends; },
/* harmony export */   __generator: function() { return /* binding */ __generator; },
/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },
/* harmony export */   __importStar: function() { return /* binding */ __importStar; },
/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },
/* harmony export */   __metadata: function() { return /* binding */ __metadata; },
/* harmony export */   __param: function() { return /* binding */ __param; },
/* harmony export */   __propKey: function() { return /* binding */ __propKey; },
/* harmony export */   __read: function() { return /* binding */ __read; },
/* harmony export */   __rest: function() { return /* binding */ __rest; },
/* harmony export */   __runInitializers: function() { return /* binding */ __runInitializers; },
/* harmony export */   __setFunctionName: function() { return /* binding */ __setFunctionName; },
/* harmony export */   __spread: function() { return /* binding */ __spread; },
/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },
/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },
/* harmony export */   __values: function() { return /* binding */ __values; }
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ __webpack_exports__["default"] = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(4769);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});